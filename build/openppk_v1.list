
build/openppk_v1.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08004000 <_vectors>:
 8004000:	20004000 	.word	0x20004000
 8004004:	08004301 	.word	0x08004301
 8004008:	08004303 	.word	0x08004303
 800400c:	08004302 	.word	0x08004302
 8004010:	08004302 	.word	0x08004302
 8004014:	08004302 	.word	0x08004302
 8004018:	08004302 	.word	0x08004302
 800401c:	08004302 	.word	0x08004302
 8004020:	08004302 	.word	0x08004302
 8004024:	08004302 	.word	0x08004302
 8004028:	08004302 	.word	0x08004302
 800402c:	08013651 	.word	0x08013651
 8004030:	08004302 	.word	0x08004302
 8004034:	08004302 	.word	0x08004302
 8004038:	08004302 	.word	0x08004302
 800403c:	08004302 	.word	0x08004302
 8004040:	08004302 	.word	0x08004302
 8004044:	08004302 	.word	0x08004302
 8004048:	08004302 	.word	0x08004302
 800404c:	08004302 	.word	0x08004302
 8004050:	08004302 	.word	0x08004302
 8004054:	08004302 	.word	0x08004302
 8004058:	08016fe1 	.word	0x08016fe1
 800405c:	08017041 	.word	0x08017041
 8004060:	080170b1 	.word	0x080170b1
 8004064:	08017121 	.word	0x08017121
 8004068:	08017191 	.word	0x08017191
 800406c:	08017cf1 	.word	0x08017cf1
 8004070:	08017d31 	.word	0x08017d31
 8004074:	08017d71 	.word	0x08017d71
 8004078:	08017db1 	.word	0x08017db1
 800407c:	08017df1 	.word	0x08017df1
 8004080:	08017e31 	.word	0x08017e31
 8004084:	08017e71 	.word	0x08017e71
 8004088:	08004302 	.word	0x08004302
 800408c:	08017c21 	.word	0x08017c21
 8004090:	08017c41 	.word	0x08017c41
 8004094:	08017c61 	.word	0x08017c61
 8004098:	08017c81 	.word	0x08017c81
 800409c:	08017201 	.word	0x08017201
 80040a0:	08004302 	.word	0x08004302
 80040a4:	08004302 	.word	0x08004302
 80040a8:	08004302 	.word	0x08004302
 80040ac:	08004302 	.word	0x08004302
 80040b0:	080167a1 	.word	0x080167a1
 80040b4:	08004302 	.word	0x08004302
 80040b8:	08004302 	.word	0x08004302
 80040bc:	08004302 	.word	0x08004302
 80040c0:	08004302 	.word	0x08004302
 80040c4:	08004302 	.word	0x08004302
 80040c8:	08004302 	.word	0x08004302
 80040cc:	08004302 	.word	0x08004302
 80040d0:	08004302 	.word	0x08004302
 80040d4:	08016bb1 	.word	0x08016bb1
 80040d8:	08004302 	.word	0x08004302
 80040dc:	08004302 	.word	0x08004302
 80040e0:	08017341 	.word	0x08017341
 80040e4:	08004302 	.word	0x08004302
 80040e8:	08004302 	.word	0x08004302
 80040ec:	08004302 	.word	0x08004302
 80040f0:	08004302 	.word	0x08004302
 80040f4:	08004302 	.word	0x08004302
 80040f8:	08004302 	.word	0x08004302
 80040fc:	08017eb1 	.word	0x08017eb1
 8004100:	08004302 	.word	0x08004302
 8004104:	080160e1 	.word	0x080160e1
 8004108:	08004302 	.word	0x08004302
 800410c:	08004302 	.word	0x08004302
 8004110:	08004302 	.word	0x08004302
 8004114:	08004302 	.word	0x08004302
 8004118:	08004302 	.word	0x08004302
 800411c:	08004302 	.word	0x08004302
 8004120:	08017ef1 	.word	0x08017ef1
 8004124:	08017f31 	.word	0x08017f31
 8004128:	08017f71 	.word	0x08017f71
 800412c:	08017fb1 	.word	0x08017fb1
 8004130:	08017ff1 	.word	0x08017ff1
 8004134:	08004302 	.word	0x08004302
 8004138:	08004302 	.word	0x08004302
 800413c:	08004302 	.word	0x08004302
 8004140:	08004302 	.word	0x08004302
 8004144:	08004302 	.word	0x08004302
 8004148:	08004302 	.word	0x08004302
 800414c:	08015641 	.word	0x08015641
 8004150:	08018031 	.word	0x08018031
 8004154:	08018071 	.word	0x08018071
 8004158:	080180b1 	.word	0x080180b1
 800415c:	08004302 	.word	0x08004302
 8004160:	08004302 	.word	0x08004302
 8004164:	08004302 	.word	0x08004302
 8004168:	08004302 	.word	0x08004302
 800416c:	08004302 	.word	0x08004302
 8004170:	08004302 	.word	0x08004302
 8004174:	08004302 	.word	0x08004302
 8004178:	08004302 	.word	0x08004302
 800417c:	08004302 	.word	0x08004302
 8004180:	08004302 	.word	0x08004302
 8004184:	08004302 	.word	0x08004302
 8004188:	08004302 	.word	0x08004302
 800418c:	08004302 	.word	0x08004302
 8004190:	08004302 	.word	0x08004302
 8004194:	08004302 	.word	0x08004302
 8004198:	08004302 	.word	0x08004302
 800419c:	08004302 	.word	0x08004302
 80041a0:	08004302 	.word	0x08004302
 80041a4:	08004302 	.word	0x08004302
 80041a8:	08004302 	.word	0x08004302
 80041ac:	08004302 	.word	0x08004302
 80041b0:	08004302 	.word	0x08004302
 80041b4:	08004302 	.word	0x08004302
 80041b8:	08004302 	.word	0x08004302
 80041bc:	08004302 	.word	0x08004302
 80041c0:	08004302 	.word	0x08004302
 80041c4:	08004302 	.word	0x08004302
 80041c8:	08004302 	.word	0x08004302
 80041cc:	08004302 	.word	0x08004302
 80041d0:	08004302 	.word	0x08004302
 80041d4:	08004302 	.word	0x08004302
 80041d8:	08004302 	.word	0x08004302
 80041dc:	08004302 	.word	0x08004302

Disassembly of section .text:

080041e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80041e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80041e2:	4839      	ldr	r0, [pc, #228]	; (80042c8 <endfiniloop+0x6>)
                msr     MSP, r0
 80041e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80041e8:	4838      	ldr	r0, [pc, #224]	; (80042cc <endfiniloop+0xa>)
                msr     PSP, r0
 80041ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80041ee:	4838      	ldr	r0, [pc, #224]	; (80042d0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80041f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80041f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80041f8:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80041fa:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80041fe:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8004202:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8004206:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800420a:	6008      	str	r0, [r1, #0]
                dsb
 800420c:	f3bf 8f4f 	dsb	sy
                isb
 8004210:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8004214:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8004218:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800421c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8004220:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8004224:	6008      	str	r0, [r1, #0]
                dsb
 8004226:	f3bf 8f4f 	dsb	sy
                isb
 800422a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800422e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8004232:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8004236:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800423a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800423e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8004240:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8004242:	f380 8814 	msr	CONTROL, r0
                isb
 8004246:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800424a:	f015 fb59 	bl	8019900 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800424e:	f012 fd97 	bl	8016d80 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8004252:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8004256:	491f      	ldr	r1, [pc, #124]	; (80042d4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8004258:	4a1b      	ldr	r2, [pc, #108]	; (80042c8 <endfiniloop+0x6>)

0800425a <msloop>:
msloop:
                cmp     r1, r2
 800425a:	4291      	cmp	r1, r2
                itt     lo
 800425c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800425e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8004262:	e7fa      	bcc.n	800425a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8004264:	491c      	ldr	r1, [pc, #112]	; (80042d8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8004266:	4a19      	ldr	r2, [pc, #100]	; (80042cc <endfiniloop+0xa>)

08004268 <psloop>:
psloop:
                cmp     r1, r2
 8004268:	4291      	cmp	r1, r2
                itt     lo
 800426a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800426c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8004270:	e7fa      	bcc.n	8004268 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8004272:	491a      	ldr	r1, [pc, #104]	; (80042dc <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8004274:	4a1a      	ldr	r2, [pc, #104]	; (80042e0 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 8004276:	4b1b      	ldr	r3, [pc, #108]	; (80042e4 <endfiniloop+0x22>)

08004278 <dloop>:
dloop:
                cmp     r2, r3
 8004278:	429a      	cmp	r2, r3
                ittt    lo
 800427a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800427c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8004280:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8004284:	e7f8      	bcc.n	8004278 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8004286:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8004288:	4917      	ldr	r1, [pc, #92]	; (80042e8 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 800428a:	4a18      	ldr	r2, [pc, #96]	; (80042ec <endfiniloop+0x2a>)

0800428c <bloop>:
bloop:
                cmp     r1, r2
 800428c:	4291      	cmp	r1, r2
                itt     lo
 800428e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8004290:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8004294:	e7fa      	bcc.n	800428c <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8004296:	f015 fb4b 	bl	8019930 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800429a:	f015 fb39 	bl	8019910 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800429e:	4c14      	ldr	r4, [pc, #80]	; (80042f0 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 80042a0:	4d14      	ldr	r5, [pc, #80]	; (80042f4 <endfiniloop+0x32>)

080042a2 <initloop>:
initloop:
                cmp     r4, r5
 80042a2:	42ac      	cmp	r4, r5
                bge     endinitloop
 80042a4:	da03      	bge.n	80042ae <endinitloop>
                ldr     r1, [r4], #4
 80042a6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80042aa:	4788      	blx	r1
                b       initloop
 80042ac:	e7f9      	b.n	80042a2 <initloop>

080042ae <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80042ae:	f001 fd5f 	bl	8005d70 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80042b2:	4c11      	ldr	r4, [pc, #68]	; (80042f8 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 80042b4:	4d11      	ldr	r5, [pc, #68]	; (80042fc <endfiniloop+0x3a>)

080042b6 <finiloop>:
finiloop:
                cmp     r4, r5
 80042b6:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80042b8:	da03      	bge.n	80042c2 <endfiniloop>
                ldr     r1, [r4], #4
 80042ba:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80042be:	4788      	blx	r1
                b       finiloop
 80042c0:	e7f9      	b.n	80042b6 <finiloop>

080042c2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80042c2:	f015 bb2d 	b.w	8019920 <__default_exit>
 80042c6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80042c8:	20004000 	.word	0x20004000
                ldr     r0, =__process_stack_end__
 80042cc:	20004400 	.word	0x20004400
                ldr     r0, =_vectors
 80042d0:	08004000 	.word	0x08004000
                ldr     r1, =__main_stack_base__
 80042d4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80042d8:	20004000 	.word	0x20004000
                ldr     r1, =_textdata_start
 80042dc:	0802531c 	.word	0x0802531c
                ldr     r2, =_data_start
 80042e0:	20004400 	.word	0x20004400
                ldr     r3, =_data_end
 80042e4:	20004e68 	.word	0x20004e68
                ldr     r1, =_bss_start
 80042e8:	20004e68 	.word	0x20004e68
                ldr     r2, =_bss_end
 80042ec:	2000f258 	.word	0x2000f258
                ldr     r4, =__init_array_start
 80042f0:	080041e0 	.word	0x080041e0
                ldr     r5, =__init_array_end
 80042f4:	080041e0 	.word	0x080041e0
                ldr     r4, =__fini_array_start
 80042f8:	080041e0 	.word	0x080041e0
                ldr     r5, =__fini_array_end
 80042fc:	080041e0 	.word	0x080041e0

08004300 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8004300:	e76e      	b.n	80041e0 <_crt0_entry>

08004302 <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
         b          _unhandled_exception
 8004302:	e7ff      	b.n	8004304 <_unhandled_exception>

08004304 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8004304:	e7fe      	b.n	8004304 <_unhandled_exception>
 8004306:	46c0      	nop			; (mov r8, r8)

08004308 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8004308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 800430c:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8004310:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8004314:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8004316:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 8004318:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800431c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004320 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8004320:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8004322:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8004326:	4628      	mov	r0, r5
                blx     r4
 8004328:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 800432a:	2000      	movs	r0, #0
                bl      chThdExit
 800432c:	f010 fb40 	bl	80149b0 <chThdExit>

08004330 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8004330:	f010 f996 	bl	8014660 <chSchDoReschedule>

08004334 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8004334:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8004336:	e7fe      	b.n	8004336 <_port_exit_from_isr+0x2>
	...
 8004340:	eba2 0003 	sub.w	r0, r2, r3
 8004344:	4770      	bx	lr
 8004346:	bf00      	nop

08004348 <strcmp>:
 8004348:	7802      	ldrb	r2, [r0, #0]
 800434a:	780b      	ldrb	r3, [r1, #0]
 800434c:	2a01      	cmp	r2, #1
 800434e:	bf28      	it	cs
 8004350:	429a      	cmpcs	r2, r3
 8004352:	d1f5      	bne.n	8004340 <_port_exit_from_isr+0xc>
 8004354:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8004358:	ea40 0401 	orr.w	r4, r0, r1
 800435c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8004360:	f06f 0c00 	mvn.w	ip, #0
 8004364:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8004368:	b312      	cbz	r2, 80043b0 <strcmp+0x68>
 800436a:	ea80 0401 	eor.w	r4, r0, r1
 800436e:	f014 0f07 	tst.w	r4, #7
 8004372:	d16a      	bne.n	800444a <strcmp+0x102>
 8004374:	f000 0407 	and.w	r4, r0, #7
 8004378:	f020 0007 	bic.w	r0, r0, #7
 800437c:	f004 0503 	and.w	r5, r4, #3
 8004380:	f021 0107 	bic.w	r1, r1, #7
 8004384:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8004388:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800438c:	f014 0f04 	tst.w	r4, #4
 8004390:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8004394:	fa0c f405 	lsl.w	r4, ip, r5
 8004398:	ea62 0204 	orn	r2, r2, r4
 800439c:	ea66 0604 	orn	r6, r6, r4
 80043a0:	d00a      	beq.n	80043b8 <strcmp+0x70>
 80043a2:	ea63 0304 	orn	r3, r3, r4
 80043a6:	4662      	mov	r2, ip
 80043a8:	ea67 0704 	orn	r7, r7, r4
 80043ac:	4666      	mov	r6, ip
 80043ae:	e003      	b.n	80043b8 <strcmp+0x70>
 80043b0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80043b4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80043b8:	fa82 f54c 	uadd8	r5, r2, ip
 80043bc:	ea82 0406 	eor.w	r4, r2, r6
 80043c0:	faa4 f48c 	sel	r4, r4, ip
 80043c4:	bb6c      	cbnz	r4, 8004422 <strcmp+0xda>
 80043c6:	fa83 f54c 	uadd8	r5, r3, ip
 80043ca:	ea83 0507 	eor.w	r5, r3, r7
 80043ce:	faa5 f58c 	sel	r5, r5, ip
 80043d2:	b995      	cbnz	r5, 80043fa <strcmp+0xb2>
 80043d4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80043d8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80043dc:	fa82 f54c 	uadd8	r5, r2, ip
 80043e0:	ea82 0406 	eor.w	r4, r2, r6
 80043e4:	faa4 f48c 	sel	r4, r4, ip
 80043e8:	fa83 f54c 	uadd8	r5, r3, ip
 80043ec:	ea83 0507 	eor.w	r5, r3, r7
 80043f0:	faa5 f58c 	sel	r5, r5, ip
 80043f4:	4325      	orrs	r5, r4
 80043f6:	d0db      	beq.n	80043b0 <strcmp+0x68>
 80043f8:	b99c      	cbnz	r4, 8004422 <strcmp+0xda>
 80043fa:	ba2d      	rev	r5, r5
 80043fc:	fab5 f485 	clz	r4, r5
 8004400:	f024 0407 	bic.w	r4, r4, #7
 8004404:	fa27 f104 	lsr.w	r1, r7, r4
 8004408:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800440c:	fa23 f304 	lsr.w	r3, r3, r4
 8004410:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8004414:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8004418:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800441c:	eba0 0001 	sub.w	r0, r0, r1
 8004420:	4770      	bx	lr
 8004422:	ba24      	rev	r4, r4
 8004424:	fab4 f484 	clz	r4, r4
 8004428:	f024 0407 	bic.w	r4, r4, #7
 800442c:	fa26 f104 	lsr.w	r1, r6, r4
 8004430:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8004434:	fa22 f204 	lsr.w	r2, r2, r4
 8004438:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800443c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8004440:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8004444:	eba0 0001 	sub.w	r0, r0, r1
 8004448:	4770      	bx	lr
 800444a:	f014 0f03 	tst.w	r4, #3
 800444e:	d13c      	bne.n	80044ca <strcmp+0x182>
 8004450:	f010 0403 	ands.w	r4, r0, #3
 8004454:	d128      	bne.n	80044a8 <strcmp+0x160>
 8004456:	f850 2b08 	ldr.w	r2, [r0], #8
 800445a:	f851 3b08 	ldr.w	r3, [r1], #8
 800445e:	fa82 f54c 	uadd8	r5, r2, ip
 8004462:	ea82 0503 	eor.w	r5, r2, r3
 8004466:	faa5 f58c 	sel	r5, r5, ip
 800446a:	b95d      	cbnz	r5, 8004484 <strcmp+0x13c>
 800446c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8004470:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8004474:	fa82 f54c 	uadd8	r5, r2, ip
 8004478:	ea82 0503 	eor.w	r5, r2, r3
 800447c:	faa5 f58c 	sel	r5, r5, ip
 8004480:	2d00      	cmp	r5, #0
 8004482:	d0e8      	beq.n	8004456 <strcmp+0x10e>
 8004484:	ba2d      	rev	r5, r5
 8004486:	fab5 f485 	clz	r4, r5
 800448a:	f024 0407 	bic.w	r4, r4, #7
 800448e:	fa23 f104 	lsr.w	r1, r3, r4
 8004492:	fa22 f204 	lsr.w	r2, r2, r4
 8004496:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800449a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800449e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80044a2:	eba0 0001 	sub.w	r0, r0, r1
 80044a6:	4770      	bx	lr
 80044a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80044ac:	f020 0003 	bic.w	r0, r0, #3
 80044b0:	f850 2b08 	ldr.w	r2, [r0], #8
 80044b4:	f021 0103 	bic.w	r1, r1, #3
 80044b8:	f851 3b08 	ldr.w	r3, [r1], #8
 80044bc:	fa0c f404 	lsl.w	r4, ip, r4
 80044c0:	ea62 0204 	orn	r2, r2, r4
 80044c4:	ea63 0304 	orn	r3, r3, r4
 80044c8:	e7c9      	b.n	800445e <strcmp+0x116>
 80044ca:	f010 0403 	ands.w	r4, r0, #3
 80044ce:	d01a      	beq.n	8004506 <strcmp+0x1be>
 80044d0:	eba1 0104 	sub.w	r1, r1, r4
 80044d4:	f020 0003 	bic.w	r0, r0, #3
 80044d8:	07e4      	lsls	r4, r4, #31
 80044da:	f850 2b04 	ldr.w	r2, [r0], #4
 80044de:	d006      	beq.n	80044ee <strcmp+0x1a6>
 80044e0:	d20f      	bcs.n	8004502 <strcmp+0x1ba>
 80044e2:	788b      	ldrb	r3, [r1, #2]
 80044e4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80044e8:	1ae4      	subs	r4, r4, r3
 80044ea:	d106      	bne.n	80044fa <strcmp+0x1b2>
 80044ec:	b12b      	cbz	r3, 80044fa <strcmp+0x1b2>
 80044ee:	78cb      	ldrb	r3, [r1, #3]
 80044f0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80044f4:	1ae4      	subs	r4, r4, r3
 80044f6:	d100      	bne.n	80044fa <strcmp+0x1b2>
 80044f8:	b91b      	cbnz	r3, 8004502 <strcmp+0x1ba>
 80044fa:	4620      	mov	r0, r4
 80044fc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8004500:	4770      	bx	lr
 8004502:	f101 0104 	add.w	r1, r1, #4
 8004506:	f850 2b04 	ldr.w	r2, [r0], #4
 800450a:	07cc      	lsls	r4, r1, #31
 800450c:	f021 0103 	bic.w	r1, r1, #3
 8004510:	f851 3b04 	ldr.w	r3, [r1], #4
 8004514:	d848      	bhi.n	80045a8 <strcmp+0x260>
 8004516:	d224      	bcs.n	8004562 <strcmp+0x21a>
 8004518:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800451c:	fa82 f54c 	uadd8	r5, r2, ip
 8004520:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8004524:	faa5 f58c 	sel	r5, r5, ip
 8004528:	d10a      	bne.n	8004540 <strcmp+0x1f8>
 800452a:	b965      	cbnz	r5, 8004546 <strcmp+0x1fe>
 800452c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004530:	ea84 0402 	eor.w	r4, r4, r2
 8004534:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8004538:	d10e      	bne.n	8004558 <strcmp+0x210>
 800453a:	f850 2b04 	ldr.w	r2, [r0], #4
 800453e:	e7eb      	b.n	8004518 <strcmp+0x1d0>
 8004540:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8004544:	e055      	b.n	80045f2 <strcmp+0x2aa>
 8004546:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800454a:	d14d      	bne.n	80045e8 <strcmp+0x2a0>
 800454c:	7808      	ldrb	r0, [r1, #0]
 800454e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8004552:	f1c0 0000 	rsb	r0, r0, #0
 8004556:	4770      	bx	lr
 8004558:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800455c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8004560:	e047      	b.n	80045f2 <strcmp+0x2aa>
 8004562:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8004566:	fa82 f54c 	uadd8	r5, r2, ip
 800456a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800456e:	faa5 f58c 	sel	r5, r5, ip
 8004572:	d10a      	bne.n	800458a <strcmp+0x242>
 8004574:	b965      	cbnz	r5, 8004590 <strcmp+0x248>
 8004576:	f851 3b04 	ldr.w	r3, [r1], #4
 800457a:	ea84 0402 	eor.w	r4, r4, r2
 800457e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8004582:	d10c      	bne.n	800459e <strcmp+0x256>
 8004584:	f850 2b04 	ldr.w	r2, [r0], #4
 8004588:	e7eb      	b.n	8004562 <strcmp+0x21a>
 800458a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800458e:	e030      	b.n	80045f2 <strcmp+0x2aa>
 8004590:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8004594:	d128      	bne.n	80045e8 <strcmp+0x2a0>
 8004596:	880b      	ldrh	r3, [r1, #0]
 8004598:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800459c:	e029      	b.n	80045f2 <strcmp+0x2aa>
 800459e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80045a2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80045a6:	e024      	b.n	80045f2 <strcmp+0x2aa>
 80045a8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80045ac:	fa82 f54c 	uadd8	r5, r2, ip
 80045b0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80045b4:	faa5 f58c 	sel	r5, r5, ip
 80045b8:	d10a      	bne.n	80045d0 <strcmp+0x288>
 80045ba:	b965      	cbnz	r5, 80045d6 <strcmp+0x28e>
 80045bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80045c0:	ea84 0402 	eor.w	r4, r4, r2
 80045c4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80045c8:	d109      	bne.n	80045de <strcmp+0x296>
 80045ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80045ce:	e7eb      	b.n	80045a8 <strcmp+0x260>
 80045d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80045d4:	e00d      	b.n	80045f2 <strcmp+0x2aa>
 80045d6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80045da:	d105      	bne.n	80045e8 <strcmp+0x2a0>
 80045dc:	680b      	ldr	r3, [r1, #0]
 80045de:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80045e2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80045e6:	e004      	b.n	80045f2 <strcmp+0x2aa>
 80045e8:	f04f 0000 	mov.w	r0, #0
 80045ec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80045f0:	4770      	bx	lr
 80045f2:	ba12      	rev	r2, r2
 80045f4:	ba1b      	rev	r3, r3
 80045f6:	fa82 f44c 	uadd8	r4, r2, ip
 80045fa:	ea82 0403 	eor.w	r4, r2, r3
 80045fe:	faa4 f58c 	sel	r5, r4, ip
 8004602:	fab5 f485 	clz	r4, r5
 8004606:	fa02 f204 	lsl.w	r2, r2, r4
 800460a:	fa03 f304 	lsl.w	r3, r3, r4
 800460e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8004612:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8004616:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800461a:	4770      	bx	lr
	...

08004640 <strlen>:
 8004640:	f890 f000 	pld	[r0]
 8004644:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8004648:	f020 0107 	bic.w	r1, r0, #7
 800464c:	f06f 0c00 	mvn.w	ip, #0
 8004650:	f010 0407 	ands.w	r4, r0, #7
 8004654:	f891 f020 	pld	[r1, #32]
 8004658:	f040 8049 	bne.w	80046ee <strlen+0xae>
 800465c:	f04f 0400 	mov.w	r4, #0
 8004660:	f06f 0007 	mvn.w	r0, #7
 8004664:	e9d1 2300 	ldrd	r2, r3, [r1]
 8004668:	f891 f040 	pld	[r1, #64]	; 0x40
 800466c:	f100 0008 	add.w	r0, r0, #8
 8004670:	fa82 f24c 	uadd8	r2, r2, ip
 8004674:	faa4 f28c 	sel	r2, r4, ip
 8004678:	fa83 f34c 	uadd8	r3, r3, ip
 800467c:	faa2 f38c 	sel	r3, r2, ip
 8004680:	bb4b      	cbnz	r3, 80046d6 <strlen+0x96>
 8004682:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8004686:	fa82 f24c 	uadd8	r2, r2, ip
 800468a:	f100 0008 	add.w	r0, r0, #8
 800468e:	faa4 f28c 	sel	r2, r4, ip
 8004692:	fa83 f34c 	uadd8	r3, r3, ip
 8004696:	faa2 f38c 	sel	r3, r2, ip
 800469a:	b9e3      	cbnz	r3, 80046d6 <strlen+0x96>
 800469c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 80046a0:	fa82 f24c 	uadd8	r2, r2, ip
 80046a4:	f100 0008 	add.w	r0, r0, #8
 80046a8:	faa4 f28c 	sel	r2, r4, ip
 80046ac:	fa83 f34c 	uadd8	r3, r3, ip
 80046b0:	faa2 f38c 	sel	r3, r2, ip
 80046b4:	b97b      	cbnz	r3, 80046d6 <strlen+0x96>
 80046b6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80046ba:	f101 0120 	add.w	r1, r1, #32
 80046be:	fa82 f24c 	uadd8	r2, r2, ip
 80046c2:	f100 0008 	add.w	r0, r0, #8
 80046c6:	faa4 f28c 	sel	r2, r4, ip
 80046ca:	fa83 f34c 	uadd8	r3, r3, ip
 80046ce:	faa2 f38c 	sel	r3, r2, ip
 80046d2:	2b00      	cmp	r3, #0
 80046d4:	d0c6      	beq.n	8004664 <strlen+0x24>
 80046d6:	2a00      	cmp	r2, #0
 80046d8:	bf04      	itt	eq
 80046da:	3004      	addeq	r0, #4
 80046dc:	461a      	moveq	r2, r3
 80046de:	ba12      	rev	r2, r2
 80046e0:	fab2 f282 	clz	r2, r2
 80046e4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 80046e8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80046ec:	4770      	bx	lr
 80046ee:	e9d1 2300 	ldrd	r2, r3, [r1]
 80046f2:	f004 0503 	and.w	r5, r4, #3
 80046f6:	f1c4 0000 	rsb	r0, r4, #0
 80046fa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80046fe:	f014 0f04 	tst.w	r4, #4
 8004702:	f891 f040 	pld	[r1, #64]	; 0x40
 8004706:	fa0c f505 	lsl.w	r5, ip, r5
 800470a:	ea62 0205 	orn	r2, r2, r5
 800470e:	bf1c      	itt	ne
 8004710:	ea63 0305 	ornne	r3, r3, r5
 8004714:	4662      	movne	r2, ip
 8004716:	f04f 0400 	mov.w	r4, #0
 800471a:	e7a9      	b.n	8004670 <strlen+0x30>

0800471c <memcpy>:
 800471c:	4684      	mov	ip, r0
 800471e:	ea41 0300 	orr.w	r3, r1, r0
 8004722:	f013 0303 	ands.w	r3, r3, #3
 8004726:	d16d      	bne.n	8004804 <memcpy+0xe8>
 8004728:	3a40      	subs	r2, #64	; 0x40
 800472a:	d341      	bcc.n	80047b0 <memcpy+0x94>
 800472c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004730:	f840 3b04 	str.w	r3, [r0], #4
 8004734:	f851 3b04 	ldr.w	r3, [r1], #4
 8004738:	f840 3b04 	str.w	r3, [r0], #4
 800473c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004740:	f840 3b04 	str.w	r3, [r0], #4
 8004744:	f851 3b04 	ldr.w	r3, [r1], #4
 8004748:	f840 3b04 	str.w	r3, [r0], #4
 800474c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004750:	f840 3b04 	str.w	r3, [r0], #4
 8004754:	f851 3b04 	ldr.w	r3, [r1], #4
 8004758:	f840 3b04 	str.w	r3, [r0], #4
 800475c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004760:	f840 3b04 	str.w	r3, [r0], #4
 8004764:	f851 3b04 	ldr.w	r3, [r1], #4
 8004768:	f840 3b04 	str.w	r3, [r0], #4
 800476c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004770:	f840 3b04 	str.w	r3, [r0], #4
 8004774:	f851 3b04 	ldr.w	r3, [r1], #4
 8004778:	f840 3b04 	str.w	r3, [r0], #4
 800477c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004780:	f840 3b04 	str.w	r3, [r0], #4
 8004784:	f851 3b04 	ldr.w	r3, [r1], #4
 8004788:	f840 3b04 	str.w	r3, [r0], #4
 800478c:	f851 3b04 	ldr.w	r3, [r1], #4
 8004790:	f840 3b04 	str.w	r3, [r0], #4
 8004794:	f851 3b04 	ldr.w	r3, [r1], #4
 8004798:	f840 3b04 	str.w	r3, [r0], #4
 800479c:	f851 3b04 	ldr.w	r3, [r1], #4
 80047a0:	f840 3b04 	str.w	r3, [r0], #4
 80047a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80047a8:	f840 3b04 	str.w	r3, [r0], #4
 80047ac:	3a40      	subs	r2, #64	; 0x40
 80047ae:	d2bd      	bcs.n	800472c <memcpy+0x10>
 80047b0:	3230      	adds	r2, #48	; 0x30
 80047b2:	d311      	bcc.n	80047d8 <memcpy+0xbc>
 80047b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80047b8:	f840 3b04 	str.w	r3, [r0], #4
 80047bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80047c0:	f840 3b04 	str.w	r3, [r0], #4
 80047c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80047c8:	f840 3b04 	str.w	r3, [r0], #4
 80047cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80047d0:	f840 3b04 	str.w	r3, [r0], #4
 80047d4:	3a10      	subs	r2, #16
 80047d6:	d2ed      	bcs.n	80047b4 <memcpy+0x98>
 80047d8:	320c      	adds	r2, #12
 80047da:	d305      	bcc.n	80047e8 <memcpy+0xcc>
 80047dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80047e0:	f840 3b04 	str.w	r3, [r0], #4
 80047e4:	3a04      	subs	r2, #4
 80047e6:	d2f9      	bcs.n	80047dc <memcpy+0xc0>
 80047e8:	3204      	adds	r2, #4
 80047ea:	d008      	beq.n	80047fe <memcpy+0xe2>
 80047ec:	07d2      	lsls	r2, r2, #31
 80047ee:	bf1c      	itt	ne
 80047f0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80047f4:	f800 3b01 	strbne.w	r3, [r0], #1
 80047f8:	d301      	bcc.n	80047fe <memcpy+0xe2>
 80047fa:	880b      	ldrh	r3, [r1, #0]
 80047fc:	8003      	strh	r3, [r0, #0]
 80047fe:	4660      	mov	r0, ip
 8004800:	4770      	bx	lr
 8004802:	bf00      	nop
 8004804:	2a08      	cmp	r2, #8
 8004806:	d313      	bcc.n	8004830 <memcpy+0x114>
 8004808:	078b      	lsls	r3, r1, #30
 800480a:	d08d      	beq.n	8004728 <memcpy+0xc>
 800480c:	f010 0303 	ands.w	r3, r0, #3
 8004810:	d08a      	beq.n	8004728 <memcpy+0xc>
 8004812:	f1c3 0304 	rsb	r3, r3, #4
 8004816:	1ad2      	subs	r2, r2, r3
 8004818:	07db      	lsls	r3, r3, #31
 800481a:	bf1c      	itt	ne
 800481c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8004820:	f800 3b01 	strbne.w	r3, [r0], #1
 8004824:	d380      	bcc.n	8004728 <memcpy+0xc>
 8004826:	f831 3b02 	ldrh.w	r3, [r1], #2
 800482a:	f820 3b02 	strh.w	r3, [r0], #2
 800482e:	e77b      	b.n	8004728 <memcpy+0xc>
 8004830:	3a04      	subs	r2, #4
 8004832:	d3d9      	bcc.n	80047e8 <memcpy+0xcc>
 8004834:	3a01      	subs	r2, #1
 8004836:	f811 3b01 	ldrb.w	r3, [r1], #1
 800483a:	f800 3b01 	strb.w	r3, [r0], #1
 800483e:	d2f9      	bcs.n	8004834 <memcpy+0x118>
 8004840:	780b      	ldrb	r3, [r1, #0]
 8004842:	7003      	strb	r3, [r0, #0]
 8004844:	784b      	ldrb	r3, [r1, #1]
 8004846:	7043      	strb	r3, [r0, #1]
 8004848:	788b      	ldrb	r3, [r1, #2]
 800484a:	7083      	strb	r3, [r0, #2]
 800484c:	4660      	mov	r0, ip
 800484e:	4770      	bx	lr

08004850 <__aeabi_uldivmod>:
 8004850:	b953      	cbnz	r3, 8004868 <__aeabi_uldivmod+0x18>
 8004852:	b94a      	cbnz	r2, 8004868 <__aeabi_uldivmod+0x18>
 8004854:	2900      	cmp	r1, #0
 8004856:	bf08      	it	eq
 8004858:	2800      	cmpeq	r0, #0
 800485a:	bf1c      	itt	ne
 800485c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8004860:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8004864:	f000 b97a 	b.w	8004b5c <__aeabi_idiv0>
 8004868:	f1ad 0c08 	sub.w	ip, sp, #8
 800486c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8004870:	f000 f806 	bl	8004880 <__udivmoddi4>
 8004874:	f8dd e004 	ldr.w	lr, [sp, #4]
 8004878:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800487c:	b004      	add	sp, #16
 800487e:	4770      	bx	lr

08004880 <__udivmoddi4>:
 8004880:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004884:	468c      	mov	ip, r1
 8004886:	460d      	mov	r5, r1
 8004888:	4604      	mov	r4, r0
 800488a:	9e08      	ldr	r6, [sp, #32]
 800488c:	2b00      	cmp	r3, #0
 800488e:	d151      	bne.n	8004934 <__udivmoddi4+0xb4>
 8004890:	428a      	cmp	r2, r1
 8004892:	4617      	mov	r7, r2
 8004894:	d96d      	bls.n	8004972 <__udivmoddi4+0xf2>
 8004896:	fab2 fe82 	clz	lr, r2
 800489a:	f1be 0f00 	cmp.w	lr, #0
 800489e:	d00b      	beq.n	80048b8 <__udivmoddi4+0x38>
 80048a0:	f1ce 0c20 	rsb	ip, lr, #32
 80048a4:	fa01 f50e 	lsl.w	r5, r1, lr
 80048a8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80048ac:	fa02 f70e 	lsl.w	r7, r2, lr
 80048b0:	ea4c 0c05 	orr.w	ip, ip, r5
 80048b4:	fa00 f40e 	lsl.w	r4, r0, lr
 80048b8:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 80048bc:	0c25      	lsrs	r5, r4, #16
 80048be:	fbbc f8fa 	udiv	r8, ip, sl
 80048c2:	fa1f f987 	uxth.w	r9, r7
 80048c6:	fb0a cc18 	mls	ip, sl, r8, ip
 80048ca:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 80048ce:	fb08 f309 	mul.w	r3, r8, r9
 80048d2:	42ab      	cmp	r3, r5
 80048d4:	d90a      	bls.n	80048ec <__udivmoddi4+0x6c>
 80048d6:	19ed      	adds	r5, r5, r7
 80048d8:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 80048dc:	f080 8123 	bcs.w	8004b26 <__udivmoddi4+0x2a6>
 80048e0:	42ab      	cmp	r3, r5
 80048e2:	f240 8120 	bls.w	8004b26 <__udivmoddi4+0x2a6>
 80048e6:	f1a8 0802 	sub.w	r8, r8, #2
 80048ea:	443d      	add	r5, r7
 80048ec:	1aed      	subs	r5, r5, r3
 80048ee:	b2a4      	uxth	r4, r4
 80048f0:	fbb5 f0fa 	udiv	r0, r5, sl
 80048f4:	fb0a 5510 	mls	r5, sl, r0, r5
 80048f8:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 80048fc:	fb00 f909 	mul.w	r9, r0, r9
 8004900:	45a1      	cmp	r9, r4
 8004902:	d909      	bls.n	8004918 <__udivmoddi4+0x98>
 8004904:	19e4      	adds	r4, r4, r7
 8004906:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800490a:	f080 810a 	bcs.w	8004b22 <__udivmoddi4+0x2a2>
 800490e:	45a1      	cmp	r9, r4
 8004910:	f240 8107 	bls.w	8004b22 <__udivmoddi4+0x2a2>
 8004914:	3802      	subs	r0, #2
 8004916:	443c      	add	r4, r7
 8004918:	eba4 0409 	sub.w	r4, r4, r9
 800491c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8004920:	2100      	movs	r1, #0
 8004922:	2e00      	cmp	r6, #0
 8004924:	d061      	beq.n	80049ea <__udivmoddi4+0x16a>
 8004926:	fa24 f40e 	lsr.w	r4, r4, lr
 800492a:	2300      	movs	r3, #0
 800492c:	6034      	str	r4, [r6, #0]
 800492e:	6073      	str	r3, [r6, #4]
 8004930:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004934:	428b      	cmp	r3, r1
 8004936:	d907      	bls.n	8004948 <__udivmoddi4+0xc8>
 8004938:	2e00      	cmp	r6, #0
 800493a:	d054      	beq.n	80049e6 <__udivmoddi4+0x166>
 800493c:	2100      	movs	r1, #0
 800493e:	e886 0021 	stmia.w	r6, {r0, r5}
 8004942:	4608      	mov	r0, r1
 8004944:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004948:	fab3 f183 	clz	r1, r3
 800494c:	2900      	cmp	r1, #0
 800494e:	f040 808e 	bne.w	8004a6e <__udivmoddi4+0x1ee>
 8004952:	42ab      	cmp	r3, r5
 8004954:	d302      	bcc.n	800495c <__udivmoddi4+0xdc>
 8004956:	4282      	cmp	r2, r0
 8004958:	f200 80fa 	bhi.w	8004b50 <__udivmoddi4+0x2d0>
 800495c:	1a84      	subs	r4, r0, r2
 800495e:	eb65 0503 	sbc.w	r5, r5, r3
 8004962:	2001      	movs	r0, #1
 8004964:	46ac      	mov	ip, r5
 8004966:	2e00      	cmp	r6, #0
 8004968:	d03f      	beq.n	80049ea <__udivmoddi4+0x16a>
 800496a:	e886 1010 	stmia.w	r6, {r4, ip}
 800496e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004972:	b912      	cbnz	r2, 800497a <__udivmoddi4+0xfa>
 8004974:	2701      	movs	r7, #1
 8004976:	fbb7 f7f2 	udiv	r7, r7, r2
 800497a:	fab7 fe87 	clz	lr, r7
 800497e:	f1be 0f00 	cmp.w	lr, #0
 8004982:	d134      	bne.n	80049ee <__udivmoddi4+0x16e>
 8004984:	1beb      	subs	r3, r5, r7
 8004986:	0c3a      	lsrs	r2, r7, #16
 8004988:	fa1f fc87 	uxth.w	ip, r7
 800498c:	2101      	movs	r1, #1
 800498e:	fbb3 f8f2 	udiv	r8, r3, r2
 8004992:	0c25      	lsrs	r5, r4, #16
 8004994:	fb02 3318 	mls	r3, r2, r8, r3
 8004998:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800499c:	fb0c f308 	mul.w	r3, ip, r8
 80049a0:	42ab      	cmp	r3, r5
 80049a2:	d907      	bls.n	80049b4 <__udivmoddi4+0x134>
 80049a4:	19ed      	adds	r5, r5, r7
 80049a6:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 80049aa:	d202      	bcs.n	80049b2 <__udivmoddi4+0x132>
 80049ac:	42ab      	cmp	r3, r5
 80049ae:	f200 80d1 	bhi.w	8004b54 <__udivmoddi4+0x2d4>
 80049b2:	4680      	mov	r8, r0
 80049b4:	1aed      	subs	r5, r5, r3
 80049b6:	b2a3      	uxth	r3, r4
 80049b8:	fbb5 f0f2 	udiv	r0, r5, r2
 80049bc:	fb02 5510 	mls	r5, r2, r0, r5
 80049c0:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 80049c4:	fb0c fc00 	mul.w	ip, ip, r0
 80049c8:	45a4      	cmp	ip, r4
 80049ca:	d907      	bls.n	80049dc <__udivmoddi4+0x15c>
 80049cc:	19e4      	adds	r4, r4, r7
 80049ce:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80049d2:	d202      	bcs.n	80049da <__udivmoddi4+0x15a>
 80049d4:	45a4      	cmp	ip, r4
 80049d6:	f200 80b8 	bhi.w	8004b4a <__udivmoddi4+0x2ca>
 80049da:	4618      	mov	r0, r3
 80049dc:	eba4 040c 	sub.w	r4, r4, ip
 80049e0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80049e4:	e79d      	b.n	8004922 <__udivmoddi4+0xa2>
 80049e6:	4631      	mov	r1, r6
 80049e8:	4630      	mov	r0, r6
 80049ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80049ee:	f1ce 0420 	rsb	r4, lr, #32
 80049f2:	fa05 f30e 	lsl.w	r3, r5, lr
 80049f6:	fa07 f70e 	lsl.w	r7, r7, lr
 80049fa:	fa20 f804 	lsr.w	r8, r0, r4
 80049fe:	0c3a      	lsrs	r2, r7, #16
 8004a00:	fa25 f404 	lsr.w	r4, r5, r4
 8004a04:	ea48 0803 	orr.w	r8, r8, r3
 8004a08:	fbb4 f1f2 	udiv	r1, r4, r2
 8004a0c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8004a10:	fb02 4411 	mls	r4, r2, r1, r4
 8004a14:	fa1f fc87 	uxth.w	ip, r7
 8004a18:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8004a1c:	fb01 f30c 	mul.w	r3, r1, ip
 8004a20:	42ab      	cmp	r3, r5
 8004a22:	fa00 f40e 	lsl.w	r4, r0, lr
 8004a26:	d909      	bls.n	8004a3c <__udivmoddi4+0x1bc>
 8004a28:	19ed      	adds	r5, r5, r7
 8004a2a:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 8004a2e:	f080 808a 	bcs.w	8004b46 <__udivmoddi4+0x2c6>
 8004a32:	42ab      	cmp	r3, r5
 8004a34:	f240 8087 	bls.w	8004b46 <__udivmoddi4+0x2c6>
 8004a38:	3902      	subs	r1, #2
 8004a3a:	443d      	add	r5, r7
 8004a3c:	1aeb      	subs	r3, r5, r3
 8004a3e:	fa1f f588 	uxth.w	r5, r8
 8004a42:	fbb3 f0f2 	udiv	r0, r3, r2
 8004a46:	fb02 3310 	mls	r3, r2, r0, r3
 8004a4a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8004a4e:	fb00 f30c 	mul.w	r3, r0, ip
 8004a52:	42ab      	cmp	r3, r5
 8004a54:	d907      	bls.n	8004a66 <__udivmoddi4+0x1e6>
 8004a56:	19ed      	adds	r5, r5, r7
 8004a58:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 8004a5c:	d26f      	bcs.n	8004b3e <__udivmoddi4+0x2be>
 8004a5e:	42ab      	cmp	r3, r5
 8004a60:	d96d      	bls.n	8004b3e <__udivmoddi4+0x2be>
 8004a62:	3802      	subs	r0, #2
 8004a64:	443d      	add	r5, r7
 8004a66:	1aeb      	subs	r3, r5, r3
 8004a68:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8004a6c:	e78f      	b.n	800498e <__udivmoddi4+0x10e>
 8004a6e:	f1c1 0720 	rsb	r7, r1, #32
 8004a72:	fa22 f807 	lsr.w	r8, r2, r7
 8004a76:	408b      	lsls	r3, r1
 8004a78:	fa05 f401 	lsl.w	r4, r5, r1
 8004a7c:	ea48 0303 	orr.w	r3, r8, r3
 8004a80:	fa20 fe07 	lsr.w	lr, r0, r7
 8004a84:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8004a88:	40fd      	lsrs	r5, r7
 8004a8a:	ea4e 0e04 	orr.w	lr, lr, r4
 8004a8e:	fbb5 f9fc 	udiv	r9, r5, ip
 8004a92:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8004a96:	fb0c 5519 	mls	r5, ip, r9, r5
 8004a9a:	fa1f f883 	uxth.w	r8, r3
 8004a9e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8004aa2:	fb09 f408 	mul.w	r4, r9, r8
 8004aa6:	42ac      	cmp	r4, r5
 8004aa8:	fa02 f201 	lsl.w	r2, r2, r1
 8004aac:	fa00 fa01 	lsl.w	sl, r0, r1
 8004ab0:	d908      	bls.n	8004ac4 <__udivmoddi4+0x244>
 8004ab2:	18ed      	adds	r5, r5, r3
 8004ab4:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8004ab8:	d243      	bcs.n	8004b42 <__udivmoddi4+0x2c2>
 8004aba:	42ac      	cmp	r4, r5
 8004abc:	d941      	bls.n	8004b42 <__udivmoddi4+0x2c2>
 8004abe:	f1a9 0902 	sub.w	r9, r9, #2
 8004ac2:	441d      	add	r5, r3
 8004ac4:	1b2d      	subs	r5, r5, r4
 8004ac6:	fa1f fe8e 	uxth.w	lr, lr
 8004aca:	fbb5 f0fc 	udiv	r0, r5, ip
 8004ace:	fb0c 5510 	mls	r5, ip, r0, r5
 8004ad2:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8004ad6:	fb00 f808 	mul.w	r8, r0, r8
 8004ada:	45a0      	cmp	r8, r4
 8004adc:	d907      	bls.n	8004aee <__udivmoddi4+0x26e>
 8004ade:	18e4      	adds	r4, r4, r3
 8004ae0:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8004ae4:	d229      	bcs.n	8004b3a <__udivmoddi4+0x2ba>
 8004ae6:	45a0      	cmp	r8, r4
 8004ae8:	d927      	bls.n	8004b3a <__udivmoddi4+0x2ba>
 8004aea:	3802      	subs	r0, #2
 8004aec:	441c      	add	r4, r3
 8004aee:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8004af2:	eba4 0408 	sub.w	r4, r4, r8
 8004af6:	fba0 8902 	umull	r8, r9, r0, r2
 8004afa:	454c      	cmp	r4, r9
 8004afc:	46c6      	mov	lr, r8
 8004afe:	464d      	mov	r5, r9
 8004b00:	d315      	bcc.n	8004b2e <__udivmoddi4+0x2ae>
 8004b02:	d012      	beq.n	8004b2a <__udivmoddi4+0x2aa>
 8004b04:	b156      	cbz	r6, 8004b1c <__udivmoddi4+0x29c>
 8004b06:	ebba 030e 	subs.w	r3, sl, lr
 8004b0a:	eb64 0405 	sbc.w	r4, r4, r5
 8004b0e:	fa04 f707 	lsl.w	r7, r4, r7
 8004b12:	40cb      	lsrs	r3, r1
 8004b14:	431f      	orrs	r7, r3
 8004b16:	40cc      	lsrs	r4, r1
 8004b18:	6037      	str	r7, [r6, #0]
 8004b1a:	6074      	str	r4, [r6, #4]
 8004b1c:	2100      	movs	r1, #0
 8004b1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004b22:	4618      	mov	r0, r3
 8004b24:	e6f8      	b.n	8004918 <__udivmoddi4+0x98>
 8004b26:	4690      	mov	r8, r2
 8004b28:	e6e0      	b.n	80048ec <__udivmoddi4+0x6c>
 8004b2a:	45c2      	cmp	sl, r8
 8004b2c:	d2ea      	bcs.n	8004b04 <__udivmoddi4+0x284>
 8004b2e:	ebb8 0e02 	subs.w	lr, r8, r2
 8004b32:	eb69 0503 	sbc.w	r5, r9, r3
 8004b36:	3801      	subs	r0, #1
 8004b38:	e7e4      	b.n	8004b04 <__udivmoddi4+0x284>
 8004b3a:	4628      	mov	r0, r5
 8004b3c:	e7d7      	b.n	8004aee <__udivmoddi4+0x26e>
 8004b3e:	4640      	mov	r0, r8
 8004b40:	e791      	b.n	8004a66 <__udivmoddi4+0x1e6>
 8004b42:	4681      	mov	r9, r0
 8004b44:	e7be      	b.n	8004ac4 <__udivmoddi4+0x244>
 8004b46:	4601      	mov	r1, r0
 8004b48:	e778      	b.n	8004a3c <__udivmoddi4+0x1bc>
 8004b4a:	3802      	subs	r0, #2
 8004b4c:	443c      	add	r4, r7
 8004b4e:	e745      	b.n	80049dc <__udivmoddi4+0x15c>
 8004b50:	4608      	mov	r0, r1
 8004b52:	e708      	b.n	8004966 <__udivmoddi4+0xe6>
 8004b54:	f1a8 0802 	sub.w	r8, r8, #2
 8004b58:	443d      	add	r5, r7
 8004b5a:	e72b      	b.n	80049b4 <__udivmoddi4+0x134>

08004b5c <__aeabi_idiv0>:
 8004b5c:	4770      	bx	lr
 8004b5e:	bf00      	nop

08004b60 <__aeabi_drsub>:
 8004b60:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8004b64:	e002      	b.n	8004b6c <__adddf3>
 8004b66:	bf00      	nop

08004b68 <__aeabi_dsub>:
 8004b68:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08004b6c <__adddf3>:
 8004b6c:	b530      	push	{r4, r5, lr}
 8004b6e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8004b72:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8004b76:	ea94 0f05 	teq	r4, r5
 8004b7a:	bf08      	it	eq
 8004b7c:	ea90 0f02 	teqeq	r0, r2
 8004b80:	bf1f      	itttt	ne
 8004b82:	ea54 0c00 	orrsne.w	ip, r4, r0
 8004b86:	ea55 0c02 	orrsne.w	ip, r5, r2
 8004b8a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8004b8e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8004b92:	f000 80e2 	beq.w	8004d5a <__adddf3+0x1ee>
 8004b96:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8004b9a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8004b9e:	bfb8      	it	lt
 8004ba0:	426d      	neglt	r5, r5
 8004ba2:	dd0c      	ble.n	8004bbe <__adddf3+0x52>
 8004ba4:	442c      	add	r4, r5
 8004ba6:	ea80 0202 	eor.w	r2, r0, r2
 8004baa:	ea81 0303 	eor.w	r3, r1, r3
 8004bae:	ea82 0000 	eor.w	r0, r2, r0
 8004bb2:	ea83 0101 	eor.w	r1, r3, r1
 8004bb6:	ea80 0202 	eor.w	r2, r0, r2
 8004bba:	ea81 0303 	eor.w	r3, r1, r3
 8004bbe:	2d36      	cmp	r5, #54	; 0x36
 8004bc0:	bf88      	it	hi
 8004bc2:	bd30      	pophi	{r4, r5, pc}
 8004bc4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8004bc8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8004bcc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8004bd0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8004bd4:	d002      	beq.n	8004bdc <__adddf3+0x70>
 8004bd6:	4240      	negs	r0, r0
 8004bd8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8004bdc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8004be0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8004be4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8004be8:	d002      	beq.n	8004bf0 <__adddf3+0x84>
 8004bea:	4252      	negs	r2, r2
 8004bec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8004bf0:	ea94 0f05 	teq	r4, r5
 8004bf4:	f000 80a7 	beq.w	8004d46 <__adddf3+0x1da>
 8004bf8:	f1a4 0401 	sub.w	r4, r4, #1
 8004bfc:	f1d5 0e20 	rsbs	lr, r5, #32
 8004c00:	db0d      	blt.n	8004c1e <__adddf3+0xb2>
 8004c02:	fa02 fc0e 	lsl.w	ip, r2, lr
 8004c06:	fa22 f205 	lsr.w	r2, r2, r5
 8004c0a:	1880      	adds	r0, r0, r2
 8004c0c:	f141 0100 	adc.w	r1, r1, #0
 8004c10:	fa03 f20e 	lsl.w	r2, r3, lr
 8004c14:	1880      	adds	r0, r0, r2
 8004c16:	fa43 f305 	asr.w	r3, r3, r5
 8004c1a:	4159      	adcs	r1, r3
 8004c1c:	e00e      	b.n	8004c3c <__adddf3+0xd0>
 8004c1e:	f1a5 0520 	sub.w	r5, r5, #32
 8004c22:	f10e 0e20 	add.w	lr, lr, #32
 8004c26:	2a01      	cmp	r2, #1
 8004c28:	fa03 fc0e 	lsl.w	ip, r3, lr
 8004c2c:	bf28      	it	cs
 8004c2e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8004c32:	fa43 f305 	asr.w	r3, r3, r5
 8004c36:	18c0      	adds	r0, r0, r3
 8004c38:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8004c3c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8004c40:	d507      	bpl.n	8004c52 <__adddf3+0xe6>
 8004c42:	f04f 0e00 	mov.w	lr, #0
 8004c46:	f1dc 0c00 	rsbs	ip, ip, #0
 8004c4a:	eb7e 0000 	sbcs.w	r0, lr, r0
 8004c4e:	eb6e 0101 	sbc.w	r1, lr, r1
 8004c52:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8004c56:	d31b      	bcc.n	8004c90 <__adddf3+0x124>
 8004c58:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8004c5c:	d30c      	bcc.n	8004c78 <__adddf3+0x10c>
 8004c5e:	0849      	lsrs	r1, r1, #1
 8004c60:	ea5f 0030 	movs.w	r0, r0, rrx
 8004c64:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8004c68:	f104 0401 	add.w	r4, r4, #1
 8004c6c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8004c70:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8004c74:	f080 809a 	bcs.w	8004dac <__adddf3+0x240>
 8004c78:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8004c7c:	bf08      	it	eq
 8004c7e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8004c82:	f150 0000 	adcs.w	r0, r0, #0
 8004c86:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8004c8a:	ea41 0105 	orr.w	r1, r1, r5
 8004c8e:	bd30      	pop	{r4, r5, pc}
 8004c90:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8004c94:	4140      	adcs	r0, r0
 8004c96:	eb41 0101 	adc.w	r1, r1, r1
 8004c9a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8004c9e:	f1a4 0401 	sub.w	r4, r4, #1
 8004ca2:	d1e9      	bne.n	8004c78 <__adddf3+0x10c>
 8004ca4:	f091 0f00 	teq	r1, #0
 8004ca8:	bf04      	itt	eq
 8004caa:	4601      	moveq	r1, r0
 8004cac:	2000      	moveq	r0, #0
 8004cae:	fab1 f381 	clz	r3, r1
 8004cb2:	bf08      	it	eq
 8004cb4:	3320      	addeq	r3, #32
 8004cb6:	f1a3 030b 	sub.w	r3, r3, #11
 8004cba:	f1b3 0220 	subs.w	r2, r3, #32
 8004cbe:	da0c      	bge.n	8004cda <__adddf3+0x16e>
 8004cc0:	320c      	adds	r2, #12
 8004cc2:	dd08      	ble.n	8004cd6 <__adddf3+0x16a>
 8004cc4:	f102 0c14 	add.w	ip, r2, #20
 8004cc8:	f1c2 020c 	rsb	r2, r2, #12
 8004ccc:	fa01 f00c 	lsl.w	r0, r1, ip
 8004cd0:	fa21 f102 	lsr.w	r1, r1, r2
 8004cd4:	e00c      	b.n	8004cf0 <__adddf3+0x184>
 8004cd6:	f102 0214 	add.w	r2, r2, #20
 8004cda:	bfd8      	it	le
 8004cdc:	f1c2 0c20 	rsble	ip, r2, #32
 8004ce0:	fa01 f102 	lsl.w	r1, r1, r2
 8004ce4:	fa20 fc0c 	lsr.w	ip, r0, ip
 8004ce8:	bfdc      	itt	le
 8004cea:	ea41 010c 	orrle.w	r1, r1, ip
 8004cee:	4090      	lslle	r0, r2
 8004cf0:	1ae4      	subs	r4, r4, r3
 8004cf2:	bfa2      	ittt	ge
 8004cf4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8004cf8:	4329      	orrge	r1, r5
 8004cfa:	bd30      	popge	{r4, r5, pc}
 8004cfc:	ea6f 0404 	mvn.w	r4, r4
 8004d00:	3c1f      	subs	r4, #31
 8004d02:	da1c      	bge.n	8004d3e <__adddf3+0x1d2>
 8004d04:	340c      	adds	r4, #12
 8004d06:	dc0e      	bgt.n	8004d26 <__adddf3+0x1ba>
 8004d08:	f104 0414 	add.w	r4, r4, #20
 8004d0c:	f1c4 0220 	rsb	r2, r4, #32
 8004d10:	fa20 f004 	lsr.w	r0, r0, r4
 8004d14:	fa01 f302 	lsl.w	r3, r1, r2
 8004d18:	ea40 0003 	orr.w	r0, r0, r3
 8004d1c:	fa21 f304 	lsr.w	r3, r1, r4
 8004d20:	ea45 0103 	orr.w	r1, r5, r3
 8004d24:	bd30      	pop	{r4, r5, pc}
 8004d26:	f1c4 040c 	rsb	r4, r4, #12
 8004d2a:	f1c4 0220 	rsb	r2, r4, #32
 8004d2e:	fa20 f002 	lsr.w	r0, r0, r2
 8004d32:	fa01 f304 	lsl.w	r3, r1, r4
 8004d36:	ea40 0003 	orr.w	r0, r0, r3
 8004d3a:	4629      	mov	r1, r5
 8004d3c:	bd30      	pop	{r4, r5, pc}
 8004d3e:	fa21 f004 	lsr.w	r0, r1, r4
 8004d42:	4629      	mov	r1, r5
 8004d44:	bd30      	pop	{r4, r5, pc}
 8004d46:	f094 0f00 	teq	r4, #0
 8004d4a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8004d4e:	bf06      	itte	eq
 8004d50:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8004d54:	3401      	addeq	r4, #1
 8004d56:	3d01      	subne	r5, #1
 8004d58:	e74e      	b.n	8004bf8 <__adddf3+0x8c>
 8004d5a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8004d5e:	bf18      	it	ne
 8004d60:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8004d64:	d029      	beq.n	8004dba <__adddf3+0x24e>
 8004d66:	ea94 0f05 	teq	r4, r5
 8004d6a:	bf08      	it	eq
 8004d6c:	ea90 0f02 	teqeq	r0, r2
 8004d70:	d005      	beq.n	8004d7e <__adddf3+0x212>
 8004d72:	ea54 0c00 	orrs.w	ip, r4, r0
 8004d76:	bf04      	itt	eq
 8004d78:	4619      	moveq	r1, r3
 8004d7a:	4610      	moveq	r0, r2
 8004d7c:	bd30      	pop	{r4, r5, pc}
 8004d7e:	ea91 0f03 	teq	r1, r3
 8004d82:	bf1e      	ittt	ne
 8004d84:	2100      	movne	r1, #0
 8004d86:	2000      	movne	r0, #0
 8004d88:	bd30      	popne	{r4, r5, pc}
 8004d8a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8004d8e:	d105      	bne.n	8004d9c <__adddf3+0x230>
 8004d90:	0040      	lsls	r0, r0, #1
 8004d92:	4149      	adcs	r1, r1
 8004d94:	bf28      	it	cs
 8004d96:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8004d9a:	bd30      	pop	{r4, r5, pc}
 8004d9c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8004da0:	bf3c      	itt	cc
 8004da2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8004da6:	bd30      	popcc	{r4, r5, pc}
 8004da8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8004dac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8004db0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8004db4:	f04f 0000 	mov.w	r0, #0
 8004db8:	bd30      	pop	{r4, r5, pc}
 8004dba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8004dbe:	bf1a      	itte	ne
 8004dc0:	4619      	movne	r1, r3
 8004dc2:	4610      	movne	r0, r2
 8004dc4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8004dc8:	bf1c      	itt	ne
 8004dca:	460b      	movne	r3, r1
 8004dcc:	4602      	movne	r2, r0
 8004dce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8004dd2:	bf06      	itte	eq
 8004dd4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8004dd8:	ea91 0f03 	teqeq	r1, r3
 8004ddc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8004de0:	bd30      	pop	{r4, r5, pc}
 8004de2:	bf00      	nop

08004de4 <__aeabi_ui2d>:
 8004de4:	f090 0f00 	teq	r0, #0
 8004de8:	bf04      	itt	eq
 8004dea:	2100      	moveq	r1, #0
 8004dec:	4770      	bxeq	lr
 8004dee:	b530      	push	{r4, r5, lr}
 8004df0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8004df4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8004df8:	f04f 0500 	mov.w	r5, #0
 8004dfc:	f04f 0100 	mov.w	r1, #0
 8004e00:	e750      	b.n	8004ca4 <__adddf3+0x138>
 8004e02:	bf00      	nop

08004e04 <__aeabi_i2d>:
 8004e04:	f090 0f00 	teq	r0, #0
 8004e08:	bf04      	itt	eq
 8004e0a:	2100      	moveq	r1, #0
 8004e0c:	4770      	bxeq	lr
 8004e0e:	b530      	push	{r4, r5, lr}
 8004e10:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8004e14:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8004e18:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8004e1c:	bf48      	it	mi
 8004e1e:	4240      	negmi	r0, r0
 8004e20:	f04f 0100 	mov.w	r1, #0
 8004e24:	e73e      	b.n	8004ca4 <__adddf3+0x138>
 8004e26:	bf00      	nop

08004e28 <__aeabi_f2d>:
 8004e28:	0042      	lsls	r2, r0, #1
 8004e2a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8004e2e:	ea4f 0131 	mov.w	r1, r1, rrx
 8004e32:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8004e36:	bf1f      	itttt	ne
 8004e38:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8004e3c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8004e40:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8004e44:	4770      	bxne	lr
 8004e46:	f092 0f00 	teq	r2, #0
 8004e4a:	bf14      	ite	ne
 8004e4c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8004e50:	4770      	bxeq	lr
 8004e52:	b530      	push	{r4, r5, lr}
 8004e54:	f44f 7460 	mov.w	r4, #896	; 0x380
 8004e58:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8004e5c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8004e60:	e720      	b.n	8004ca4 <__adddf3+0x138>
 8004e62:	bf00      	nop

08004e64 <__aeabi_ul2d>:
 8004e64:	ea50 0201 	orrs.w	r2, r0, r1
 8004e68:	bf08      	it	eq
 8004e6a:	4770      	bxeq	lr
 8004e6c:	b530      	push	{r4, r5, lr}
 8004e6e:	f04f 0500 	mov.w	r5, #0
 8004e72:	e00a      	b.n	8004e8a <__aeabi_l2d+0x16>

08004e74 <__aeabi_l2d>:
 8004e74:	ea50 0201 	orrs.w	r2, r0, r1
 8004e78:	bf08      	it	eq
 8004e7a:	4770      	bxeq	lr
 8004e7c:	b530      	push	{r4, r5, lr}
 8004e7e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8004e82:	d502      	bpl.n	8004e8a <__aeabi_l2d+0x16>
 8004e84:	4240      	negs	r0, r0
 8004e86:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8004e8a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8004e8e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8004e92:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8004e96:	f43f aedc 	beq.w	8004c52 <__adddf3+0xe6>
 8004e9a:	f04f 0203 	mov.w	r2, #3
 8004e9e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8004ea2:	bf18      	it	ne
 8004ea4:	3203      	addne	r2, #3
 8004ea6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8004eaa:	bf18      	it	ne
 8004eac:	3203      	addne	r2, #3
 8004eae:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8004eb2:	f1c2 0320 	rsb	r3, r2, #32
 8004eb6:	fa00 fc03 	lsl.w	ip, r0, r3
 8004eba:	fa20 f002 	lsr.w	r0, r0, r2
 8004ebe:	fa01 fe03 	lsl.w	lr, r1, r3
 8004ec2:	ea40 000e 	orr.w	r0, r0, lr
 8004ec6:	fa21 f102 	lsr.w	r1, r1, r2
 8004eca:	4414      	add	r4, r2
 8004ecc:	e6c1      	b.n	8004c52 <__adddf3+0xe6>
 8004ece:	bf00      	nop

08004ed0 <__aeabi_dmul>:
 8004ed0:	b570      	push	{r4, r5, r6, lr}
 8004ed2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8004ed6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8004eda:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8004ede:	bf1d      	ittte	ne
 8004ee0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8004ee4:	ea94 0f0c 	teqne	r4, ip
 8004ee8:	ea95 0f0c 	teqne	r5, ip
 8004eec:	f000 f8de 	bleq	80050ac <__aeabi_dmul+0x1dc>
 8004ef0:	442c      	add	r4, r5
 8004ef2:	ea81 0603 	eor.w	r6, r1, r3
 8004ef6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8004efa:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8004efe:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8004f02:	bf18      	it	ne
 8004f04:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8004f08:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8004f0c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004f10:	d038      	beq.n	8004f84 <__aeabi_dmul+0xb4>
 8004f12:	fba0 ce02 	umull	ip, lr, r0, r2
 8004f16:	f04f 0500 	mov.w	r5, #0
 8004f1a:	fbe1 e502 	umlal	lr, r5, r1, r2
 8004f1e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8004f22:	fbe0 e503 	umlal	lr, r5, r0, r3
 8004f26:	f04f 0600 	mov.w	r6, #0
 8004f2a:	fbe1 5603 	umlal	r5, r6, r1, r3
 8004f2e:	f09c 0f00 	teq	ip, #0
 8004f32:	bf18      	it	ne
 8004f34:	f04e 0e01 	orrne.w	lr, lr, #1
 8004f38:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8004f3c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8004f40:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8004f44:	d204      	bcs.n	8004f50 <__aeabi_dmul+0x80>
 8004f46:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8004f4a:	416d      	adcs	r5, r5
 8004f4c:	eb46 0606 	adc.w	r6, r6, r6
 8004f50:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8004f54:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8004f58:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8004f5c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8004f60:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8004f64:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8004f68:	bf88      	it	hi
 8004f6a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8004f6e:	d81e      	bhi.n	8004fae <__aeabi_dmul+0xde>
 8004f70:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8004f74:	bf08      	it	eq
 8004f76:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8004f7a:	f150 0000 	adcs.w	r0, r0, #0
 8004f7e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8004f82:	bd70      	pop	{r4, r5, r6, pc}
 8004f84:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8004f88:	ea46 0101 	orr.w	r1, r6, r1
 8004f8c:	ea40 0002 	orr.w	r0, r0, r2
 8004f90:	ea81 0103 	eor.w	r1, r1, r3
 8004f94:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8004f98:	bfc2      	ittt	gt
 8004f9a:	ebd4 050c 	rsbsgt	r5, r4, ip
 8004f9e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8004fa2:	bd70      	popgt	{r4, r5, r6, pc}
 8004fa4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8004fa8:	f04f 0e00 	mov.w	lr, #0
 8004fac:	3c01      	subs	r4, #1
 8004fae:	f300 80ab 	bgt.w	8005108 <__aeabi_dmul+0x238>
 8004fb2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8004fb6:	bfde      	ittt	le
 8004fb8:	2000      	movle	r0, #0
 8004fba:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8004fbe:	bd70      	pople	{r4, r5, r6, pc}
 8004fc0:	f1c4 0400 	rsb	r4, r4, #0
 8004fc4:	3c20      	subs	r4, #32
 8004fc6:	da35      	bge.n	8005034 <__aeabi_dmul+0x164>
 8004fc8:	340c      	adds	r4, #12
 8004fca:	dc1b      	bgt.n	8005004 <__aeabi_dmul+0x134>
 8004fcc:	f104 0414 	add.w	r4, r4, #20
 8004fd0:	f1c4 0520 	rsb	r5, r4, #32
 8004fd4:	fa00 f305 	lsl.w	r3, r0, r5
 8004fd8:	fa20 f004 	lsr.w	r0, r0, r4
 8004fdc:	fa01 f205 	lsl.w	r2, r1, r5
 8004fe0:	ea40 0002 	orr.w	r0, r0, r2
 8004fe4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8004fe8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8004fec:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8004ff0:	fa21 f604 	lsr.w	r6, r1, r4
 8004ff4:	eb42 0106 	adc.w	r1, r2, r6
 8004ff8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8004ffc:	bf08      	it	eq
 8004ffe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8005002:	bd70      	pop	{r4, r5, r6, pc}
 8005004:	f1c4 040c 	rsb	r4, r4, #12
 8005008:	f1c4 0520 	rsb	r5, r4, #32
 800500c:	fa00 f304 	lsl.w	r3, r0, r4
 8005010:	fa20 f005 	lsr.w	r0, r0, r5
 8005014:	fa01 f204 	lsl.w	r2, r1, r4
 8005018:	ea40 0002 	orr.w	r0, r0, r2
 800501c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8005020:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8005024:	f141 0100 	adc.w	r1, r1, #0
 8005028:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800502c:	bf08      	it	eq
 800502e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8005032:	bd70      	pop	{r4, r5, r6, pc}
 8005034:	f1c4 0520 	rsb	r5, r4, #32
 8005038:	fa00 f205 	lsl.w	r2, r0, r5
 800503c:	ea4e 0e02 	orr.w	lr, lr, r2
 8005040:	fa20 f304 	lsr.w	r3, r0, r4
 8005044:	fa01 f205 	lsl.w	r2, r1, r5
 8005048:	ea43 0302 	orr.w	r3, r3, r2
 800504c:	fa21 f004 	lsr.w	r0, r1, r4
 8005050:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8005054:	fa21 f204 	lsr.w	r2, r1, r4
 8005058:	ea20 0002 	bic.w	r0, r0, r2
 800505c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8005060:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8005064:	bf08      	it	eq
 8005066:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800506a:	bd70      	pop	{r4, r5, r6, pc}
 800506c:	f094 0f00 	teq	r4, #0
 8005070:	d10f      	bne.n	8005092 <__aeabi_dmul+0x1c2>
 8005072:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8005076:	0040      	lsls	r0, r0, #1
 8005078:	eb41 0101 	adc.w	r1, r1, r1
 800507c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8005080:	bf08      	it	eq
 8005082:	3c01      	subeq	r4, #1
 8005084:	d0f7      	beq.n	8005076 <__aeabi_dmul+0x1a6>
 8005086:	ea41 0106 	orr.w	r1, r1, r6
 800508a:	f095 0f00 	teq	r5, #0
 800508e:	bf18      	it	ne
 8005090:	4770      	bxne	lr
 8005092:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8005096:	0052      	lsls	r2, r2, #1
 8005098:	eb43 0303 	adc.w	r3, r3, r3
 800509c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80050a0:	bf08      	it	eq
 80050a2:	3d01      	subeq	r5, #1
 80050a4:	d0f7      	beq.n	8005096 <__aeabi_dmul+0x1c6>
 80050a6:	ea43 0306 	orr.w	r3, r3, r6
 80050aa:	4770      	bx	lr
 80050ac:	ea94 0f0c 	teq	r4, ip
 80050b0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80050b4:	bf18      	it	ne
 80050b6:	ea95 0f0c 	teqne	r5, ip
 80050ba:	d00c      	beq.n	80050d6 <__aeabi_dmul+0x206>
 80050bc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80050c0:	bf18      	it	ne
 80050c2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80050c6:	d1d1      	bne.n	800506c <__aeabi_dmul+0x19c>
 80050c8:	ea81 0103 	eor.w	r1, r1, r3
 80050cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80050d0:	f04f 0000 	mov.w	r0, #0
 80050d4:	bd70      	pop	{r4, r5, r6, pc}
 80050d6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80050da:	bf06      	itte	eq
 80050dc:	4610      	moveq	r0, r2
 80050de:	4619      	moveq	r1, r3
 80050e0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80050e4:	d019      	beq.n	800511a <__aeabi_dmul+0x24a>
 80050e6:	ea94 0f0c 	teq	r4, ip
 80050ea:	d102      	bne.n	80050f2 <__aeabi_dmul+0x222>
 80050ec:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80050f0:	d113      	bne.n	800511a <__aeabi_dmul+0x24a>
 80050f2:	ea95 0f0c 	teq	r5, ip
 80050f6:	d105      	bne.n	8005104 <__aeabi_dmul+0x234>
 80050f8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80050fc:	bf1c      	itt	ne
 80050fe:	4610      	movne	r0, r2
 8005100:	4619      	movne	r1, r3
 8005102:	d10a      	bne.n	800511a <__aeabi_dmul+0x24a>
 8005104:	ea81 0103 	eor.w	r1, r1, r3
 8005108:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800510c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8005110:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8005114:	f04f 0000 	mov.w	r0, #0
 8005118:	bd70      	pop	{r4, r5, r6, pc}
 800511a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800511e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8005122:	bd70      	pop	{r4, r5, r6, pc}

08005124 <__aeabi_ddiv>:
 8005124:	b570      	push	{r4, r5, r6, lr}
 8005126:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800512a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800512e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8005132:	bf1d      	ittte	ne
 8005134:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8005138:	ea94 0f0c 	teqne	r4, ip
 800513c:	ea95 0f0c 	teqne	r5, ip
 8005140:	f000 f8a7 	bleq	8005292 <__aeabi_ddiv+0x16e>
 8005144:	eba4 0405 	sub.w	r4, r4, r5
 8005148:	ea81 0e03 	eor.w	lr, r1, r3
 800514c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8005150:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8005154:	f000 8088 	beq.w	8005268 <__aeabi_ddiv+0x144>
 8005158:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800515c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8005160:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8005164:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8005168:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800516c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8005170:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8005174:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8005178:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800517c:	429d      	cmp	r5, r3
 800517e:	bf08      	it	eq
 8005180:	4296      	cmpeq	r6, r2
 8005182:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8005186:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800518a:	d202      	bcs.n	8005192 <__aeabi_ddiv+0x6e>
 800518c:	085b      	lsrs	r3, r3, #1
 800518e:	ea4f 0232 	mov.w	r2, r2, rrx
 8005192:	1ab6      	subs	r6, r6, r2
 8005194:	eb65 0503 	sbc.w	r5, r5, r3
 8005198:	085b      	lsrs	r3, r3, #1
 800519a:	ea4f 0232 	mov.w	r2, r2, rrx
 800519e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80051a2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80051a6:	ebb6 0e02 	subs.w	lr, r6, r2
 80051aa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80051ae:	bf22      	ittt	cs
 80051b0:	1ab6      	subcs	r6, r6, r2
 80051b2:	4675      	movcs	r5, lr
 80051b4:	ea40 000c 	orrcs.w	r0, r0, ip
 80051b8:	085b      	lsrs	r3, r3, #1
 80051ba:	ea4f 0232 	mov.w	r2, r2, rrx
 80051be:	ebb6 0e02 	subs.w	lr, r6, r2
 80051c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80051c6:	bf22      	ittt	cs
 80051c8:	1ab6      	subcs	r6, r6, r2
 80051ca:	4675      	movcs	r5, lr
 80051cc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80051d0:	085b      	lsrs	r3, r3, #1
 80051d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80051d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80051da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80051de:	bf22      	ittt	cs
 80051e0:	1ab6      	subcs	r6, r6, r2
 80051e2:	4675      	movcs	r5, lr
 80051e4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80051e8:	085b      	lsrs	r3, r3, #1
 80051ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80051ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80051f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80051f6:	bf22      	ittt	cs
 80051f8:	1ab6      	subcs	r6, r6, r2
 80051fa:	4675      	movcs	r5, lr
 80051fc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8005200:	ea55 0e06 	orrs.w	lr, r5, r6
 8005204:	d018      	beq.n	8005238 <__aeabi_ddiv+0x114>
 8005206:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800520a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800520e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8005212:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8005216:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800521a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800521e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8005222:	d1c0      	bne.n	80051a6 <__aeabi_ddiv+0x82>
 8005224:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8005228:	d10b      	bne.n	8005242 <__aeabi_ddiv+0x11e>
 800522a:	ea41 0100 	orr.w	r1, r1, r0
 800522e:	f04f 0000 	mov.w	r0, #0
 8005232:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8005236:	e7b6      	b.n	80051a6 <__aeabi_ddiv+0x82>
 8005238:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800523c:	bf04      	itt	eq
 800523e:	4301      	orreq	r1, r0
 8005240:	2000      	moveq	r0, #0
 8005242:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8005246:	bf88      	it	hi
 8005248:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800524c:	f63f aeaf 	bhi.w	8004fae <__aeabi_dmul+0xde>
 8005250:	ebb5 0c03 	subs.w	ip, r5, r3
 8005254:	bf04      	itt	eq
 8005256:	ebb6 0c02 	subseq.w	ip, r6, r2
 800525a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800525e:	f150 0000 	adcs.w	r0, r0, #0
 8005262:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8005266:	bd70      	pop	{r4, r5, r6, pc}
 8005268:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800526c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8005270:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8005274:	bfc2      	ittt	gt
 8005276:	ebd4 050c 	rsbsgt	r5, r4, ip
 800527a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800527e:	bd70      	popgt	{r4, r5, r6, pc}
 8005280:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8005284:	f04f 0e00 	mov.w	lr, #0
 8005288:	3c01      	subs	r4, #1
 800528a:	e690      	b.n	8004fae <__aeabi_dmul+0xde>
 800528c:	ea45 0e06 	orr.w	lr, r5, r6
 8005290:	e68d      	b.n	8004fae <__aeabi_dmul+0xde>
 8005292:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8005296:	ea94 0f0c 	teq	r4, ip
 800529a:	bf08      	it	eq
 800529c:	ea95 0f0c 	teqeq	r5, ip
 80052a0:	f43f af3b 	beq.w	800511a <__aeabi_dmul+0x24a>
 80052a4:	ea94 0f0c 	teq	r4, ip
 80052a8:	d10a      	bne.n	80052c0 <__aeabi_ddiv+0x19c>
 80052aa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80052ae:	f47f af34 	bne.w	800511a <__aeabi_dmul+0x24a>
 80052b2:	ea95 0f0c 	teq	r5, ip
 80052b6:	f47f af25 	bne.w	8005104 <__aeabi_dmul+0x234>
 80052ba:	4610      	mov	r0, r2
 80052bc:	4619      	mov	r1, r3
 80052be:	e72c      	b.n	800511a <__aeabi_dmul+0x24a>
 80052c0:	ea95 0f0c 	teq	r5, ip
 80052c4:	d106      	bne.n	80052d4 <__aeabi_ddiv+0x1b0>
 80052c6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80052ca:	f43f aefd 	beq.w	80050c8 <__aeabi_dmul+0x1f8>
 80052ce:	4610      	mov	r0, r2
 80052d0:	4619      	mov	r1, r3
 80052d2:	e722      	b.n	800511a <__aeabi_dmul+0x24a>
 80052d4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80052d8:	bf18      	it	ne
 80052da:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80052de:	f47f aec5 	bne.w	800506c <__aeabi_dmul+0x19c>
 80052e2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80052e6:	f47f af0d 	bne.w	8005104 <__aeabi_dmul+0x234>
 80052ea:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80052ee:	f47f aeeb 	bne.w	80050c8 <__aeabi_dmul+0x1f8>
 80052f2:	e712      	b.n	800511a <__aeabi_dmul+0x24a>

080052f4 <__aeabi_d2iz>:
 80052f4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80052f8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80052fc:	d215      	bcs.n	800532a <__aeabi_d2iz+0x36>
 80052fe:	d511      	bpl.n	8005324 <__aeabi_d2iz+0x30>
 8005300:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8005304:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8005308:	d912      	bls.n	8005330 <__aeabi_d2iz+0x3c>
 800530a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800530e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005312:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8005316:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800531a:	fa23 f002 	lsr.w	r0, r3, r2
 800531e:	bf18      	it	ne
 8005320:	4240      	negne	r0, r0
 8005322:	4770      	bx	lr
 8005324:	f04f 0000 	mov.w	r0, #0
 8005328:	4770      	bx	lr
 800532a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800532e:	d105      	bne.n	800533c <__aeabi_d2iz+0x48>
 8005330:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8005334:	bf08      	it	eq
 8005336:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800533a:	4770      	bx	lr
 800533c:	f04f 0000 	mov.w	r0, #0
 8005340:	4770      	bx	lr
 8005342:	bf00      	nop

08005344 <__aeabi_d2f>:
 8005344:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8005348:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 800534c:	bf24      	itt	cs
 800534e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8005352:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8005356:	d90d      	bls.n	8005374 <__aeabi_d2f+0x30>
 8005358:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800535c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8005360:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8005364:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8005368:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 800536c:	bf08      	it	eq
 800536e:	f020 0001 	biceq.w	r0, r0, #1
 8005372:	4770      	bx	lr
 8005374:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8005378:	d121      	bne.n	80053be <__aeabi_d2f+0x7a>
 800537a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 800537e:	bfbc      	itt	lt
 8005380:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8005384:	4770      	bxlt	lr
 8005386:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800538a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 800538e:	f1c2 0218 	rsb	r2, r2, #24
 8005392:	f1c2 0c20 	rsb	ip, r2, #32
 8005396:	fa10 f30c 	lsls.w	r3, r0, ip
 800539a:	fa20 f002 	lsr.w	r0, r0, r2
 800539e:	bf18      	it	ne
 80053a0:	f040 0001 	orrne.w	r0, r0, #1
 80053a4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80053a8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80053ac:	fa03 fc0c 	lsl.w	ip, r3, ip
 80053b0:	ea40 000c 	orr.w	r0, r0, ip
 80053b4:	fa23 f302 	lsr.w	r3, r3, r2
 80053b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80053bc:	e7cc      	b.n	8005358 <__aeabi_d2f+0x14>
 80053be:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80053c2:	d107      	bne.n	80053d4 <__aeabi_d2f+0x90>
 80053c4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80053c8:	bf1e      	ittt	ne
 80053ca:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80053ce:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80053d2:	4770      	bxne	lr
 80053d4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80053d8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80053dc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80053e0:	4770      	bx	lr
 80053e2:	bf00      	nop
	...

080053f0 <memchr>:
 80053f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80053f4:	2a10      	cmp	r2, #16
 80053f6:	db2b      	blt.n	8005450 <memchr+0x60>
 80053f8:	f010 0f07 	tst.w	r0, #7
 80053fc:	d008      	beq.n	8005410 <memchr+0x20>
 80053fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8005402:	3a01      	subs	r2, #1
 8005404:	428b      	cmp	r3, r1
 8005406:	d02d      	beq.n	8005464 <memchr+0x74>
 8005408:	f010 0f07 	tst.w	r0, #7
 800540c:	b342      	cbz	r2, 8005460 <memchr+0x70>
 800540e:	d1f6      	bne.n	80053fe <memchr+0xe>
 8005410:	b4f0      	push	{r4, r5, r6, r7}
 8005412:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8005416:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800541a:	f022 0407 	bic.w	r4, r2, #7
 800541e:	f07f 0700 	mvns.w	r7, #0
 8005422:	2300      	movs	r3, #0
 8005424:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8005428:	3c08      	subs	r4, #8
 800542a:	ea85 0501 	eor.w	r5, r5, r1
 800542e:	ea86 0601 	eor.w	r6, r6, r1
 8005432:	fa85 f547 	uadd8	r5, r5, r7
 8005436:	faa3 f587 	sel	r5, r3, r7
 800543a:	fa86 f647 	uadd8	r6, r6, r7
 800543e:	faa5 f687 	sel	r6, r5, r7
 8005442:	b98e      	cbnz	r6, 8005468 <memchr+0x78>
 8005444:	d1ee      	bne.n	8005424 <memchr+0x34>
 8005446:	bcf0      	pop	{r4, r5, r6, r7}
 8005448:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800544c:	f002 0207 	and.w	r2, r2, #7
 8005450:	b132      	cbz	r2, 8005460 <memchr+0x70>
 8005452:	f810 3b01 	ldrb.w	r3, [r0], #1
 8005456:	3a01      	subs	r2, #1
 8005458:	ea83 0301 	eor.w	r3, r3, r1
 800545c:	b113      	cbz	r3, 8005464 <memchr+0x74>
 800545e:	d1f8      	bne.n	8005452 <memchr+0x62>
 8005460:	2000      	movs	r0, #0
 8005462:	4770      	bx	lr
 8005464:	3801      	subs	r0, #1
 8005466:	4770      	bx	lr
 8005468:	2d00      	cmp	r5, #0
 800546a:	bf06      	itte	eq
 800546c:	4635      	moveq	r5, r6
 800546e:	3803      	subeq	r0, #3
 8005470:	3807      	subne	r0, #7
 8005472:	f015 0f01 	tst.w	r5, #1
 8005476:	d107      	bne.n	8005488 <memchr+0x98>
 8005478:	3001      	adds	r0, #1
 800547a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800547e:	bf02      	ittt	eq
 8005480:	3001      	addeq	r0, #1
 8005482:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8005486:	3001      	addeq	r0, #1
 8005488:	bcf0      	pop	{r4, r5, r6, r7}
 800548a:	3801      	subs	r0, #1
 800548c:	4770      	bx	lr
 800548e:	bf00      	nop

08005490 <__gedf2>:
 8005490:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8005494:	e006      	b.n	80054a4 <__cmpdf2+0x4>
 8005496:	bf00      	nop

08005498 <__ledf2>:
 8005498:	f04f 0c01 	mov.w	ip, #1
 800549c:	e002      	b.n	80054a4 <__cmpdf2+0x4>
 800549e:	bf00      	nop

080054a0 <__cmpdf2>:
 80054a0:	f04f 0c01 	mov.w	ip, #1
 80054a4:	f84d cd04 	str.w	ip, [sp, #-4]!
 80054a8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80054ac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80054b0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80054b4:	bf18      	it	ne
 80054b6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80054ba:	d01b      	beq.n	80054f4 <__cmpdf2+0x54>
 80054bc:	b001      	add	sp, #4
 80054be:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80054c2:	bf0c      	ite	eq
 80054c4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80054c8:	ea91 0f03 	teqne	r1, r3
 80054cc:	bf02      	ittt	eq
 80054ce:	ea90 0f02 	teqeq	r0, r2
 80054d2:	2000      	moveq	r0, #0
 80054d4:	4770      	bxeq	lr
 80054d6:	f110 0f00 	cmn.w	r0, #0
 80054da:	ea91 0f03 	teq	r1, r3
 80054de:	bf58      	it	pl
 80054e0:	4299      	cmppl	r1, r3
 80054e2:	bf08      	it	eq
 80054e4:	4290      	cmpeq	r0, r2
 80054e6:	bf2c      	ite	cs
 80054e8:	17d8      	asrcs	r0, r3, #31
 80054ea:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80054ee:	f040 0001 	orr.w	r0, r0, #1
 80054f2:	4770      	bx	lr
 80054f4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80054f8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80054fc:	d102      	bne.n	8005504 <__cmpdf2+0x64>
 80054fe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8005502:	d107      	bne.n	8005514 <__cmpdf2+0x74>
 8005504:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8005508:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800550c:	d1d6      	bne.n	80054bc <__cmpdf2+0x1c>
 800550e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8005512:	d0d3      	beq.n	80054bc <__cmpdf2+0x1c>
 8005514:	f85d 0b04 	ldr.w	r0, [sp], #4
 8005518:	4770      	bx	lr
 800551a:	bf00      	nop

0800551c <__aeabi_cdrcmple>:
 800551c:	4684      	mov	ip, r0
 800551e:	4610      	mov	r0, r2
 8005520:	4662      	mov	r2, ip
 8005522:	468c      	mov	ip, r1
 8005524:	4619      	mov	r1, r3
 8005526:	4663      	mov	r3, ip
 8005528:	e000      	b.n	800552c <__aeabi_cdcmpeq>
 800552a:	bf00      	nop

0800552c <__aeabi_cdcmpeq>:
 800552c:	b501      	push	{r0, lr}
 800552e:	f7ff ffb7 	bl	80054a0 <__cmpdf2>
 8005532:	2800      	cmp	r0, #0
 8005534:	bf48      	it	mi
 8005536:	f110 0f00 	cmnmi.w	r0, #0
 800553a:	bd01      	pop	{r0, pc}

0800553c <__aeabi_dcmpeq>:
 800553c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8005540:	f7ff fff4 	bl	800552c <__aeabi_cdcmpeq>
 8005544:	bf0c      	ite	eq
 8005546:	2001      	moveq	r0, #1
 8005548:	2000      	movne	r0, #0
 800554a:	f85d fb08 	ldr.w	pc, [sp], #8
 800554e:	bf00      	nop

08005550 <__aeabi_dcmplt>:
 8005550:	f84d ed08 	str.w	lr, [sp, #-8]!
 8005554:	f7ff ffea 	bl	800552c <__aeabi_cdcmpeq>
 8005558:	bf34      	ite	cc
 800555a:	2001      	movcc	r0, #1
 800555c:	2000      	movcs	r0, #0
 800555e:	f85d fb08 	ldr.w	pc, [sp], #8
 8005562:	bf00      	nop

08005564 <__aeabi_dcmple>:
 8005564:	f84d ed08 	str.w	lr, [sp, #-8]!
 8005568:	f7ff ffe0 	bl	800552c <__aeabi_cdcmpeq>
 800556c:	bf94      	ite	ls
 800556e:	2001      	movls	r0, #1
 8005570:	2000      	movhi	r0, #0
 8005572:	f85d fb08 	ldr.w	pc, [sp], #8
 8005576:	bf00      	nop

08005578 <__aeabi_dcmpge>:
 8005578:	f84d ed08 	str.w	lr, [sp, #-8]!
 800557c:	f7ff ffce 	bl	800551c <__aeabi_cdrcmple>
 8005580:	bf94      	ite	ls
 8005582:	2001      	movls	r0, #1
 8005584:	2000      	movhi	r0, #0
 8005586:	f85d fb08 	ldr.w	pc, [sp], #8
 800558a:	bf00      	nop

0800558c <__aeabi_dcmpgt>:
 800558c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8005590:	f7ff ffc4 	bl	800551c <__aeabi_cdrcmple>
 8005594:	bf34      	ite	cc
 8005596:	2001      	movcc	r0, #1
 8005598:	2000      	movcs	r0, #0
 800559a:	f85d fb08 	ldr.w	pc, [sp], #8
 800559e:	bf00      	nop

080055a0 <__aeabi_dcmpun>:
 80055a0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80055a4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80055a8:	d102      	bne.n	80055b0 <__aeabi_dcmpun+0x10>
 80055aa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80055ae:	d10a      	bne.n	80055c6 <__aeabi_dcmpun+0x26>
 80055b0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80055b4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80055b8:	d102      	bne.n	80055c0 <__aeabi_dcmpun+0x20>
 80055ba:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80055be:	d102      	bne.n	80055c6 <__aeabi_dcmpun+0x26>
 80055c0:	f04f 0000 	mov.w	r0, #0
 80055c4:	4770      	bx	lr
 80055c6:	f04f 0001 	mov.w	r0, #1
 80055ca:	4770      	bx	lr
 80055cc:	0000      	movs	r0, r0
	...

080055d0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 80055d0:	b500      	push	{lr}
 80055d2:	b083      	sub	sp, #12
 80055d4:	9001      	str	r0, [sp, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80055d6:	2200      	movs	r2, #0
 80055d8:	2104      	movs	r1, #4
 80055da:	9801      	ldr	r0, [sp, #4]
 80055dc:	f00d fe30 	bl	8013240 <chCoreAllocAlignedWithOffset>
 80055e0:	4603      	mov	r3, r0
}
 80055e2:	4618      	mov	r0, r3
 80055e4:	b003      	add	sp, #12
 80055e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80055ea:	bf00      	nop
 80055ec:	0000      	movs	r0, r0
	...

080055f0 <_read_r>:

/***************************************************************************/

__attribute__((used))
int _read_r(struct _reent *r, int file, char * ptr, int len)
{
 80055f0:	b084      	sub	sp, #16
 80055f2:	9003      	str	r0, [sp, #12]
 80055f4:	9102      	str	r1, [sp, #8]
 80055f6:	9201      	str	r2, [sp, #4]
 80055f8:	9300      	str	r3, [sp, #0]
  return len;
#else
  (void)file;
  (void)ptr;
  (void)len;
  __errno_r(r) = EINVAL;
 80055fa:	9b03      	ldr	r3, [sp, #12]
 80055fc:	2216      	movs	r2, #22
 80055fe:	601a      	str	r2, [r3, #0]
  return -1;
 8005600:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
#endif
}
 8005604:	4618      	mov	r0, r3
 8005606:	b004      	add	sp, #16
 8005608:	4770      	bx	lr
 800560a:	bf00      	nop
 800560c:	0000      	movs	r0, r0
	...

08005610 <_lseek_r>:

/***************************************************************************/

__attribute__((used))
int _lseek_r(struct _reent *r, int file, int ptr, int dir)
{
 8005610:	b084      	sub	sp, #16
 8005612:	9003      	str	r0, [sp, #12]
 8005614:	9102      	str	r1, [sp, #8]
 8005616:	9201      	str	r2, [sp, #4]
 8005618:	9300      	str	r3, [sp, #0]
  (void)r;
  (void)file;
  (void)ptr;
  (void)dir;

  return 0;
 800561a:	2300      	movs	r3, #0
}
 800561c:	4618      	mov	r0, r3
 800561e:	b004      	add	sp, #16
 8005620:	4770      	bx	lr
 8005622:	bf00      	nop
	...

08005630 <_write_r>:

/***************************************************************************/

__attribute__((used))
int _write_r(struct _reent *r, int file, char * ptr, int len)
{
 8005630:	b084      	sub	sp, #16
 8005632:	9003      	str	r0, [sp, #12]
 8005634:	9102      	str	r1, [sp, #8]
 8005636:	9201      	str	r2, [sp, #4]
 8005638:	9300      	str	r3, [sp, #0]
    __errno_r(r) = EINVAL;
    return -1;
  }
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  return len;
 800563a:	9b00      	ldr	r3, [sp, #0]
}
 800563c:	4618      	mov	r0, r3
 800563e:	b004      	add	sp, #16
 8005640:	4770      	bx	lr
 8005642:	bf00      	nop
	...

08005650 <_close_r>:

/***************************************************************************/

__attribute__((used))
int _close_r(struct _reent *r, int file)
{
 8005650:	b082      	sub	sp, #8
 8005652:	9001      	str	r0, [sp, #4]
 8005654:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)file;

  return 0;
 8005656:	2300      	movs	r3, #0
}
 8005658:	4618      	mov	r0, r3
 800565a:	b002      	add	sp, #8
 800565c:	4770      	bx	lr
 800565e:	bf00      	nop

08005660 <_sbrk_r>:

/***************************************************************************/

__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8005660:	b500      	push	{lr}
 8005662:	b085      	sub	sp, #20
 8005664:	9001      	str	r0, [sp, #4]
 8005666:	9100      	str	r1, [sp, #0]
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);

  p = chCoreAlloc((size_t)incr);
 8005668:	9b00      	ldr	r3, [sp, #0]
 800566a:	4618      	mov	r0, r3
 800566c:	f7ff ffb0 	bl	80055d0 <chCoreAlloc>
 8005670:	9003      	str	r0, [sp, #12]
  if (p == NULL) {
 8005672:	9b03      	ldr	r3, [sp, #12]
 8005674:	2b00      	cmp	r3, #0
 8005676:	d105      	bne.n	8005684 <_sbrk_r+0x24>
    __errno_r(r) = ENOMEM;
 8005678:	9b01      	ldr	r3, [sp, #4]
 800567a:	220c      	movs	r2, #12
 800567c:	601a      	str	r2, [r3, #0]
    return (caddr_t)-1;
 800567e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005682:	e000      	b.n	8005686 <_sbrk_r+0x26>
  }
  return (caddr_t)p;
 8005684:	9b03      	ldr	r3, [sp, #12]
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8005686:	4618      	mov	r0, r3
 8005688:	b005      	add	sp, #20
 800568a:	f85d fb04 	ldr.w	pc, [sp], #4
 800568e:	bf00      	nop

08005690 <_fstat_r>:

/***************************************************************************/

__attribute__((used))
int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8005690:	b500      	push	{lr}
 8005692:	b085      	sub	sp, #20
 8005694:	9003      	str	r0, [sp, #12]
 8005696:	9102      	str	r1, [sp, #8]
 8005698:	9201      	str	r2, [sp, #4]
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 800569a:	223c      	movs	r2, #60	; 0x3c
 800569c:	2100      	movs	r1, #0
 800569e:	9801      	ldr	r0, [sp, #4]
 80056a0:	f018 f898 	bl	801d7d4 <memset>
  st->st_mode = S_IFCHR;
 80056a4:	9b01      	ldr	r3, [sp, #4]
 80056a6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80056aa:	605a      	str	r2, [r3, #4]
  return 0;
 80056ac:	2300      	movs	r3, #0
}
 80056ae:	4618      	mov	r0, r3
 80056b0:	b005      	add	sp, #20
 80056b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80056b6:	bf00      	nop
	...

080056c0 <_isatty_r>:

/***************************************************************************/

__attribute__((used))
int _isatty_r(struct _reent *r, int fd)
{
 80056c0:	b082      	sub	sp, #8
 80056c2:	9001      	str	r0, [sp, #4]
 80056c4:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)fd;

  return 1;
 80056c6:	2301      	movs	r3, #1
}
 80056c8:	4618      	mov	r0, r3
 80056ca:	b002      	add	sp, #8
 80056cc:	4770      	bx	lr
 80056ce:	bf00      	nop

080056d0 <debug>:

void get_rx_num(){
	return 0;//sdReadTimeout(&SDU1, BUFFER, 64, MS2ST(10));
}

void debug(const char *fmt, ...){
 80056d0:	b40f      	push	{r0, r1, r2, r3}
 80056d2:	b500      	push	{lr}
 80056d4:	b083      	sub	sp, #12
#if USE_DEBUG
	chprintf((BaseSequentialStream *)&SERIAL_LINE, "%s", "");
 80056d6:	4a0b      	ldr	r2, [pc, #44]	; (8005704 <debug+0x34>)
 80056d8:	490b      	ldr	r1, [pc, #44]	; (8005708 <debug+0x38>)
 80056da:	480c      	ldr	r0, [pc, #48]	; (800570c <debug+0x3c>)
 80056dc:	f00e fb28 	bl	8013d30 <chprintf>
	va_list ap;
	va_start(ap, fmt);
 80056e0:	ab05      	add	r3, sp, #20
 80056e2:	9301      	str	r3, [sp, #4]
	chvprintf((BaseSequentialStream *)&SERIAL_LINE, fmt, ap);
 80056e4:	9a01      	ldr	r2, [sp, #4]
 80056e6:	9904      	ldr	r1, [sp, #16]
 80056e8:	4808      	ldr	r0, [pc, #32]	; (800570c <debug+0x3c>)
 80056ea:	f00e f8c9 	bl	8013880 <chvprintf>
	va_end(ap);

	chprintf((BaseSequentialStream *)&SERIAL_LINE, "%s", "\r\n");
 80056ee:	4a08      	ldr	r2, [pc, #32]	; (8005710 <debug+0x40>)
 80056f0:	4905      	ldr	r1, [pc, #20]	; (8005708 <debug+0x38>)
 80056f2:	4806      	ldr	r0, [pc, #24]	; (800570c <debug+0x3c>)
 80056f4:	f00e fb1c 	bl	8013d30 <chprintf>

#else
	(void)fmt;
#endif
}
 80056f8:	b003      	add	sp, #12
 80056fa:	f85d eb04 	ldr.w	lr, [sp], #4
 80056fe:	b004      	add	sp, #16
 8005700:	4770      	bx	lr
 8005702:	bf00      	nop
 8005704:	08023558 	.word	0x08023558
 8005708:	08024b90 	.word	0x08024b90
 800570c:	200052e4 	.word	0x200052e4
 8005710:	08024b94 	.word	0x08024b94
	...

08005720 <delay>:

void delay(uint32_t _time){
 8005720:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005724:	b083      	sub	sp, #12
 8005726:	9001      	str	r0, [sp, #4]
	chThdSleepMilliseconds(_time);
 8005728:	9b01      	ldr	r3, [sp, #4]
 800572a:	461d      	mov	r5, r3
 800572c:	f04f 0600 	mov.w	r6, #0
 8005730:	462b      	mov	r3, r5
 8005732:	4634      	mov	r4, r6
 8005734:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 8005738:	ea4c 7c93 	orr.w	ip, ip, r3, lsr #30
 800573c:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 8005740:	465b      	mov	r3, fp
 8005742:	4664      	mov	r4, ip
 8005744:	195b      	adds	r3, r3, r5
 8005746:	eb44 0406 	adc.w	r4, r4, r6
 800574a:	ea4f 0ac4 	mov.w	sl, r4, lsl #3
 800574e:	ea4a 7a53 	orr.w	sl, sl, r3, lsr #29
 8005752:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8005756:	464b      	mov	r3, r9
 8005758:	4654      	mov	r4, sl
 800575a:	1b5b      	subs	r3, r3, r5
 800575c:	eb64 0406 	sbc.w	r4, r4, r6
 8005760:	ea4f 1804 	mov.w	r8, r4, lsl #4
 8005764:	ea48 7813 	orr.w	r8, r8, r3, lsr #28
 8005768:	011f      	lsls	r7, r3, #4
 800576a:	463b      	mov	r3, r7
 800576c:	4644      	mov	r4, r8
 800576e:	195b      	adds	r3, r3, r5
 8005770:	eb44 0406 	adc.w	r4, r4, r6
 8005774:	0122      	lsls	r2, r4, #4
 8005776:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 800577a:	0119      	lsls	r1, r3, #4
 800577c:	460b      	mov	r3, r1
 800577e:	4614      	mov	r4, r2
 8005780:	4619      	mov	r1, r3
 8005782:	4622      	mov	r2, r4
 8005784:	f240 33e7 	movw	r3, #999	; 0x3e7
 8005788:	f04f 0400 	mov.w	r4, #0
 800578c:	18cd      	adds	r5, r1, r3
 800578e:	eb42 0604 	adc.w	r6, r2, r4
 8005792:	4628      	mov	r0, r5
 8005794:	4631      	mov	r1, r6
 8005796:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800579a:	f04f 0300 	mov.w	r3, #0
 800579e:	f7ff f857 	bl	8004850 <__aeabi_uldivmod>
 80057a2:	4603      	mov	r3, r0
 80057a4:	460c      	mov	r4, r1
 80057a6:	4618      	mov	r0, r3
 80057a8:	f00f f952 	bl	8014a50 <chThdSleep>
}
 80057ac:	b003      	add	sp, #12
 80057ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80057b2:	bf00      	nop
	...

080057c0 <chHeapAlloc.lto_priv.3>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80057c0:	b500      	push	{lr}
 80057c2:	b083      	sub	sp, #12
 80057c4:	9001      	str	r0, [sp, #4]
 80057c6:	9100      	str	r1, [sp, #0]

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80057c8:	2208      	movs	r2, #8
 80057ca:	9900      	ldr	r1, [sp, #0]
 80057cc:	9801      	ldr	r0, [sp, #4]
 80057ce:	f00d fd67 	bl	80132a0 <chHeapAllocAligned>
 80057d2:	4603      	mov	r3, r0
}
 80057d4:	4618      	mov	r0, r3
 80057d6:	b003      	add	sp, #12
 80057d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80057dc:	0000      	movs	r0, r0
	...

080057e0 <chHeapRealloc>:
    systime_t t = chVTGetSystemTimeX();
    return ST2MS(t);
}

void *chHeapRealloc (void *addr, uint32_t size)
{
 80057e0:	b500      	push	{lr}
 80057e2:	b087      	sub	sp, #28
 80057e4:	9001      	str	r0, [sp, #4]
 80057e6:	9100      	str	r1, [sp, #0]
    union heap_header *hp;
    uint32_t prev_size, new_size;

    void *ptr;

    if(addr == NULL) {
 80057e8:	9b01      	ldr	r3, [sp, #4]
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	d105      	bne.n	80057fa <chHeapRealloc+0x1a>
        return chHeapAlloc(NULL, size);
 80057ee:	9900      	ldr	r1, [sp, #0]
 80057f0:	2000      	movs	r0, #0
 80057f2:	f7ff ffe5 	bl	80057c0 <chHeapAlloc.lto_priv.3>
 80057f6:	4603      	mov	r3, r0
 80057f8:	e02b      	b.n	8005852 <chHeapRealloc+0x72>
    }

    /* previous allocated segment is preceded by an heap_header */
    hp = addr - sizeof(union heap_header);
 80057fa:	9b01      	ldr	r3, [sp, #4]
 80057fc:	3b08      	subs	r3, #8
 80057fe:	9304      	str	r3, [sp, #16]
    prev_size = hp->used.size; /* size is always multiple of 8 */
 8005800:	9b04      	ldr	r3, [sp, #16]
 8005802:	685b      	ldr	r3, [r3, #4]
 8005804:	9303      	str	r3, [sp, #12]

    /* check new size memory alignment */
    if(size % 8 == 0) {
 8005806:	9b00      	ldr	r3, [sp, #0]
 8005808:	f003 0307 	and.w	r3, r3, #7
 800580c:	2b00      	cmp	r3, #0
 800580e:	d102      	bne.n	8005816 <chHeapRealloc+0x36>
        new_size = size;
 8005810:	9b00      	ldr	r3, [sp, #0]
 8005812:	9305      	str	r3, [sp, #20]
 8005814:	e004      	b.n	8005820 <chHeapRealloc+0x40>
    }
    else {
        new_size = ((int) (size / 8)) * 8 + 8;
 8005816:	9b00      	ldr	r3, [sp, #0]
 8005818:	08db      	lsrs	r3, r3, #3
 800581a:	3301      	adds	r3, #1
 800581c:	00db      	lsls	r3, r3, #3
 800581e:	9305      	str	r3, [sp, #20]
    }

    if(prev_size >= new_size) {
 8005820:	9a03      	ldr	r2, [sp, #12]
 8005822:	9b05      	ldr	r3, [sp, #20]
 8005824:	429a      	cmp	r2, r3
 8005826:	d301      	bcc.n	800582c <chHeapRealloc+0x4c>
        return addr;
 8005828:	9b01      	ldr	r3, [sp, #4]
 800582a:	e012      	b.n	8005852 <chHeapRealloc+0x72>
    }

    ptr = chHeapAlloc(NULL, size);
 800582c:	9900      	ldr	r1, [sp, #0]
 800582e:	2000      	movs	r0, #0
 8005830:	f7ff ffc6 	bl	80057c0 <chHeapAlloc.lto_priv.3>
 8005834:	9002      	str	r0, [sp, #8]
    if(ptr == NULL) {
 8005836:	9b02      	ldr	r3, [sp, #8]
 8005838:	2b00      	cmp	r3, #0
 800583a:	d101      	bne.n	8005840 <chHeapRealloc+0x60>
        return NULL;
 800583c:	2300      	movs	r3, #0
 800583e:	e008      	b.n	8005852 <chHeapRealloc+0x72>
    }

    memcpy(ptr, addr, prev_size);
 8005840:	9a03      	ldr	r2, [sp, #12]
 8005842:	9901      	ldr	r1, [sp, #4]
 8005844:	9802      	ldr	r0, [sp, #8]
 8005846:	f7fe ff69 	bl	800471c <memcpy>

    chHeapFree(addr);
 800584a:	9801      	ldr	r0, [sp, #4]
 800584c:	f00d fe00 	bl	8013450 <chHeapFree>

    return ptr;
 8005850:	9b02      	ldr	r3, [sp, #8]
}
 8005852:	4618      	mov	r0, r3
 8005854:	b007      	add	sp, #28
 8005856:	f85d fb04 	ldr.w	pc, [sp], #4
 800585a:	bf00      	nop
 800585c:	0000      	movs	r0, r0
	...

08005860 <chibios_alloc>:

void *chibios_alloc(void *heap, int size)
{
 8005860:	b500      	push	{lr}
 8005862:	b083      	sub	sp, #12
 8005864:	9001      	str	r0, [sp, #4]
 8005866:	9100      	str	r1, [sp, #0]
    return chHeapAlloc(heap, size);
 8005868:	9b00      	ldr	r3, [sp, #0]
 800586a:	4619      	mov	r1, r3
 800586c:	9801      	ldr	r0, [sp, #4]
 800586e:	f7ff ffa7 	bl	80057c0 <chHeapAlloc.lto_priv.3>
 8005872:	4603      	mov	r3, r0
}
 8005874:	4618      	mov	r0, r3
 8005876:	b003      	add	sp, #12
 8005878:	f85d fb04 	ldr.w	pc, [sp], #4
 800587c:	0000      	movs	r0, r0
	...

08005880 <chibios_free>:

void chibios_free(void *ptr)
{
 8005880:	b500      	push	{lr}
 8005882:	b083      	sub	sp, #12
 8005884:	9001      	str	r0, [sp, #4]
    if (ptr)
 8005886:	9b01      	ldr	r3, [sp, #4]
 8005888:	2b00      	cmp	r3, #0
 800588a:	d002      	beq.n	8005892 <chibios_free+0x12>
        chHeapFree(ptr);
 800588c:	9801      	ldr	r0, [sp, #4]
 800588e:	f00d fddf 	bl	8013450 <chHeapFree>
}
 8005892:	b003      	add	sp, #12
 8005894:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080058a0 <chRegSetThreadName.lto_priv.0>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80058a0:	b082      	sub	sp, #8
 80058a2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80058a4:	4b02      	ldr	r3, [pc, #8]	; (80058b0 <chRegSetThreadName.lto_priv.0+0x10>)
 80058a6:	699b      	ldr	r3, [r3, #24]
 80058a8:	9a01      	ldr	r2, [sp, #4]
 80058aa:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80058ac:	b002      	add	sp, #8
 80058ae:	4770      	bx	lr
 80058b0:	20005ca0 	.word	0x20005ca0
	...

080058c0 <get_hash_sha256>:
void get_dgca_public_key(void){
	//int derSz = wc_DerToPem(cert, sizeof(cert), cert_der, FOURK_BUF);
	int derSz = wolfSSL_CertPemToDer(cert, sizeof(cert), cert_der, sizeof(cert_der),CERT_TYPE);
}

void get_hash_sha256(void){
 80058c0:	b500      	push	{lr}
 80058c2:	b0cf      	sub	sp, #316	; 0x13c
	wc_Sha256 sha;
	wc_InitSha256(&sha);
 80058c4:	ab2f      	add	r3, sp, #188	; 0xbc
 80058c6:	4618      	mov	r0, r3
 80058c8:	f000 feea 	bl	80066a0 <wc_InitSha256>

	wc_Sha256Update(&sha, signature, strlen(signature));
 80058cc:	484a      	ldr	r0, [pc, #296]	; (80059f8 <get_hash_sha256+0x138>)
 80058ce:	f7fe feb7 	bl	8004640 <strlen>
 80058d2:	4602      	mov	r2, r0
 80058d4:	ab2f      	add	r3, sp, #188	; 0xbc
 80058d6:	4948      	ldr	r1, [pc, #288]	; (80059f8 <get_hash_sha256+0x138>)
 80058d8:	4618      	mov	r0, r3
 80058da:	f000 fd61 	bl	80063a0 <wc_Sha256Update>
	wc_Sha256Final(&sha, shasha);
 80058de:	ab2f      	add	r3, sp, #188	; 0xbc
 80058e0:	4946      	ldr	r1, [pc, #280]	; (80059fc <get_hash_sha256+0x13c>)
 80058e2:	4618      	mov	r0, r3
 80058e4:	f000 fdec 	bl	80064c0 <wc_Sha256Final>

	chprintf((BaseSequentialStream *)&SERIAL_LINE, "%s\n", sig_value);
 80058e8:	4a45      	ldr	r2, [pc, #276]	; (8005a00 <get_hash_sha256+0x140>)
 80058ea:	4946      	ldr	r1, [pc, #280]	; (8005a04 <get_hash_sha256+0x144>)
 80058ec:	4846      	ldr	r0, [pc, #280]	; (8005a08 <get_hash_sha256+0x148>)
 80058ee:	f00e fa1f 	bl	8013d30 <chprintf>


	RsaKey rsaKey;
    DerBuffer* converted = NULL;
 80058f2:	ab07      	add	r3, sp, #28
 80058f4:	2200      	movs	r2, #0
 80058f6:	601a      	str	r2, [r3, #0]

	int ret = PemToDer(pem_pub, strlen(pem_pub), PUBLICKEY_TYPE, &converted, 0, NULL, NULL);
 80058f8:	4844      	ldr	r0, [pc, #272]	; (8005a0c <get_hash_sha256+0x14c>)
 80058fa:	f7fe fea1 	bl	8004640 <strlen>
 80058fe:	4603      	mov	r3, r0
 8005900:	4619      	mov	r1, r3
 8005902:	aa07      	add	r2, sp, #28
 8005904:	2300      	movs	r3, #0
 8005906:	9302      	str	r3, [sp, #8]
 8005908:	2300      	movs	r3, #0
 800590a:	9301      	str	r3, [sp, #4]
 800590c:	2300      	movs	r3, #0
 800590e:	9300      	str	r3, [sp, #0]
 8005910:	4613      	mov	r3, r2
 8005912:	220c      	movs	r2, #12
 8005914:	483d      	ldr	r0, [pc, #244]	; (8005a0c <get_hash_sha256+0x14c>)
 8005916:	f000 fa53 	bl	8005dc0 <PemToDer>
 800591a:	904d      	str	r0, [sp, #308]	; 0x134

	if (ret == 0) {
 800591c:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 800591e:	2b00      	cmp	r3, #0
 8005920:	d10d      	bne.n	800593e <get_hash_sha256+0x7e>
		debug("%d", converted->length);
 8005922:	ab07      	add	r3, sp, #28
 8005924:	681b      	ldr	r3, [r3, #0]
 8005926:	689b      	ldr	r3, [r3, #8]
 8005928:	4619      	mov	r1, r3
 800592a:	4839      	ldr	r0, [pc, #228]	; (8005a10 <get_hash_sha256+0x150>)
 800592c:	f7ff fed0 	bl	80056d0 <debug>
		ret = wc_InitRsaKey(&rsaKey, 0);
 8005930:	ab08      	add	r3, sp, #32
 8005932:	2100      	movs	r1, #0
 8005934:	4618      	mov	r0, r3
 8005936:	f00a fbc3 	bl	80100c0 <wc_InitRsaKey>
 800593a:	904d      	str	r0, [sp, #308]	; 0x134
 800593c:	e003      	b.n	8005946 <get_hash_sha256+0x86>
	}
	else{
		debug("uninit %d", ret);
 800593e:	994d      	ldr	r1, [sp, #308]	; 0x134
 8005940:	4834      	ldr	r0, [pc, #208]	; (8005a14 <get_hash_sha256+0x154>)
 8005942:	f7ff fec5 	bl	80056d0 <debug>
	}
	if (ret == 0) {
 8005946:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 8005948:	2b00      	cmp	r3, #0
 800594a:	d111      	bne.n	8005970 <get_hash_sha256+0xb0>
		debug("init successful");
 800594c:	4832      	ldr	r0, [pc, #200]	; (8005a18 <get_hash_sha256+0x158>)
 800594e:	f7ff febf 	bl	80056d0 <debug>
		word32 idx = 0;
 8005952:	ab05      	add	r3, sp, #20
 8005954:	2200      	movs	r2, #0
 8005956:	601a      	str	r2, [r3, #0]
		ret = wc_RsaPublicKeyDecode(converted->buffer, &idx, &rsaKey, converted->length);
 8005958:	ab07      	add	r3, sp, #28
 800595a:	681b      	ldr	r3, [r3, #0]
 800595c:	6818      	ldr	r0, [r3, #0]
 800595e:	ab07      	add	r3, sp, #28
 8005960:	681b      	ldr	r3, [r3, #0]
 8005962:	689b      	ldr	r3, [r3, #8]
 8005964:	aa08      	add	r2, sp, #32
 8005966:	a905      	add	r1, sp, #20
 8005968:	f00a f9ca 	bl	800fd00 <wc_RsaPublicKeyDecode>
 800596c:	904d      	str	r0, [sp, #308]	; 0x134
 800596e:	e003      	b.n	8005978 <get_hash_sha256+0xb8>
	}
	else{
		debug("not decoded %d", ret);
 8005970:	994d      	ldr	r1, [sp, #308]	; 0x134
 8005972:	482a      	ldr	r0, [pc, #168]	; (8005a1c <get_hash_sha256+0x15c>)
 8005974:	f7ff feac 	bl	80056d0 <debug>
	}
	uint16_t sig_base64_len = strlen(sig_value);
 8005978:	4821      	ldr	r0, [pc, #132]	; (8005a00 <get_hash_sha256+0x140>)
 800597a:	f7fe fe61 	bl	8004640 <strlen>
 800597e:	4603      	mov	r3, r0
 8005980:	f8ad 3132 	strh.w	r3, [sp, #306]	; 0x132
	debug("%s",sig_value);
 8005984:	491e      	ldr	r1, [pc, #120]	; (8005a00 <get_hash_sha256+0x140>)
 8005986:	4826      	ldr	r0, [pc, #152]	; (8005a20 <get_hash_sha256+0x160>)
 8005988:	f7ff fea2 	bl	80056d0 <debug>

	if(ret == 0){
 800598c:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 800598e:	2b00      	cmp	r3, #0
 8005990:	d10e      	bne.n	80059b0 <get_hash_sha256+0xf0>
		debug("decode success");
 8005992:	4824      	ldr	r0, [pc, #144]	; (8005a24 <get_hash_sha256+0x164>)
 8005994:	f7ff fe9c 	bl	80056d0 <debug>
		ret = Base64_Decode(sig_value, strlen(sig_value), sig_base64, sig_base64_len);
 8005998:	4819      	ldr	r0, [pc, #100]	; (8005a00 <get_hash_sha256+0x140>)
 800599a:	f7fe fe51 	bl	8004640 <strlen>
 800599e:	4601      	mov	r1, r0
 80059a0:	f8bd 3132 	ldrh.w	r3, [sp, #306]	; 0x132
 80059a4:	4a20      	ldr	r2, [pc, #128]	; (8005a28 <get_hash_sha256+0x168>)
 80059a6:	4816      	ldr	r0, [pc, #88]	; (8005a00 <get_hash_sha256+0x140>)
 80059a8:	f006 fad2 	bl	800bf50 <Base64_Decode>
 80059ac:	904d      	str	r0, [sp, #308]	; 0x134
 80059ae:	e002      	b.n	80059b6 <get_hash_sha256+0xf6>
	}
	else{
		debug("base64 failed");
 80059b0:	481e      	ldr	r0, [pc, #120]	; (8005a2c <get_hash_sha256+0x16c>)
 80059b2:	f7ff fe8d 	bl	80056d0 <debug>
	}

	if (ret == 0) {
 80059b6:	9b4d      	ldr	r3, [sp, #308]	; 0x134
 80059b8:	2b00      	cmp	r3, #0
 80059ba:	d116      	bne.n	80059ea <get_hash_sha256+0x12a>
		debug("%s",rsaKey.data);
 80059bc:	ab08      	add	r3, sp, #32
 80059be:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80059c2:	4619      	mov	r1, r3
 80059c4:	4816      	ldr	r0, [pc, #88]	; (8005a20 <get_hash_sha256+0x160>)
 80059c6:	f7ff fe83 	bl	80056d0 <debug>
	    uint8_t* decSig = NULL;
 80059ca:	ab06      	add	r3, sp, #24
 80059cc:	2200      	movs	r2, #0
 80059ce:	601a      	str	r2, [r3, #0]
		int decSigLen = wc_RsaSSL_VerifyInline(sig_base64, sig_base64_len, &decSig, &rsaKey);
 80059d0:	f8bd 1132 	ldrh.w	r1, [sp, #306]	; 0x132
 80059d4:	ab08      	add	r3, sp, #32
 80059d6:	aa06      	add	r2, sp, #24
 80059d8:	4813      	ldr	r0, [pc, #76]	; (8005a28 <get_hash_sha256+0x168>)
 80059da:	f00b f969 	bl	8010cb0 <wc_RsaSSL_VerifyInline>
 80059de:	904b      	str	r0, [sp, #300]	; 0x12c
		debug("%d",decSigLen);
 80059e0:	994b      	ldr	r1, [sp, #300]	; 0x12c
 80059e2:	480b      	ldr	r0, [pc, #44]	; (8005a10 <get_hash_sha256+0x150>)
 80059e4:	f7ff fe74 	bl	80056d0 <debug>
 80059e8:	e003      	b.n	80059f2 <get_hash_sha256+0x132>
	}
	else{
		printf("not able to verify %d", ret);
 80059ea:	994d      	ldr	r1, [sp, #308]	; 0x134
 80059ec:	4810      	ldr	r0, [pc, #64]	; (8005a30 <get_hash_sha256+0x170>)
 80059ee:	f018 fbe5 	bl	801e1bc <printf>
	}
}
 80059f2:	b04f      	add	sp, #316	; 0x13c
 80059f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80059f8:	20009d80 	.word	0x20009d80
 80059fc:	2000cd80 	.word	0x2000cd80
 8005a00:	2000ad80 	.word	0x2000ad80
 8005a04:	08024b98 	.word	0x08024b98
 8005a08:	200052e4 	.word	0x200052e4
 8005a0c:	20008d80 	.word	0x20008d80
 8005a10:	08024bc4 	.word	0x08024bc4
 8005a14:	08024b9c 	.word	0x08024b9c
 8005a18:	08024ba8 	.word	0x08024ba8
 8005a1c:	08024bb8 	.word	0x08024bb8
 8005a20:	08024b90 	.word	0x08024b90
 8005a24:	08024bc8 	.word	0x08024bc8
 8005a28:	2000bd80 	.word	0x2000bd80
 8005a2c:	08024bd8 	.word	0x08024bd8
 8005a30:	08024be8 	.word	0x08024be8
	...

08005a40 <rsa_key_generation>:

void rsa_key_generation(void){
 8005a40:	b500      	push	{lr}
 8005a42:	b0b1      	sub	sp, #196	; 0xc4
	RsaKey rsakey;
	WC_RNG rng;
	wc_InitRng(&rng);
 8005a44:	ab02      	add	r3, sp, #8
 8005a46:	4618      	mov	r0, r3
 8005a48:	f008 ff6a 	bl	800e920 <wc_InitRng>
	wc_InitRsaKey(&rsakey, NULL);
 8005a4c:	ab06      	add	r3, sp, #24
 8005a4e:	2100      	movs	r1, #0
 8005a50:	4618      	mov	r0, r3
 8005a52:	f00a fb35 	bl	80100c0 <wc_InitRsaKey>

	int ret = wc_MakeRsaKey(&rsakey, 2048, 65537, &rng);
 8005a56:	ab02      	add	r3, sp, #8
 8005a58:	a806      	add	r0, sp, #24
 8005a5a:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8005a5e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8005a62:	f00b f96d 	bl	8010d40 <wc_MakeRsaKey>
 8005a66:	902f      	str	r0, [sp, #188]	; 0xbc

	if (ret != 0){
 8005a68:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8005a6a:	2b00      	cmp	r3, #0
 8005a6c:	d130      	bne.n	8005ad0 <rsa_key_generation+0x90>
		return;
	}

	int  derSz = wc_RsaKeyToDer(&rsakey, der, sizeof(der));
 8005a6e:	ab06      	add	r3, sp, #24
 8005a70:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8005a74:	4918      	ldr	r1, [pc, #96]	; (8005ad8 <rsa_key_generation+0x98>)
 8005a76:	4618      	mov	r0, r3
 8005a78:	f008 fbca 	bl	800e210 <wc_RsaKeyToDer>
 8005a7c:	902e      	str	r0, [sp, #184]	; 0xb8

	int  pemSz = wc_DerToPem(der, derSz, pem, sizeof(pem), PRIVATEKEY_TYPE);
 8005a7e:	992e      	ldr	r1, [sp, #184]	; 0xb8
 8005a80:	2301      	movs	r3, #1
 8005a82:	9300      	str	r3, [sp, #0]
 8005a84:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005a88:	4a14      	ldr	r2, [pc, #80]	; (8005adc <rsa_key_generation+0x9c>)
 8005a8a:	4813      	ldr	r0, [pc, #76]	; (8005ad8 <rsa_key_generation+0x98>)
 8005a8c:	f008 f858 	bl	800db40 <wc_DerToPem>
 8005a90:	902d      	str	r0, [sp, #180]	; 0xb4

	derSz = wc_RsaKeyToPublicDer(&rsakey, der_pub, sizeof(der_pub));
 8005a92:	ab06      	add	r3, sp, #24
 8005a94:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8005a98:	4911      	ldr	r1, [pc, #68]	; (8005ae0 <rsa_key_generation+0xa0>)
 8005a9a:	4618      	mov	r0, r3
 8005a9c:	f008 fca8 	bl	800e3f0 <wc_RsaKeyToPublicDer>
 8005aa0:	902e      	str	r0, [sp, #184]	; 0xb8

	pemSz = wc_DerToPem(der_pub, derSz, pem_pub, sizeof(pem_pub), RSA_PUBLICKEY_TYPE);
 8005aa2:	992e      	ldr	r1, [sp, #184]	; 0xb8
 8005aa4:	230d      	movs	r3, #13
 8005aa6:	9300      	str	r3, [sp, #0]
 8005aa8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005aac:	4a0d      	ldr	r2, [pc, #52]	; (8005ae4 <rsa_key_generation+0xa4>)
 8005aae:	480c      	ldr	r0, [pc, #48]	; (8005ae0 <rsa_key_generation+0xa0>)
 8005ab0:	f008 f846 	bl	800db40 <wc_DerToPem>
 8005ab4:	902d      	str	r0, [sp, #180]	; 0xb4
	debug("%s", pem_pub);
 8005ab6:	490b      	ldr	r1, [pc, #44]	; (8005ae4 <rsa_key_generation+0xa4>)
 8005ab8:	480b      	ldr	r0, [pc, #44]	; (8005ae8 <rsa_key_generation+0xa8>)
 8005aba:	f7ff fe09 	bl	80056d0 <debug>

	wc_FreeRng(&rng);
 8005abe:	ab02      	add	r3, sp, #8
 8005ac0:	4618      	mov	r0, r3
 8005ac2:	f008 ffbd 	bl	800ea40 <wc_FreeRng>
	wc_FreeRsaKey(&rsakey);
 8005ac6:	ab06      	add	r3, sp, #24
 8005ac8:	4618      	mov	r0, r3
 8005aca:	f00a fb09 	bl	80100e0 <wc_FreeRsaKey>
 8005ace:	e000      	b.n	8005ad2 <rsa_key_generation+0x92>
		return;
 8005ad0:	bf00      	nop
}
 8005ad2:	b031      	add	sp, #196	; 0xc4
 8005ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ad8:	20005d80 	.word	0x20005d80
 8005adc:	20007d80 	.word	0x20007d80
 8005ae0:	20006d80 	.word	0x20006d80
 8005ae4:	20008d80 	.word	0x20008d80
 8005ae8:	08024b90 	.word	0x08024b90
 8005aec:	00000000 	.word	0x00000000

08005af0 <Thread_crypto>:

static THD_WORKING_AREA(waThread_crypto, 8000);
static THD_FUNCTION(Thread_crypto, arg) {
 8005af0:	b500      	push	{lr}
 8005af2:	b083      	sub	sp, #12
 8005af4:	9001      	str	r0, [sp, #4]


	(void)arg;
	chRegSetThreadName("crypto");
 8005af6:	480d      	ldr	r0, [pc, #52]	; (8005b2c <Thread_crypto+0x3c>)
 8005af8:	f7ff fed2 	bl	80058a0 <chRegSetThreadName.lto_priv.0>

	while (true) {
		switch(current_state){
 8005afc:	4b0c      	ldr	r3, [pc, #48]	; (8005b30 <Thread_crypto+0x40>)
 8005afe:	781b      	ldrb	r3, [r3, #0]
 8005b00:	2b01      	cmp	r3, #1
 8005b02:	d003      	beq.n	8005b0c <Thread_crypto+0x1c>
 8005b04:	2b03      	cmp	r3, #3
 8005b06:	d007      	beq.n	8005b18 <Thread_crypto+0x28>
 8005b08:	2b00      	cmp	r3, #0
 8005b0a:	e00a      	b.n	8005b22 <Thread_crypto+0x32>
		case IDLE:
			break;
		case KEY_ROTATION:
			rsa_key_generation();
 8005b0c:	f7ff ff98 	bl	8005a40 <rsa_key_generation>
			current_state = IDLE;
 8005b10:	4b07      	ldr	r3, [pc, #28]	; (8005b30 <Thread_crypto+0x40>)
 8005b12:	2200      	movs	r2, #0
 8005b14:	701a      	strb	r2, [r3, #0]
 8005b16:	e004      	b.n	8005b22 <Thread_crypto+0x32>
			break;
		case SIGN_VERIFY:
			get_hash_sha256();
 8005b18:	f7ff fed2 	bl	80058c0 <get_hash_sha256>
			current_state = IDLE;
 8005b1c:	4b04      	ldr	r3, [pc, #16]	; (8005b30 <Thread_crypto+0x40>)
 8005b1e:	2200      	movs	r2, #0
 8005b20:	701a      	strb	r2, [r3, #0]
		default:
			break;
		}
			//debug("rx_num : %d", rx_num);
			//rsa_key_generation();
		delay(100);
 8005b22:	2064      	movs	r0, #100	; 0x64
 8005b24:	f7ff fdfc 	bl	8005720 <delay>
 8005b28:	e7e8      	b.n	8005afc <Thread_crypto+0xc>
 8005b2a:	bf00      	nop
 8005b2c:	08024c00 	.word	0x08024c00
 8005b30:	2000cda0 	.word	0x2000cda0
	...

08005b40 <Reader>:
	}
}

static THD_WORKING_AREA(waReader, 128);
static THD_FUNCTION(Reader, arg) {
 8005b40:	b500      	push	{lr}
 8005b42:	b087      	sub	sp, #28
 8005b44:	9001      	str	r0, [sp, #4]

	(void)arg;
	chRegSetThreadName("reader"); //thread for reading the data from host
 8005b46:	4846      	ldr	r0, [pc, #280]	; (8005c60 <Reader+0x120>)
 8005b48:	f7ff feaa 	bl	80058a0 <chRegSetThreadName.lto_priv.0>
	uint16_t j=0;
 8005b4c:	2300      	movs	r3, #0
 8005b4e:	f8ad 3016 	strh.w	r3, [sp, #22]
	int rx = 0;
 8005b52:	2300      	movs	r3, #0
 8005b54:	9304      	str	r3, [sp, #16]
	char type;

	while (true) {
		uint16_t rx_num = qSpaceI(&(&SERIAL_LINE)->iqueue);
 8005b56:	4b43      	ldr	r3, [pc, #268]	; (8005c64 <Reader+0x124>)
 8005b58:	695b      	ldr	r3, [r3, #20]
 8005b5a:	f8ad 300a 	strh.w	r3, [sp, #10]
		if(rx_num > 0){
 8005b5e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8005b62:	2b00      	cmp	r3, #0
 8005b64:	d077      	beq.n	8005c56 <Reader+0x116>
			for(uint16_t i=0; i < rx_num; i++){
 8005b66:	2300      	movs	r3, #0
 8005b68:	f8ad 300c 	strh.w	r3, [sp, #12]
 8005b6c:	e06d      	b.n	8005c4a <Reader+0x10a>
				uint8_t data = sdGetTimeout(&SERIAL_LINE, 5);
 8005b6e:	2105      	movs	r1, #5
 8005b70:	483d      	ldr	r0, [pc, #244]	; (8005c68 <Reader+0x128>)
 8005b72:	f014 f92d 	bl	8019dd0 <iqGetTimeout>
 8005b76:	4603      	mov	r3, r0
 8005b78:	f88d 3009 	strb.w	r3, [sp, #9]
				if(data == '*' && rx){
 8005b7c:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005b80:	2b2a      	cmp	r3, #42	; 0x2a
 8005b82:	d112      	bne.n	8005baa <Reader+0x6a>
 8005b84:	9b04      	ldr	r3, [sp, #16]
 8005b86:	2b00      	cmp	r3, #0
 8005b88:	d00f      	beq.n	8005baa <Reader+0x6a>
					rx = 0;
 8005b8a:	2300      	movs	r3, #0
 8005b8c:	9304      	str	r3, [sp, #16]
					j = 0;
 8005b8e:	2300      	movs	r3, #0
 8005b90:	f8ad 3016 	strh.w	r3, [sp, #22]
					if(type == '3'){
 8005b94:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005b98:	2b33      	cmp	r3, #51	; 0x33
 8005b9a:	d150      	bne.n	8005c3e <Reader+0xfe>
						debug("sign verify started");
 8005b9c:	4833      	ldr	r0, [pc, #204]	; (8005c6c <Reader+0x12c>)
 8005b9e:	f7ff fd97 	bl	80056d0 <debug>
						current_state = SIGN_VERIFY;
 8005ba2:	4b33      	ldr	r3, [pc, #204]	; (8005c70 <Reader+0x130>)
 8005ba4:	2203      	movs	r2, #3
 8005ba6:	701a      	strb	r2, [r3, #0]
 8005ba8:	e04a      	b.n	8005c40 <Reader+0x100>
					}
				}
				else if(data == '*' && !rx){
 8005baa:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005bae:	2b2a      	cmp	r3, #42	; 0x2a
 8005bb0:	d10c      	bne.n	8005bcc <Reader+0x8c>
 8005bb2:	9b04      	ldr	r3, [sp, #16]
 8005bb4:	2b00      	cmp	r3, #0
 8005bb6:	d109      	bne.n	8005bcc <Reader+0x8c>
					type = sdGetTimeout(&SERIAL_LINE, 5);
 8005bb8:	2105      	movs	r1, #5
 8005bba:	482b      	ldr	r0, [pc, #172]	; (8005c68 <Reader+0x128>)
 8005bbc:	f014 f908 	bl	8019dd0 <iqGetTimeout>
 8005bc0:	4603      	mov	r3, r0
 8005bc2:	f88d 300f 	strb.w	r3, [sp, #15]
					rx = 1;
 8005bc6:	2301      	movs	r3, #1
 8005bc8:	9304      	str	r3, [sp, #16]
 8005bca:	e039      	b.n	8005c40 <Reader+0x100>
				}
				else if(rx && type == '1'){
 8005bcc:	9b04      	ldr	r3, [sp, #16]
 8005bce:	2b00      	cmp	r3, #0
 8005bd0:	d00f      	beq.n	8005bf2 <Reader+0xb2>
 8005bd2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005bd6:	2b31      	cmp	r3, #49	; 0x31
 8005bd8:	d10b      	bne.n	8005bf2 <Reader+0xb2>
					pem_pub[j] = data;
 8005bda:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005bde:	4925      	ldr	r1, [pc, #148]	; (8005c74 <Reader+0x134>)
 8005be0:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8005be4:	54ca      	strb	r2, [r1, r3]
					j++;
 8005be6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005bea:	3301      	adds	r3, #1
 8005bec:	f8ad 3016 	strh.w	r3, [sp, #22]
 8005bf0:	e026      	b.n	8005c40 <Reader+0x100>
				}
				else if(rx && type == '2'){
 8005bf2:	9b04      	ldr	r3, [sp, #16]
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	d00f      	beq.n	8005c18 <Reader+0xd8>
 8005bf8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005bfc:	2b32      	cmp	r3, #50	; 0x32
 8005bfe:	d10b      	bne.n	8005c18 <Reader+0xd8>
					signature[j] = data;
 8005c00:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005c04:	491c      	ldr	r1, [pc, #112]	; (8005c78 <Reader+0x138>)
 8005c06:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8005c0a:	54ca      	strb	r2, [r1, r3]
					j++;
 8005c0c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005c10:	3301      	adds	r3, #1
 8005c12:	f8ad 3016 	strh.w	r3, [sp, #22]
 8005c16:	e013      	b.n	8005c40 <Reader+0x100>
				}
				else if(rx && type == '3'){
 8005c18:	9b04      	ldr	r3, [sp, #16]
 8005c1a:	2b00      	cmp	r3, #0
 8005c1c:	d010      	beq.n	8005c40 <Reader+0x100>
 8005c1e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005c22:	2b33      	cmp	r3, #51	; 0x33
 8005c24:	d10c      	bne.n	8005c40 <Reader+0x100>
					sig_value[j] = data;
 8005c26:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005c2a:	4914      	ldr	r1, [pc, #80]	; (8005c7c <Reader+0x13c>)
 8005c2c:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8005c30:	54ca      	strb	r2, [r1, r3]
					j++;
 8005c32:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005c36:	3301      	adds	r3, #1
 8005c38:	f8ad 3016 	strh.w	r3, [sp, #22]
 8005c3c:	e000      	b.n	8005c40 <Reader+0x100>
						current_state = SIGN_VERIFY;
 8005c3e:	bf00      	nop
			for(uint16_t i=0; i < rx_num; i++){
 8005c40:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8005c44:	3301      	adds	r3, #1
 8005c46:	f8ad 300c 	strh.w	r3, [sp, #12]
 8005c4a:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8005c4e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8005c52:	429a      	cmp	r2, r3
 8005c54:	d38b      	bcc.n	8005b6e <Reader+0x2e>
//			else if(strcmp(rxbuf,"END_CERT")==0){
//				current_state = IDLE;
//			}
//            memset(rxbuf, 0, sizeof(rxbuf)); //empty the buffer
		}
		chThdSleepMilliseconds(100);
 8005c56:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005c5a:	f00e fef9 	bl	8014a50 <chThdSleep>
 8005c5e:	e77a      	b.n	8005b56 <Reader+0x16>
 8005c60:	08024c08 	.word	0x08024c08
 8005c64:	200052e4 	.word	0x200052e4
 8005c68:	200052f0 	.word	0x200052f0
 8005c6c:	08024c10 	.word	0x08024c10
 8005c70:	2000cda0 	.word	0x2000cda0
 8005c74:	20008d80 	.word	0x20008d80
 8005c78:	20009d80 	.word	0x20009d80
 8005c7c:	2000ad80 	.word	0x2000ad80

08005c80 <ecc_init_keypair>:
	}
}


void ecc_init_keypair(void){
 8005c80:	b500      	push	{lr}
 8005c82:	b083      	sub	sp, #12

	chThdCreateStatic(waThread_crypto, sizeof(waThread_crypto),NORMALPRIO, Thread_crypto, NULL);
 8005c84:	2300      	movs	r3, #0
 8005c86:	9300      	str	r3, [sp, #0]
 8005c88:	4b09      	ldr	r3, [pc, #36]	; (8005cb0 <ecc_init_keypair+0x30>)
 8005c8a:	2280      	movs	r2, #128	; 0x80
 8005c8c:	f242 0190 	movw	r1, #8336	; 0x2090
 8005c90:	4808      	ldr	r0, [pc, #32]	; (8005cb4 <ecc_init_keypair+0x34>)
 8005c92:	f00e fe55 	bl	8014940 <chThdCreateStatic>
	chThdCreateStatic(waReader, sizeof(waReader), NORMALPRIO, Reader, NULL);
 8005c96:	2300      	movs	r3, #0
 8005c98:	9300      	str	r3, [sp, #0]
 8005c9a:	4b07      	ldr	r3, [pc, #28]	; (8005cb8 <ecc_init_keypair+0x38>)
 8005c9c:	2280      	movs	r2, #128	; 0x80
 8005c9e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005ca2:	4806      	ldr	r0, [pc, #24]	; (8005cbc <ecc_init_keypair+0x3c>)
 8005ca4:	f00e fe4c 	bl	8014940 <chThdCreateStatic>

}
 8005ca8:	b003      	add	sp, #12
 8005caa:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cae:	bf00      	nop
 8005cb0:	08005af1 	.word	0x08005af1
 8005cb4:	2000cda8 	.word	0x2000cda8
 8005cb8:	08005b41 	.word	0x08005b41
 8005cbc:	2000ee38 	.word	0x2000ee38

08005cc0 <chRegSetThreadName.lto_priv.1>:
static inline void chRegSetThreadName(const char *name) {
 8005cc0:	b082      	sub	sp, #8
 8005cc2:	9001      	str	r0, [sp, #4]
  ch.rlist.current->name = name;
 8005cc4:	4b02      	ldr	r3, [pc, #8]	; (8005cd0 <chRegSetThreadName.lto_priv.1+0x10>)
 8005cc6:	699b      	ldr	r3, [r3, #24]
 8005cc8:	9a01      	ldr	r2, [sp, #4]
 8005cca:	619a      	str	r2, [r3, #24]
}
 8005ccc:	b002      	add	sp, #8
 8005cce:	4770      	bx	lr
 8005cd0:	20005ca0 	.word	0x20005ca0
	...

08005ce0 <Thread1>:
};

uint8_t count=0;

static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8005ce0:	b510      	push	{r4, lr}
 8005ce2:	b0ce      	sub	sp, #312	; 0x138
 8005ce4:	ab01      	add	r3, sp, #4
 8005ce6:	6018      	str	r0, [r3, #0]

	(void)arg;
	chRegSetThreadName("blinker1");
 8005ce8:	4819      	ldr	r0, [pc, #100]	; (8005d50 <Thread1+0x70>)
 8005cea:	f7ff ffe9 	bl	8005cc0 <chRegSetThreadName.lto_priv.1>
	while (true) {
		debug("heartbeat %d", current_state);
 8005cee:	4b19      	ldr	r3, [pc, #100]	; (8005d54 <Thread1+0x74>)
 8005cf0:	781b      	ldrb	r3, [r3, #0]
 8005cf2:	4619      	mov	r1, r3
 8005cf4:	4818      	ldr	r0, [pc, #96]	; (8005d58 <Thread1+0x78>)
 8005cf6:	f7ff fceb 	bl	80056d0 <debug>
		palTogglePad(GPIOC, 1);
 8005cfa:	4a18      	ldr	r2, [pc, #96]	; (8005d5c <Thread1+0x7c>)
 8005cfc:	4b17      	ldr	r3, [pc, #92]	; (8005d5c <Thread1+0x7c>)
 8005cfe:	695b      	ldr	r3, [r3, #20]
 8005d00:	f083 0302 	eor.w	r3, r3, #2
 8005d04:	6153      	str	r3, [r2, #20]
		uint64_t gps_time = 1561788062400263;
 8005d06:	a410      	add	r4, pc, #64	; (adr r4, 8005d48 <Thread1+0x68>)
 8005d08:	e9d4 3400 	ldrd	r3, r4, [r4]
 8005d0c:	aa4c      	add	r2, sp, #304	; 0x130
 8005d0e:	e9c2 3400 	strd	r3, r4, [r2]
		struct tm tm;
		char buf[255];

		memset(&tm, 0, sizeof(struct tm));
 8005d12:	ab03      	add	r3, sp, #12
 8005d14:	2224      	movs	r2, #36	; 0x24
 8005d16:	2100      	movs	r1, #0
 8005d18:	4618      	mov	r0, r3
 8005d1a:	f017 fd5b 	bl	801d7d4 <memset>
		strptime("1360440555", "%s", &tm);
 8005d1e:	ab03      	add	r3, sp, #12
 8005d20:	461a      	mov	r2, r3
 8005d22:	490f      	ldr	r1, [pc, #60]	; (8005d60 <Thread1+0x80>)
 8005d24:	480f      	ldr	r0, [pc, #60]	; (8005d64 <Thread1+0x84>)
 8005d26:	f015 fc5f 	bl	801b5e8 <strptime>
		strftime(buf, sizeof(buf), "%b %d %H:%M %Y", &tm);
 8005d2a:	ab03      	add	r3, sp, #12
 8005d2c:	a80c      	add	r0, sp, #48	; 0x30
 8005d2e:	4a0e      	ldr	r2, [pc, #56]	; (8005d68 <Thread1+0x88>)
 8005d30:	21ff      	movs	r1, #255	; 0xff
 8005d32:	f019 f8ef 	bl	801ef14 <strftime>
		puts(buf); /* -> Feb 09 20:09 2013 */
 8005d36:	ab0c      	add	r3, sp, #48	; 0x30
 8005d38:	4618      	mov	r0, r3
 8005d3a:	f018 faa1 	bl	801e280 <puts>
		chThdSleepMilliseconds(5000);
 8005d3e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005d42:	f00e fe85 	bl	8014a50 <chThdSleep>
 8005d46:	e7d2      	b.n	8005cee <Thread1+0xe>
 8005d48:	1eac7f07 	.word	0x1eac7f07
 8005d4c:	00058c70 	.word	0x00058c70
 8005d50:	08024c24 	.word	0x08024c24
 8005d54:	2000cda0 	.word	0x2000cda0
 8005d58:	08024c30 	.word	0x08024c30
 8005d5c:	40020800 	.word	0x40020800
 8005d60:	08024b90 	.word	0x08024b90
 8005d64:	08024c40 	.word	0x08024c40
 8005d68:	08024c4c 	.word	0x08024c4c
 8005d6c:	00000000 	.word	0x00000000

08005d70 <main>:
	}
}

int main(void) {
 8005d70:	b500      	push	{lr}
 8005d72:	b083      	sub	sp, #12

	halInit();
 8005d74:	f013 fe1c 	bl	80199b0 <halInit>
	chSysInit();
 8005d78:	f00e f87a 	bl	8013e70 <chSysInit>

	sdStart(&SERIAL_LINE, &Serial_config);
 8005d7c:	490b      	ldr	r1, [pc, #44]	; (8005dac <main+0x3c>)
 8005d7e:	480c      	ldr	r0, [pc, #48]	; (8005db0 <main+0x40>)
 8005d80:	f012 fec6 	bl	8018b10 <sdStart>
	delay(1000);
 8005d84:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005d88:	f7ff fcca 	bl	8005720 <delay>

	chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8005d8c:	2300      	movs	r3, #0
 8005d8e:	9300      	str	r3, [sp, #0]
 8005d90:	4b08      	ldr	r3, [pc, #32]	; (8005db4 <main+0x44>)
 8005d92:	2281      	movs	r2, #129	; 0x81
 8005d94:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005d98:	4807      	ldr	r0, [pc, #28]	; (8005db8 <main+0x48>)
 8005d9a:	f00e fdd1 	bl	8014940 <chThdCreateStatic>

	ecc_init_keypair();
 8005d9e:	f7ff ff6f 	bl	8005c80 <ecc_init_keypair>

	while (true) {
		delay(1000);
 8005da2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005da6:	f7ff fcbb 	bl	8005720 <delay>
 8005daa:	e7fa      	b.n	8005da2 <main+0x32>
 8005dac:	20004468 	.word	0x20004468
 8005db0:	200052e4 	.word	0x200052e4
 8005db4:	08005ce1 	.word	0x08005ce1
 8005db8:	2000f008 	.word	0x2000f008
 8005dbc:	00000000 	.word	0x00000000

08005dc0 <PemToDer>:

/* Remove PEM header/footer, convert to ASN1, store any encrypted data
   info->consumed tracks of PEM bytes consumed in case multiple parts */
int PemToDer(const unsigned char* buff, long longSz, int type,
              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* eccKey)
{
 8005dc0:	b500      	push	{lr}
 8005dc2:	b091      	sub	sp, #68	; 0x44
 8005dc4:	9003      	str	r0, [sp, #12]
 8005dc6:	9102      	str	r1, [sp, #8]
 8005dc8:	9201      	str	r2, [sp, #4]
 8005dca:	9300      	str	r3, [sp, #0]
    const char* header      = NULL;
 8005dcc:	2300      	movs	r3, #0
 8005dce:	930f      	str	r3, [sp, #60]	; 0x3c
    const char* footer      = NULL;
 8005dd0:	2300      	movs	r3, #0
 8005dd2:	930e      	str	r3, [sp, #56]	; 0x38
    char*       headerEnd;
    char*       footerEnd;
    char*       consumedEnd;
    char*       bufferEnd   = (char*)(buff + longSz);
 8005dd4:	9b02      	ldr	r3, [sp, #8]
 8005dd6:	9a03      	ldr	r2, [sp, #12]
 8005dd8:	4413      	add	r3, r2
 8005dda:	930b      	str	r3, [sp, #44]	; 0x2c
    long        neededSz;
    int         ret         = 0;
 8005ddc:	2300      	movs	r3, #0
 8005dde:	930a      	str	r3, [sp, #40]	; 0x28
    int         sz          = (int)longSz;
 8005de0:	9b02      	ldr	r3, [sp, #8]
 8005de2:	9309      	str	r3, [sp, #36]	; 0x24
    int         encrypted_key = 0;
 8005de4:	2300      	movs	r3, #0
 8005de6:	9308      	str	r3, [sp, #32]
    DerBuffer*  der;

    WOLFSSL_ENTER("PemToDer");

    switch (type) {
 8005de8:	9b01      	ldr	r3, [sp, #4]
 8005dea:	2b11      	cmp	r3, #17
 8005dec:	d86c      	bhi.n	8005ec8 <PemToDer+0x108>
 8005dee:	a201      	add	r2, pc, #4	; (adr r2, 8005df4 <PemToDer+0x34>)
 8005df0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005df4:	08005e3d 	.word	0x08005e3d
 8005df8:	08005ec9 	.word	0x08005ec9
 8005dfc:	08005e59 	.word	0x08005e59
 8005e00:	08005e67 	.word	0x08005e67
 8005e04:	08005e4b 	.word	0x08005e4b
 8005e08:	08005e3d 	.word	0x08005e3d
 8005e0c:	08005ec9 	.word	0x08005ec9
 8005e10:	08005ec9 	.word	0x08005ec9
 8005e14:	08005e75 	.word	0x08005e75
 8005e18:	08005e83 	.word	0x08005e83
 8005e1c:	08005e91 	.word	0x08005e91
 8005e20:	08005e9f 	.word	0x08005e9f
 8005e24:	08005ebb 	.word	0x08005ebb
 8005e28:	08005ec9 	.word	0x08005ec9
 8005e2c:	08005ec9 	.word	0x08005ec9
 8005e30:	08005e3d 	.word	0x08005e3d
 8005e34:	08005ec9 	.word	0x08005ec9
 8005e38:	08005ead 	.word	0x08005ead
        case CA_TYPE:       /* same as below */
        case TRUSTED_PEER_TYPE:
        case CERT_TYPE:      header=BEGIN_CERT;       footer=END_CERT;
 8005e3c:	4b8c      	ldr	r3, [pc, #560]	; (8006070 <PemToDer+0x2b0>)
 8005e3e:	681b      	ldr	r3, [r3, #0]
 8005e40:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e42:	4b8c      	ldr	r3, [pc, #560]	; (8006074 <PemToDer+0x2b4>)
 8005e44:	681b      	ldr	r3, [r3, #0]
 8005e46:	930e      	str	r3, [sp, #56]	; 0x38
 8005e48:	e044      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case CRL_TYPE:       header=BEGIN_X509_CRL;   footer=END_X509_CRL;
 8005e4a:	4b8b      	ldr	r3, [pc, #556]	; (8006078 <PemToDer+0x2b8>)
 8005e4c:	681b      	ldr	r3, [r3, #0]
 8005e4e:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e50:	4b8a      	ldr	r3, [pc, #552]	; (800607c <PemToDer+0x2bc>)
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	930e      	str	r3, [sp, #56]	; 0x38
 8005e56:	e03d      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case DH_PARAM_TYPE:  header=BEGIN_DH_PARAM;   footer=END_DH_PARAM;
 8005e58:	4b89      	ldr	r3, [pc, #548]	; (8006080 <PemToDer+0x2c0>)
 8005e5a:	681b      	ldr	r3, [r3, #0]
 8005e5c:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e5e:	4b89      	ldr	r3, [pc, #548]	; (8006084 <PemToDer+0x2c4>)
 8005e60:	681b      	ldr	r3, [r3, #0]
 8005e62:	930e      	str	r3, [sp, #56]	; 0x38
 8005e64:	e036      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case DSA_PARAM_TYPE: header=BEGIN_DSA_PARAM;  footer=END_DSA_PARAM;
 8005e66:	4b88      	ldr	r3, [pc, #544]	; (8006088 <PemToDer+0x2c8>)
 8005e68:	681b      	ldr	r3, [r3, #0]
 8005e6a:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e6c:	4b87      	ldr	r3, [pc, #540]	; (800608c <PemToDer+0x2cc>)
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	930e      	str	r3, [sp, #56]	; 0x38
 8005e72:	e02f      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case CERTREQ_TYPE:   header=BEGIN_CERT_REQ;   footer=END_CERT_REQ;
 8005e74:	4b86      	ldr	r3, [pc, #536]	; (8006090 <PemToDer+0x2d0>)
 8005e76:	681b      	ldr	r3, [r3, #0]
 8005e78:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e7a:	4b86      	ldr	r3, [pc, #536]	; (8006094 <PemToDer+0x2d4>)
 8005e7c:	681b      	ldr	r3, [r3, #0]
 8005e7e:	930e      	str	r3, [sp, #56]	; 0x38
 8005e80:	e028      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case DSA_TYPE:       header=BEGIN_DSA_PRIV;   footer=END_DSA_PRIV;
 8005e82:	4b85      	ldr	r3, [pc, #532]	; (8006098 <PemToDer+0x2d8>)
 8005e84:	681b      	ldr	r3, [r3, #0]
 8005e86:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e88:	4b84      	ldr	r3, [pc, #528]	; (800609c <PemToDer+0x2dc>)
 8005e8a:	681b      	ldr	r3, [r3, #0]
 8005e8c:	930e      	str	r3, [sp, #56]	; 0x38
 8005e8e:	e021      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case ECC_TYPE:       header=BEGIN_EC_PRIV;    footer=END_EC_PRIV;
 8005e90:	4b83      	ldr	r3, [pc, #524]	; (80060a0 <PemToDer+0x2e0>)
 8005e92:	681b      	ldr	r3, [r3, #0]
 8005e94:	930f      	str	r3, [sp, #60]	; 0x3c
 8005e96:	4b83      	ldr	r3, [pc, #524]	; (80060a4 <PemToDer+0x2e4>)
 8005e98:	681b      	ldr	r3, [r3, #0]
 8005e9a:	930e      	str	r3, [sp, #56]	; 0x38
 8005e9c:	e01a      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case RSA_TYPE:       header=BEGIN_RSA_PRIV;   footer=END_RSA_PRIV;
 8005e9e:	4b82      	ldr	r3, [pc, #520]	; (80060a8 <PemToDer+0x2e8>)
 8005ea0:	681b      	ldr	r3, [r3, #0]
 8005ea2:	930f      	str	r3, [sp, #60]	; 0x3c
 8005ea4:	4b81      	ldr	r3, [pc, #516]	; (80060ac <PemToDer+0x2ec>)
 8005ea6:	681b      	ldr	r3, [r3, #0]
 8005ea8:	930e      	str	r3, [sp, #56]	; 0x38
 8005eaa:	e013      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case ED25519_TYPE:   header=BEGIN_EDDSA_PRIV; footer=END_EDDSA_PRIV;
 8005eac:	4b80      	ldr	r3, [pc, #512]	; (80060b0 <PemToDer+0x2f0>)
 8005eae:	681b      	ldr	r3, [r3, #0]
 8005eb0:	930f      	str	r3, [sp, #60]	; 0x3c
 8005eb2:	4b80      	ldr	r3, [pc, #512]	; (80060b4 <PemToDer+0x2f4>)
 8005eb4:	681b      	ldr	r3, [r3, #0]
 8005eb6:	930e      	str	r3, [sp, #56]	; 0x38
 8005eb8:	e00c      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        case PUBLICKEY_TYPE: header=BEGIN_PUB_KEY;    footer=END_PUB_KEY;
 8005eba:	4b7f      	ldr	r3, [pc, #508]	; (80060b8 <PemToDer+0x2f8>)
 8005ebc:	681b      	ldr	r3, [r3, #0]
 8005ebe:	930f      	str	r3, [sp, #60]	; 0x3c
 8005ec0:	4b7e      	ldr	r3, [pc, #504]	; (80060bc <PemToDer+0x2fc>)
 8005ec2:	681b      	ldr	r3, [r3, #0]
 8005ec4:	930e      	str	r3, [sp, #56]	; 0x38
 8005ec6:	e005      	b.n	8005ed4 <PemToDer+0x114>
                             break;
        default:             header=BEGIN_RSA_PRIV;   footer=END_RSA_PRIV;
 8005ec8:	4b77      	ldr	r3, [pc, #476]	; (80060a8 <PemToDer+0x2e8>)
 8005eca:	681b      	ldr	r3, [r3, #0]
 8005ecc:	930f      	str	r3, [sp, #60]	; 0x3c
 8005ece:	4b77      	ldr	r3, [pc, #476]	; (80060ac <PemToDer+0x2ec>)
 8005ed0:	681b      	ldr	r3, [r3, #0]
 8005ed2:	930e      	str	r3, [sp, #56]	; 0x38
                             break;
    }

    /* find header */
    for (;;) {
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 8005ed4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005ed6:	461a      	mov	r2, r3
 8005ed8:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8005eda:	9803      	ldr	r0, [sp, #12]
 8005edc:	f000 f950 	bl	8006180 <mystrnstr>
 8005ee0:	900d      	str	r0, [sp, #52]	; 0x34

        if (headerEnd || type != PRIVATEKEY_TYPE) {
 8005ee2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ee4:	2b00      	cmp	r3, #0
 8005ee6:	d13e      	bne.n	8005f66 <PemToDer+0x1a6>
 8005ee8:	9b01      	ldr	r3, [sp, #4]
 8005eea:	2b01      	cmp	r3, #1
 8005eec:	d13b      	bne.n	8005f66 <PemToDer+0x1a6>
            break;
        } else if (header == BEGIN_RSA_PRIV) {
 8005eee:	4b6e      	ldr	r3, [pc, #440]	; (80060a8 <PemToDer+0x2e8>)
 8005ef0:	681b      	ldr	r3, [r3, #0]
 8005ef2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005ef4:	429a      	cmp	r2, r3
 8005ef6:	d106      	bne.n	8005f06 <PemToDer+0x146>
                   header =  BEGIN_PRIV_KEY;       footer = END_PRIV_KEY;
 8005ef8:	4b71      	ldr	r3, [pc, #452]	; (80060c0 <PemToDer+0x300>)
 8005efa:	681b      	ldr	r3, [r3, #0]
 8005efc:	930f      	str	r3, [sp, #60]	; 0x3c
 8005efe:	4b71      	ldr	r3, [pc, #452]	; (80060c4 <PemToDer+0x304>)
 8005f00:	681b      	ldr	r3, [r3, #0]
 8005f02:	930e      	str	r3, [sp, #56]	; 0x38
 8005f04:	e7e6      	b.n	8005ed4 <PemToDer+0x114>
        } else if (header == BEGIN_PRIV_KEY) {
 8005f06:	4b6e      	ldr	r3, [pc, #440]	; (80060c0 <PemToDer+0x300>)
 8005f08:	681b      	ldr	r3, [r3, #0]
 8005f0a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005f0c:	429a      	cmp	r2, r3
 8005f0e:	d106      	bne.n	8005f1e <PemToDer+0x15e>
                   header =  BEGIN_ENC_PRIV_KEY;   footer = END_ENC_PRIV_KEY;
 8005f10:	4b6d      	ldr	r3, [pc, #436]	; (80060c8 <PemToDer+0x308>)
 8005f12:	681b      	ldr	r3, [r3, #0]
 8005f14:	930f      	str	r3, [sp, #60]	; 0x3c
 8005f16:	4b6d      	ldr	r3, [pc, #436]	; (80060cc <PemToDer+0x30c>)
 8005f18:	681b      	ldr	r3, [r3, #0]
 8005f1a:	930e      	str	r3, [sp, #56]	; 0x38
 8005f1c:	e7da      	b.n	8005ed4 <PemToDer+0x114>
        } else if (header == BEGIN_ENC_PRIV_KEY) {
 8005f1e:	4b6a      	ldr	r3, [pc, #424]	; (80060c8 <PemToDer+0x308>)
 8005f20:	681b      	ldr	r3, [r3, #0]
 8005f22:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005f24:	429a      	cmp	r2, r3
 8005f26:	d106      	bne.n	8005f36 <PemToDer+0x176>
                   header =  BEGIN_EC_PRIV;        footer = END_EC_PRIV;
 8005f28:	4b5d      	ldr	r3, [pc, #372]	; (80060a0 <PemToDer+0x2e0>)
 8005f2a:	681b      	ldr	r3, [r3, #0]
 8005f2c:	930f      	str	r3, [sp, #60]	; 0x3c
 8005f2e:	4b5d      	ldr	r3, [pc, #372]	; (80060a4 <PemToDer+0x2e4>)
 8005f30:	681b      	ldr	r3, [r3, #0]
 8005f32:	930e      	str	r3, [sp, #56]	; 0x38
 8005f34:	e7ce      	b.n	8005ed4 <PemToDer+0x114>
        } else if (header == BEGIN_EC_PRIV) {
 8005f36:	4b5a      	ldr	r3, [pc, #360]	; (80060a0 <PemToDer+0x2e0>)
 8005f38:	681b      	ldr	r3, [r3, #0]
 8005f3a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005f3c:	429a      	cmp	r2, r3
 8005f3e:	d106      	bne.n	8005f4e <PemToDer+0x18e>
                   header =  BEGIN_DSA_PRIV;       footer = END_DSA_PRIV;
 8005f40:	4b55      	ldr	r3, [pc, #340]	; (8006098 <PemToDer+0x2d8>)
 8005f42:	681b      	ldr	r3, [r3, #0]
 8005f44:	930f      	str	r3, [sp, #60]	; 0x3c
 8005f46:	4b55      	ldr	r3, [pc, #340]	; (800609c <PemToDer+0x2dc>)
 8005f48:	681b      	ldr	r3, [r3, #0]
 8005f4a:	930e      	str	r3, [sp, #56]	; 0x38
 8005f4c:	e7c2      	b.n	8005ed4 <PemToDer+0x114>
        } else if (header == BEGIN_DSA_PRIV) {
 8005f4e:	4b52      	ldr	r3, [pc, #328]	; (8006098 <PemToDer+0x2d8>)
 8005f50:	681b      	ldr	r3, [r3, #0]
 8005f52:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005f54:	429a      	cmp	r2, r3
 8005f56:	d106      	bne.n	8005f66 <PemToDer+0x1a6>
                   header =  BEGIN_EDDSA_PRIV;     footer = END_EDDSA_PRIV;
 8005f58:	4b55      	ldr	r3, [pc, #340]	; (80060b0 <PemToDer+0x2f0>)
 8005f5a:	681b      	ldr	r3, [r3, #0]
 8005f5c:	930f      	str	r3, [sp, #60]	; 0x3c
 8005f5e:	4b55      	ldr	r3, [pc, #340]	; (80060b4 <PemToDer+0x2f4>)
 8005f60:	681b      	ldr	r3, [r3, #0]
 8005f62:	930e      	str	r3, [sp, #56]	; 0x38
 8005f64:	e7b6      	b.n	8005ed4 <PemToDer+0x114>
        } else
            break;
    }

    if (!headerEnd) {
 8005f66:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f68:	2b00      	cmp	r3, #0
 8005f6a:	d101      	bne.n	8005f70 <PemToDer+0x1b0>
        WOLFSSL_MSG("Couldn't find PEM header");
        return SSL_NO_PEM_HEADER;
 8005f6c:	4b58      	ldr	r3, [pc, #352]	; (80060d0 <PemToDer+0x310>)
 8005f6e:	e100      	b.n	8006172 <PemToDer+0x3b2>
    }

    headerEnd += XSTRLEN(header);
 8005f70:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005f72:	f7fe fb65 	bl	8004640 <strlen>
 8005f76:	4602      	mov	r2, r0
 8005f78:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f7a:	4413      	add	r3, r2
 8005f7c:	930d      	str	r3, [sp, #52]	; 0x34

    if ((headerEnd + 1) >= bufferEnd)
 8005f7e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f80:	1c5a      	adds	r2, r3, #1
 8005f82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005f84:	429a      	cmp	r2, r3
 8005f86:	d302      	bcc.n	8005f8e <PemToDer+0x1ce>
        return WOLFSSL_BAD_FILE;
 8005f88:	f06f 0303 	mvn.w	r3, #3
 8005f8c:	e0f1      	b.n	8006172 <PemToDer+0x3b2>

    /* eat end of line */
    if (headerEnd[0] == '\n')
 8005f8e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f90:	781b      	ldrb	r3, [r3, #0]
 8005f92:	2b0a      	cmp	r3, #10
 8005f94:	d103      	bne.n	8005f9e <PemToDer+0x1de>
        headerEnd++;
 8005f96:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f98:	3301      	adds	r3, #1
 8005f9a:	930d      	str	r3, [sp, #52]	; 0x34
 8005f9c:	e015      	b.n	8005fca <PemToDer+0x20a>
    else if (headerEnd[1] == '\n')
 8005f9e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005fa0:	3301      	adds	r3, #1
 8005fa2:	781b      	ldrb	r3, [r3, #0]
 8005fa4:	2b0a      	cmp	r3, #10
 8005fa6:	d103      	bne.n	8005fb0 <PemToDer+0x1f0>
        headerEnd += 2;
 8005fa8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005faa:	3302      	adds	r3, #2
 8005fac:	930d      	str	r3, [sp, #52]	; 0x34
 8005fae:	e00c      	b.n	8005fca <PemToDer+0x20a>
    else {
        if (info)
 8005fb0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005fb2:	2b00      	cmp	r3, #0
 8005fb4:	d006      	beq.n	8005fc4 <PemToDer+0x204>
            info->consumed = (long)(headerEnd+2 - (char*)buff);
 8005fb6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005fb8:	3302      	adds	r3, #2
 8005fba:	461a      	mov	r2, r3
 8005fbc:	9b03      	ldr	r3, [sp, #12]
 8005fbe:	1ad2      	subs	r2, r2, r3
 8005fc0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005fc2:	675a      	str	r2, [r3, #116]	; 0x74
        return WOLFSSL_BAD_FILE;
 8005fc4:	f06f 0303 	mvn.w	r3, #3
 8005fc8:	e0d3      	b.n	8006172 <PemToDer+0x3b2>
    }

    if (type == PRIVATEKEY_TYPE) {
 8005fca:	9b01      	ldr	r3, [sp, #4]
 8005fcc:	2b01      	cmp	r3, #1
 8005fce:	d10d      	bne.n	8005fec <PemToDer+0x22c>
        if (eccKey)
 8005fd0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8005fd2:	2b00      	cmp	r3, #0
 8005fd4:	d00a      	beq.n	8005fec <PemToDer+0x22c>
            *eccKey = header == BEGIN_EC_PRIV;
 8005fd6:	4b32      	ldr	r3, [pc, #200]	; (80060a0 <PemToDer+0x2e0>)
 8005fd8:	681b      	ldr	r3, [r3, #0]
 8005fda:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005fdc:	429a      	cmp	r2, r3
 8005fde:	bf0c      	ite	eq
 8005fe0:	2301      	moveq	r3, #1
 8005fe2:	2300      	movne	r3, #0
 8005fe4:	b2db      	uxtb	r3, r3
 8005fe6:	461a      	mov	r2, r3
 8005fe8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8005fea:	601a      	str	r2, [r3, #0]
        }
    }
#endif /* OPENSSL_EXTRA || HAVE_WEBSERVER */

    /* find footer */
    footerEnd = XSTRNSTR((char*)buff, footer, sz);
 8005fec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005fee:	461a      	mov	r2, r3
 8005ff0:	990e      	ldr	r1, [sp, #56]	; 0x38
 8005ff2:	9803      	ldr	r0, [sp, #12]
 8005ff4:	f000 f8c4 	bl	8006180 <mystrnstr>
 8005ff8:	9007      	str	r0, [sp, #28]
    if (!footerEnd) {
 8005ffa:	9b07      	ldr	r3, [sp, #28]
 8005ffc:	2b00      	cmp	r3, #0
 8005ffe:	d108      	bne.n	8006012 <PemToDer+0x252>
        if (info)
 8006000:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006002:	2b00      	cmp	r3, #0
 8006004:	d002      	beq.n	800600c <PemToDer+0x24c>
            info->consumed = longSz; /* No more certs if no footer */
 8006006:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006008:	9a02      	ldr	r2, [sp, #8]
 800600a:	675a      	str	r2, [r3, #116]	; 0x74
        return WOLFSSL_BAD_FILE;
 800600c:	f06f 0303 	mvn.w	r3, #3
 8006010:	e0af      	b.n	8006172 <PemToDer+0x3b2>
    }

    consumedEnd = footerEnd + XSTRLEN(footer);
 8006012:	980e      	ldr	r0, [sp, #56]	; 0x38
 8006014:	f7fe fb14 	bl	8004640 <strlen>
 8006018:	4602      	mov	r2, r0
 800601a:	9b07      	ldr	r3, [sp, #28]
 800601c:	4413      	add	r3, r2
 800601e:	930c      	str	r3, [sp, #48]	; 0x30

    if (consumedEnd < bufferEnd) {  /* handle no end of line on last line */
 8006020:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8006022:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006024:	429a      	cmp	r2, r3
 8006026:	d255      	bcs.n	80060d4 <PemToDer+0x314>
        /* eat end of line */
        if (consumedEnd[0] == '\n')
 8006028:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800602a:	781b      	ldrb	r3, [r3, #0]
 800602c:	2b0a      	cmp	r3, #10
 800602e:	d103      	bne.n	8006038 <PemToDer+0x278>
            consumedEnd++;
 8006030:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006032:	3301      	adds	r3, #1
 8006034:	930c      	str	r3, [sp, #48]	; 0x30
 8006036:	e04d      	b.n	80060d4 <PemToDer+0x314>
        else if ((consumedEnd + 1 < bufferEnd) && consumedEnd[1] == '\n')
 8006038:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800603a:	1c5a      	adds	r2, r3, #1
 800603c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800603e:	429a      	cmp	r2, r3
 8006040:	d208      	bcs.n	8006054 <PemToDer+0x294>
 8006042:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006044:	3301      	adds	r3, #1
 8006046:	781b      	ldrb	r3, [r3, #0]
 8006048:	2b0a      	cmp	r3, #10
 800604a:	d103      	bne.n	8006054 <PemToDer+0x294>
            consumedEnd += 2;
 800604c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800604e:	3302      	adds	r3, #2
 8006050:	930c      	str	r3, [sp, #48]	; 0x30
 8006052:	e03f      	b.n	80060d4 <PemToDer+0x314>
        else {
            if (info)
 8006054:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006056:	2b00      	cmp	r3, #0
 8006058:	d006      	beq.n	8006068 <PemToDer+0x2a8>
                info->consumed = (long)(consumedEnd+2 - (char*)buff);
 800605a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800605c:	3302      	adds	r3, #2
 800605e:	461a      	mov	r2, r3
 8006060:	9b03      	ldr	r3, [sp, #12]
 8006062:	1ad2      	subs	r2, r2, r3
 8006064:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006066:	675a      	str	r2, [r3, #116]	; 0x74
            return WOLFSSL_BAD_FILE;
 8006068:	f06f 0303 	mvn.w	r3, #3
 800606c:	e081      	b.n	8006172 <PemToDer+0x3b2>
 800606e:	bf00      	nop
 8006070:	20004400 	.word	0x20004400
 8006074:	20004404 	.word	0x20004404
 8006078:	20004420 	.word	0x20004420
 800607c:	20004424 	.word	0x20004424
 8006080:	20004410 	.word	0x20004410
 8006084:	20004414 	.word	0x20004414
 8006088:	20004418 	.word	0x20004418
 800608c:	2000441c 	.word	0x2000441c
 8006090:	20004408 	.word	0x20004408
 8006094:	2000440c 	.word	0x2000440c
 8006098:	20004450 	.word	0x20004450
 800609c:	20004454 	.word	0x20004454
 80060a0:	20004448 	.word	0x20004448
 80060a4:	2000444c 	.word	0x2000444c
 80060a8:	20004428 	.word	0x20004428
 80060ac:	2000442c 	.word	0x2000442c
 80060b0:	20004460 	.word	0x20004460
 80060b4:	20004464 	.word	0x20004464
 80060b8:	20004458 	.word	0x20004458
 80060bc:	2000445c 	.word	0x2000445c
 80060c0:	20004438 	.word	0x20004438
 80060c4:	2000443c 	.word	0x2000443c
 80060c8:	20004440 	.word	0x20004440
 80060cc:	20004444 	.word	0x20004444
 80060d0:	fffffe8c 	.word	0xfffffe8c
        }
    }

    if (info)
 80060d4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80060d6:	2b00      	cmp	r3, #0
 80060d8:	d004      	beq.n	80060e4 <PemToDer+0x324>
        info->consumed = (long)(consumedEnd - (char*)buff);
 80060da:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80060dc:	9b03      	ldr	r3, [sp, #12]
 80060de:	1ad2      	subs	r2, r2, r3
 80060e0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80060e2:	675a      	str	r2, [r3, #116]	; 0x74

    /* set up der buffer */
    neededSz = (long)(footerEnd - headerEnd);
 80060e4:	9a07      	ldr	r2, [sp, #28]
 80060e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80060e8:	1ad3      	subs	r3, r2, r3
 80060ea:	9306      	str	r3, [sp, #24]
    if (neededSz > sz || neededSz <= 0)
 80060ec:	9a06      	ldr	r2, [sp, #24]
 80060ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80060f0:	429a      	cmp	r2, r3
 80060f2:	dc02      	bgt.n	80060fa <PemToDer+0x33a>
 80060f4:	9b06      	ldr	r3, [sp, #24]
 80060f6:	2b00      	cmp	r3, #0
 80060f8:	dc02      	bgt.n	8006100 <PemToDer+0x340>
        return WOLFSSL_BAD_FILE;
 80060fa:	f06f 0303 	mvn.w	r3, #3
 80060fe:	e038      	b.n	8006172 <PemToDer+0x3b2>

    ret = AllocDer(pDer, (word32)neededSz, type, heap);
 8006100:	9906      	ldr	r1, [sp, #24]
 8006102:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006104:	9a01      	ldr	r2, [sp, #4]
 8006106:	9800      	ldr	r0, [sp, #0]
 8006108:	f000 f872 	bl	80061f0 <AllocDer>
 800610c:	900a      	str	r0, [sp, #40]	; 0x28
    if (ret < 0) {
 800610e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006110:	2b00      	cmp	r3, #0
 8006112:	da01      	bge.n	8006118 <PemToDer+0x358>
        return ret;
 8006114:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006116:	e02c      	b.n	8006172 <PemToDer+0x3b2>
    }
    der = *pDer;
 8006118:	9b00      	ldr	r3, [sp, #0]
 800611a:	681b      	ldr	r3, [r3, #0]
 800611c:	9305      	str	r3, [sp, #20]

    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 800611e:	9906      	ldr	r1, [sp, #24]
 8006120:	9b05      	ldr	r3, [sp, #20]
 8006122:	681a      	ldr	r2, [r3, #0]
 8006124:	9b05      	ldr	r3, [sp, #20]
 8006126:	3308      	adds	r3, #8
 8006128:	980d      	ldr	r0, [sp, #52]	; 0x34
 800612a:	f005 ff11 	bl	800bf50 <Base64_Decode>
 800612e:	4603      	mov	r3, r0
 8006130:	2b00      	cmp	r3, #0
 8006132:	da02      	bge.n	800613a <PemToDer+0x37a>
                      der->buffer, &der->length) < 0)
        return WOLFSSL_BAD_FILE;
 8006134:	f06f 0303 	mvn.w	r3, #3
 8006138:	e01b      	b.n	8006172 <PemToDer+0x3b2>

    if (header == BEGIN_PRIV_KEY && !encrypted_key) {
 800613a:	4b10      	ldr	r3, [pc, #64]	; (800617c <PemToDer+0x3bc>)
 800613c:	681b      	ldr	r3, [r3, #0]
 800613e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006140:	429a      	cmp	r2, r3
 8006142:	d115      	bne.n	8006170 <PemToDer+0x3b0>
 8006144:	9b08      	ldr	r3, [sp, #32]
 8006146:	2b00      	cmp	r3, #0
 8006148:	d112      	bne.n	8006170 <PemToDer+0x3b0>
        /* pkcs8 key, convert and adjust length */
        if ((ret = ToTraditional(der->buffer, der->length)) < 0)
 800614a:	9b05      	ldr	r3, [sp, #20]
 800614c:	681a      	ldr	r2, [r3, #0]
 800614e:	9b05      	ldr	r3, [sp, #20]
 8006150:	689b      	ldr	r3, [r3, #8]
 8006152:	4619      	mov	r1, r3
 8006154:	4610      	mov	r0, r2
 8006156:	f009 fdab 	bl	800fcb0 <ToTraditional>
 800615a:	900a      	str	r0, [sp, #40]	; 0x28
 800615c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800615e:	2b00      	cmp	r3, #0
 8006160:	da01      	bge.n	8006166 <PemToDer+0x3a6>
            return ret;
 8006162:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006164:	e005      	b.n	8006172 <PemToDer+0x3b2>

        der->length = ret;
 8006166:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006168:	9b05      	ldr	r3, [sp, #20]
 800616a:	609a      	str	r2, [r3, #8]
        return 0;
 800616c:	2300      	movs	r3, #0
 800616e:	e000      	b.n	8006172 <PemToDer+0x3b2>
            }
        }
    }
#endif  /* OPENSSL_EXTRA || HAVE_WEBSERVER || NO_PWDBASED */

    return 0;
 8006170:	2300      	movs	r3, #0
}
 8006172:	4618      	mov	r0, r3
 8006174:	b011      	add	sp, #68	; 0x44
 8006176:	f85d fb04 	ldr.w	pc, [sp], #4
 800617a:	bf00      	nop
 800617c:	20004438 	.word	0x20004438

08006180 <mystrnstr>:
{
 8006180:	b500      	push	{lr}
 8006182:	b087      	sub	sp, #28
 8006184:	9003      	str	r0, [sp, #12]
 8006186:	9102      	str	r1, [sp, #8]
 8006188:	9201      	str	r2, [sp, #4]
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
 800618a:	9802      	ldr	r0, [sp, #8]
 800618c:	f7fe fa58 	bl	8004640 <strlen>
 8006190:	9005      	str	r0, [sp, #20]
    if (s2_len == 0)
 8006192:	9b05      	ldr	r3, [sp, #20]
 8006194:	2b00      	cmp	r3, #0
 8006196:	d117      	bne.n	80061c8 <mystrnstr+0x48>
        return (char*)s1;
 8006198:	9b03      	ldr	r3, [sp, #12]
 800619a:	e01e      	b.n	80061da <mystrnstr+0x5a>
        if (s1[0] == s2[0])
 800619c:	9b03      	ldr	r3, [sp, #12]
 800619e:	781a      	ldrb	r2, [r3, #0]
 80061a0:	9b02      	ldr	r3, [sp, #8]
 80061a2:	781b      	ldrb	r3, [r3, #0]
 80061a4:	429a      	cmp	r2, r3
 80061a6:	d109      	bne.n	80061bc <mystrnstr+0x3c>
            if (XMEMCMP(s1, s2, s2_len) == 0)
 80061a8:	9a05      	ldr	r2, [sp, #20]
 80061aa:	9902      	ldr	r1, [sp, #8]
 80061ac:	9803      	ldr	r0, [sp, #12]
 80061ae:	f017 ffd5 	bl	801e15c <memcmp>
 80061b2:	4603      	mov	r3, r0
 80061b4:	2b00      	cmp	r3, #0
 80061b6:	d101      	bne.n	80061bc <mystrnstr+0x3c>
                return (char*)s1;
 80061b8:	9b03      	ldr	r3, [sp, #12]
 80061ba:	e00e      	b.n	80061da <mystrnstr+0x5a>
        s1++;
 80061bc:	9b03      	ldr	r3, [sp, #12]
 80061be:	3301      	adds	r3, #1
 80061c0:	9303      	str	r3, [sp, #12]
        n--;
 80061c2:	9b01      	ldr	r3, [sp, #4]
 80061c4:	3b01      	subs	r3, #1
 80061c6:	9301      	str	r3, [sp, #4]
    while (n >= s2_len && s1[0]) {
 80061c8:	9a01      	ldr	r2, [sp, #4]
 80061ca:	9b05      	ldr	r3, [sp, #20]
 80061cc:	429a      	cmp	r2, r3
 80061ce:	d303      	bcc.n	80061d8 <mystrnstr+0x58>
 80061d0:	9b03      	ldr	r3, [sp, #12]
 80061d2:	781b      	ldrb	r3, [r3, #0]
 80061d4:	2b00      	cmp	r3, #0
 80061d6:	d1e1      	bne.n	800619c <mystrnstr+0x1c>
    return NULL;
 80061d8:	2300      	movs	r3, #0
}
 80061da:	4618      	mov	r0, r3
 80061dc:	b007      	add	sp, #28
 80061de:	f85d fb04 	ldr.w	pc, [sp], #4
 80061e2:	bf00      	nop
	...

080061f0 <AllocDer>:
{
 80061f0:	b500      	push	{lr}
 80061f2:	b089      	sub	sp, #36	; 0x24
 80061f4:	9003      	str	r0, [sp, #12]
 80061f6:	9102      	str	r1, [sp, #8]
 80061f8:	9201      	str	r2, [sp, #4]
 80061fa:	9300      	str	r3, [sp, #0]
    int ret = BAD_FUNC_ARG;
 80061fc:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006200:	9307      	str	r3, [sp, #28]
    if (pDer) {
 8006202:	9b03      	ldr	r3, [sp, #12]
 8006204:	2b00      	cmp	r3, #0
 8006206:	d061      	beq.n	80062cc <AllocDer+0xdc>
        int dynType = 0;
 8006208:	2300      	movs	r3, #0
 800620a:	9306      	str	r3, [sp, #24]
        switch (type) {
 800620c:	9b01      	ldr	r3, [sp, #4]
 800620e:	2b0b      	cmp	r3, #11
 8006210:	d82c      	bhi.n	800626c <AllocDer+0x7c>
 8006212:	a201      	add	r2, pc, #4	; (adr r2, 8006218 <AllocDer+0x28>)
 8006214:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006218:	0800624f 	.word	0x0800624f
 800621c:	0800626d 	.word	0x0800626d
 8006220:	0800626d 	.word	0x0800626d
 8006224:	0800626d 	.word	0x0800626d
 8006228:	08006255 	.word	0x08006255
 800622c:	08006249 	.word	0x08006249
 8006230:	0800626d 	.word	0x0800626d
 8006234:	0800626d 	.word	0x0800626d
 8006238:	0800626d 	.word	0x0800626d
 800623c:	0800625b 	.word	0x0800625b
 8006240:	08006261 	.word	0x08006261
 8006244:	08006267 	.word	0x08006267
            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;
 8006248:	2301      	movs	r3, #1
 800624a:	9306      	str	r3, [sp, #24]
 800624c:	e010      	b.n	8006270 <AllocDer+0x80>
            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;
 800624e:	2302      	movs	r3, #2
 8006250:	9306      	str	r3, [sp, #24]
 8006252:	e00d      	b.n	8006270 <AllocDer+0x80>
            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;
 8006254:	2316      	movs	r3, #22
 8006256:	9306      	str	r3, [sp, #24]
 8006258:	e00a      	b.n	8006270 <AllocDer+0x80>
            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;
 800625a:	2315      	movs	r3, #21
 800625c:	9306      	str	r3, [sp, #24]
 800625e:	e007      	b.n	8006270 <AllocDer+0x80>
            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;
 8006260:	2325      	movs	r3, #37	; 0x25
 8006262:	9306      	str	r3, [sp, #24]
 8006264:	e004      	b.n	8006270 <AllocDer+0x80>
            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;
 8006266:	230a      	movs	r3, #10
 8006268:	9306      	str	r3, [sp, #24]
 800626a:	e001      	b.n	8006270 <AllocDer+0x80>
            default:        dynType = DYNAMIC_TYPE_KEY;  break;
 800626c:	2303      	movs	r3, #3
 800626e:	9306      	str	r3, [sp, #24]
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
 8006270:	9b02      	ldr	r3, [sp, #8]
 8006272:	3314      	adds	r3, #20
 8006274:	4619      	mov	r1, r3
 8006276:	9800      	ldr	r0, [sp, #0]
 8006278:	f7ff faf2 	bl	8005860 <chibios_alloc>
 800627c:	4602      	mov	r2, r0
 800627e:	9b03      	ldr	r3, [sp, #12]
 8006280:	601a      	str	r2, [r3, #0]
        if (*pDer == NULL) {
 8006282:	9b03      	ldr	r3, [sp, #12]
 8006284:	681b      	ldr	r3, [r3, #0]
 8006286:	2b00      	cmp	r3, #0
 8006288:	d102      	bne.n	8006290 <AllocDer+0xa0>
            return MEMORY_ERROR;
 800628a:	f46f 7397 	mvn.w	r3, #302	; 0x12e
 800628e:	e01e      	b.n	80062ce <AllocDer+0xde>
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
 8006290:	9b03      	ldr	r3, [sp, #12]
 8006292:	6818      	ldr	r0, [r3, #0]
 8006294:	9b02      	ldr	r3, [sp, #8]
 8006296:	3314      	adds	r3, #20
 8006298:	461a      	mov	r2, r3
 800629a:	2100      	movs	r1, #0
 800629c:	f017 fa9a 	bl	801d7d4 <memset>
        der = *pDer;
 80062a0:	9b03      	ldr	r3, [sp, #12]
 80062a2:	681b      	ldr	r3, [r3, #0]
 80062a4:	9305      	str	r3, [sp, #20]
        der->type = type;
 80062a6:	9b05      	ldr	r3, [sp, #20]
 80062a8:	9a01      	ldr	r2, [sp, #4]
 80062aa:	60da      	str	r2, [r3, #12]
        der->dynType = dynType; /* Cache this for FreeDer */
 80062ac:	9b05      	ldr	r3, [sp, #20]
 80062ae:	9a06      	ldr	r2, [sp, #24]
 80062b0:	611a      	str	r2, [r3, #16]
        der->heap = heap;
 80062b2:	9b05      	ldr	r3, [sp, #20]
 80062b4:	9a00      	ldr	r2, [sp, #0]
 80062b6:	605a      	str	r2, [r3, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
 80062b8:	9b05      	ldr	r3, [sp, #20]
 80062ba:	f103 0214 	add.w	r2, r3, #20
 80062be:	9b05      	ldr	r3, [sp, #20]
 80062c0:	601a      	str	r2, [r3, #0]
        der->length = length;
 80062c2:	9b05      	ldr	r3, [sp, #20]
 80062c4:	9a02      	ldr	r2, [sp, #8]
 80062c6:	609a      	str	r2, [r3, #8]
        ret = 0; /* Success */
 80062c8:	2300      	movs	r3, #0
 80062ca:	9307      	str	r3, [sp, #28]
    return ret;
 80062cc:	9b07      	ldr	r3, [sp, #28]
}
 80062ce:	4618      	mov	r0, r3
 80062d0:	b009      	add	sp, #36	; 0x24
 80062d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80062d6:	bf00      	nop
	...

080062e0 <Sha256Update>:


#ifdef XTRANSFORM

    static INLINE int Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 80062e0:	b500      	push	{lr}
 80062e2:	b089      	sub	sp, #36	; 0x24
 80062e4:	9003      	str	r0, [sp, #12]
 80062e6:	9102      	str	r1, [sp, #8]
 80062e8:	9201      	str	r2, [sp, #4]
        int ret = 0;
 80062ea:	2300      	movs	r3, #0
 80062ec:	9307      	str	r3, [sp, #28]
        byte* local;

        if (sha256 == NULL || (data == NULL && len > 0)) {
 80062ee:	9b03      	ldr	r3, [sp, #12]
 80062f0:	2b00      	cmp	r3, #0
 80062f2:	d005      	beq.n	8006300 <Sha256Update+0x20>
 80062f4:	9b02      	ldr	r3, [sp, #8]
 80062f6:	2b00      	cmp	r3, #0
 80062f8:	d105      	bne.n	8006306 <Sha256Update+0x26>
 80062fa:	9b01      	ldr	r3, [sp, #4]
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	d002      	beq.n	8006306 <Sha256Update+0x26>
            return BAD_FUNC_ARG;
 8006300:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006304:	e048      	b.n	8006398 <Sha256Update+0xb8>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        /* do block size increments */
        local = (byte*)sha256->buffer;
 8006306:	9b03      	ldr	r3, [sp, #12]
 8006308:	3320      	adds	r3, #32
 800630a:	9306      	str	r3, [sp, #24]

        /* check that internal buffLen is valid */
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE)
 800630c:	9b03      	ldr	r3, [sp, #12]
 800630e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006310:	2b3f      	cmp	r3, #63	; 0x3f
 8006312:	d93d      	bls.n	8006390 <Sha256Update+0xb0>
            return BUFFER_E;
 8006314:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8006318:	e03e      	b.n	8006398 <Sha256Update+0xb8>

        SAVE_XMM_YMM; /* for Intel AVX */

        while (len) {
            word32 add = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 800631a:	9b03      	ldr	r3, [sp, #12]
 800631c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800631e:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8006322:	4619      	mov	r1, r3
 8006324:	9801      	ldr	r0, [sp, #4]
 8006326:	f001 f88b 	bl	8007440 <min.lto_priv.361>
 800632a:	9005      	str	r0, [sp, #20]
            XMEMCPY(&local[sha256->buffLen], data, add);
 800632c:	9b03      	ldr	r3, [sp, #12]
 800632e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006330:	9a06      	ldr	r2, [sp, #24]
 8006332:	4413      	add	r3, r2
 8006334:	9a05      	ldr	r2, [sp, #20]
 8006336:	9902      	ldr	r1, [sp, #8]
 8006338:	4618      	mov	r0, r3
 800633a:	f7fe f9ef 	bl	800471c <memcpy>

            sha256->buffLen += add;
 800633e:	9b03      	ldr	r3, [sp, #12]
 8006340:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006342:	9b05      	ldr	r3, [sp, #20]
 8006344:	441a      	add	r2, r3
 8006346:	9b03      	ldr	r3, [sp, #12]
 8006348:	661a      	str	r2, [r3, #96]	; 0x60
            data            += add;
 800634a:	9a02      	ldr	r2, [sp, #8]
 800634c:	9b05      	ldr	r3, [sp, #20]
 800634e:	4413      	add	r3, r2
 8006350:	9302      	str	r3, [sp, #8]
            len             -= add;
 8006352:	9a01      	ldr	r2, [sp, #4]
 8006354:	9b05      	ldr	r3, [sp, #20]
 8006356:	1ad3      	subs	r3, r2, r3
 8006358:	9301      	str	r3, [sp, #4]

            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 800635a:	9b03      	ldr	r3, [sp, #12]
 800635c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800635e:	2b40      	cmp	r3, #64	; 0x40
 8006360:	d116      	bne.n	8006390 <Sha256Update+0xb0>
        #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
            #if defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)
                if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
            #endif
                {
                    ByteReverseWords(sha256->buffer, sha256->buffer,
 8006362:	9b03      	ldr	r3, [sp, #12]
 8006364:	f103 0020 	add.w	r0, r3, #32
 8006368:	9b03      	ldr	r3, [sp, #12]
 800636a:	3320      	adds	r3, #32
 800636c:	2240      	movs	r2, #64	; 0x40
 800636e:	4619      	mov	r1, r3
 8006370:	f001 f83e 	bl	80073f0 <ByteReverseWords.lto_priv.357>
                                                             WC_SHA256_BLOCK_SIZE);
                }
        #endif
                ret = XTRANSFORM(sha256, local);
 8006374:	9803      	ldr	r0, [sp, #12]
 8006376:	f001 f8db 	bl	8007530 <Transform.lto_priv.359>
 800637a:	9007      	str	r0, [sp, #28]
                if (ret != 0) {
 800637c:	9b07      	ldr	r3, [sp, #28]
 800637e:	2b00      	cmp	r3, #0
 8006380:	d109      	bne.n	8006396 <Sha256Update+0xb6>
                    break;
                }

                AddLength(sha256, WC_SHA256_BLOCK_SIZE);
 8006382:	2140      	movs	r1, #64	; 0x40
 8006384:	9803      	ldr	r0, [sp, #12]
 8006386:	f001 fc43 	bl	8007c10 <AddLength.lto_priv.360>
                sha256->buffLen = 0;
 800638a:	9b03      	ldr	r3, [sp, #12]
 800638c:	2200      	movs	r2, #0
 800638e:	661a      	str	r2, [r3, #96]	; 0x60
        while (len) {
 8006390:	9b01      	ldr	r3, [sp, #4]
 8006392:	2b00      	cmp	r3, #0
 8006394:	d1c1      	bne.n	800631a <Sha256Update+0x3a>
            }
        }

        return ret;
 8006396:	9b07      	ldr	r3, [sp, #28]
    }
 8006398:	4618      	mov	r0, r3
 800639a:	b009      	add	sp, #36	; 0x24
 800639c:	f85d fb04 	ldr.w	pc, [sp], #4

080063a0 <wc_Sha256Update>:

    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 80063a0:	b500      	push	{lr}
 80063a2:	b085      	sub	sp, #20
 80063a4:	9003      	str	r0, [sp, #12]
 80063a6:	9102      	str	r1, [sp, #8]
 80063a8:	9201      	str	r2, [sp, #4]
        return Sha256Update(sha256, data, len);
 80063aa:	9a01      	ldr	r2, [sp, #4]
 80063ac:	9902      	ldr	r1, [sp, #8]
 80063ae:	9803      	ldr	r0, [sp, #12]
 80063b0:	f7ff ff96 	bl	80062e0 <Sha256Update>
 80063b4:	4603      	mov	r3, r0
    }
 80063b6:	4618      	mov	r0, r3
 80063b8:	b005      	add	sp, #20
 80063ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80063be:	bf00      	nop

080063c0 <Sha256Final>:

    static INLINE int Sha256Final(wc_Sha256* sha256)
    {
 80063c0:	b500      	push	{lr}
 80063c2:	b085      	sub	sp, #20
 80063c4:	9001      	str	r0, [sp, #4]

        int ret;
        byte* local = (byte*)sha256->buffer;
 80063c6:	9b01      	ldr	r3, [sp, #4]
 80063c8:	3320      	adds	r3, #32
 80063ca:	9303      	str	r3, [sp, #12]

        if (sha256 == NULL) {
 80063cc:	9b01      	ldr	r3, [sp, #4]
 80063ce:	2b00      	cmp	r3, #0
 80063d0:	d102      	bne.n	80063d8 <Sha256Final+0x18>
            return BAD_FUNC_ARG;
 80063d2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80063d6:	e069      	b.n	80064ac <Sha256Final+0xec>
        }

        SAVE_XMM_YMM; /* for Intel AVX */

        AddLength(sha256, sha256->buffLen);  /* before adding pads */
 80063d8:	9b01      	ldr	r3, [sp, #4]
 80063da:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80063dc:	4619      	mov	r1, r3
 80063de:	9801      	ldr	r0, [sp, #4]
 80063e0:	f001 fc16 	bl	8007c10 <AddLength.lto_priv.360>
        local[sha256->buffLen++] = 0x80;     /* add 1 */
 80063e4:	9b01      	ldr	r3, [sp, #4]
 80063e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80063e8:	1c59      	adds	r1, r3, #1
 80063ea:	9a01      	ldr	r2, [sp, #4]
 80063ec:	6611      	str	r1, [r2, #96]	; 0x60
 80063ee:	9a03      	ldr	r2, [sp, #12]
 80063f0:	4413      	add	r3, r2
 80063f2:	2280      	movs	r2, #128	; 0x80
 80063f4:	701a      	strb	r2, [r3, #0]

        /* pad with zeros */
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 80063f6:	9b01      	ldr	r3, [sp, #4]
 80063f8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80063fa:	2b38      	cmp	r3, #56	; 0x38
 80063fc:	d923      	bls.n	8006446 <Sha256Final+0x86>
            XMEMSET(&local[sha256->buffLen], 0,
 80063fe:	9b01      	ldr	r3, [sp, #4]
 8006400:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006402:	9a03      	ldr	r2, [sp, #12]
 8006404:	18d0      	adds	r0, r2, r3
 8006406:	9b01      	ldr	r3, [sp, #4]
 8006408:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800640a:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800640e:	461a      	mov	r2, r3
 8006410:	2100      	movs	r1, #0
 8006412:	f017 f9df 	bl	801d7d4 <memset>
                WC_SHA256_BLOCK_SIZE - sha256->buffLen);
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
 8006416:	9b01      	ldr	r3, [sp, #4]
 8006418:	2240      	movs	r2, #64	; 0x40
 800641a:	661a      	str	r2, [r3, #96]	; 0x60
        #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
            #if defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)
                if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
            #endif
                {
                    ByteReverseWords(sha256->buffer, sha256->buffer,
 800641c:	9b01      	ldr	r3, [sp, #4]
 800641e:	f103 0020 	add.w	r0, r3, #32
 8006422:	9b01      	ldr	r3, [sp, #4]
 8006424:	3320      	adds	r3, #32
 8006426:	2240      	movs	r2, #64	; 0x40
 8006428:	4619      	mov	r1, r3
 800642a:	f000 ffe1 	bl	80073f0 <ByteReverseWords.lto_priv.357>
                                                             WC_SHA256_BLOCK_SIZE);
                }
        #endif
            }

            ret = XTRANSFORM(sha256, local);
 800642e:	9801      	ldr	r0, [sp, #4]
 8006430:	f001 f87e 	bl	8007530 <Transform.lto_priv.359>
 8006434:	9002      	str	r0, [sp, #8]
            if (ret != 0)
 8006436:	9b02      	ldr	r3, [sp, #8]
 8006438:	2b00      	cmp	r3, #0
 800643a:	d001      	beq.n	8006440 <Sha256Final+0x80>
                return ret;
 800643c:	9b02      	ldr	r3, [sp, #8]
 800643e:	e035      	b.n	80064ac <Sha256Final+0xec>

            sha256->buffLen = 0;
 8006440:	9b01      	ldr	r3, [sp, #4]
 8006442:	2200      	movs	r2, #0
 8006444:	661a      	str	r2, [r3, #96]	; 0x60
        }
        XMEMSET(&local[sha256->buffLen], 0, WC_SHA256_PAD_SIZE - sha256->buffLen);
 8006446:	9b01      	ldr	r3, [sp, #4]
 8006448:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800644a:	9a03      	ldr	r2, [sp, #12]
 800644c:	18d0      	adds	r0, r2, r3
 800644e:	9b01      	ldr	r3, [sp, #4]
 8006450:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8006452:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 8006456:	461a      	mov	r2, r3
 8006458:	2100      	movs	r1, #0
 800645a:	f017 f9bb 	bl	801d7d4 <memset>

        /* put lengths in bits */
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 800645e:	9b01      	ldr	r3, [sp, #4]
 8006460:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006462:	0f5a      	lsrs	r2, r3, #29
                                                         (sha256->hiLen << 3);
 8006464:	9b01      	ldr	r3, [sp, #4]
 8006466:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8006468:	00db      	lsls	r3, r3, #3
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 800646a:	441a      	add	r2, r3
 800646c:	9b01      	ldr	r3, [sp, #4]
 800646e:	669a      	str	r2, [r3, #104]	; 0x68
        sha256->loLen = sha256->loLen << 3;
 8006470:	9b01      	ldr	r3, [sp, #4]
 8006472:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006474:	00da      	lsls	r2, r3, #3
 8006476:	9b01      	ldr	r3, [sp, #4]
 8006478:	665a      	str	r2, [r3, #100]	; 0x64
    #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        #if defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)
            if (!IS_INTEL_AVX1(intel_flags) && !IS_INTEL_AVX2(intel_flags))
        #endif
            {
                ByteReverseWords(sha256->buffer, sha256->buffer,
 800647a:	9b01      	ldr	r3, [sp, #4]
 800647c:	f103 0020 	add.w	r0, r3, #32
 8006480:	9b01      	ldr	r3, [sp, #4]
 8006482:	3320      	adds	r3, #32
 8006484:	2240      	movs	r2, #64	; 0x40
 8006486:	4619      	mov	r1, r3
 8006488:	f000 ffb2 	bl	80073f0 <ByteReverseWords.lto_priv.357>
                    WC_SHA256_BLOCK_SIZE);
            }
    #endif
        /* ! length ordering dependent on digest endian type ! */
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 800648c:	9b03      	ldr	r3, [sp, #12]
 800648e:	3338      	adds	r3, #56	; 0x38
 8006490:	9a01      	ldr	r2, [sp, #4]
 8006492:	3268      	adds	r2, #104	; 0x68
 8006494:	6812      	ldr	r2, [r2, #0]
 8006496:	601a      	str	r2, [r3, #0]
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 8006498:	9b03      	ldr	r3, [sp, #12]
 800649a:	333c      	adds	r3, #60	; 0x3c
 800649c:	9a01      	ldr	r2, [sp, #4]
 800649e:	3264      	adds	r2, #100	; 0x64
 80064a0:	6812      	ldr	r2, [r2, #0]
 80064a2:	601a      	str	r2, [r3, #0]
                    &sha256->buffer[WC_SHA256_PAD_SIZE / sizeof(word32)],
                    2 * sizeof(word32));
            }
    #endif

        return XTRANSFORM(sha256, local);
 80064a4:	9801      	ldr	r0, [sp, #4]
 80064a6:	f001 f843 	bl	8007530 <Transform.lto_priv.359>
 80064aa:	4603      	mov	r3, r0
    }
 80064ac:	4618      	mov	r0, r3
 80064ae:	b005      	add	sp, #20
 80064b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080064c0 <wc_Sha256Final>:

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
 80064c0:	b500      	push	{lr}
 80064c2:	b085      	sub	sp, #20
 80064c4:	9001      	str	r0, [sp, #4]
 80064c6:	9100      	str	r1, [sp, #0]
        int ret;

        if (sha256 == NULL || hash == NULL) {
 80064c8:	9b01      	ldr	r3, [sp, #4]
 80064ca:	2b00      	cmp	r3, #0
 80064cc:	d002      	beq.n	80064d4 <wc_Sha256Final+0x14>
 80064ce:	9b00      	ldr	r3, [sp, #0]
 80064d0:	2b00      	cmp	r3, #0
 80064d2:	d102      	bne.n	80064da <wc_Sha256Final+0x1a>
            return BAD_FUNC_ARG;
 80064d4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80064d8:	e018      	b.n	800650c <wc_Sha256Final+0x4c>
                                            WC_SHA256_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
 80064da:	9801      	ldr	r0, [sp, #4]
 80064dc:	f7ff ff70 	bl	80063c0 <Sha256Final>
 80064e0:	9003      	str	r0, [sp, #12]
        if (ret != 0)
 80064e2:	9b03      	ldr	r3, [sp, #12]
 80064e4:	2b00      	cmp	r3, #0
 80064e6:	d001      	beq.n	80064ec <wc_Sha256Final+0x2c>
            return ret;
 80064e8:	9b03      	ldr	r3, [sp, #12]
 80064ea:	e00f      	b.n	800650c <wc_Sha256Final+0x4c>

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
 80064ec:	9b01      	ldr	r3, [sp, #4]
 80064ee:	9901      	ldr	r1, [sp, #4]
 80064f0:	2220      	movs	r2, #32
 80064f2:	4618      	mov	r0, r3
 80064f4:	f000 ff7c 	bl	80073f0 <ByteReverseWords.lto_priv.357>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 80064f8:	9b01      	ldr	r3, [sp, #4]
 80064fa:	2220      	movs	r2, #32
 80064fc:	4619      	mov	r1, r3
 80064fe:	9800      	ldr	r0, [sp, #0]
 8006500:	f7fe f90c 	bl	800471c <memcpy>

        return InitSha256(sha256);  /* reset state */
 8006504:	9801      	ldr	r0, [sp, #4]
 8006506:	f000 ffab 	bl	8007460 <InitSha256.lto_priv.358>
 800650a:	4603      	mov	r3, r0
    }
 800650c:	4618      	mov	r0, r3
 800650e:	b005      	add	sp, #20
 8006510:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006520 <InitSha224>:
    }

#else

    static int InitSha224(wc_Sha224* sha224)
    {
 8006520:	b084      	sub	sp, #16
 8006522:	9001      	str	r0, [sp, #4]
        int ret = 0;
 8006524:	2300      	movs	r3, #0
 8006526:	9303      	str	r3, [sp, #12]

        if (sha224 == NULL) {
 8006528:	9b01      	ldr	r3, [sp, #4]
 800652a:	2b00      	cmp	r3, #0
 800652c:	d102      	bne.n	8006534 <InitSha224+0x14>
            return BAD_FUNC_ARG;
 800652e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006532:	e021      	b.n	8006578 <InitSha224+0x58>
        }

        sha224->digest[0] = 0xc1059ed8;
 8006534:	9b01      	ldr	r3, [sp, #4]
 8006536:	4a12      	ldr	r2, [pc, #72]	; (8006580 <InitSha224+0x60>)
 8006538:	601a      	str	r2, [r3, #0]
        sha224->digest[1] = 0x367cd507;
 800653a:	9b01      	ldr	r3, [sp, #4]
 800653c:	4a11      	ldr	r2, [pc, #68]	; (8006584 <InitSha224+0x64>)
 800653e:	605a      	str	r2, [r3, #4]
        sha224->digest[2] = 0x3070dd17;
 8006540:	9b01      	ldr	r3, [sp, #4]
 8006542:	4a11      	ldr	r2, [pc, #68]	; (8006588 <InitSha224+0x68>)
 8006544:	609a      	str	r2, [r3, #8]
        sha224->digest[3] = 0xf70e5939;
 8006546:	9b01      	ldr	r3, [sp, #4]
 8006548:	4a10      	ldr	r2, [pc, #64]	; (800658c <InitSha224+0x6c>)
 800654a:	60da      	str	r2, [r3, #12]
        sha224->digest[4] = 0xffc00b31;
 800654c:	9b01      	ldr	r3, [sp, #4]
 800654e:	4a10      	ldr	r2, [pc, #64]	; (8006590 <InitSha224+0x70>)
 8006550:	611a      	str	r2, [r3, #16]
        sha224->digest[5] = 0x68581511;
 8006552:	9b01      	ldr	r3, [sp, #4]
 8006554:	4a0f      	ldr	r2, [pc, #60]	; (8006594 <InitSha224+0x74>)
 8006556:	615a      	str	r2, [r3, #20]
        sha224->digest[6] = 0x64f98fa7;
 8006558:	9b01      	ldr	r3, [sp, #4]
 800655a:	4a0f      	ldr	r2, [pc, #60]	; (8006598 <InitSha224+0x78>)
 800655c:	619a      	str	r2, [r3, #24]
        sha224->digest[7] = 0xbefa4fa4;
 800655e:	9b01      	ldr	r3, [sp, #4]
 8006560:	4a0e      	ldr	r2, [pc, #56]	; (800659c <InitSha224+0x7c>)
 8006562:	61da      	str	r2, [r3, #28]

        sha224->buffLen = 0;
 8006564:	9b01      	ldr	r3, [sp, #4]
 8006566:	2200      	movs	r2, #0
 8006568:	661a      	str	r2, [r3, #96]	; 0x60
        sha224->loLen   = 0;
 800656a:	9b01      	ldr	r3, [sp, #4]
 800656c:	2200      	movs	r2, #0
 800656e:	665a      	str	r2, [r3, #100]	; 0x64
        sha224->hiLen   = 0;
 8006570:	9b01      	ldr	r3, [sp, #4]
 8006572:	2200      	movs	r2, #0
 8006574:	669a      	str	r2, [r3, #104]	; 0x68
    #if defined(HAVE_INTEL_AVX1)|| defined(HAVE_INTEL_AVX2)
        /* choose best Transform function under this runtime environment */
        Sha256_SetTransform();
    #endif

        return ret;
 8006576:	9b03      	ldr	r3, [sp, #12]
    }
 8006578:	4618      	mov	r0, r3
 800657a:	b004      	add	sp, #16
 800657c:	4770      	bx	lr
 800657e:	bf00      	nop
 8006580:	c1059ed8 	.word	0xc1059ed8
 8006584:	367cd507 	.word	0x367cd507
 8006588:	3070dd17 	.word	0x3070dd17
 800658c:	f70e5939 	.word	0xf70e5939
 8006590:	ffc00b31 	.word	0xffc00b31
 8006594:	68581511 	.word	0x68581511
 8006598:	64f98fa7 	.word	0x64f98fa7
 800659c:	befa4fa4 	.word	0xbefa4fa4

080065a0 <wc_InitSha224_ex>:

#endif /* STM32_HASH */

    int wc_InitSha224_ex(wc_Sha224* sha224, void* heap, int devId)
    {
 80065a0:	b500      	push	{lr}
 80065a2:	b087      	sub	sp, #28
 80065a4:	9003      	str	r0, [sp, #12]
 80065a6:	9102      	str	r1, [sp, #8]
 80065a8:	9201      	str	r2, [sp, #4]
        int ret = 0;
 80065aa:	2300      	movs	r3, #0
 80065ac:	9305      	str	r3, [sp, #20]

        if (sha224 == NULL)
 80065ae:	9b03      	ldr	r3, [sp, #12]
 80065b0:	2b00      	cmp	r3, #0
 80065b2:	d102      	bne.n	80065ba <wc_InitSha224_ex+0x1a>
            return BAD_FUNC_ARG;
 80065b4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80065b8:	e00c      	b.n	80065d4 <wc_InitSha224_ex+0x34>

        sha224->heap = heap;
 80065ba:	9b03      	ldr	r3, [sp, #12]
 80065bc:	9a02      	ldr	r2, [sp, #8]
 80065be:	66da      	str	r2, [r3, #108]	; 0x6c

        ret = InitSha224(sha224);
 80065c0:	9803      	ldr	r0, [sp, #12]
 80065c2:	f7ff ffad 	bl	8006520 <InitSha224>
 80065c6:	9005      	str	r0, [sp, #20]
        if (ret != 0)
 80065c8:	9b05      	ldr	r3, [sp, #20]
 80065ca:	2b00      	cmp	r3, #0
 80065cc:	d001      	beq.n	80065d2 <wc_InitSha224_ex+0x32>
            return ret;
 80065ce:	9b05      	ldr	r3, [sp, #20]
 80065d0:	e000      	b.n	80065d4 <wc_InitSha224_ex+0x34>
                            WOLFSSL_ASYNC_MARKER_SHA224, sha224->heap, devId);
    #else
        (void)devId;
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return ret;
 80065d2:	9b05      	ldr	r3, [sp, #20]
    }
 80065d4:	4618      	mov	r0, r3
 80065d6:	b007      	add	sp, #28
 80065d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80065dc:	0000      	movs	r0, r0
	...

080065e0 <wc_InitSha224>:

    int wc_InitSha224(wc_Sha224* sha224)
    {
 80065e0:	b500      	push	{lr}
 80065e2:	b083      	sub	sp, #12
 80065e4:	9001      	str	r0, [sp, #4]
        return wc_InitSha224_ex(sha224, NULL, INVALID_DEVID);
 80065e6:	f06f 0201 	mvn.w	r2, #1
 80065ea:	2100      	movs	r1, #0
 80065ec:	9801      	ldr	r0, [sp, #4]
 80065ee:	f7ff ffd7 	bl	80065a0 <wc_InitSha224_ex>
 80065f2:	4603      	mov	r3, r0
    }
 80065f4:	4618      	mov	r0, r3
 80065f6:	b003      	add	sp, #12
 80065f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80065fc:	0000      	movs	r0, r0
	...

08006600 <wc_Sha224Update>:

    int wc_Sha224Update(wc_Sha224* sha224, const byte* data, word32 len)
    {
 8006600:	b500      	push	{lr}
 8006602:	b087      	sub	sp, #28
 8006604:	9003      	str	r0, [sp, #12]
 8006606:	9102      	str	r1, [sp, #8]
 8006608:	9201      	str	r2, [sp, #4]
        int ret;

        if (sha224 == NULL || (data == NULL && len > 0)) {
 800660a:	9b03      	ldr	r3, [sp, #12]
 800660c:	2b00      	cmp	r3, #0
 800660e:	d005      	beq.n	800661c <wc_Sha224Update+0x1c>
 8006610:	9b02      	ldr	r3, [sp, #8]
 8006612:	2b00      	cmp	r3, #0
 8006614:	d105      	bne.n	8006622 <wc_Sha224Update+0x22>
 8006616:	9b01      	ldr	r3, [sp, #4]
 8006618:	2b00      	cmp	r3, #0
 800661a:	d002      	beq.n	8006622 <wc_Sha224Update+0x22>
            return BAD_FUNC_ARG;
 800661c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006620:	e006      	b.n	8006630 <wc_Sha224Update+0x30>
            return IntelQaSymSha224(&sha224->asyncDev, NULL, data, len);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Update((wc_Sha256*)sha224, data, len);
 8006622:	9a01      	ldr	r2, [sp, #4]
 8006624:	9902      	ldr	r1, [sp, #8]
 8006626:	9803      	ldr	r0, [sp, #12]
 8006628:	f7ff fe5a 	bl	80062e0 <Sha256Update>
 800662c:	9005      	str	r0, [sp, #20]

        return ret;
 800662e:	9b05      	ldr	r3, [sp, #20]
    }
 8006630:	4618      	mov	r0, r3
 8006632:	b007      	add	sp, #28
 8006634:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006640 <wc_Sha224Final>:

    int wc_Sha224Final(wc_Sha224* sha224, byte* hash)
    {
 8006640:	b500      	push	{lr}
 8006642:	b085      	sub	sp, #20
 8006644:	9001      	str	r0, [sp, #4]
 8006646:	9100      	str	r1, [sp, #0]
        int ret;

        if (sha224 == NULL || hash == NULL) {
 8006648:	9b01      	ldr	r3, [sp, #4]
 800664a:	2b00      	cmp	r3, #0
 800664c:	d002      	beq.n	8006654 <wc_Sha224Final+0x14>
 800664e:	9b00      	ldr	r3, [sp, #0]
 8006650:	2b00      	cmp	r3, #0
 8006652:	d102      	bne.n	800665a <wc_Sha224Final+0x1a>
            return BAD_FUNC_ARG;
 8006654:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8006658:	e018      	b.n	800668c <wc_Sha224Final+0x4c>
                                            WC_SHA224_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final((wc_Sha256*)sha224);
 800665a:	9801      	ldr	r0, [sp, #4]
 800665c:	f7ff feb0 	bl	80063c0 <Sha256Final>
 8006660:	9003      	str	r0, [sp, #12]
        if (ret != 0)
 8006662:	9b03      	ldr	r3, [sp, #12]
 8006664:	2b00      	cmp	r3, #0
 8006666:	d001      	beq.n	800666c <wc_Sha224Final+0x2c>
            return ret;
 8006668:	9b03      	ldr	r3, [sp, #12]
 800666a:	e00f      	b.n	800668c <wc_Sha224Final+0x4c>

    #if defined(LITTLE_ENDIAN_ORDER) && !defined(STM32_HASH)
        ByteReverseWords(sha224->digest, sha224->digest, WC_SHA224_DIGEST_SIZE);
 800666c:	9b01      	ldr	r3, [sp, #4]
 800666e:	9901      	ldr	r1, [sp, #4]
 8006670:	221c      	movs	r2, #28
 8006672:	4618      	mov	r0, r3
 8006674:	f000 febc 	bl	80073f0 <ByteReverseWords.lto_priv.357>
    #endif
        XMEMCPY(hash, sha224->digest, WC_SHA224_DIGEST_SIZE);
 8006678:	9b01      	ldr	r3, [sp, #4]
 800667a:	221c      	movs	r2, #28
 800667c:	4619      	mov	r1, r3
 800667e:	9800      	ldr	r0, [sp, #0]
 8006680:	f7fe f84c 	bl	800471c <memcpy>

        return InitSha224(sha224);  /* reset state */
 8006684:	9801      	ldr	r0, [sp, #4]
 8006686:	f7ff ff4b 	bl	8006520 <InitSha224>
 800668a:	4603      	mov	r3, r0
    }
 800668c:	4618      	mov	r0, r3
 800668e:	b005      	add	sp, #20
 8006690:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080066a0 <wc_InitSha256>:

#endif /* WOLFSSL_SHA224 */


int wc_InitSha256(wc_Sha256* sha256)
{
 80066a0:	b500      	push	{lr}
 80066a2:	b083      	sub	sp, #12
 80066a4:	9001      	str	r0, [sp, #4]
    return wc_InitSha256_ex(sha256, NULL, INVALID_DEVID);
 80066a6:	f06f 0201 	mvn.w	r2, #1
 80066aa:	2100      	movs	r1, #0
 80066ac:	9801      	ldr	r0, [sp, #4]
 80066ae:	f000 ff1f 	bl	80074f0 <wc_InitSha256_ex>
 80066b2:	4603      	mov	r3, r0
}
 80066b4:	4618      	mov	r0, r3
 80066b6:	b003      	add	sp, #12
 80066b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80066bc:	0000      	movs	r0, r0
	...

080066c0 <wc_Sha256Free>:

void wc_Sha256Free(wc_Sha256* sha256)
{
 80066c0:	b082      	sub	sp, #8
 80066c2:	9001      	str	r0, [sp, #4]
        return;

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA256)
    wolfAsync_DevCtxFree(&sha256->asyncDev, WOLFSSL_ASYNC_MARKER_SHA256);
#endif /* WOLFSSL_ASYNC_CRYPT */
}
 80066c4:	b002      	add	sp, #8
 80066c6:	4770      	bx	lr
	...

080066d0 <mp_set_int>:

#ifndef MP_SET_CHUNK_BITS
    #define MP_SET_CHUNK_BITS 4
#endif
int mp_set_int (mp_int * a, unsigned long b)
{
 80066d0:	b500      	push	{lr}
 80066d2:	b085      	sub	sp, #20
 80066d4:	9001      	str	r0, [sp, #4]
 80066d6:	9100      	str	r1, [sp, #0]
  int x, res;

  /* use direct mp_set if b is less than mp_digit max */
  if (b < MP_DIGIT_MAX) {
 80066d8:	9b00      	ldr	r3, [sp, #0]
 80066da:	4a1c      	ldr	r2, [pc, #112]	; (800674c <mp_set_int+0x7c>)
 80066dc:	4293      	cmp	r3, r2
 80066de:	d805      	bhi.n	80066ec <mp_set_int+0x1c>
    return mp_set (a, (mp_digit)b);
 80066e0:	9900      	ldr	r1, [sp, #0]
 80066e2:	9801      	ldr	r0, [sp, #4]
 80066e4:	f005 fa54 	bl	800bb90 <mp_set>
 80066e8:	4603      	mov	r3, r0
 80066ea:	e02b      	b.n	8006744 <mp_set_int+0x74>
  }

  mp_zero (a);
 80066ec:	9801      	ldr	r0, [sp, #4]
 80066ee:	f004 fa3f 	bl	800ab70 <mp_zero>

  /* set chunk bits at a time */
  for (x = 0; x < (int)(sizeof(b) * 8) / MP_SET_CHUNK_BITS; x++) {
 80066f2:	2300      	movs	r3, #0
 80066f4:	9303      	str	r3, [sp, #12]
 80066f6:	e01e      	b.n	8006736 <mp_set_int+0x66>
    /* shift the number up chunk bits */
    if ((res = mp_mul_2d (a, MP_SET_CHUNK_BITS, a)) != MP_OKAY) {
 80066f8:	9a01      	ldr	r2, [sp, #4]
 80066fa:	2104      	movs	r1, #4
 80066fc:	9801      	ldr	r0, [sp, #4]
 80066fe:	f004 fbf7 	bl	800aef0 <mp_mul_2d>
 8006702:	9002      	str	r0, [sp, #8]
 8006704:	9b02      	ldr	r3, [sp, #8]
 8006706:	2b00      	cmp	r3, #0
 8006708:	d001      	beq.n	800670e <mp_set_int+0x3e>
      return res;
 800670a:	9b02      	ldr	r3, [sp, #8]
 800670c:	e01a      	b.n	8006744 <mp_set_int+0x74>
    }

    /* OR in the top bits of the source */
    a->dp[0] |= (b >> ((sizeof(b) * 8) - MP_SET_CHUNK_BITS)) &
 800670e:	9b01      	ldr	r3, [sp, #4]
 8006710:	68db      	ldr	r3, [r3, #12]
 8006712:	9a01      	ldr	r2, [sp, #4]
 8006714:	68d2      	ldr	r2, [r2, #12]
 8006716:	6811      	ldr	r1, [r2, #0]
 8006718:	9a00      	ldr	r2, [sp, #0]
 800671a:	0f12      	lsrs	r2, r2, #28
 800671c:	430a      	orrs	r2, r1
 800671e:	601a      	str	r2, [r3, #0]
                                  ((1 << MP_SET_CHUNK_BITS) - 1);

    /* shift the source up to the next chunk bits */
    b <<= MP_SET_CHUNK_BITS;
 8006720:	9b00      	ldr	r3, [sp, #0]
 8006722:	011b      	lsls	r3, r3, #4
 8006724:	9300      	str	r3, [sp, #0]

    /* ensure that digits are not clamped off */
    a->used += 1;
 8006726:	9b01      	ldr	r3, [sp, #4]
 8006728:	681b      	ldr	r3, [r3, #0]
 800672a:	1c5a      	adds	r2, r3, #1
 800672c:	9b01      	ldr	r3, [sp, #4]
 800672e:	601a      	str	r2, [r3, #0]
  for (x = 0; x < (int)(sizeof(b) * 8) / MP_SET_CHUNK_BITS; x++) {
 8006730:	9b03      	ldr	r3, [sp, #12]
 8006732:	3301      	adds	r3, #1
 8006734:	9303      	str	r3, [sp, #12]
 8006736:	9b03      	ldr	r3, [sp, #12]
 8006738:	2b07      	cmp	r3, #7
 800673a:	dddd      	ble.n	80066f8 <mp_set_int+0x28>
  }
  mp_clamp (a);
 800673c:	9801      	ldr	r0, [sp, #4]
 800673e:	f004 fa37 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8006742:	2300      	movs	r3, #0
}
 8006744:	4618      	mov	r0, r3
 8006746:	b005      	add	sp, #20
 8006748:	f85d fb04 	ldr.w	pc, [sp], #4
 800674c:	0ffffffe 	.word	0x0ffffffe

08006750 <mp_sqrmod>:

#if defined(WOLFSSL_KEY_GEN) || defined(HAVE_ECC)

/* c = a * a (mod b) */
int mp_sqrmod (mp_int * a, mp_int * b, mp_int * c)
{
 8006750:	b500      	push	{lr}
 8006752:	b08b      	sub	sp, #44	; 0x2c
 8006754:	9003      	str	r0, [sp, #12]
 8006756:	9102      	str	r1, [sp, #8]
 8006758:	9201      	str	r2, [sp, #4]
  int     res;
  mp_int  t;

  if ((res = mp_init (&t)) != MP_OKAY) {
 800675a:	ab05      	add	r3, sp, #20
 800675c:	4618      	mov	r0, r3
 800675e:	f003 ff4f 	bl	800a600 <mp_init>
 8006762:	9009      	str	r0, [sp, #36]	; 0x24
 8006764:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006766:	2b00      	cmp	r3, #0
 8006768:	d001      	beq.n	800676e <mp_sqrmod+0x1e>
    return res;
 800676a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800676c:	e01a      	b.n	80067a4 <mp_sqrmod+0x54>
  }

  if ((res = mp_sqr (a, &t)) != MP_OKAY) {
 800676e:	ab05      	add	r3, sp, #20
 8006770:	4619      	mov	r1, r3
 8006772:	9803      	ldr	r0, [sp, #12]
 8006774:	f002 fc5c 	bl	8009030 <mp_sqr>
 8006778:	9009      	str	r0, [sp, #36]	; 0x24
 800677a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800677c:	2b00      	cmp	r3, #0
 800677e:	d005      	beq.n	800678c <mp_sqrmod+0x3c>
    mp_clear (&t);
 8006780:	ab05      	add	r3, sp, #20
 8006782:	4618      	mov	r0, r3
 8006784:	f003 ff54 	bl	800a630 <mp_clear>
    return res;
 8006788:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800678a:	e00b      	b.n	80067a4 <mp_sqrmod+0x54>
  }
  res = mp_mod (&t, b, c);
 800678c:	ab05      	add	r3, sp, #20
 800678e:	9a01      	ldr	r2, [sp, #4]
 8006790:	9902      	ldr	r1, [sp, #8]
 8006792:	4618      	mov	r0, r3
 8006794:	f005 fa24 	bl	800bbe0 <mp_mod>
 8006798:	9009      	str	r0, [sp, #36]	; 0x24
  mp_clear (&t);
 800679a:	ab05      	add	r3, sp, #20
 800679c:	4618      	mov	r0, r3
 800679e:	f003 ff47 	bl	800a630 <mp_clear>
  return res;
 80067a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 80067a4:	4618      	mov	r0, r3
 80067a6:	b00b      	add	sp, #44	; 0x2c
 80067a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80067ac:	0000      	movs	r0, r0
	...

080067b0 <mp_add_d>:
    defined(WOLFSSL_HAVE_WOLFSCEP) || defined(WOLFSSL_KEY_GEN) || \
    defined(OPENSSL_EXTRA) || defined(WC_RSA_BLINDING)

/* single digit addition */
int mp_add_d (mp_int* a, mp_digit b, mp_int* c)
{
 80067b0:	b500      	push	{lr}
 80067b2:	b08b      	sub	sp, #44	; 0x2c
 80067b4:	9003      	str	r0, [sp, #12]
 80067b6:	9102      	str	r1, [sp, #8]
 80067b8:	9201      	str	r2, [sp, #4]
  int     res, ix, oldused;
  mp_digit *tmpa, *tmpc, mu;

  /* grow c as required */
  if (c->alloc < a->used + 1) {
 80067ba:	9b01      	ldr	r3, [sp, #4]
 80067bc:	685a      	ldr	r2, [r3, #4]
 80067be:	9b03      	ldr	r3, [sp, #12]
 80067c0:	681b      	ldr	r3, [r3, #0]
 80067c2:	3301      	adds	r3, #1
 80067c4:	429a      	cmp	r2, r3
 80067c6:	da0c      	bge.n	80067e2 <mp_add_d+0x32>
     if ((res = mp_grow(c, a->used + 1)) != MP_OKAY) {
 80067c8:	9b03      	ldr	r3, [sp, #12]
 80067ca:	681b      	ldr	r3, [r3, #0]
 80067cc:	3301      	adds	r3, #1
 80067ce:	4619      	mov	r1, r3
 80067d0:	9801      	ldr	r0, [sp, #4]
 80067d2:	f004 f90d 	bl	800a9f0 <mp_grow>
 80067d6:	9005      	str	r0, [sp, #20]
 80067d8:	9b05      	ldr	r3, [sp, #20]
 80067da:	2b00      	cmp	r3, #0
 80067dc:	d001      	beq.n	80067e2 <mp_add_d+0x32>
        return res;
 80067de:	9b05      	ldr	r3, [sp, #20]
 80067e0:	e09e      	b.n	8006920 <mp_add_d+0x170>
     }
  }

  /* if a is negative and |a| >= b, call c = |a| - b */
  if (a->sign == MP_NEG && (a->used > 1 || a->dp[0] >= b)) {
 80067e2:	9b03      	ldr	r3, [sp, #12]
 80067e4:	689b      	ldr	r3, [r3, #8]
 80067e6:	2b01      	cmp	r3, #1
 80067e8:	d11e      	bne.n	8006828 <mp_add_d+0x78>
 80067ea:	9b03      	ldr	r3, [sp, #12]
 80067ec:	681b      	ldr	r3, [r3, #0]
 80067ee:	2b01      	cmp	r3, #1
 80067f0:	dc05      	bgt.n	80067fe <mp_add_d+0x4e>
 80067f2:	9b03      	ldr	r3, [sp, #12]
 80067f4:	68db      	ldr	r3, [r3, #12]
 80067f6:	681a      	ldr	r2, [r3, #0]
 80067f8:	9b02      	ldr	r3, [sp, #8]
 80067fa:	429a      	cmp	r2, r3
 80067fc:	d314      	bcc.n	8006828 <mp_add_d+0x78>
     /* temporarily fix sign of a */
     a->sign = MP_ZPOS;
 80067fe:	9b03      	ldr	r3, [sp, #12]
 8006800:	2200      	movs	r2, #0
 8006802:	609a      	str	r2, [r3, #8]

     /* c = |a| - b */
     res = mp_sub_d(a, b, c);
 8006804:	9a01      	ldr	r2, [sp, #4]
 8006806:	9902      	ldr	r1, [sp, #8]
 8006808:	9803      	ldr	r0, [sp, #12]
 800680a:	f000 f891 	bl	8006930 <mp_sub_d>
 800680e:	9005      	str	r0, [sp, #20]

     /* fix sign  */
     a->sign = c->sign = MP_NEG;
 8006810:	9b01      	ldr	r3, [sp, #4]
 8006812:	2201      	movs	r2, #1
 8006814:	609a      	str	r2, [r3, #8]
 8006816:	9b01      	ldr	r3, [sp, #4]
 8006818:	689a      	ldr	r2, [r3, #8]
 800681a:	9b03      	ldr	r3, [sp, #12]
 800681c:	609a      	str	r2, [r3, #8]

     /* clamp */
     mp_clamp(c);
 800681e:	9801      	ldr	r0, [sp, #4]
 8006820:	f004 f9c6 	bl	800abb0 <mp_clamp>

     return res;
 8006824:	9b05      	ldr	r3, [sp, #20]
 8006826:	e07b      	b.n	8006920 <mp_add_d+0x170>
  }

  /* old number of used digits in c */
  oldused = c->used;
 8006828:	9b01      	ldr	r3, [sp, #4]
 800682a:	681b      	ldr	r3, [r3, #0]
 800682c:	9304      	str	r3, [sp, #16]

  /* sign always positive */
  c->sign = MP_ZPOS;
 800682e:	9b01      	ldr	r3, [sp, #4]
 8006830:	2200      	movs	r2, #0
 8006832:	609a      	str	r2, [r3, #8]

  /* source alias */
  tmpa    = a->dp;
 8006834:	9b03      	ldr	r3, [sp, #12]
 8006836:	68db      	ldr	r3, [r3, #12]
 8006838:	9308      	str	r3, [sp, #32]

  /* destination alias */
  tmpc    = c->dp;
 800683a:	9b01      	ldr	r3, [sp, #4]
 800683c:	68db      	ldr	r3, [r3, #12]
 800683e:	9307      	str	r3, [sp, #28]

  /* if a is positive */
  if (a->sign == MP_ZPOS) {
 8006840:	9b03      	ldr	r3, [sp, #12]
 8006842:	689b      	ldr	r3, [r3, #8]
 8006844:	2b00      	cmp	r3, #0
 8006846:	d143      	bne.n	80068d0 <mp_add_d+0x120>
     /* add digit, after this we're propagating
      * the carry.
      */
     *tmpc   = *tmpa++ + b;
 8006848:	9b08      	ldr	r3, [sp, #32]
 800684a:	1d1a      	adds	r2, r3, #4
 800684c:	9208      	str	r2, [sp, #32]
 800684e:	681a      	ldr	r2, [r3, #0]
 8006850:	9b02      	ldr	r3, [sp, #8]
 8006852:	441a      	add	r2, r3
 8006854:	9b07      	ldr	r3, [sp, #28]
 8006856:	601a      	str	r2, [r3, #0]
     mu      = *tmpc >> DIGIT_BIT;
 8006858:	9b07      	ldr	r3, [sp, #28]
 800685a:	681b      	ldr	r3, [r3, #0]
 800685c:	0f1b      	lsrs	r3, r3, #28
 800685e:	9306      	str	r3, [sp, #24]
     *tmpc++ &= MP_MASK;
 8006860:	9b07      	ldr	r3, [sp, #28]
 8006862:	1d1a      	adds	r2, r3, #4
 8006864:	9207      	str	r2, [sp, #28]
 8006866:	681a      	ldr	r2, [r3, #0]
 8006868:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800686c:	601a      	str	r2, [r3, #0]

     /* now handle rest of the digits */
     for (ix = 1; ix < a->used; ix++) {
 800686e:	2301      	movs	r3, #1
 8006870:	9309      	str	r3, [sp, #36]	; 0x24
 8006872:	e015      	b.n	80068a0 <mp_add_d+0xf0>
        *tmpc   = *tmpa++ + mu;
 8006874:	9b08      	ldr	r3, [sp, #32]
 8006876:	1d1a      	adds	r2, r3, #4
 8006878:	9208      	str	r2, [sp, #32]
 800687a:	681a      	ldr	r2, [r3, #0]
 800687c:	9b06      	ldr	r3, [sp, #24]
 800687e:	441a      	add	r2, r3
 8006880:	9b07      	ldr	r3, [sp, #28]
 8006882:	601a      	str	r2, [r3, #0]
        mu      = *tmpc >> DIGIT_BIT;
 8006884:	9b07      	ldr	r3, [sp, #28]
 8006886:	681b      	ldr	r3, [r3, #0]
 8006888:	0f1b      	lsrs	r3, r3, #28
 800688a:	9306      	str	r3, [sp, #24]
        *tmpc++ &= MP_MASK;
 800688c:	9b07      	ldr	r3, [sp, #28]
 800688e:	1d1a      	adds	r2, r3, #4
 8006890:	9207      	str	r2, [sp, #28]
 8006892:	681a      	ldr	r2, [r3, #0]
 8006894:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8006898:	601a      	str	r2, [r3, #0]
     for (ix = 1; ix < a->used; ix++) {
 800689a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800689c:	3301      	adds	r3, #1
 800689e:	9309      	str	r3, [sp, #36]	; 0x24
 80068a0:	9b03      	ldr	r3, [sp, #12]
 80068a2:	681a      	ldr	r2, [r3, #0]
 80068a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80068a6:	429a      	cmp	r2, r3
 80068a8:	dce4      	bgt.n	8006874 <mp_add_d+0xc4>
     }
     /* set final carry */
     if (ix < c->alloc) {
 80068aa:	9b01      	ldr	r3, [sp, #4]
 80068ac:	685a      	ldr	r2, [r3, #4]
 80068ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80068b0:	429a      	cmp	r2, r3
 80068b2:	dd07      	ble.n	80068c4 <mp_add_d+0x114>
        ix++;
 80068b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80068b6:	3301      	adds	r3, #1
 80068b8:	9309      	str	r3, [sp, #36]	; 0x24
        *tmpc++  = mu;
 80068ba:	9b07      	ldr	r3, [sp, #28]
 80068bc:	1d1a      	adds	r2, r3, #4
 80068be:	9207      	str	r2, [sp, #28]
 80068c0:	9a06      	ldr	r2, [sp, #24]
 80068c2:	601a      	str	r2, [r3, #0]
     }

     /* setup size */
     c->used = a->used + 1;
 80068c4:	9b03      	ldr	r3, [sp, #12]
 80068c6:	681b      	ldr	r3, [r3, #0]
 80068c8:	1c5a      	adds	r2, r3, #1
 80068ca:	9b01      	ldr	r3, [sp, #4]
 80068cc:	601a      	str	r2, [r3, #0]
 80068ce:	e01d      	b.n	800690c <mp_add_d+0x15c>
  } else {
     /* a was negative and |a| < b */
     c->used  = 1;
 80068d0:	9b01      	ldr	r3, [sp, #4]
 80068d2:	2201      	movs	r2, #1
 80068d4:	601a      	str	r2, [r3, #0]

     /* the result is a single digit */
     if (a->used == 1) {
 80068d6:	9b03      	ldr	r3, [sp, #12]
 80068d8:	681b      	ldr	r3, [r3, #0]
 80068da:	2b01      	cmp	r3, #1
 80068dc:	d109      	bne.n	80068f2 <mp_add_d+0x142>
        *tmpc++  =  b - a->dp[0];
 80068de:	9b07      	ldr	r3, [sp, #28]
 80068e0:	1d1a      	adds	r2, r3, #4
 80068e2:	9207      	str	r2, [sp, #28]
 80068e4:	9a03      	ldr	r2, [sp, #12]
 80068e6:	68d2      	ldr	r2, [r2, #12]
 80068e8:	6812      	ldr	r2, [r2, #0]
 80068ea:	9902      	ldr	r1, [sp, #8]
 80068ec:	1a8a      	subs	r2, r1, r2
 80068ee:	601a      	str	r2, [r3, #0]
 80068f0:	e004      	b.n	80068fc <mp_add_d+0x14c>
     } else {
        *tmpc++  =  b;
 80068f2:	9b07      	ldr	r3, [sp, #28]
 80068f4:	1d1a      	adds	r2, r3, #4
 80068f6:	9207      	str	r2, [sp, #28]
 80068f8:	9a02      	ldr	r2, [sp, #8]
 80068fa:	601a      	str	r2, [r3, #0]
     }

     /* setup count so the clearing of oldused
      * can fall through correctly
      */
     ix       = 1;
 80068fc:	2301      	movs	r3, #1
 80068fe:	9309      	str	r3, [sp, #36]	; 0x24
 8006900:	e004      	b.n	800690c <mp_add_d+0x15c>
  }

  /* now zero to oldused */
  while (ix++ < oldused) {
     *tmpc++ = 0;
 8006902:	9b07      	ldr	r3, [sp, #28]
 8006904:	1d1a      	adds	r2, r3, #4
 8006906:	9207      	str	r2, [sp, #28]
 8006908:	2200      	movs	r2, #0
 800690a:	601a      	str	r2, [r3, #0]
  while (ix++ < oldused) {
 800690c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800690e:	1c5a      	adds	r2, r3, #1
 8006910:	9209      	str	r2, [sp, #36]	; 0x24
 8006912:	9a04      	ldr	r2, [sp, #16]
 8006914:	4293      	cmp	r3, r2
 8006916:	dbf4      	blt.n	8006902 <mp_add_d+0x152>
  }
  mp_clamp(c);
 8006918:	9801      	ldr	r0, [sp, #4]
 800691a:	f004 f949 	bl	800abb0 <mp_clamp>

  return MP_OKAY;
 800691e:	2300      	movs	r3, #0
}
 8006920:	4618      	mov	r0, r3
 8006922:	b00b      	add	sp, #44	; 0x2c
 8006924:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006930 <mp_sub_d>:


/* single digit subtraction */
int mp_sub_d (mp_int * a, mp_digit b, mp_int * c)
{
 8006930:	b500      	push	{lr}
 8006932:	b08b      	sub	sp, #44	; 0x2c
 8006934:	9003      	str	r0, [sp, #12]
 8006936:	9102      	str	r1, [sp, #8]
 8006938:	9201      	str	r2, [sp, #4]
  mp_digit *tmpa, *tmpc, mu;
  int       res, ix, oldused;

  /* grow c as required */
  if (c->alloc < a->used + 1) {
 800693a:	9b01      	ldr	r3, [sp, #4]
 800693c:	685a      	ldr	r2, [r3, #4]
 800693e:	9b03      	ldr	r3, [sp, #12]
 8006940:	681b      	ldr	r3, [r3, #0]
 8006942:	3301      	adds	r3, #1
 8006944:	429a      	cmp	r2, r3
 8006946:	da0c      	bge.n	8006962 <mp_sub_d+0x32>
     if ((res = mp_grow(c, a->used + 1)) != MP_OKAY) {
 8006948:	9b03      	ldr	r3, [sp, #12]
 800694a:	681b      	ldr	r3, [r3, #0]
 800694c:	3301      	adds	r3, #1
 800694e:	4619      	mov	r1, r3
 8006950:	9801      	ldr	r0, [sp, #4]
 8006952:	f004 f84d 	bl	800a9f0 <mp_grow>
 8006956:	9005      	str	r0, [sp, #20]
 8006958:	9b05      	ldr	r3, [sp, #20]
 800695a:	2b00      	cmp	r3, #0
 800695c:	d001      	beq.n	8006962 <mp_sub_d+0x32>
        return res;
 800695e:	9b05      	ldr	r3, [sp, #20]
 8006960:	e092      	b.n	8006a88 <mp_sub_d+0x158>
  }

  /* if a is negative just do an unsigned
   * addition [with fudged signs]
   */
  if (a->sign == MP_NEG) {
 8006962:	9b03      	ldr	r3, [sp, #12]
 8006964:	689b      	ldr	r3, [r3, #8]
 8006966:	2b01      	cmp	r3, #1
 8006968:	d114      	bne.n	8006994 <mp_sub_d+0x64>
     a->sign = MP_ZPOS;
 800696a:	9b03      	ldr	r3, [sp, #12]
 800696c:	2200      	movs	r2, #0
 800696e:	609a      	str	r2, [r3, #8]
     res     = mp_add_d(a, b, c);
 8006970:	9a01      	ldr	r2, [sp, #4]
 8006972:	9902      	ldr	r1, [sp, #8]
 8006974:	9803      	ldr	r0, [sp, #12]
 8006976:	f7ff ff1b 	bl	80067b0 <mp_add_d>
 800697a:	9005      	str	r0, [sp, #20]
     a->sign = c->sign = MP_NEG;
 800697c:	9b01      	ldr	r3, [sp, #4]
 800697e:	2201      	movs	r2, #1
 8006980:	609a      	str	r2, [r3, #8]
 8006982:	9b01      	ldr	r3, [sp, #4]
 8006984:	689a      	ldr	r2, [r3, #8]
 8006986:	9b03      	ldr	r3, [sp, #12]
 8006988:	609a      	str	r2, [r3, #8]

     /* clamp */
     mp_clamp(c);
 800698a:	9801      	ldr	r0, [sp, #4]
 800698c:	f004 f910 	bl	800abb0 <mp_clamp>

     return res;
 8006990:	9b05      	ldr	r3, [sp, #20]
 8006992:	e079      	b.n	8006a88 <mp_sub_d+0x158>
  }

  /* setup regs */
  oldused = c->used;
 8006994:	9b01      	ldr	r3, [sp, #4]
 8006996:	681b      	ldr	r3, [r3, #0]
 8006998:	9304      	str	r3, [sp, #16]
  tmpa    = a->dp;
 800699a:	9b03      	ldr	r3, [sp, #12]
 800699c:	68db      	ldr	r3, [r3, #12]
 800699e:	9309      	str	r3, [sp, #36]	; 0x24
  tmpc    = c->dp;
 80069a0:	9b01      	ldr	r3, [sp, #4]
 80069a2:	68db      	ldr	r3, [r3, #12]
 80069a4:	9308      	str	r3, [sp, #32]

  /* if a <= b simply fix the single digit */
  if ((a->used == 1 && a->dp[0] <= b) || a->used == 0) {
 80069a6:	9b03      	ldr	r3, [sp, #12]
 80069a8:	681b      	ldr	r3, [r3, #0]
 80069aa:	2b01      	cmp	r3, #1
 80069ac:	d105      	bne.n	80069ba <mp_sub_d+0x8a>
 80069ae:	9b03      	ldr	r3, [sp, #12]
 80069b0:	68db      	ldr	r3, [r3, #12]
 80069b2:	681a      	ldr	r2, [r3, #0]
 80069b4:	9b02      	ldr	r3, [sp, #8]
 80069b6:	429a      	cmp	r2, r3
 80069b8:	d903      	bls.n	80069c2 <mp_sub_d+0x92>
 80069ba:	9b03      	ldr	r3, [sp, #12]
 80069bc:	681b      	ldr	r3, [r3, #0]
 80069be:	2b00      	cmp	r3, #0
 80069c0:	d11a      	bne.n	80069f8 <mp_sub_d+0xc8>
     if (a->used == 1) {
 80069c2:	9b03      	ldr	r3, [sp, #12]
 80069c4:	681b      	ldr	r3, [r3, #0]
 80069c6:	2b01      	cmp	r3, #1
 80069c8:	d108      	bne.n	80069dc <mp_sub_d+0xac>
        *tmpc++ = b - *tmpa;
 80069ca:	9b08      	ldr	r3, [sp, #32]
 80069cc:	1d1a      	adds	r2, r3, #4
 80069ce:	9208      	str	r2, [sp, #32]
 80069d0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80069d2:	6812      	ldr	r2, [r2, #0]
 80069d4:	9902      	ldr	r1, [sp, #8]
 80069d6:	1a8a      	subs	r2, r1, r2
 80069d8:	601a      	str	r2, [r3, #0]
 80069da:	e004      	b.n	80069e6 <mp_sub_d+0xb6>
     } else {
        *tmpc++ = b;
 80069dc:	9b08      	ldr	r3, [sp, #32]
 80069de:	1d1a      	adds	r2, r3, #4
 80069e0:	9208      	str	r2, [sp, #32]
 80069e2:	9a02      	ldr	r2, [sp, #8]
 80069e4:	601a      	str	r2, [r3, #0]
     }
     ix      = 1;
 80069e6:	2301      	movs	r3, #1
 80069e8:	9306      	str	r3, [sp, #24]

     /* negative/1digit */
     c->sign = MP_NEG;
 80069ea:	9b01      	ldr	r3, [sp, #4]
 80069ec:	2201      	movs	r2, #1
 80069ee:	609a      	str	r2, [r3, #8]
     c->used = 1;
 80069f0:	9b01      	ldr	r3, [sp, #4]
 80069f2:	2201      	movs	r2, #1
 80069f4:	601a      	str	r2, [r3, #0]
 80069f6:	e03d      	b.n	8006a74 <mp_sub_d+0x144>
  } else {
     /* positive/size */
     c->sign = MP_ZPOS;
 80069f8:	9b01      	ldr	r3, [sp, #4]
 80069fa:	2200      	movs	r2, #0
 80069fc:	609a      	str	r2, [r3, #8]
     c->used = a->used;
 80069fe:	9b03      	ldr	r3, [sp, #12]
 8006a00:	681a      	ldr	r2, [r3, #0]
 8006a02:	9b01      	ldr	r3, [sp, #4]
 8006a04:	601a      	str	r2, [r3, #0]

     /* subtract first digit */
     *tmpc    = *tmpa++ - b;
 8006a06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006a08:	1d1a      	adds	r2, r3, #4
 8006a0a:	9209      	str	r2, [sp, #36]	; 0x24
 8006a0c:	681a      	ldr	r2, [r3, #0]
 8006a0e:	9b02      	ldr	r3, [sp, #8]
 8006a10:	1ad2      	subs	r2, r2, r3
 8006a12:	9b08      	ldr	r3, [sp, #32]
 8006a14:	601a      	str	r2, [r3, #0]
     mu       = *tmpc >> (sizeof(mp_digit) * CHAR_BIT - 1);
 8006a16:	9b08      	ldr	r3, [sp, #32]
 8006a18:	681b      	ldr	r3, [r3, #0]
 8006a1a:	0fdb      	lsrs	r3, r3, #31
 8006a1c:	9307      	str	r3, [sp, #28]
     *tmpc++ &= MP_MASK;
 8006a1e:	9b08      	ldr	r3, [sp, #32]
 8006a20:	1d1a      	adds	r2, r3, #4
 8006a22:	9208      	str	r2, [sp, #32]
 8006a24:	681a      	ldr	r2, [r3, #0]
 8006a26:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8006a2a:	601a      	str	r2, [r3, #0]

     /* handle rest of the digits */
     for (ix = 1; ix < a->used; ix++) {
 8006a2c:	2301      	movs	r3, #1
 8006a2e:	9306      	str	r3, [sp, #24]
 8006a30:	e015      	b.n	8006a5e <mp_sub_d+0x12e>
        *tmpc    = *tmpa++ - mu;
 8006a32:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006a34:	1d1a      	adds	r2, r3, #4
 8006a36:	9209      	str	r2, [sp, #36]	; 0x24
 8006a38:	681a      	ldr	r2, [r3, #0]
 8006a3a:	9b07      	ldr	r3, [sp, #28]
 8006a3c:	1ad2      	subs	r2, r2, r3
 8006a3e:	9b08      	ldr	r3, [sp, #32]
 8006a40:	601a      	str	r2, [r3, #0]
        mu       = *tmpc >> (sizeof(mp_digit) * CHAR_BIT - 1);
 8006a42:	9b08      	ldr	r3, [sp, #32]
 8006a44:	681b      	ldr	r3, [r3, #0]
 8006a46:	0fdb      	lsrs	r3, r3, #31
 8006a48:	9307      	str	r3, [sp, #28]
        *tmpc++ &= MP_MASK;
 8006a4a:	9b08      	ldr	r3, [sp, #32]
 8006a4c:	1d1a      	adds	r2, r3, #4
 8006a4e:	9208      	str	r2, [sp, #32]
 8006a50:	681a      	ldr	r2, [r3, #0]
 8006a52:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8006a56:	601a      	str	r2, [r3, #0]
     for (ix = 1; ix < a->used; ix++) {
 8006a58:	9b06      	ldr	r3, [sp, #24]
 8006a5a:	3301      	adds	r3, #1
 8006a5c:	9306      	str	r3, [sp, #24]
 8006a5e:	9b03      	ldr	r3, [sp, #12]
 8006a60:	681a      	ldr	r2, [r3, #0]
 8006a62:	9b06      	ldr	r3, [sp, #24]
 8006a64:	429a      	cmp	r2, r3
 8006a66:	dce4      	bgt.n	8006a32 <mp_sub_d+0x102>
 8006a68:	e004      	b.n	8006a74 <mp_sub_d+0x144>
     }
  }

  /* zero excess digits */
  while (ix++ < oldused) {
     *tmpc++ = 0;
 8006a6a:	9b08      	ldr	r3, [sp, #32]
 8006a6c:	1d1a      	adds	r2, r3, #4
 8006a6e:	9208      	str	r2, [sp, #32]
 8006a70:	2200      	movs	r2, #0
 8006a72:	601a      	str	r2, [r3, #0]
  while (ix++ < oldused) {
 8006a74:	9b06      	ldr	r3, [sp, #24]
 8006a76:	1c5a      	adds	r2, r3, #1
 8006a78:	9206      	str	r2, [sp, #24]
 8006a7a:	9a04      	ldr	r2, [sp, #16]
 8006a7c:	4293      	cmp	r3, r2
 8006a7e:	dbf4      	blt.n	8006a6a <mp_sub_d+0x13a>
  }
  mp_clamp(c);
 8006a80:	9801      	ldr	r0, [sp, #4]
 8006a82:	f004 f895 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8006a86:	2300      	movs	r3, #0
}
 8006a88:	4618      	mov	r0, r3
 8006a8a:	b00b      	add	sp, #44	; 0x2c
 8006a8c:	f85d fb04 	ldr.w	pc, [sp], #4

08006a90 <mp_cnt_lsb>:
   4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

/* Counts the number of lsbs which are zero before the first zero bit */
int mp_cnt_lsb(mp_int *a)
{
 8006a90:	b086      	sub	sp, #24
 8006a92:	9001      	str	r0, [sp, #4]
    int x;
    mp_digit q = 0, qq;
 8006a94:	2300      	movs	r3, #0
 8006a96:	9304      	str	r3, [sp, #16]

    /* easy out */
    if (mp_iszero(a) == MP_YES) {
 8006a98:	9b01      	ldr	r3, [sp, #4]
 8006a9a:	681b      	ldr	r3, [r3, #0]
 8006a9c:	2b00      	cmp	r3, #0
 8006a9e:	d101      	bne.n	8006aa4 <mp_cnt_lsb+0x14>
        return 0;
 8006aa0:	2300      	movs	r3, #0
 8006aa2:	e03a      	b.n	8006b1a <mp_cnt_lsb+0x8a>
    }

    /* scan lower digits until non-zero */
    for (x = 0; x < a->used && a->dp[x] == 0; x++) {}
 8006aa4:	2300      	movs	r3, #0
 8006aa6:	9305      	str	r3, [sp, #20]
 8006aa8:	e002      	b.n	8006ab0 <mp_cnt_lsb+0x20>
 8006aaa:	9b05      	ldr	r3, [sp, #20]
 8006aac:	3301      	adds	r3, #1
 8006aae:	9305      	str	r3, [sp, #20]
 8006ab0:	9b01      	ldr	r3, [sp, #4]
 8006ab2:	681a      	ldr	r2, [r3, #0]
 8006ab4:	9b05      	ldr	r3, [sp, #20]
 8006ab6:	429a      	cmp	r2, r3
 8006ab8:	dd07      	ble.n	8006aca <mp_cnt_lsb+0x3a>
 8006aba:	9b01      	ldr	r3, [sp, #4]
 8006abc:	68da      	ldr	r2, [r3, #12]
 8006abe:	9b05      	ldr	r3, [sp, #20]
 8006ac0:	009b      	lsls	r3, r3, #2
 8006ac2:	4413      	add	r3, r2
 8006ac4:	681b      	ldr	r3, [r3, #0]
 8006ac6:	2b00      	cmp	r3, #0
 8006ac8:	d0ef      	beq.n	8006aaa <mp_cnt_lsb+0x1a>
    if (a->dp)
 8006aca:	9b01      	ldr	r3, [sp, #4]
 8006acc:	68db      	ldr	r3, [r3, #12]
 8006ace:	2b00      	cmp	r3, #0
 8006ad0:	d006      	beq.n	8006ae0 <mp_cnt_lsb+0x50>
        q = a->dp[x];
 8006ad2:	9b01      	ldr	r3, [sp, #4]
 8006ad4:	68da      	ldr	r2, [r3, #12]
 8006ad6:	9b05      	ldr	r3, [sp, #20]
 8006ad8:	009b      	lsls	r3, r3, #2
 8006ada:	4413      	add	r3, r2
 8006adc:	681b      	ldr	r3, [r3, #0]
 8006ade:	9304      	str	r3, [sp, #16]
    x *= DIGIT_BIT;
 8006ae0:	9a05      	ldr	r2, [sp, #20]
 8006ae2:	4613      	mov	r3, r2
 8006ae4:	00db      	lsls	r3, r3, #3
 8006ae6:	1a9b      	subs	r3, r3, r2
 8006ae8:	009b      	lsls	r3, r3, #2
 8006aea:	9305      	str	r3, [sp, #20]

    /* now scan this digit until a 1 is found */
    if ((q & 1) == 0) {
 8006aec:	9b04      	ldr	r3, [sp, #16]
 8006aee:	f003 0301 	and.w	r3, r3, #1
 8006af2:	2b00      	cmp	r3, #0
 8006af4:	d110      	bne.n	8006b18 <mp_cnt_lsb+0x88>
        do {
            qq  = q & 15;
 8006af6:	9b04      	ldr	r3, [sp, #16]
 8006af8:	f003 030f 	and.w	r3, r3, #15
 8006afc:	9303      	str	r3, [sp, #12]
            x  += lnz[qq];
 8006afe:	4a08      	ldr	r2, [pc, #32]	; (8006b20 <mp_cnt_lsb+0x90>)
 8006b00:	9b03      	ldr	r3, [sp, #12]
 8006b02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8006b06:	9a05      	ldr	r2, [sp, #20]
 8006b08:	4413      	add	r3, r2
 8006b0a:	9305      	str	r3, [sp, #20]
            q >>= 4;
 8006b0c:	9b04      	ldr	r3, [sp, #16]
 8006b0e:	091b      	lsrs	r3, r3, #4
 8006b10:	9304      	str	r3, [sp, #16]
        } while (qq == 0);
 8006b12:	9b03      	ldr	r3, [sp, #12]
 8006b14:	2b00      	cmp	r3, #0
 8006b16:	d0ee      	beq.n	8006af6 <mp_cnt_lsb+0x66>
    }
    return x;
 8006b18:	9b05      	ldr	r3, [sp, #20]
}
 8006b1a:	4618      	mov	r0, r3
 8006b1c:	b006      	add	sp, #24
 8006b1e:	4770      	bx	lr
 8006b20:	08024650 	.word	0x08024650
	...

08006b30 <s_is_power_of_two>:




static int s_is_power_of_two(mp_digit b, int *p)
{
 8006b30:	b084      	sub	sp, #16
 8006b32:	9001      	str	r0, [sp, #4]
 8006b34:	9100      	str	r1, [sp, #0]
   int x;

   /* fast return if no power of two */
   if ((b==0) || (b & (b-1))) {
 8006b36:	9b01      	ldr	r3, [sp, #4]
 8006b38:	2b00      	cmp	r3, #0
 8006b3a:	d005      	beq.n	8006b48 <s_is_power_of_two+0x18>
 8006b3c:	9b01      	ldr	r3, [sp, #4]
 8006b3e:	1e5a      	subs	r2, r3, #1
 8006b40:	9b01      	ldr	r3, [sp, #4]
 8006b42:	4013      	ands	r3, r2
 8006b44:	2b00      	cmp	r3, #0
 8006b46:	d001      	beq.n	8006b4c <s_is_power_of_two+0x1c>
      return 0;
 8006b48:	2300      	movs	r3, #0
 8006b4a:	e014      	b.n	8006b76 <s_is_power_of_two+0x46>
   }

   for (x = 0; x < DIGIT_BIT; x++) {
 8006b4c:	2300      	movs	r3, #0
 8006b4e:	9303      	str	r3, [sp, #12]
 8006b50:	e00d      	b.n	8006b6e <s_is_power_of_two+0x3e>
      if (b == (((mp_digit)1)<<x)) {
 8006b52:	2201      	movs	r2, #1
 8006b54:	9b03      	ldr	r3, [sp, #12]
 8006b56:	409a      	lsls	r2, r3
 8006b58:	9b01      	ldr	r3, [sp, #4]
 8006b5a:	429a      	cmp	r2, r3
 8006b5c:	d104      	bne.n	8006b68 <s_is_power_of_two+0x38>
         *p = x;
 8006b5e:	9b00      	ldr	r3, [sp, #0]
 8006b60:	9a03      	ldr	r2, [sp, #12]
 8006b62:	601a      	str	r2, [r3, #0]
         return 1;
 8006b64:	2301      	movs	r3, #1
 8006b66:	e006      	b.n	8006b76 <s_is_power_of_two+0x46>
   for (x = 0; x < DIGIT_BIT; x++) {
 8006b68:	9b03      	ldr	r3, [sp, #12]
 8006b6a:	3301      	adds	r3, #1
 8006b6c:	9303      	str	r3, [sp, #12]
 8006b6e:	9b03      	ldr	r3, [sp, #12]
 8006b70:	2b1b      	cmp	r3, #27
 8006b72:	ddee      	ble.n	8006b52 <s_is_power_of_two+0x22>
      }
   }
   return 0;
 8006b74:	2300      	movs	r3, #0
}
 8006b76:	4618      	mov	r0, r3
 8006b78:	b004      	add	sp, #16
 8006b7a:	4770      	bx	lr
 8006b7c:	0000      	movs	r0, r0
	...

08006b80 <mp_div_d>:

/* single digit division (based on routine from MPI) */
static int mp_div_d (mp_int * a, mp_digit b, mp_int * c, mp_digit * d)
{
 8006b80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006b82:	b08f      	sub	sp, #60	; 0x3c
 8006b84:	9003      	str	r0, [sp, #12]
 8006b86:	9102      	str	r1, [sp, #8]
 8006b88:	9201      	str	r2, [sp, #4]
 8006b8a:	9300      	str	r3, [sp, #0]
  mp_int  q;
  mp_word w;
  mp_digit t;
  int     res = MP_OKAY, ix;
 8006b8c:	2300      	movs	r3, #0
 8006b8e:	930a      	str	r3, [sp, #40]	; 0x28

  /* cannot divide by zero */
  if (b == 0) {
 8006b90:	9b02      	ldr	r3, [sp, #8]
 8006b92:	2b00      	cmp	r3, #0
 8006b94:	d102      	bne.n	8006b9c <mp_div_d+0x1c>
     return MP_VAL;
 8006b96:	f06f 0302 	mvn.w	r3, #2
 8006b9a:	e0dc      	b.n	8006d56 <mp_div_d+0x1d6>
  }

  /* quick outs */
  if (b == 1 || mp_iszero(a) == MP_YES) {
 8006b9c:	9b02      	ldr	r3, [sp, #8]
 8006b9e:	2b01      	cmp	r3, #1
 8006ba0:	d003      	beq.n	8006baa <mp_div_d+0x2a>
 8006ba2:	9b03      	ldr	r3, [sp, #12]
 8006ba4:	681b      	ldr	r3, [r3, #0]
 8006ba6:	2b00      	cmp	r3, #0
 8006ba8:	d110      	bne.n	8006bcc <mp_div_d+0x4c>
     if (d != NULL) {
 8006baa:	9b00      	ldr	r3, [sp, #0]
 8006bac:	2b00      	cmp	r3, #0
 8006bae:	d002      	beq.n	8006bb6 <mp_div_d+0x36>
        *d = 0;
 8006bb0:	9b00      	ldr	r3, [sp, #0]
 8006bb2:	2200      	movs	r2, #0
 8006bb4:	601a      	str	r2, [r3, #0]
     }
     if (c != NULL) {
 8006bb6:	9b01      	ldr	r3, [sp, #4]
 8006bb8:	2b00      	cmp	r3, #0
 8006bba:	d005      	beq.n	8006bc8 <mp_div_d+0x48>
        return mp_copy(a, c);
 8006bbc:	9901      	ldr	r1, [sp, #4]
 8006bbe:	9803      	ldr	r0, [sp, #12]
 8006bc0:	f003 feae 	bl	800a920 <mp_copy>
 8006bc4:	4603      	mov	r3, r0
 8006bc6:	e0c6      	b.n	8006d56 <mp_div_d+0x1d6>
     }
     return MP_OKAY;
 8006bc8:	2300      	movs	r3, #0
 8006bca:	e0c4      	b.n	8006d56 <mp_div_d+0x1d6>
  }

  /* power of two ? */
  if (s_is_power_of_two(b, &ix) == 1) {
 8006bcc:	ab05      	add	r3, sp, #20
 8006bce:	4619      	mov	r1, r3
 8006bd0:	9802      	ldr	r0, [sp, #8]
 8006bd2:	f7ff ffad 	bl	8006b30 <s_is_power_of_two>
 8006bd6:	4603      	mov	r3, r0
 8006bd8:	2b01      	cmp	r3, #1
 8006bda:	d11a      	bne.n	8006c12 <mp_div_d+0x92>
     if (d != NULL) {
 8006bdc:	9b00      	ldr	r3, [sp, #0]
 8006bde:	2b00      	cmp	r3, #0
 8006be0:	d00a      	beq.n	8006bf8 <mp_div_d+0x78>
        *d = a->dp[0] & ((((mp_digit)1)<<ix) - 1);
 8006be2:	9b03      	ldr	r3, [sp, #12]
 8006be4:	68db      	ldr	r3, [r3, #12]
 8006be6:	681a      	ldr	r2, [r3, #0]
 8006be8:	9b05      	ldr	r3, [sp, #20]
 8006bea:	2101      	movs	r1, #1
 8006bec:	fa01 f303 	lsl.w	r3, r1, r3
 8006bf0:	3b01      	subs	r3, #1
 8006bf2:	401a      	ands	r2, r3
 8006bf4:	9b00      	ldr	r3, [sp, #0]
 8006bf6:	601a      	str	r2, [r3, #0]
     }
     if (c != NULL) {
 8006bf8:	9b01      	ldr	r3, [sp, #4]
 8006bfa:	2b00      	cmp	r3, #0
 8006bfc:	d007      	beq.n	8006c0e <mp_div_d+0x8e>
        return mp_div_2d(a, ix, c, NULL);
 8006bfe:	9905      	ldr	r1, [sp, #20]
 8006c00:	2300      	movs	r3, #0
 8006c02:	9a01      	ldr	r2, [sp, #4]
 8006c04:	9803      	ldr	r0, [sp, #12]
 8006c06:	f003 ff33 	bl	800aa70 <mp_div_2d>
 8006c0a:	4603      	mov	r3, r0
 8006c0c:	e0a3      	b.n	8006d56 <mp_div_d+0x1d6>
     }
     return MP_OKAY;
 8006c0e:	2300      	movs	r3, #0
 8006c10:	e0a1      	b.n	8006d56 <mp_div_d+0x1d6>
  }

#ifdef BN_MP_DIV_3_C
  /* three? */
  if (b == 3) {
 8006c12:	9b02      	ldr	r3, [sp, #8]
 8006c14:	2b03      	cmp	r3, #3
 8006c16:	d106      	bne.n	8006c26 <mp_div_d+0xa6>
     return mp_div_3(a, c, d);
 8006c18:	9a00      	ldr	r2, [sp, #0]
 8006c1a:	9901      	ldr	r1, [sp, #4]
 8006c1c:	9803      	ldr	r0, [sp, #12]
 8006c1e:	f002 fae7 	bl	80091f0 <mp_div_3>
 8006c22:	4603      	mov	r3, r0
 8006c24:	e097      	b.n	8006d56 <mp_div_d+0x1d6>
  }
#endif

  /* no easy answer [c'est la vie].  Just division */
  if (c != NULL) {
 8006c26:	9b01      	ldr	r3, [sp, #4]
 8006c28:	2b00      	cmp	r3, #0
 8006c2a:	d013      	beq.n	8006c54 <mp_div_d+0xd4>
      if ((res = mp_init_size(&q, a->used)) != MP_OKAY) {
 8006c2c:	9b03      	ldr	r3, [sp, #12]
 8006c2e:	681a      	ldr	r2, [r3, #0]
 8006c30:	ab06      	add	r3, sp, #24
 8006c32:	4611      	mov	r1, r2
 8006c34:	4618      	mov	r0, r3
 8006c36:	f002 fb8b 	bl	8009350 <mp_init_size>
 8006c3a:	900a      	str	r0, [sp, #40]	; 0x28
 8006c3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	d001      	beq.n	8006c46 <mp_div_d+0xc6>
         return res;
 8006c42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006c44:	e087      	b.n	8006d56 <mp_div_d+0x1d6>
      }

      q.used = a->used;
 8006c46:	9b03      	ldr	r3, [sp, #12]
 8006c48:	681b      	ldr	r3, [r3, #0]
 8006c4a:	9306      	str	r3, [sp, #24]
      q.sign = a->sign;
 8006c4c:	9b03      	ldr	r3, [sp, #12]
 8006c4e:	689b      	ldr	r3, [r3, #8]
 8006c50:	9308      	str	r3, [sp, #32]
 8006c52:	e009      	b.n	8006c68 <mp_div_d+0xe8>
  }
  else {
      if ((res = mp_init(&q)) != MP_OKAY) {
 8006c54:	ab06      	add	r3, sp, #24
 8006c56:	4618      	mov	r0, r3
 8006c58:	f003 fcd2 	bl	800a600 <mp_init>
 8006c5c:	900a      	str	r0, [sp, #40]	; 0x28
 8006c5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006c60:	2b00      	cmp	r3, #0
 8006c62:	d001      	beq.n	8006c68 <mp_div_d+0xe8>
         return res;
 8006c64:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006c66:	e076      	b.n	8006d56 <mp_div_d+0x1d6>
      }
  }


  w = 0;
 8006c68:	f04f 0200 	mov.w	r2, #0
 8006c6c:	f04f 0300 	mov.w	r3, #0
 8006c70:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  for (ix = a->used - 1; ix >= 0; ix--) {
 8006c74:	9b03      	ldr	r3, [sp, #12]
 8006c76:	681b      	ldr	r3, [r3, #0]
 8006c78:	3b01      	subs	r3, #1
 8006c7a:	9305      	str	r3, [sp, #20]
 8006c7c:	e051      	b.n	8006d22 <mp_div_d+0x1a2>
     w = (w << ((mp_word)DIGIT_BIT)) | ((mp_word)a->dp[ix]);
 8006c7e:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 8006c82:	071d      	lsls	r5, r3, #28
 8006c84:	ea45 1512 	orr.w	r5, r5, r2, lsr #4
 8006c88:	0714      	lsls	r4, r2, #28
 8006c8a:	9b03      	ldr	r3, [sp, #12]
 8006c8c:	68da      	ldr	r2, [r3, #12]
 8006c8e:	9b05      	ldr	r3, [sp, #20]
 8006c90:	009b      	lsls	r3, r3, #2
 8006c92:	4413      	add	r3, r2
 8006c94:	681b      	ldr	r3, [r3, #0]
 8006c96:	461a      	mov	r2, r3
 8006c98:	f04f 0300 	mov.w	r3, #0
 8006c9c:	ea42 0204 	orr.w	r2, r2, r4
 8006ca0:	ea43 0305 	orr.w	r3, r3, r5
 8006ca4:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30

     if (w >= b) {
 8006ca8:	9b02      	ldr	r3, [sp, #8]
 8006caa:	461a      	mov	r2, r3
 8006cac:	f04f 0300 	mov.w	r3, #0
 8006cb0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8006cb4:	4299      	cmp	r1, r3
 8006cb6:	bf08      	it	eq
 8006cb8:	4290      	cmpeq	r0, r2
 8006cba:	d324      	bcc.n	8006d06 <mp_div_d+0x186>
        t = (mp_digit)(w / b);
 8006cbc:	9b02      	ldr	r3, [sp, #8]
 8006cbe:	461a      	mov	r2, r3
 8006cc0:	f04f 0300 	mov.w	r3, #0
 8006cc4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8006cc8:	f7fd fdc2 	bl	8004850 <__aeabi_uldivmod>
 8006ccc:	4602      	mov	r2, r0
 8006cce:	460b      	mov	r3, r1
 8006cd0:	4613      	mov	r3, r2
 8006cd2:	930b      	str	r3, [sp, #44]	; 0x2c
        w -= ((mp_word)t) * ((mp_word)b);
 8006cd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006cd6:	4618      	mov	r0, r3
 8006cd8:	f04f 0100 	mov.w	r1, #0
 8006cdc:	9b02      	ldr	r3, [sp, #8]
 8006cde:	461a      	mov	r2, r3
 8006ce0:	f04f 0300 	mov.w	r3, #0
 8006ce4:	fb02 f701 	mul.w	r7, r2, r1
 8006ce8:	fb00 f603 	mul.w	r6, r0, r3
 8006cec:	443e      	add	r6, r7
 8006cee:	fba0 2302 	umull	r2, r3, r0, r2
 8006cf2:	18f1      	adds	r1, r6, r3
 8006cf4:	460b      	mov	r3, r1
 8006cf6:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8006cfa:	1a82      	subs	r2, r0, r2
 8006cfc:	eb61 0303 	sbc.w	r3, r1, r3
 8006d00:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8006d04:	e001      	b.n	8006d0a <mp_div_d+0x18a>
      } else {
        t = 0;
 8006d06:	2300      	movs	r3, #0
 8006d08:	930b      	str	r3, [sp, #44]	; 0x2c
      }
      if (c != NULL)
 8006d0a:	9b01      	ldr	r3, [sp, #4]
 8006d0c:	2b00      	cmp	r3, #0
 8006d0e:	d005      	beq.n	8006d1c <mp_div_d+0x19c>
        q.dp[ix] = (mp_digit)t;
 8006d10:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006d12:	9b05      	ldr	r3, [sp, #20]
 8006d14:	009b      	lsls	r3, r3, #2
 8006d16:	4413      	add	r3, r2
 8006d18:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8006d1a:	601a      	str	r2, [r3, #0]
  for (ix = a->used - 1; ix >= 0; ix--) {
 8006d1c:	9b05      	ldr	r3, [sp, #20]
 8006d1e:	3b01      	subs	r3, #1
 8006d20:	9305      	str	r3, [sp, #20]
 8006d22:	9b05      	ldr	r3, [sp, #20]
 8006d24:	2b00      	cmp	r3, #0
 8006d26:	daaa      	bge.n	8006c7e <mp_div_d+0xfe>
  }

  if (d != NULL) {
 8006d28:	9b00      	ldr	r3, [sp, #0]
 8006d2a:	2b00      	cmp	r3, #0
 8006d2c:	d002      	beq.n	8006d34 <mp_div_d+0x1b4>
     *d = (mp_digit)w;
 8006d2e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8006d30:	9b00      	ldr	r3, [sp, #0]
 8006d32:	601a      	str	r2, [r3, #0]
  }

  if (c != NULL) {
 8006d34:	9b01      	ldr	r3, [sp, #4]
 8006d36:	2b00      	cmp	r3, #0
 8006d38:	d008      	beq.n	8006d4c <mp_div_d+0x1cc>
     mp_clamp(&q);
 8006d3a:	ab06      	add	r3, sp, #24
 8006d3c:	4618      	mov	r0, r3
 8006d3e:	f003 ff37 	bl	800abb0 <mp_clamp>
     mp_exch(&q, c);
 8006d42:	ab06      	add	r3, sp, #24
 8006d44:	9901      	ldr	r1, [sp, #4]
 8006d46:	4618      	mov	r0, r3
 8006d48:	f003 ff5a 	bl	800ac00 <mp_exch>
  }
  mp_clear(&q);
 8006d4c:	ab06      	add	r3, sp, #24
 8006d4e:	4618      	mov	r0, r3
 8006d50:	f003 fc6e 	bl	800a630 <mp_clear>

  return res;
 8006d54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 8006d56:	4618      	mov	r0, r3
 8006d58:	b00f      	add	sp, #60	; 0x3c
 8006d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006d5c:	0000      	movs	r0, r0
	...

08006d60 <mp_mod_d>:


int mp_mod_d (mp_int * a, mp_digit b, mp_digit * c)
{
 8006d60:	b500      	push	{lr}
 8006d62:	b085      	sub	sp, #20
 8006d64:	9003      	str	r0, [sp, #12]
 8006d66:	9102      	str	r1, [sp, #8]
 8006d68:	9201      	str	r2, [sp, #4]
  return mp_div_d(a, b, NULL, c);
 8006d6a:	9b01      	ldr	r3, [sp, #4]
 8006d6c:	2200      	movs	r2, #0
 8006d6e:	9902      	ldr	r1, [sp, #8]
 8006d70:	9803      	ldr	r0, [sp, #12]
 8006d72:	f7ff ff05 	bl	8006b80 <mp_div_d>
 8006d76:	4603      	mov	r3, r0
}
 8006d78:	4618      	mov	r0, r3
 8006d7a:	b005      	add	sp, #20
 8006d7c:	f85d fb04 	ldr.w	pc, [sp], #4

08006d80 <mp_prime_miller_rabin>:
 * Sets result to 0 if definitely composite or 1 if probably prime.
 * Randomly the chance of error is no more than 1/4 and often
 * very much lower.
 */
static int mp_prime_miller_rabin (mp_int * a, mp_int * b, int *result)
{
 8006d80:	b500      	push	{lr}
 8006d82:	b095      	sub	sp, #84	; 0x54
 8006d84:	9003      	str	r0, [sp, #12]
 8006d86:	9102      	str	r1, [sp, #8]
 8006d88:	9201      	str	r2, [sp, #4]
  mp_int  n1, y, r;
  int     s, j, err;

  /* default */
  *result = MP_NO;
 8006d8a:	9b01      	ldr	r3, [sp, #4]
 8006d8c:	2200      	movs	r2, #0
 8006d8e:	601a      	str	r2, [r3, #0]

  /* ensure b > 1 */
  if (mp_cmp_d(b, 1) != MP_GT) {
 8006d90:	2101      	movs	r1, #1
 8006d92:	9802      	ldr	r0, [sp, #8]
 8006d94:	f004 fec4 	bl	800bb20 <mp_cmp_d>
 8006d98:	4603      	mov	r3, r0
 8006d9a:	2b01      	cmp	r3, #1
 8006d9c:	d002      	beq.n	8006da4 <mp_prime_miller_rabin+0x24>
     return MP_VAL;
 8006d9e:	f06f 0302 	mvn.w	r3, #2
 8006da2:	e08f      	b.n	8006ec4 <mp_prime_miller_rabin+0x144>
  }

  /* get n1 = a - 1 */
  if ((err = mp_init_copy (&n1, a)) != MP_OKAY) {
 8006da4:	ab0d      	add	r3, sp, #52	; 0x34
 8006da6:	9903      	ldr	r1, [sp, #12]
 8006da8:	4618      	mov	r0, r3
 8006daa:	f003 fd99 	bl	800a8e0 <mp_init_copy>
 8006dae:	9012      	str	r0, [sp, #72]	; 0x48
 8006db0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006db2:	2b00      	cmp	r3, #0
 8006db4:	d001      	beq.n	8006dba <mp_prime_miller_rabin+0x3a>
    return err;
 8006db6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006db8:	e084      	b.n	8006ec4 <mp_prime_miller_rabin+0x144>
  }
  if ((err = mp_sub_d (&n1, 1, &n1)) != MP_OKAY) {
 8006dba:	aa0d      	add	r2, sp, #52	; 0x34
 8006dbc:	ab0d      	add	r3, sp, #52	; 0x34
 8006dbe:	2101      	movs	r1, #1
 8006dc0:	4618      	mov	r0, r3
 8006dc2:	f7ff fdb5 	bl	8006930 <mp_sub_d>
 8006dc6:	9012      	str	r0, [sp, #72]	; 0x48
 8006dc8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006dca:	2b00      	cmp	r3, #0
 8006dcc:	d175      	bne.n	8006eba <mp_prime_miller_rabin+0x13a>
    goto LBL_N1;
  }

  /* set 2**s * r = n1 */
  if ((err = mp_init_copy (&r, &n1)) != MP_OKAY) {
 8006dce:	aa0d      	add	r2, sp, #52	; 0x34
 8006dd0:	ab05      	add	r3, sp, #20
 8006dd2:	4611      	mov	r1, r2
 8006dd4:	4618      	mov	r0, r3
 8006dd6:	f003 fd83 	bl	800a8e0 <mp_init_copy>
 8006dda:	9012      	str	r0, [sp, #72]	; 0x48
 8006ddc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006dde:	2b00      	cmp	r3, #0
 8006de0:	d16b      	bne.n	8006eba <mp_prime_miller_rabin+0x13a>
  }

  /* count the number of least significant bits
   * which are zero
   */
  s = mp_cnt_lsb(&r);
 8006de2:	ab05      	add	r3, sp, #20
 8006de4:	4618      	mov	r0, r3
 8006de6:	f7ff fe53 	bl	8006a90 <mp_cnt_lsb>
 8006dea:	9011      	str	r0, [sp, #68]	; 0x44

  /* now divide n - 1 by 2**s */
  if ((err = mp_div_2d (&r, s, &r, NULL)) != MP_OKAY) {
 8006dec:	aa05      	add	r2, sp, #20
 8006dee:	a805      	add	r0, sp, #20
 8006df0:	2300      	movs	r3, #0
 8006df2:	9911      	ldr	r1, [sp, #68]	; 0x44
 8006df4:	f003 fe3c 	bl	800aa70 <mp_div_2d>
 8006df8:	9012      	str	r0, [sp, #72]	; 0x48
 8006dfa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006dfc:	2b00      	cmp	r3, #0
 8006dfe:	d158      	bne.n	8006eb2 <mp_prime_miller_rabin+0x132>
    goto LBL_R;
  }

  /* compute y = b**r mod a */
  if ((err = mp_init (&y)) != MP_OKAY) {
 8006e00:	ab09      	add	r3, sp, #36	; 0x24
 8006e02:	4618      	mov	r0, r3
 8006e04:	f003 fbfc 	bl	800a600 <mp_init>
 8006e08:	9012      	str	r0, [sp, #72]	; 0x48
 8006e0a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006e0c:	2b00      	cmp	r3, #0
 8006e0e:	d150      	bne.n	8006eb2 <mp_prime_miller_rabin+0x132>
    goto LBL_R;
  }
  if ((err = mp_exptmod (b, &r, a, &y)) != MP_OKAY) {
 8006e10:	ab09      	add	r3, sp, #36	; 0x24
 8006e12:	a905      	add	r1, sp, #20
 8006e14:	9a03      	ldr	r2, [sp, #12]
 8006e16:	9802      	ldr	r0, [sp, #8]
 8006e18:	f004 f97a 	bl	800b110 <mp_exptmod>
 8006e1c:	9012      	str	r0, [sp, #72]	; 0x48
 8006e1e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	d142      	bne.n	8006eaa <mp_prime_miller_rabin+0x12a>
    goto LBL_Y;
  }

  /* if y != 1 and y != n1 do */
  if (mp_cmp_d (&y, 1) != MP_EQ && mp_cmp (&y, &n1) != MP_EQ) {
 8006e24:	ab09      	add	r3, sp, #36	; 0x24
 8006e26:	2101      	movs	r1, #1
 8006e28:	4618      	mov	r0, r3
 8006e2a:	f004 fe79 	bl	800bb20 <mp_cmp_d>
 8006e2e:	4603      	mov	r3, r0
 8006e30:	2b00      	cmp	r3, #0
 8006e32:	d037      	beq.n	8006ea4 <mp_prime_miller_rabin+0x124>
 8006e34:	aa0d      	add	r2, sp, #52	; 0x34
 8006e36:	ab09      	add	r3, sp, #36	; 0x24
 8006e38:	4611      	mov	r1, r2
 8006e3a:	4618      	mov	r0, r3
 8006e3c:	f004 fe48 	bl	800bad0 <mp_cmp>
 8006e40:	4603      	mov	r3, r0
 8006e42:	2b00      	cmp	r3, #0
 8006e44:	d02e      	beq.n	8006ea4 <mp_prime_miller_rabin+0x124>
    j = 1;
 8006e46:	2301      	movs	r3, #1
 8006e48:	9313      	str	r3, [sp, #76]	; 0x4c
 8006e4a:	e014      	b.n	8006e76 <mp_prime_miller_rabin+0xf6>
    /* while j <= s-1 and y != n1 */
    while ((j <= (s - 1)) && mp_cmp (&y, &n1) != MP_EQ) {
      if ((err = mp_sqrmod (&y, a, &y)) != MP_OKAY) {
 8006e4c:	aa09      	add	r2, sp, #36	; 0x24
 8006e4e:	ab09      	add	r3, sp, #36	; 0x24
 8006e50:	9903      	ldr	r1, [sp, #12]
 8006e52:	4618      	mov	r0, r3
 8006e54:	f7ff fc7c 	bl	8006750 <mp_sqrmod>
 8006e58:	9012      	str	r0, [sp, #72]	; 0x48
 8006e5a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006e5c:	2b00      	cmp	r3, #0
 8006e5e:	d124      	bne.n	8006eaa <mp_prime_miller_rabin+0x12a>
         goto LBL_Y;
      }

      /* if y == 1 then composite */
      if (mp_cmp_d (&y, 1) == MP_EQ) {
 8006e60:	ab09      	add	r3, sp, #36	; 0x24
 8006e62:	2101      	movs	r1, #1
 8006e64:	4618      	mov	r0, r3
 8006e66:	f004 fe5b 	bl	800bb20 <mp_cmp_d>
 8006e6a:	4603      	mov	r3, r0
 8006e6c:	2b00      	cmp	r3, #0
 8006e6e:	d01c      	beq.n	8006eaa <mp_prime_miller_rabin+0x12a>
         goto LBL_Y;
      }

      ++j;
 8006e70:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006e72:	3301      	adds	r3, #1
 8006e74:	9313      	str	r3, [sp, #76]	; 0x4c
    while ((j <= (s - 1)) && mp_cmp (&y, &n1) != MP_EQ) {
 8006e76:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8006e78:	1e5a      	subs	r2, r3, #1
 8006e7a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006e7c:	429a      	cmp	r2, r3
 8006e7e:	db08      	blt.n	8006e92 <mp_prime_miller_rabin+0x112>
 8006e80:	aa0d      	add	r2, sp, #52	; 0x34
 8006e82:	ab09      	add	r3, sp, #36	; 0x24
 8006e84:	4611      	mov	r1, r2
 8006e86:	4618      	mov	r0, r3
 8006e88:	f004 fe22 	bl	800bad0 <mp_cmp>
 8006e8c:	4603      	mov	r3, r0
 8006e8e:	2b00      	cmp	r3, #0
 8006e90:	d1dc      	bne.n	8006e4c <mp_prime_miller_rabin+0xcc>
    }

    /* if y != n1 then composite */
    if (mp_cmp (&y, &n1) != MP_EQ) {
 8006e92:	aa0d      	add	r2, sp, #52	; 0x34
 8006e94:	ab09      	add	r3, sp, #36	; 0x24
 8006e96:	4611      	mov	r1, r2
 8006e98:	4618      	mov	r0, r3
 8006e9a:	f004 fe19 	bl	800bad0 <mp_cmp>
 8006e9e:	4603      	mov	r3, r0
 8006ea0:	2b00      	cmp	r3, #0
 8006ea2:	d102      	bne.n	8006eaa <mp_prime_miller_rabin+0x12a>
      goto LBL_Y;
    }
  }

  /* probably prime now */
  *result = MP_YES;
 8006ea4:	9b01      	ldr	r3, [sp, #4]
 8006ea6:	2201      	movs	r2, #1
 8006ea8:	601a      	str	r2, [r3, #0]
LBL_Y:mp_clear (&y);
 8006eaa:	ab09      	add	r3, sp, #36	; 0x24
 8006eac:	4618      	mov	r0, r3
 8006eae:	f003 fbbf 	bl	800a630 <mp_clear>
LBL_R:mp_clear (&r);
 8006eb2:	ab05      	add	r3, sp, #20
 8006eb4:	4618      	mov	r0, r3
 8006eb6:	f003 fbbb 	bl	800a630 <mp_clear>
LBL_N1:mp_clear (&n1);
 8006eba:	ab0d      	add	r3, sp, #52	; 0x34
 8006ebc:	4618      	mov	r0, r3
 8006ebe:	f003 fbb7 	bl	800a630 <mp_clear>
  return err;
 8006ec2:	9b12      	ldr	r3, [sp, #72]	; 0x48
}
 8006ec4:	4618      	mov	r0, r3
 8006ec6:	b015      	add	sp, #84	; 0x54
 8006ec8:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ecc:	0000      	movs	r0, r0
	...

08006ed0 <mp_prime_is_divisible>:
 * of the first PRIME_SIZE primes or not
 *
 * sets result to 0 if not, 1 if yes
 */
static int mp_prime_is_divisible (mp_int * a, int *result)
{
 8006ed0:	b500      	push	{lr}
 8006ed2:	b087      	sub	sp, #28
 8006ed4:	9001      	str	r0, [sp, #4]
 8006ed6:	9100      	str	r1, [sp, #0]
  int     err, ix;
  mp_digit res;

  /* default to not */
  *result = MP_NO;
 8006ed8:	9b00      	ldr	r3, [sp, #0]
 8006eda:	2200      	movs	r2, #0
 8006edc:	601a      	str	r2, [r3, #0]

  for (ix = 0; ix < PRIME_SIZE; ix++) {
 8006ede:	2300      	movs	r3, #0
 8006ee0:	9305      	str	r3, [sp, #20]
 8006ee2:	e019      	b.n	8006f18 <mp_prime_is_divisible+0x48>
    /* what is a mod LBL_prime_tab[ix] */
    if ((err = mp_mod_d (a, ltm_prime_tab[ix], &res)) != MP_OKAY) {
 8006ee4:	4a10      	ldr	r2, [pc, #64]	; (8006f28 <mp_prime_is_divisible+0x58>)
 8006ee6:	9b05      	ldr	r3, [sp, #20]
 8006ee8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8006eec:	aa03      	add	r2, sp, #12
 8006eee:	4619      	mov	r1, r3
 8006ef0:	9801      	ldr	r0, [sp, #4]
 8006ef2:	f7ff ff35 	bl	8006d60 <mp_mod_d>
 8006ef6:	9004      	str	r0, [sp, #16]
 8006ef8:	9b04      	ldr	r3, [sp, #16]
 8006efa:	2b00      	cmp	r3, #0
 8006efc:	d001      	beq.n	8006f02 <mp_prime_is_divisible+0x32>
      return err;
 8006efe:	9b04      	ldr	r3, [sp, #16]
 8006f00:	e00e      	b.n	8006f20 <mp_prime_is_divisible+0x50>
    }

    /* is the residue zero? */
    if (res == 0) {
 8006f02:	9b03      	ldr	r3, [sp, #12]
 8006f04:	2b00      	cmp	r3, #0
 8006f06:	d104      	bne.n	8006f12 <mp_prime_is_divisible+0x42>
      *result = MP_YES;
 8006f08:	9b00      	ldr	r3, [sp, #0]
 8006f0a:	2201      	movs	r2, #1
 8006f0c:	601a      	str	r2, [r3, #0]
      return MP_OKAY;
 8006f0e:	2300      	movs	r3, #0
 8006f10:	e006      	b.n	8006f20 <mp_prime_is_divisible+0x50>
  for (ix = 0; ix < PRIME_SIZE; ix++) {
 8006f12:	9b05      	ldr	r3, [sp, #20]
 8006f14:	3301      	adds	r3, #1
 8006f16:	9305      	str	r3, [sp, #20]
 8006f18:	9b05      	ldr	r3, [sp, #20]
 8006f1a:	2bff      	cmp	r3, #255	; 0xff
 8006f1c:	dde2      	ble.n	8006ee4 <mp_prime_is_divisible+0x14>
    }
  }

  return MP_OKAY;
 8006f1e:	2300      	movs	r3, #0
}
 8006f20:	4618      	mov	r0, r3
 8006f22:	b007      	add	sp, #28
 8006f24:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f28:	08024690 	.word	0x08024690
 8006f2c:	00000000 	.word	0x00000000

08006f30 <mp_rand_prime>:

static const int USE_BBS = 1;

int mp_rand_prime(mp_int* N, int len, WC_RNG* rng, void* heap)
{
 8006f30:	b500      	push	{lr}
 8006f32:	b089      	sub	sp, #36	; 0x24
 8006f34:	9003      	str	r0, [sp, #12]
 8006f36:	9102      	str	r1, [sp, #8]
 8006f38:	9201      	str	r2, [sp, #4]
 8006f3a:	9300      	str	r3, [sp, #0]
    int   err, res, type;
    byte* buf;

    if (N == NULL || rng == NULL)
 8006f3c:	9b03      	ldr	r3, [sp, #12]
 8006f3e:	2b00      	cmp	r3, #0
 8006f40:	d002      	beq.n	8006f48 <mp_rand_prime+0x18>
 8006f42:	9b01      	ldr	r3, [sp, #4]
 8006f44:	2b00      	cmp	r3, #0
 8006f46:	d102      	bne.n	8006f4e <mp_rand_prime+0x1e>
        return MP_VAL;
 8006f48:	f06f 0302 	mvn.w	r3, #2
 8006f4c:	e07b      	b.n	8007046 <mp_rand_prime+0x116>

    /* get type */
    if (len < 0) {
 8006f4e:	9b02      	ldr	r3, [sp, #8]
 8006f50:	2b00      	cmp	r3, #0
 8006f52:	da05      	bge.n	8006f60 <mp_rand_prime+0x30>
        type = USE_BBS;
 8006f54:	2301      	movs	r3, #1
 8006f56:	9307      	str	r3, [sp, #28]
        len = -len;
 8006f58:	9b02      	ldr	r3, [sp, #8]
 8006f5a:	425b      	negs	r3, r3
 8006f5c:	9302      	str	r3, [sp, #8]
 8006f5e:	e001      	b.n	8006f64 <mp_rand_prime+0x34>
    } else {
        type = 0;
 8006f60:	2300      	movs	r3, #0
 8006f62:	9307      	str	r3, [sp, #28]
    }

    /* allow sizes between 2 and 512 bytes for a prime size */
    if (len < 2 || len > 512) {
 8006f64:	9b02      	ldr	r3, [sp, #8]
 8006f66:	2b01      	cmp	r3, #1
 8006f68:	dd03      	ble.n	8006f72 <mp_rand_prime+0x42>
 8006f6a:	9b02      	ldr	r3, [sp, #8]
 8006f6c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006f70:	dd02      	ble.n	8006f78 <mp_rand_prime+0x48>
        return MP_VAL;
 8006f72:	f06f 0302 	mvn.w	r3, #2
 8006f76:	e066      	b.n	8007046 <mp_rand_prime+0x116>
    }

    /* allocate buffer to work with */
    buf = (byte*)XMALLOC(len, heap, DYNAMIC_TYPE_RSA);
 8006f78:	9902      	ldr	r1, [sp, #8]
 8006f7a:	9800      	ldr	r0, [sp, #0]
 8006f7c:	f7fe fc70 	bl	8005860 <chibios_alloc>
 8006f80:	9006      	str	r0, [sp, #24]
    if (buf == NULL) {
 8006f82:	9b06      	ldr	r3, [sp, #24]
 8006f84:	2b00      	cmp	r3, #0
 8006f86:	d102      	bne.n	8006f8e <mp_rand_prime+0x5e>
        return MP_MEM;
 8006f88:	f06f 0301 	mvn.w	r3, #1
 8006f8c:	e05b      	b.n	8007046 <mp_rand_prime+0x116>
    }
    XMEMSET(buf, 0, len);
 8006f8e:	9b02      	ldr	r3, [sp, #8]
 8006f90:	461a      	mov	r2, r3
 8006f92:	2100      	movs	r1, #0
 8006f94:	9806      	ldr	r0, [sp, #24]
 8006f96:	f016 fc1d 	bl	801d7d4 <memset>
#ifdef SHOW_GEN
        printf(".");
        fflush(stdout);
#endif
        /* generate value */
        err = wc_RNG_GenerateBlock(rng, buf, len);
 8006f9a:	9b02      	ldr	r3, [sp, #8]
 8006f9c:	461a      	mov	r2, r3
 8006f9e:	9906      	ldr	r1, [sp, #24]
 8006fa0:	9801      	ldr	r0, [sp, #4]
 8006fa2:	f007 fccd 	bl	800e940 <wc_RNG_GenerateBlock>
 8006fa6:	9005      	str	r0, [sp, #20]
        if (err != 0) {
 8006fa8:	9b05      	ldr	r3, [sp, #20]
 8006faa:	2b00      	cmp	r3, #0
 8006fac:	d004      	beq.n	8006fb8 <mp_rand_prime+0x88>
            XFREE(buf, heap, DYNAMIC_TYPE_RSA);
 8006fae:	9806      	ldr	r0, [sp, #24]
 8006fb0:	f7fe fc66 	bl	8005880 <chibios_free>
            return err;
 8006fb4:	9b05      	ldr	r3, [sp, #20]
 8006fb6:	e046      	b.n	8007046 <mp_rand_prime+0x116>
        }

        /* munge bits */
        buf[0]     |= 0x80 | 0x40;
 8006fb8:	9b06      	ldr	r3, [sp, #24]
 8006fba:	781b      	ldrb	r3, [r3, #0]
 8006fbc:	f063 033f 	orn	r3, r3, #63	; 0x3f
 8006fc0:	b2da      	uxtb	r2, r3
 8006fc2:	9b06      	ldr	r3, [sp, #24]
 8006fc4:	701a      	strb	r2, [r3, #0]
        buf[len-1] |= 0x01 | ((type & USE_BBS) ? 0x02 : 0x00);
 8006fc6:	9b02      	ldr	r3, [sp, #8]
 8006fc8:	3b01      	subs	r3, #1
 8006fca:	9a06      	ldr	r2, [sp, #24]
 8006fcc:	4413      	add	r3, r2
 8006fce:	9a02      	ldr	r2, [sp, #8]
 8006fd0:	3a01      	subs	r2, #1
 8006fd2:	9906      	ldr	r1, [sp, #24]
 8006fd4:	440a      	add	r2, r1
 8006fd6:	7812      	ldrb	r2, [r2, #0]
 8006fd8:	b251      	sxtb	r1, r2
 8006fda:	2001      	movs	r0, #1
 8006fdc:	9a07      	ldr	r2, [sp, #28]
 8006fde:	4002      	ands	r2, r0
 8006fe0:	2a00      	cmp	r2, #0
 8006fe2:	d001      	beq.n	8006fe8 <mp_rand_prime+0xb8>
 8006fe4:	2203      	movs	r2, #3
 8006fe6:	e000      	b.n	8006fea <mp_rand_prime+0xba>
 8006fe8:	2201      	movs	r2, #1
 8006fea:	430a      	orrs	r2, r1
 8006fec:	b252      	sxtb	r2, r2
 8006fee:	b2d2      	uxtb	r2, r2
 8006ff0:	701a      	strb	r2, [r3, #0]

        /* load value */
        if ((err = mp_read_unsigned_bin(N, buf, len)) != MP_OKAY) {
 8006ff2:	9a02      	ldr	r2, [sp, #8]
 8006ff4:	9906      	ldr	r1, [sp, #24]
 8006ff6:	9803      	ldr	r0, [sp, #12]
 8006ff8:	f003 ff3a 	bl	800ae70 <mp_read_unsigned_bin>
 8006ffc:	9005      	str	r0, [sp, #20]
 8006ffe:	9b05      	ldr	r3, [sp, #20]
 8007000:	2b00      	cmp	r3, #0
 8007002:	d004      	beq.n	800700e <mp_rand_prime+0xde>
            XFREE(buf, heap, DYNAMIC_TYPE_RSA);
 8007004:	9806      	ldr	r0, [sp, #24]
 8007006:	f7fe fc3b 	bl	8005880 <chibios_free>
            return err;
 800700a:	9b05      	ldr	r3, [sp, #20]
 800700c:	e01b      	b.n	8007046 <mp_rand_prime+0x116>
        }

        /* test */
        if ((err = mp_prime_is_prime(N, 8, &res)) != MP_OKAY) {
 800700e:	ab04      	add	r3, sp, #16
 8007010:	461a      	mov	r2, r3
 8007012:	2108      	movs	r1, #8
 8007014:	9803      	ldr	r0, [sp, #12]
 8007016:	f000 f81b 	bl	8007050 <mp_prime_is_prime>
 800701a:	9005      	str	r0, [sp, #20]
 800701c:	9b05      	ldr	r3, [sp, #20]
 800701e:	2b00      	cmp	r3, #0
 8007020:	d004      	beq.n	800702c <mp_rand_prime+0xfc>
            XFREE(buf, heap, DYNAMIC_TYPE_RSA);
 8007022:	9806      	ldr	r0, [sp, #24]
 8007024:	f7fe fc2c 	bl	8005880 <chibios_free>
            return err;
 8007028:	9b05      	ldr	r3, [sp, #20]
 800702a:	e00c      	b.n	8007046 <mp_rand_prime+0x116>
        }
    } while (res == MP_NO);
 800702c:	9b04      	ldr	r3, [sp, #16]
 800702e:	2b00      	cmp	r3, #0
 8007030:	d0b3      	beq.n	8006f9a <mp_rand_prime+0x6a>

    XMEMSET(buf, 0, len);
 8007032:	9b02      	ldr	r3, [sp, #8]
 8007034:	461a      	mov	r2, r3
 8007036:	2100      	movs	r1, #0
 8007038:	9806      	ldr	r0, [sp, #24]
 800703a:	f016 fbcb 	bl	801d7d4 <memset>
    XFREE(buf, heap, DYNAMIC_TYPE_RSA);
 800703e:	9806      	ldr	r0, [sp, #24]
 8007040:	f7fe fc1e 	bl	8005880 <chibios_free>

    return MP_OKAY;
 8007044:	2300      	movs	r3, #0
}
 8007046:	4618      	mov	r0, r3
 8007048:	b009      	add	sp, #36	; 0x24
 800704a:	f85d fb04 	ldr.w	pc, [sp], #4
 800704e:	bf00      	nop

08007050 <mp_prime_is_prime>:

/*
 * Sets result to 1 if probably prime, 0 otherwise
 */
int mp_prime_is_prime (mp_int * a, int t, int *result)
{
 8007050:	b500      	push	{lr}
 8007052:	b08d      	sub	sp, #52	; 0x34
 8007054:	9003      	str	r0, [sp, #12]
 8007056:	9102      	str	r1, [sp, #8]
 8007058:	9201      	str	r2, [sp, #4]
  mp_int  b;
  int     ix, err, res;

  /* default to no */
  *result = MP_NO;
 800705a:	9b01      	ldr	r3, [sp, #4]
 800705c:	2200      	movs	r2, #0
 800705e:	601a      	str	r2, [r3, #0]

  /* valid value of t? */
  if (t <= 0 || t > PRIME_SIZE) {
 8007060:	9b02      	ldr	r3, [sp, #8]
 8007062:	2b00      	cmp	r3, #0
 8007064:	dd03      	ble.n	800706e <mp_prime_is_prime+0x1e>
 8007066:	9b02      	ldr	r3, [sp, #8]
 8007068:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800706c:	dd02      	ble.n	8007074 <mp_prime_is_prime+0x24>
    return MP_VAL;
 800706e:	f06f 0302 	mvn.w	r3, #2
 8007072:	e05e      	b.n	8007132 <mp_prime_is_prime+0xe2>
  }

  /* is the input equal to one of the primes in the table? */
  for (ix = 0; ix < PRIME_SIZE; ix++) {
 8007074:	2300      	movs	r3, #0
 8007076:	930b      	str	r3, [sp, #44]	; 0x2c
 8007078:	e012      	b.n	80070a0 <mp_prime_is_prime+0x50>
      if (mp_cmp_d(a, ltm_prime_tab[ix]) == MP_EQ) {
 800707a:	4a30      	ldr	r2, [pc, #192]	; (800713c <mp_prime_is_prime+0xec>)
 800707c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800707e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007082:	4619      	mov	r1, r3
 8007084:	9803      	ldr	r0, [sp, #12]
 8007086:	f004 fd4b 	bl	800bb20 <mp_cmp_d>
 800708a:	4603      	mov	r3, r0
 800708c:	2b00      	cmp	r3, #0
 800708e:	d104      	bne.n	800709a <mp_prime_is_prime+0x4a>
         *result = 1;
 8007090:	9b01      	ldr	r3, [sp, #4]
 8007092:	2201      	movs	r2, #1
 8007094:	601a      	str	r2, [r3, #0]
         return MP_OKAY;
 8007096:	2300      	movs	r3, #0
 8007098:	e04b      	b.n	8007132 <mp_prime_is_prime+0xe2>
  for (ix = 0; ix < PRIME_SIZE; ix++) {
 800709a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800709c:	3301      	adds	r3, #1
 800709e:	930b      	str	r3, [sp, #44]	; 0x2c
 80070a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80070a2:	2bff      	cmp	r3, #255	; 0xff
 80070a4:	dde9      	ble.n	800707a <mp_prime_is_prime+0x2a>
      }
  }

  /* first perform trial division */
  if ((err = mp_prime_is_divisible (a, &res)) != MP_OKAY) {
 80070a6:	ab05      	add	r3, sp, #20
 80070a8:	4619      	mov	r1, r3
 80070aa:	9803      	ldr	r0, [sp, #12]
 80070ac:	f7ff ff10 	bl	8006ed0 <mp_prime_is_divisible>
 80070b0:	900a      	str	r0, [sp, #40]	; 0x28
 80070b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80070b4:	2b00      	cmp	r3, #0
 80070b6:	d001      	beq.n	80070bc <mp_prime_is_prime+0x6c>
    return err;
 80070b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80070ba:	e03a      	b.n	8007132 <mp_prime_is_prime+0xe2>
  }

  /* return if it was trivially divisible */
  if (res == MP_YES) {
 80070bc:	9b05      	ldr	r3, [sp, #20]
 80070be:	2b01      	cmp	r3, #1
 80070c0:	d101      	bne.n	80070c6 <mp_prime_is_prime+0x76>
    return MP_OKAY;
 80070c2:	2300      	movs	r3, #0
 80070c4:	e035      	b.n	8007132 <mp_prime_is_prime+0xe2>
  }

  /* now perform the miller-rabin rounds */
  if ((err = mp_init (&b)) != MP_OKAY) {
 80070c6:	ab06      	add	r3, sp, #24
 80070c8:	4618      	mov	r0, r3
 80070ca:	f003 fa99 	bl	800a600 <mp_init>
 80070ce:	900a      	str	r0, [sp, #40]	; 0x28
 80070d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80070d2:	2b00      	cmp	r3, #0
 80070d4:	d001      	beq.n	80070da <mp_prime_is_prime+0x8a>
    return err;
 80070d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80070d8:	e02b      	b.n	8007132 <mp_prime_is_prime+0xe2>
  }

  for (ix = 0; ix < t; ix++) {
 80070da:	2300      	movs	r3, #0
 80070dc:	930b      	str	r3, [sp, #44]	; 0x2c
 80070de:	e01c      	b.n	800711a <mp_prime_is_prime+0xca>
    /* set the prime */
    if ((err = mp_set (&b, ltm_prime_tab[ix])) != MP_OKAY) {
 80070e0:	4a16      	ldr	r2, [pc, #88]	; (800713c <mp_prime_is_prime+0xec>)
 80070e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80070e4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80070e8:	ab06      	add	r3, sp, #24
 80070ea:	4611      	mov	r1, r2
 80070ec:	4618      	mov	r0, r3
 80070ee:	f004 fd4f 	bl	800bb90 <mp_set>
 80070f2:	900a      	str	r0, [sp, #40]	; 0x28
 80070f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80070f6:	2b00      	cmp	r3, #0
 80070f8:	d116      	bne.n	8007128 <mp_prime_is_prime+0xd8>
        goto LBL_B;
    }

    if ((err = mp_prime_miller_rabin (a, &b, &res)) != MP_OKAY) {
 80070fa:	aa05      	add	r2, sp, #20
 80070fc:	ab06      	add	r3, sp, #24
 80070fe:	4619      	mov	r1, r3
 8007100:	9803      	ldr	r0, [sp, #12]
 8007102:	f7ff fe3d 	bl	8006d80 <mp_prime_miller_rabin>
 8007106:	900a      	str	r0, [sp, #40]	; 0x28
 8007108:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800710a:	2b00      	cmp	r3, #0
 800710c:	d10c      	bne.n	8007128 <mp_prime_is_prime+0xd8>
      goto LBL_B;
    }

    if (res == MP_NO) {
 800710e:	9b05      	ldr	r3, [sp, #20]
 8007110:	2b00      	cmp	r3, #0
 8007112:	d009      	beq.n	8007128 <mp_prime_is_prime+0xd8>
  for (ix = 0; ix < t; ix++) {
 8007114:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007116:	3301      	adds	r3, #1
 8007118:	930b      	str	r3, [sp, #44]	; 0x2c
 800711a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800711c:	9b02      	ldr	r3, [sp, #8]
 800711e:	429a      	cmp	r2, r3
 8007120:	dbde      	blt.n	80070e0 <mp_prime_is_prime+0x90>
      goto LBL_B;
    }
  }

  /* passed the test */
  *result = MP_YES;
 8007122:	9b01      	ldr	r3, [sp, #4]
 8007124:	2201      	movs	r2, #1
 8007126:	601a      	str	r2, [r3, #0]
LBL_B:mp_clear (&b);
 8007128:	ab06      	add	r3, sp, #24
 800712a:	4618      	mov	r0, r3
 800712c:	f003 fa80 	bl	800a630 <mp_clear>
  return err;
 8007130:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 8007132:	4618      	mov	r0, r3
 8007134:	b00d      	add	sp, #52	; 0x34
 8007136:	f85d fb04 	ldr.w	pc, [sp], #4
 800713a:	bf00      	nop
 800713c:	08024690 	.word	0x08024690

08007140 <mp_lcm>:


/* computes least common multiple as |a*b|/(a, b) */
int mp_lcm (mp_int * a, mp_int * b, mp_int * c)
{
 8007140:	b500      	push	{lr}
 8007142:	b091      	sub	sp, #68	; 0x44
 8007144:	9005      	str	r0, [sp, #20]
 8007146:	9104      	str	r1, [sp, #16]
 8007148:	9203      	str	r2, [sp, #12]
  int     res;
  mp_int  t1, t2;


  if ((res = mp_init_multi (&t1, &t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
 800714a:	a907      	add	r1, sp, #28
 800714c:	a80b      	add	r0, sp, #44	; 0x2c
 800714e:	2300      	movs	r3, #0
 8007150:	9301      	str	r3, [sp, #4]
 8007152:	2300      	movs	r3, #0
 8007154:	9300      	str	r3, [sp, #0]
 8007156:	2300      	movs	r3, #0
 8007158:	2200      	movs	r2, #0
 800715a:	f005 fc99 	bl	800ca90 <mp_init_multi>
 800715e:	900f      	str	r0, [sp, #60]	; 0x3c
 8007160:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007162:	2b00      	cmp	r3, #0
 8007164:	d001      	beq.n	800716a <mp_lcm+0x2a>
    return res;
 8007166:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007168:	e040      	b.n	80071ec <mp_lcm+0xac>
  }

  /* t1 = get the GCD of the two inputs */
  if ((res = mp_gcd (a, b, &t1)) != MP_OKAY) {
 800716a:	ab0b      	add	r3, sp, #44	; 0x2c
 800716c:	461a      	mov	r2, r3
 800716e:	9904      	ldr	r1, [sp, #16]
 8007170:	9805      	ldr	r0, [sp, #20]
 8007172:	f000 f845 	bl	8007200 <mp_gcd>
 8007176:	900f      	str	r0, [sp, #60]	; 0x3c
 8007178:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800717a:	2b00      	cmp	r3, #0
 800717c:	d12d      	bne.n	80071da <mp_lcm+0x9a>
    goto LBL_T;
  }

  /* divide the smallest by the GCD */
  if (mp_cmp_mag(a, b) == MP_LT) {
 800717e:	9904      	ldr	r1, [sp, #16]
 8007180:	9805      	ldr	r0, [sp, #20]
 8007182:	f004 fc55 	bl	800ba30 <mp_cmp_mag>
 8007186:	4603      	mov	r3, r0
 8007188:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800718c:	d111      	bne.n	80071b2 <mp_lcm+0x72>
     /* store quotient in t2 such that t2 * b is the LCM */
     if ((res = mp_div(a, &t1, &t2, NULL)) != MP_OKAY) {
 800718e:	aa07      	add	r2, sp, #28
 8007190:	a90b      	add	r1, sp, #44	; 0x2c
 8007192:	2300      	movs	r3, #0
 8007194:	9805      	ldr	r0, [sp, #20]
 8007196:	f004 fd6b 	bl	800bc70 <mp_div>
 800719a:	900f      	str	r0, [sp, #60]	; 0x3c
 800719c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800719e:	2b00      	cmp	r3, #0
 80071a0:	d11b      	bne.n	80071da <mp_lcm+0x9a>
        goto LBL_T;
     }
     res = mp_mul(b, &t2, c);
 80071a2:	ab07      	add	r3, sp, #28
 80071a4:	9a03      	ldr	r2, [sp, #12]
 80071a6:	4619      	mov	r1, r3
 80071a8:	9804      	ldr	r0, [sp, #16]
 80071aa:	f001 ff69 	bl	8009080 <mp_mul>
 80071ae:	900f      	str	r0, [sp, #60]	; 0x3c
 80071b0:	e010      	b.n	80071d4 <mp_lcm+0x94>
  } else {
     /* store quotient in t2 such that t2 * a is the LCM */
     if ((res = mp_div(b, &t1, &t2, NULL)) != MP_OKAY) {
 80071b2:	aa07      	add	r2, sp, #28
 80071b4:	a90b      	add	r1, sp, #44	; 0x2c
 80071b6:	2300      	movs	r3, #0
 80071b8:	9804      	ldr	r0, [sp, #16]
 80071ba:	f004 fd59 	bl	800bc70 <mp_div>
 80071be:	900f      	str	r0, [sp, #60]	; 0x3c
 80071c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80071c2:	2b00      	cmp	r3, #0
 80071c4:	d109      	bne.n	80071da <mp_lcm+0x9a>
        goto LBL_T;
     }
     res = mp_mul(a, &t2, c);
 80071c6:	ab07      	add	r3, sp, #28
 80071c8:	9a03      	ldr	r2, [sp, #12]
 80071ca:	4619      	mov	r1, r3
 80071cc:	9805      	ldr	r0, [sp, #20]
 80071ce:	f001 ff57 	bl	8009080 <mp_mul>
 80071d2:	900f      	str	r0, [sp, #60]	; 0x3c
  }

  /* fix the sign to positive */
  c->sign = MP_ZPOS;
 80071d4:	9b03      	ldr	r3, [sp, #12]
 80071d6:	2200      	movs	r2, #0
 80071d8:	609a      	str	r2, [r3, #8]

LBL_T:
  mp_clear(&t1);
 80071da:	ab0b      	add	r3, sp, #44	; 0x2c
 80071dc:	4618      	mov	r0, r3
 80071de:	f003 fa27 	bl	800a630 <mp_clear>
  mp_clear(&t2);
 80071e2:	ab07      	add	r3, sp, #28
 80071e4:	4618      	mov	r0, r3
 80071e6:	f003 fa23 	bl	800a630 <mp_clear>
  return res;
 80071ea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
 80071ec:	4618      	mov	r0, r3
 80071ee:	b011      	add	sp, #68	; 0x44
 80071f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08007200 <mp_gcd>:



/* Greatest Common Divisor using the binary method */
int mp_gcd (mp_int * a, mp_int * b, mp_int * c)
{
 8007200:	b500      	push	{lr}
 8007202:	b091      	sub	sp, #68	; 0x44
 8007204:	9003      	str	r0, [sp, #12]
 8007206:	9102      	str	r1, [sp, #8]
 8007208:	9201      	str	r2, [sp, #4]
    mp_int  u, v;
    int     k, u_lsb, v_lsb, res;

    /* either zero than gcd is the largest */
    if (mp_iszero (a) == MP_YES) {
 800720a:	9b03      	ldr	r3, [sp, #12]
 800720c:	681b      	ldr	r3, [r3, #0]
 800720e:	2b00      	cmp	r3, #0
 8007210:	d105      	bne.n	800721e <mp_gcd+0x1e>
        return mp_abs (b, c);
 8007212:	9901      	ldr	r1, [sp, #4]
 8007214:	9802      	ldr	r0, [sp, #8]
 8007216:	f004 f823 	bl	800b260 <mp_abs>
 800721a:	4603      	mov	r3, r0
 800721c:	e0ac      	b.n	8007378 <mp_gcd+0x178>
    }
    if (mp_iszero (b) == MP_YES) {
 800721e:	9b02      	ldr	r3, [sp, #8]
 8007220:	681b      	ldr	r3, [r3, #0]
 8007222:	2b00      	cmp	r3, #0
 8007224:	d105      	bne.n	8007232 <mp_gcd+0x32>
        return mp_abs (a, c);
 8007226:	9901      	ldr	r1, [sp, #4]
 8007228:	9803      	ldr	r0, [sp, #12]
 800722a:	f004 f819 	bl	800b260 <mp_abs>
 800722e:	4603      	mov	r3, r0
 8007230:	e0a2      	b.n	8007378 <mp_gcd+0x178>
    }

    /* get copies of a and b we can modify */
    if ((res = mp_init_copy (&u, a)) != MP_OKAY) {
 8007232:	ab08      	add	r3, sp, #32
 8007234:	9903      	ldr	r1, [sp, #12]
 8007236:	4618      	mov	r0, r3
 8007238:	f003 fb52 	bl	800a8e0 <mp_init_copy>
 800723c:	900f      	str	r0, [sp, #60]	; 0x3c
 800723e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007240:	2b00      	cmp	r3, #0
 8007242:	d001      	beq.n	8007248 <mp_gcd+0x48>
        return res;
 8007244:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007246:	e097      	b.n	8007378 <mp_gcd+0x178>
    }

    if ((res = mp_init_copy (&v, b)) != MP_OKAY) {
 8007248:	ab04      	add	r3, sp, #16
 800724a:	9902      	ldr	r1, [sp, #8]
 800724c:	4618      	mov	r0, r3
 800724e:	f003 fb47 	bl	800a8e0 <mp_init_copy>
 8007252:	900f      	str	r0, [sp, #60]	; 0x3c
 8007254:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007256:	2b00      	cmp	r3, #0
 8007258:	f040 8089 	bne.w	800736e <mp_gcd+0x16e>
        goto LBL_U;
    }

    /* must be positive for the remainder of the algorithm */
    u.sign = v.sign = MP_ZPOS;
 800725c:	2300      	movs	r3, #0
 800725e:	9306      	str	r3, [sp, #24]
 8007260:	9b06      	ldr	r3, [sp, #24]
 8007262:	930a      	str	r3, [sp, #40]	; 0x28

    /* B1.  Find the common power of two for u and v */
    u_lsb = mp_cnt_lsb(&u);
 8007264:	ab08      	add	r3, sp, #32
 8007266:	4618      	mov	r0, r3
 8007268:	f7ff fc12 	bl	8006a90 <mp_cnt_lsb>
 800726c:	900e      	str	r0, [sp, #56]	; 0x38
    v_lsb = mp_cnt_lsb(&v);
 800726e:	ab04      	add	r3, sp, #16
 8007270:	4618      	mov	r0, r3
 8007272:	f7ff fc0d 	bl	8006a90 <mp_cnt_lsb>
 8007276:	900d      	str	r0, [sp, #52]	; 0x34
    k     = MIN(u_lsb, v_lsb);
 8007278:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800727a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800727c:	4293      	cmp	r3, r2
 800727e:	bfa8      	it	ge
 8007280:	4613      	movge	r3, r2
 8007282:	930c      	str	r3, [sp, #48]	; 0x30

    if (k > 0) {
 8007284:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007286:	2b00      	cmp	r3, #0
 8007288:	dd13      	ble.n	80072b2 <mp_gcd+0xb2>
        /* divide the power of two out */
        if ((res = mp_div_2d(&u, k, &u, NULL)) != MP_OKAY) {
 800728a:	aa08      	add	r2, sp, #32
 800728c:	a808      	add	r0, sp, #32
 800728e:	2300      	movs	r3, #0
 8007290:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007292:	f003 fbed 	bl	800aa70 <mp_div_2d>
 8007296:	900f      	str	r0, [sp, #60]	; 0x3c
 8007298:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800729a:	2b00      	cmp	r3, #0
 800729c:	d163      	bne.n	8007366 <mp_gcd+0x166>
            goto LBL_V;
        }

        if ((res = mp_div_2d(&v, k, &v, NULL)) != MP_OKAY) {
 800729e:	aa04      	add	r2, sp, #16
 80072a0:	a804      	add	r0, sp, #16
 80072a2:	2300      	movs	r3, #0
 80072a4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80072a6:	f003 fbe3 	bl	800aa70 <mp_div_2d>
 80072aa:	900f      	str	r0, [sp, #60]	; 0x3c
 80072ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80072ae:	2b00      	cmp	r3, #0
 80072b0:	d159      	bne.n	8007366 <mp_gcd+0x166>
            goto LBL_V;
        }
    }

    /* divide any remaining factors of two out */
    if (u_lsb != k) {
 80072b2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80072b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80072b6:	429a      	cmp	r2, r3
 80072b8:	d00b      	beq.n	80072d2 <mp_gcd+0xd2>
        if ((res = mp_div_2d(&u, u_lsb - k, &u, NULL)) != MP_OKAY) {
 80072ba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80072bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80072be:	1ad1      	subs	r1, r2, r3
 80072c0:	aa08      	add	r2, sp, #32
 80072c2:	a808      	add	r0, sp, #32
 80072c4:	2300      	movs	r3, #0
 80072c6:	f003 fbd3 	bl	800aa70 <mp_div_2d>
 80072ca:	900f      	str	r0, [sp, #60]	; 0x3c
 80072cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80072ce:	2b00      	cmp	r3, #0
 80072d0:	d149      	bne.n	8007366 <mp_gcd+0x166>
            goto LBL_V;
        }
    }

    if (v_lsb != k) {
 80072d2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80072d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80072d6:	429a      	cmp	r2, r3
 80072d8:	d033      	beq.n	8007342 <mp_gcd+0x142>
        if ((res = mp_div_2d(&v, v_lsb - k, &v, NULL)) != MP_OKAY) {
 80072da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80072dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80072de:	1ad1      	subs	r1, r2, r3
 80072e0:	aa04      	add	r2, sp, #16
 80072e2:	a804      	add	r0, sp, #16
 80072e4:	2300      	movs	r3, #0
 80072e6:	f003 fbc3 	bl	800aa70 <mp_div_2d>
 80072ea:	900f      	str	r0, [sp, #60]	; 0x3c
 80072ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80072ee:	2b00      	cmp	r3, #0
 80072f0:	d139      	bne.n	8007366 <mp_gcd+0x166>
 80072f2:	e026      	b.n	8007342 <mp_gcd+0x142>
        }
    }

    while (mp_iszero(&v) == MP_NO) {
        /* make sure v is the largest */
        if (mp_cmp_mag(&u, &v) == MP_GT) {
 80072f4:	aa04      	add	r2, sp, #16
 80072f6:	ab08      	add	r3, sp, #32
 80072f8:	4611      	mov	r1, r2
 80072fa:	4618      	mov	r0, r3
 80072fc:	f004 fb98 	bl	800ba30 <mp_cmp_mag>
 8007300:	4603      	mov	r3, r0
 8007302:	2b01      	cmp	r3, #1
 8007304:	d105      	bne.n	8007312 <mp_gcd+0x112>
            /* swap u and v to make sure v is >= u */
            mp_exch(&u, &v);
 8007306:	aa04      	add	r2, sp, #16
 8007308:	ab08      	add	r3, sp, #32
 800730a:	4611      	mov	r1, r2
 800730c:	4618      	mov	r0, r3
 800730e:	f003 fc77 	bl	800ac00 <mp_exch>
        }

        /* subtract smallest from largest */
        if ((res = s_mp_sub(&v, &u, &v)) != MP_OKAY) {
 8007312:	aa04      	add	r2, sp, #16
 8007314:	a908      	add	r1, sp, #32
 8007316:	ab04      	add	r3, sp, #16
 8007318:	4618      	mov	r0, r3
 800731a:	f000 fde9 	bl	8007ef0 <s_mp_sub>
 800731e:	900f      	str	r0, [sp, #60]	; 0x3c
 8007320:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007322:	2b00      	cmp	r3, #0
 8007324:	d11f      	bne.n	8007366 <mp_gcd+0x166>
            goto LBL_V;
        }

        /* Divide out all factors of two */
        if ((res = mp_div_2d(&v, mp_cnt_lsb(&v), &v, NULL)) != MP_OKAY) {
 8007326:	ab04      	add	r3, sp, #16
 8007328:	4618      	mov	r0, r3
 800732a:	f7ff fbb1 	bl	8006a90 <mp_cnt_lsb>
 800732e:	4601      	mov	r1, r0
 8007330:	aa04      	add	r2, sp, #16
 8007332:	a804      	add	r0, sp, #16
 8007334:	2300      	movs	r3, #0
 8007336:	f003 fb9b 	bl	800aa70 <mp_div_2d>
 800733a:	900f      	str	r0, [sp, #60]	; 0x3c
 800733c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800733e:	2b00      	cmp	r3, #0
 8007340:	d111      	bne.n	8007366 <mp_gcd+0x166>
    while (mp_iszero(&v) == MP_NO) {
 8007342:	9b04      	ldr	r3, [sp, #16]
 8007344:	2b00      	cmp	r3, #0
 8007346:	d1d5      	bne.n	80072f4 <mp_gcd+0xf4>
            goto LBL_V;
        }
    }

    /* multiply by 2**k which we divided out at the beginning */
    if ((res = mp_mul_2d (&u, k, c)) != MP_OKAY) {
 8007348:	ab08      	add	r3, sp, #32
 800734a:	9a01      	ldr	r2, [sp, #4]
 800734c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800734e:	4618      	mov	r0, r3
 8007350:	f003 fdce 	bl	800aef0 <mp_mul_2d>
 8007354:	900f      	str	r0, [sp, #60]	; 0x3c
 8007356:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007358:	2b00      	cmp	r3, #0
 800735a:	d104      	bne.n	8007366 <mp_gcd+0x166>
        goto LBL_V;
    }
    c->sign = MP_ZPOS;
 800735c:	9b01      	ldr	r3, [sp, #4]
 800735e:	2200      	movs	r2, #0
 8007360:	609a      	str	r2, [r3, #8]
    res = MP_OKAY;
 8007362:	2300      	movs	r3, #0
 8007364:	930f      	str	r3, [sp, #60]	; 0x3c
LBL_V:mp_clear (&u);
 8007366:	ab08      	add	r3, sp, #32
 8007368:	4618      	mov	r0, r3
 800736a:	f003 f961 	bl	800a630 <mp_clear>
LBL_U:mp_clear (&v);
 800736e:	ab04      	add	r3, sp, #16
 8007370:	4618      	mov	r0, r3
 8007372:	f003 f95d 	bl	800a630 <mp_clear>
    return res;
 8007376:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
 8007378:	4618      	mov	r0, r3
 800737a:	b011      	add	sp, #68	; 0x44
 800737c:	f85d fb04 	ldr.w	pc, [sp], #4

08007380 <rotlFixed>:
    }

#else /* generic */

    STATIC INLINE word32 rotlFixed(word32 x, word32 y)
    {
 8007380:	b082      	sub	sp, #8
 8007382:	9001      	str	r0, [sp, #4]
 8007384:	9100      	str	r1, [sp, #0]
        return (x << y) | (x >> (sizeof(y) * 8 - y));
 8007386:	9a01      	ldr	r2, [sp, #4]
 8007388:	9b00      	ldr	r3, [sp, #0]
 800738a:	f1c3 0320 	rsb	r3, r3, #32
 800738e:	fa62 f303 	ror.w	r3, r2, r3
    }
 8007392:	4618      	mov	r0, r3
 8007394:	b002      	add	sp, #8
 8007396:	4770      	bx	lr
	...

080073a0 <rotrFixed>:


    STATIC INLINE word32 rotrFixed(word32 x, word32 y)
    {
 80073a0:	b082      	sub	sp, #8
 80073a2:	9001      	str	r0, [sp, #4]
 80073a4:	9100      	str	r1, [sp, #0]
        return (x >> y) | (x << (sizeof(y) * 8 - y));
 80073a6:	9a01      	ldr	r2, [sp, #4]
 80073a8:	9b00      	ldr	r3, [sp, #0]
 80073aa:	fa62 f303 	ror.w	r3, r2, r3
    }
 80073ae:	4618      	mov	r0, r3
 80073b0:	b002      	add	sp, #8
 80073b2:	4770      	bx	lr
	...

080073c0 <ByteReverseWord32>:

#endif


STATIC INLINE word32 ByteReverseWord32(word32 value)
{
 80073c0:	b500      	push	{lr}
 80073c2:	b083      	sub	sp, #12
 80073c4:	9001      	str	r0, [sp, #4]
    /* 5 instructions with rotate instruction, 9 without */
    return (rotrFixed(value, 8U) & 0xff00ff00) |
           (rotlFixed(value, 8U) & 0x00ff00ff);
#else
    /* 6 instructions with rotate instruction, 8 without */
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 80073c6:	9b01      	ldr	r3, [sp, #4]
 80073c8:	0a1b      	lsrs	r3, r3, #8
 80073ca:	f003 12ff 	and.w	r2, r3, #16711935	; 0xff00ff
 80073ce:	9b01      	ldr	r3, [sp, #4]
 80073d0:	021b      	lsls	r3, r3, #8
 80073d2:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 80073d6:	4313      	orrs	r3, r2
 80073d8:	9301      	str	r3, [sp, #4]
    return rotlFixed(value, 16U);
 80073da:	2110      	movs	r1, #16
 80073dc:	9801      	ldr	r0, [sp, #4]
 80073de:	f7ff ffcf 	bl	8007380 <rotlFixed>
 80073e2:	4603      	mov	r3, r0
#endif
}
 80073e4:	4618      	mov	r0, r3
 80073e6:	b003      	add	sp, #12
 80073e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80073ec:	0000      	movs	r0, r0
	...

080073f0 <ByteReverseWords.lto_priv.357>:


STATIC INLINE void ByteReverseWords(word32* out, const word32* in,
                                    word32 byteCount)
{
 80073f0:	b510      	push	{r4, lr}
 80073f2:	b086      	sub	sp, #24
 80073f4:	9003      	str	r0, [sp, #12]
 80073f6:	9102      	str	r1, [sp, #8]
 80073f8:	9201      	str	r2, [sp, #4]
    word32 count = byteCount/(word32)sizeof(word32), i;
 80073fa:	9b01      	ldr	r3, [sp, #4]
 80073fc:	089b      	lsrs	r3, r3, #2
 80073fe:	9304      	str	r3, [sp, #16]

    for (i = 0; i < count; i++)
 8007400:	2300      	movs	r3, #0
 8007402:	9305      	str	r3, [sp, #20]
 8007404:	e010      	b.n	8007428 <ByteReverseWords.lto_priv.357+0x38>
        out[i] = ByteReverseWord32(in[i]);
 8007406:	9b05      	ldr	r3, [sp, #20]
 8007408:	009b      	lsls	r3, r3, #2
 800740a:	9a03      	ldr	r2, [sp, #12]
 800740c:	18d4      	adds	r4, r2, r3
 800740e:	9b05      	ldr	r3, [sp, #20]
 8007410:	009b      	lsls	r3, r3, #2
 8007412:	9a02      	ldr	r2, [sp, #8]
 8007414:	4413      	add	r3, r2
 8007416:	681b      	ldr	r3, [r3, #0]
 8007418:	4618      	mov	r0, r3
 800741a:	f7ff ffd1 	bl	80073c0 <ByteReverseWord32>
 800741e:	4603      	mov	r3, r0
 8007420:	6023      	str	r3, [r4, #0]
    for (i = 0; i < count; i++)
 8007422:	9b05      	ldr	r3, [sp, #20]
 8007424:	3301      	adds	r3, #1
 8007426:	9305      	str	r3, [sp, #20]
 8007428:	9a05      	ldr	r2, [sp, #20]
 800742a:	9b04      	ldr	r3, [sp, #16]
 800742c:	429a      	cmp	r2, r3
 800742e:	d3ea      	bcc.n	8007406 <ByteReverseWords.lto_priv.357+0x16>

}
 8007430:	b006      	add	sp, #24
 8007432:	bd10      	pop	{r4, pc}
	...

08007440 <min.lto_priv.361>:
    #define WOLFSSL_HAVE_MIN
    #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
        #define min min
    #endif
    STATIC INLINE word32 min(word32 a, word32 b)
    {
 8007440:	b082      	sub	sp, #8
 8007442:	9001      	str	r0, [sp, #4]
 8007444:	9100      	str	r1, [sp, #0]
        return a > b ? b : a;
 8007446:	9a01      	ldr	r2, [sp, #4]
 8007448:	9b00      	ldr	r3, [sp, #0]
 800744a:	4293      	cmp	r3, r2
 800744c:	bf28      	it	cs
 800744e:	4613      	movcs	r3, r2
    }
 8007450:	4618      	mov	r0, r3
 8007452:	b002      	add	sp, #8
 8007454:	4770      	bx	lr
 8007456:	bf00      	nop
	...

08007460 <InitSha256.lto_priv.358>:
{
 8007460:	b500      	push	{lr}
 8007462:	b085      	sub	sp, #20
 8007464:	9001      	str	r0, [sp, #4]
    int ret = 0;
 8007466:	2300      	movs	r3, #0
 8007468:	9303      	str	r3, [sp, #12]
    if (sha256 == NULL)
 800746a:	9b01      	ldr	r3, [sp, #4]
 800746c:	2b00      	cmp	r3, #0
 800746e:	d102      	bne.n	8007476 <InitSha256.lto_priv.358+0x16>
        return BAD_FUNC_ARG;
 8007470:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007474:	e027      	b.n	80074c6 <InitSha256.lto_priv.358+0x66>
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 8007476:	9b01      	ldr	r3, [sp, #4]
 8007478:	2220      	movs	r2, #32
 800747a:	2100      	movs	r1, #0
 800747c:	4618      	mov	r0, r3
 800747e:	f016 f9a9 	bl	801d7d4 <memset>
    sha256->digest[0] = 0x6A09E667L;
 8007482:	9b01      	ldr	r3, [sp, #4]
 8007484:	4a12      	ldr	r2, [pc, #72]	; (80074d0 <InitSha256.lto_priv.358+0x70>)
 8007486:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
 8007488:	9b01      	ldr	r3, [sp, #4]
 800748a:	4a12      	ldr	r2, [pc, #72]	; (80074d4 <InitSha256.lto_priv.358+0x74>)
 800748c:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
 800748e:	9b01      	ldr	r3, [sp, #4]
 8007490:	4a11      	ldr	r2, [pc, #68]	; (80074d8 <InitSha256.lto_priv.358+0x78>)
 8007492:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
 8007494:	9b01      	ldr	r3, [sp, #4]
 8007496:	4a11      	ldr	r2, [pc, #68]	; (80074dc <InitSha256.lto_priv.358+0x7c>)
 8007498:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
 800749a:	9b01      	ldr	r3, [sp, #4]
 800749c:	4a10      	ldr	r2, [pc, #64]	; (80074e0 <InitSha256.lto_priv.358+0x80>)
 800749e:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
 80074a0:	9b01      	ldr	r3, [sp, #4]
 80074a2:	4a10      	ldr	r2, [pc, #64]	; (80074e4 <InitSha256.lto_priv.358+0x84>)
 80074a4:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
 80074a6:	9b01      	ldr	r3, [sp, #4]
 80074a8:	4a0f      	ldr	r2, [pc, #60]	; (80074e8 <InitSha256.lto_priv.358+0x88>)
 80074aa:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
 80074ac:	9b01      	ldr	r3, [sp, #4]
 80074ae:	4a0f      	ldr	r2, [pc, #60]	; (80074ec <InitSha256.lto_priv.358+0x8c>)
 80074b0:	61da      	str	r2, [r3, #28]
    sha256->buffLen = 0;
 80074b2:	9b01      	ldr	r3, [sp, #4]
 80074b4:	2200      	movs	r2, #0
 80074b6:	661a      	str	r2, [r3, #96]	; 0x60
    sha256->loLen   = 0;
 80074b8:	9b01      	ldr	r3, [sp, #4]
 80074ba:	2200      	movs	r2, #0
 80074bc:	665a      	str	r2, [r3, #100]	; 0x64
    sha256->hiLen   = 0;
 80074be:	9b01      	ldr	r3, [sp, #4]
 80074c0:	2200      	movs	r2, #0
 80074c2:	669a      	str	r2, [r3, #104]	; 0x68
    return ret;
 80074c4:	9b03      	ldr	r3, [sp, #12]
}
 80074c6:	4618      	mov	r0, r3
 80074c8:	b005      	add	sp, #20
 80074ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80074ce:	bf00      	nop
 80074d0:	6a09e667 	.word	0x6a09e667
 80074d4:	bb67ae85 	.word	0xbb67ae85
 80074d8:	3c6ef372 	.word	0x3c6ef372
 80074dc:	a54ff53a 	.word	0xa54ff53a
 80074e0:	510e527f 	.word	0x510e527f
 80074e4:	9b05688c 	.word	0x9b05688c
 80074e8:	1f83d9ab 	.word	0x1f83d9ab
 80074ec:	5be0cd19 	.word	0x5be0cd19

080074f0 <wc_InitSha256_ex>:
    {
 80074f0:	b500      	push	{lr}
 80074f2:	b087      	sub	sp, #28
 80074f4:	9003      	str	r0, [sp, #12]
 80074f6:	9102      	str	r1, [sp, #8]
 80074f8:	9201      	str	r2, [sp, #4]
        int ret = 0;
 80074fa:	2300      	movs	r3, #0
 80074fc:	9305      	str	r3, [sp, #20]
        if (sha256 == NULL)
 80074fe:	9b03      	ldr	r3, [sp, #12]
 8007500:	2b00      	cmp	r3, #0
 8007502:	d102      	bne.n	800750a <wc_InitSha256_ex+0x1a>
            return BAD_FUNC_ARG;
 8007504:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8007508:	e00c      	b.n	8007524 <wc_InitSha256_ex+0x34>
        sha256->heap = heap;
 800750a:	9b03      	ldr	r3, [sp, #12]
 800750c:	9a02      	ldr	r2, [sp, #8]
 800750e:	66da      	str	r2, [r3, #108]	; 0x6c
        ret = InitSha256(sha256);
 8007510:	9803      	ldr	r0, [sp, #12]
 8007512:	f7ff ffa5 	bl	8007460 <InitSha256.lto_priv.358>
 8007516:	9005      	str	r0, [sp, #20]
        if (ret != 0)
 8007518:	9b05      	ldr	r3, [sp, #20]
 800751a:	2b00      	cmp	r3, #0
 800751c:	d001      	beq.n	8007522 <wc_InitSha256_ex+0x32>
            return ret;
 800751e:	9b05      	ldr	r3, [sp, #20]
 8007520:	e000      	b.n	8007524 <wc_InitSha256_ex+0x34>
        return ret;
 8007522:	9b05      	ldr	r3, [sp, #20]
    }
 8007524:	4618      	mov	r0, r3
 8007526:	b007      	add	sp, #28
 8007528:	f85d fb04 	ldr.w	pc, [sp], #4
 800752c:	0000      	movs	r0, r0
	...

08007530 <Transform.lto_priv.359>:
    {
 8007530:	b570      	push	{r4, r5, r6, lr}
 8007532:	b08e      	sub	sp, #56	; 0x38
 8007534:	9001      	str	r0, [sp, #4]
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 8007536:	f44f 7180 	mov.w	r1, #256	; 0x100
 800753a:	2000      	movs	r0, #0
 800753c:	f7fe f990 	bl	8005860 <chibios_alloc>
 8007540:	900c      	str	r0, [sp, #48]	; 0x30
        if (W == NULL)
 8007542:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007544:	2b00      	cmp	r3, #0
 8007546:	d102      	bne.n	800754e <Transform.lto_priv.359+0x1e>
            return MEMORY_E;
 8007548:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800754c:	e359      	b.n	8007c02 <Transform.lto_priv.359+0x6d2>
        for (i = 0; i < 8; i++)
 800754e:	2300      	movs	r3, #0
 8007550:	930d      	str	r3, [sp, #52]	; 0x34
 8007552:	e00c      	b.n	800756e <Transform.lto_priv.359+0x3e>
            S[i] = sha256->digest[i];
 8007554:	9b01      	ldr	r3, [sp, #4]
 8007556:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007558:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800755c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800755e:	009b      	lsls	r3, r3, #2
 8007560:	a90e      	add	r1, sp, #56	; 0x38
 8007562:	440b      	add	r3, r1
 8007564:	f843 2c30 	str.w	r2, [r3, #-48]
        for (i = 0; i < 8; i++)
 8007568:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800756a:	3301      	adds	r3, #1
 800756c:	930d      	str	r3, [sp, #52]	; 0x34
 800756e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007570:	2b07      	cmp	r3, #7
 8007572:	ddef      	ble.n	8007554 <Transform.lto_priv.359+0x24>
        for (i = 0; i < 16; i++)
 8007574:	2300      	movs	r3, #0
 8007576:	930d      	str	r3, [sp, #52]	; 0x34
 8007578:	e00c      	b.n	8007594 <Transform.lto_priv.359+0x64>
            W[i] = sha256->buffer[i];
 800757a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800757c:	009b      	lsls	r3, r3, #2
 800757e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007580:	4413      	add	r3, r2
 8007582:	9a01      	ldr	r2, [sp, #4]
 8007584:	990d      	ldr	r1, [sp, #52]	; 0x34
 8007586:	3108      	adds	r1, #8
 8007588:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800758c:	601a      	str	r2, [r3, #0]
        for (i = 0; i < 16; i++)
 800758e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007590:	3301      	adds	r3, #1
 8007592:	930d      	str	r3, [sp, #52]	; 0x34
 8007594:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007596:	2b0f      	cmp	r3, #15
 8007598:	ddef      	ble.n	800757a <Transform.lto_priv.359+0x4a>
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 800759a:	2310      	movs	r3, #16
 800759c:	930d      	str	r3, [sp, #52]	; 0x34
 800759e:	e066      	b.n	800766e <Transform.lto_priv.359+0x13e>
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 80075a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075a2:	009b      	lsls	r3, r3, #2
 80075a4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80075a6:	18d4      	adds	r4, r2, r3
 80075a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075aa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80075ae:	3b02      	subs	r3, #2
 80075b0:	009b      	lsls	r3, r3, #2
 80075b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80075b4:	4413      	add	r3, r2
 80075b6:	681b      	ldr	r3, [r3, #0]
 80075b8:	2111      	movs	r1, #17
 80075ba:	4618      	mov	r0, r3
 80075bc:	f7ff fef0 	bl	80073a0 <rotrFixed>
 80075c0:	4605      	mov	r5, r0
 80075c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075c4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80075c8:	3b02      	subs	r3, #2
 80075ca:	009b      	lsls	r3, r3, #2
 80075cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80075ce:	4413      	add	r3, r2
 80075d0:	681b      	ldr	r3, [r3, #0]
 80075d2:	2113      	movs	r1, #19
 80075d4:	4618      	mov	r0, r3
 80075d6:	f7ff fee3 	bl	80073a0 <rotrFixed>
 80075da:	4603      	mov	r3, r0
 80075dc:	ea85 0203 	eor.w	r2, r5, r3
 80075e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075e2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80075e6:	3b02      	subs	r3, #2
 80075e8:	009b      	lsls	r3, r3, #2
 80075ea:	990c      	ldr	r1, [sp, #48]	; 0x30
 80075ec:	440b      	add	r3, r1
 80075ee:	681b      	ldr	r3, [r3, #0]
 80075f0:	0a9b      	lsrs	r3, r3, #10
 80075f2:	405a      	eors	r2, r3
 80075f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80075f6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80075fa:	3b07      	subs	r3, #7
 80075fc:	009b      	lsls	r3, r3, #2
 80075fe:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007600:	440b      	add	r3, r1
 8007602:	681b      	ldr	r3, [r3, #0]
 8007604:	18d5      	adds	r5, r2, r3
 8007606:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007608:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800760c:	3b0f      	subs	r3, #15
 800760e:	009b      	lsls	r3, r3, #2
 8007610:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007612:	4413      	add	r3, r2
 8007614:	681b      	ldr	r3, [r3, #0]
 8007616:	2107      	movs	r1, #7
 8007618:	4618      	mov	r0, r3
 800761a:	f7ff fec1 	bl	80073a0 <rotrFixed>
 800761e:	4606      	mov	r6, r0
 8007620:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007622:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007626:	3b0f      	subs	r3, #15
 8007628:	009b      	lsls	r3, r3, #2
 800762a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800762c:	4413      	add	r3, r2
 800762e:	681b      	ldr	r3, [r3, #0]
 8007630:	2112      	movs	r1, #18
 8007632:	4618      	mov	r0, r3
 8007634:	f7ff feb4 	bl	80073a0 <rotrFixed>
 8007638:	4603      	mov	r3, r0
 800763a:	ea86 0203 	eor.w	r2, r6, r3
 800763e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007640:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007644:	3b0f      	subs	r3, #15
 8007646:	009b      	lsls	r3, r3, #2
 8007648:	990c      	ldr	r1, [sp, #48]	; 0x30
 800764a:	440b      	add	r3, r1
 800764c:	681b      	ldr	r3, [r3, #0]
 800764e:	08db      	lsrs	r3, r3, #3
 8007650:	4053      	eors	r3, r2
 8007652:	18ea      	adds	r2, r5, r3
 8007654:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007656:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800765a:	3b10      	subs	r3, #16
 800765c:	009b      	lsls	r3, r3, #2
 800765e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007660:	440b      	add	r3, r1
 8007662:	681b      	ldr	r3, [r3, #0]
 8007664:	4413      	add	r3, r2
 8007666:	6023      	str	r3, [r4, #0]
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 8007668:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800766a:	3301      	adds	r3, #1
 800766c:	930d      	str	r3, [sp, #52]	; 0x34
 800766e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007670:	2b3f      	cmp	r3, #63	; 0x3f
 8007672:	dd95      	ble.n	80075a0 <Transform.lto_priv.359+0x70>
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8007674:	2300      	movs	r3, #0
 8007676:	930d      	str	r3, [sp, #52]	; 0x34
 8007678:	e2a3      	b.n	8007bc2 <Transform.lto_priv.359+0x692>
            RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i+0);
 800767a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800767c:	9b06      	ldr	r3, [sp, #24]
 800767e:	2106      	movs	r1, #6
 8007680:	4618      	mov	r0, r3
 8007682:	f7ff fe8d 	bl	80073a0 <rotrFixed>
 8007686:	4605      	mov	r5, r0
 8007688:	9b06      	ldr	r3, [sp, #24]
 800768a:	210b      	movs	r1, #11
 800768c:	4618      	mov	r0, r3
 800768e:	f7ff fe87 	bl	80073a0 <rotrFixed>
 8007692:	4603      	mov	r3, r0
 8007694:	405d      	eors	r5, r3
 8007696:	9b06      	ldr	r3, [sp, #24]
 8007698:	2119      	movs	r1, #25
 800769a:	4618      	mov	r0, r3
 800769c:	f7ff fe80 	bl	80073a0 <rotrFixed>
 80076a0:	4603      	mov	r3, r0
 80076a2:	406b      	eors	r3, r5
 80076a4:	18e2      	adds	r2, r4, r3
 80076a6:	9908      	ldr	r1, [sp, #32]
 80076a8:	9806      	ldr	r0, [sp, #24]
 80076aa:	9c07      	ldr	r4, [sp, #28]
 80076ac:	9b08      	ldr	r3, [sp, #32]
 80076ae:	4063      	eors	r3, r4
 80076b0:	4003      	ands	r3, r0
 80076b2:	404b      	eors	r3, r1
 80076b4:	441a      	add	r2, r3
 80076b6:	49bd      	ldr	r1, [pc, #756]	; (80079ac <Transform.lto_priv.359+0x47c>)
 80076b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80076ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80076be:	441a      	add	r2, r3
 80076c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80076c2:	009b      	lsls	r3, r3, #2
 80076c4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80076c6:	440b      	add	r3, r1
 80076c8:	681b      	ldr	r3, [r3, #0]
 80076ca:	4413      	add	r3, r2
 80076cc:	930b      	str	r3, [sp, #44]	; 0x2c
 80076ce:	9b02      	ldr	r3, [sp, #8]
 80076d0:	2102      	movs	r1, #2
 80076d2:	4618      	mov	r0, r3
 80076d4:	f7ff fe64 	bl	80073a0 <rotrFixed>
 80076d8:	4604      	mov	r4, r0
 80076da:	9b02      	ldr	r3, [sp, #8]
 80076dc:	210d      	movs	r1, #13
 80076de:	4618      	mov	r0, r3
 80076e0:	f7ff fe5e 	bl	80073a0 <rotrFixed>
 80076e4:	4603      	mov	r3, r0
 80076e6:	405c      	eors	r4, r3
 80076e8:	9b02      	ldr	r3, [sp, #8]
 80076ea:	2116      	movs	r1, #22
 80076ec:	4618      	mov	r0, r3
 80076ee:	f7ff fe57 	bl	80073a0 <rotrFixed>
 80076f2:	4603      	mov	r3, r0
 80076f4:	ea84 0203 	eor.w	r2, r4, r3
 80076f8:	9902      	ldr	r1, [sp, #8]
 80076fa:	9b03      	ldr	r3, [sp, #12]
 80076fc:	4319      	orrs	r1, r3
 80076fe:	9b04      	ldr	r3, [sp, #16]
 8007700:	4019      	ands	r1, r3
 8007702:	9802      	ldr	r0, [sp, #8]
 8007704:	9b03      	ldr	r3, [sp, #12]
 8007706:	4003      	ands	r3, r0
 8007708:	430b      	orrs	r3, r1
 800770a:	4413      	add	r3, r2
 800770c:	930a      	str	r3, [sp, #40]	; 0x28
 800770e:	9a05      	ldr	r2, [sp, #20]
 8007710:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007712:	4413      	add	r3, r2
 8007714:	9305      	str	r3, [sp, #20]
 8007716:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007718:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800771a:	4413      	add	r3, r2
 800771c:	9309      	str	r3, [sp, #36]	; 0x24
            RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],i+1);
 800771e:	9c08      	ldr	r4, [sp, #32]
 8007720:	9b05      	ldr	r3, [sp, #20]
 8007722:	2106      	movs	r1, #6
 8007724:	4618      	mov	r0, r3
 8007726:	f7ff fe3b 	bl	80073a0 <rotrFixed>
 800772a:	4605      	mov	r5, r0
 800772c:	9b05      	ldr	r3, [sp, #20]
 800772e:	210b      	movs	r1, #11
 8007730:	4618      	mov	r0, r3
 8007732:	f7ff fe35 	bl	80073a0 <rotrFixed>
 8007736:	4603      	mov	r3, r0
 8007738:	405d      	eors	r5, r3
 800773a:	9b05      	ldr	r3, [sp, #20]
 800773c:	2119      	movs	r1, #25
 800773e:	4618      	mov	r0, r3
 8007740:	f7ff fe2e 	bl	80073a0 <rotrFixed>
 8007744:	4603      	mov	r3, r0
 8007746:	406b      	eors	r3, r5
 8007748:	18e2      	adds	r2, r4, r3
 800774a:	9907      	ldr	r1, [sp, #28]
 800774c:	9805      	ldr	r0, [sp, #20]
 800774e:	9c06      	ldr	r4, [sp, #24]
 8007750:	9b07      	ldr	r3, [sp, #28]
 8007752:	4063      	eors	r3, r4
 8007754:	4003      	ands	r3, r0
 8007756:	404b      	eors	r3, r1
 8007758:	441a      	add	r2, r3
 800775a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800775c:	3301      	adds	r3, #1
 800775e:	4993      	ldr	r1, [pc, #588]	; (80079ac <Transform.lto_priv.359+0x47c>)
 8007760:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007764:	441a      	add	r2, r3
 8007766:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007768:	3301      	adds	r3, #1
 800776a:	009b      	lsls	r3, r3, #2
 800776c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800776e:	440b      	add	r3, r1
 8007770:	681b      	ldr	r3, [r3, #0]
 8007772:	4413      	add	r3, r2
 8007774:	930b      	str	r3, [sp, #44]	; 0x2c
 8007776:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007778:	2102      	movs	r1, #2
 800777a:	4618      	mov	r0, r3
 800777c:	f7ff fe10 	bl	80073a0 <rotrFixed>
 8007780:	4604      	mov	r4, r0
 8007782:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007784:	210d      	movs	r1, #13
 8007786:	4618      	mov	r0, r3
 8007788:	f7ff fe0a 	bl	80073a0 <rotrFixed>
 800778c:	4603      	mov	r3, r0
 800778e:	405c      	eors	r4, r3
 8007790:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007792:	2116      	movs	r1, #22
 8007794:	4618      	mov	r0, r3
 8007796:	f7ff fe03 	bl	80073a0 <rotrFixed>
 800779a:	4603      	mov	r3, r0
 800779c:	ea84 0203 	eor.w	r2, r4, r3
 80077a0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80077a2:	9b02      	ldr	r3, [sp, #8]
 80077a4:	4319      	orrs	r1, r3
 80077a6:	9b03      	ldr	r3, [sp, #12]
 80077a8:	4019      	ands	r1, r3
 80077aa:	9809      	ldr	r0, [sp, #36]	; 0x24
 80077ac:	9b02      	ldr	r3, [sp, #8]
 80077ae:	4003      	ands	r3, r0
 80077b0:	430b      	orrs	r3, r1
 80077b2:	4413      	add	r3, r2
 80077b4:	930a      	str	r3, [sp, #40]	; 0x28
 80077b6:	9a04      	ldr	r2, [sp, #16]
 80077b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80077ba:	4413      	add	r3, r2
 80077bc:	9304      	str	r3, [sp, #16]
 80077be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80077c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80077c2:	4413      	add	r3, r2
 80077c4:	9308      	str	r3, [sp, #32]
            RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],i+2);
 80077c6:	9c07      	ldr	r4, [sp, #28]
 80077c8:	9b04      	ldr	r3, [sp, #16]
 80077ca:	2106      	movs	r1, #6
 80077cc:	4618      	mov	r0, r3
 80077ce:	f7ff fde7 	bl	80073a0 <rotrFixed>
 80077d2:	4605      	mov	r5, r0
 80077d4:	9b04      	ldr	r3, [sp, #16]
 80077d6:	210b      	movs	r1, #11
 80077d8:	4618      	mov	r0, r3
 80077da:	f7ff fde1 	bl	80073a0 <rotrFixed>
 80077de:	4603      	mov	r3, r0
 80077e0:	405d      	eors	r5, r3
 80077e2:	9b04      	ldr	r3, [sp, #16]
 80077e4:	2119      	movs	r1, #25
 80077e6:	4618      	mov	r0, r3
 80077e8:	f7ff fdda 	bl	80073a0 <rotrFixed>
 80077ec:	4603      	mov	r3, r0
 80077ee:	406b      	eors	r3, r5
 80077f0:	18e2      	adds	r2, r4, r3
 80077f2:	9906      	ldr	r1, [sp, #24]
 80077f4:	9804      	ldr	r0, [sp, #16]
 80077f6:	9c05      	ldr	r4, [sp, #20]
 80077f8:	9b06      	ldr	r3, [sp, #24]
 80077fa:	4063      	eors	r3, r4
 80077fc:	4003      	ands	r3, r0
 80077fe:	404b      	eors	r3, r1
 8007800:	441a      	add	r2, r3
 8007802:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007804:	3302      	adds	r3, #2
 8007806:	4969      	ldr	r1, [pc, #420]	; (80079ac <Transform.lto_priv.359+0x47c>)
 8007808:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800780c:	441a      	add	r2, r3
 800780e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007810:	3302      	adds	r3, #2
 8007812:	009b      	lsls	r3, r3, #2
 8007814:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007816:	440b      	add	r3, r1
 8007818:	681b      	ldr	r3, [r3, #0]
 800781a:	4413      	add	r3, r2
 800781c:	930b      	str	r3, [sp, #44]	; 0x2c
 800781e:	9b08      	ldr	r3, [sp, #32]
 8007820:	2102      	movs	r1, #2
 8007822:	4618      	mov	r0, r3
 8007824:	f7ff fdbc 	bl	80073a0 <rotrFixed>
 8007828:	4604      	mov	r4, r0
 800782a:	9b08      	ldr	r3, [sp, #32]
 800782c:	210d      	movs	r1, #13
 800782e:	4618      	mov	r0, r3
 8007830:	f7ff fdb6 	bl	80073a0 <rotrFixed>
 8007834:	4603      	mov	r3, r0
 8007836:	405c      	eors	r4, r3
 8007838:	9b08      	ldr	r3, [sp, #32]
 800783a:	2116      	movs	r1, #22
 800783c:	4618      	mov	r0, r3
 800783e:	f7ff fdaf 	bl	80073a0 <rotrFixed>
 8007842:	4603      	mov	r3, r0
 8007844:	ea84 0203 	eor.w	r2, r4, r3
 8007848:	9908      	ldr	r1, [sp, #32]
 800784a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800784c:	4319      	orrs	r1, r3
 800784e:	9b02      	ldr	r3, [sp, #8]
 8007850:	4019      	ands	r1, r3
 8007852:	9808      	ldr	r0, [sp, #32]
 8007854:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007856:	4003      	ands	r3, r0
 8007858:	430b      	orrs	r3, r1
 800785a:	4413      	add	r3, r2
 800785c:	930a      	str	r3, [sp, #40]	; 0x28
 800785e:	9a03      	ldr	r2, [sp, #12]
 8007860:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007862:	4413      	add	r3, r2
 8007864:	9303      	str	r3, [sp, #12]
 8007866:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007868:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800786a:	4413      	add	r3, r2
 800786c:	9307      	str	r3, [sp, #28]
            RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],i+3);
 800786e:	9c06      	ldr	r4, [sp, #24]
 8007870:	9b03      	ldr	r3, [sp, #12]
 8007872:	2106      	movs	r1, #6
 8007874:	4618      	mov	r0, r3
 8007876:	f7ff fd93 	bl	80073a0 <rotrFixed>
 800787a:	4605      	mov	r5, r0
 800787c:	9b03      	ldr	r3, [sp, #12]
 800787e:	210b      	movs	r1, #11
 8007880:	4618      	mov	r0, r3
 8007882:	f7ff fd8d 	bl	80073a0 <rotrFixed>
 8007886:	4603      	mov	r3, r0
 8007888:	405d      	eors	r5, r3
 800788a:	9b03      	ldr	r3, [sp, #12]
 800788c:	2119      	movs	r1, #25
 800788e:	4618      	mov	r0, r3
 8007890:	f7ff fd86 	bl	80073a0 <rotrFixed>
 8007894:	4603      	mov	r3, r0
 8007896:	406b      	eors	r3, r5
 8007898:	18e2      	adds	r2, r4, r3
 800789a:	9905      	ldr	r1, [sp, #20]
 800789c:	9803      	ldr	r0, [sp, #12]
 800789e:	9c04      	ldr	r4, [sp, #16]
 80078a0:	9b05      	ldr	r3, [sp, #20]
 80078a2:	4063      	eors	r3, r4
 80078a4:	4003      	ands	r3, r0
 80078a6:	404b      	eors	r3, r1
 80078a8:	441a      	add	r2, r3
 80078aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80078ac:	3303      	adds	r3, #3
 80078ae:	493f      	ldr	r1, [pc, #252]	; (80079ac <Transform.lto_priv.359+0x47c>)
 80078b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80078b4:	441a      	add	r2, r3
 80078b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80078b8:	3303      	adds	r3, #3
 80078ba:	009b      	lsls	r3, r3, #2
 80078bc:	990c      	ldr	r1, [sp, #48]	; 0x30
 80078be:	440b      	add	r3, r1
 80078c0:	681b      	ldr	r3, [r3, #0]
 80078c2:	4413      	add	r3, r2
 80078c4:	930b      	str	r3, [sp, #44]	; 0x2c
 80078c6:	9b07      	ldr	r3, [sp, #28]
 80078c8:	2102      	movs	r1, #2
 80078ca:	4618      	mov	r0, r3
 80078cc:	f7ff fd68 	bl	80073a0 <rotrFixed>
 80078d0:	4604      	mov	r4, r0
 80078d2:	9b07      	ldr	r3, [sp, #28]
 80078d4:	210d      	movs	r1, #13
 80078d6:	4618      	mov	r0, r3
 80078d8:	f7ff fd62 	bl	80073a0 <rotrFixed>
 80078dc:	4603      	mov	r3, r0
 80078de:	405c      	eors	r4, r3
 80078e0:	9b07      	ldr	r3, [sp, #28]
 80078e2:	2116      	movs	r1, #22
 80078e4:	4618      	mov	r0, r3
 80078e6:	f7ff fd5b 	bl	80073a0 <rotrFixed>
 80078ea:	4603      	mov	r3, r0
 80078ec:	ea84 0203 	eor.w	r2, r4, r3
 80078f0:	9907      	ldr	r1, [sp, #28]
 80078f2:	9b08      	ldr	r3, [sp, #32]
 80078f4:	4319      	orrs	r1, r3
 80078f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80078f8:	4019      	ands	r1, r3
 80078fa:	9807      	ldr	r0, [sp, #28]
 80078fc:	9b08      	ldr	r3, [sp, #32]
 80078fe:	4003      	ands	r3, r0
 8007900:	430b      	orrs	r3, r1
 8007902:	4413      	add	r3, r2
 8007904:	930a      	str	r3, [sp, #40]	; 0x28
 8007906:	9a02      	ldr	r2, [sp, #8]
 8007908:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800790a:	4413      	add	r3, r2
 800790c:	9302      	str	r3, [sp, #8]
 800790e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007910:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007912:	4413      	add	r3, r2
 8007914:	9306      	str	r3, [sp, #24]
            RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],i+4);
 8007916:	9c05      	ldr	r4, [sp, #20]
 8007918:	9b02      	ldr	r3, [sp, #8]
 800791a:	2106      	movs	r1, #6
 800791c:	4618      	mov	r0, r3
 800791e:	f7ff fd3f 	bl	80073a0 <rotrFixed>
 8007922:	4605      	mov	r5, r0
 8007924:	9b02      	ldr	r3, [sp, #8]
 8007926:	210b      	movs	r1, #11
 8007928:	4618      	mov	r0, r3
 800792a:	f7ff fd39 	bl	80073a0 <rotrFixed>
 800792e:	4603      	mov	r3, r0
 8007930:	405d      	eors	r5, r3
 8007932:	9b02      	ldr	r3, [sp, #8]
 8007934:	2119      	movs	r1, #25
 8007936:	4618      	mov	r0, r3
 8007938:	f7ff fd32 	bl	80073a0 <rotrFixed>
 800793c:	4603      	mov	r3, r0
 800793e:	406b      	eors	r3, r5
 8007940:	18e2      	adds	r2, r4, r3
 8007942:	9904      	ldr	r1, [sp, #16]
 8007944:	9802      	ldr	r0, [sp, #8]
 8007946:	9c03      	ldr	r4, [sp, #12]
 8007948:	9b04      	ldr	r3, [sp, #16]
 800794a:	4063      	eors	r3, r4
 800794c:	4003      	ands	r3, r0
 800794e:	404b      	eors	r3, r1
 8007950:	441a      	add	r2, r3
 8007952:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007954:	3304      	adds	r3, #4
 8007956:	4915      	ldr	r1, [pc, #84]	; (80079ac <Transform.lto_priv.359+0x47c>)
 8007958:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800795c:	441a      	add	r2, r3
 800795e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007960:	3304      	adds	r3, #4
 8007962:	009b      	lsls	r3, r3, #2
 8007964:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007966:	440b      	add	r3, r1
 8007968:	681b      	ldr	r3, [r3, #0]
 800796a:	4413      	add	r3, r2
 800796c:	930b      	str	r3, [sp, #44]	; 0x2c
 800796e:	9b06      	ldr	r3, [sp, #24]
 8007970:	2102      	movs	r1, #2
 8007972:	4618      	mov	r0, r3
 8007974:	f7ff fd14 	bl	80073a0 <rotrFixed>
 8007978:	4604      	mov	r4, r0
 800797a:	9b06      	ldr	r3, [sp, #24]
 800797c:	210d      	movs	r1, #13
 800797e:	4618      	mov	r0, r3
 8007980:	f7ff fd0e 	bl	80073a0 <rotrFixed>
 8007984:	4603      	mov	r3, r0
 8007986:	405c      	eors	r4, r3
 8007988:	9b06      	ldr	r3, [sp, #24]
 800798a:	2116      	movs	r1, #22
 800798c:	4618      	mov	r0, r3
 800798e:	f7ff fd07 	bl	80073a0 <rotrFixed>
 8007992:	4603      	mov	r3, r0
 8007994:	ea84 0203 	eor.w	r2, r4, r3
 8007998:	9906      	ldr	r1, [sp, #24]
 800799a:	9b07      	ldr	r3, [sp, #28]
 800799c:	4319      	orrs	r1, r3
 800799e:	9b08      	ldr	r3, [sp, #32]
 80079a0:	4019      	ands	r1, r3
 80079a2:	9806      	ldr	r0, [sp, #24]
 80079a4:	9b07      	ldr	r3, [sp, #28]
 80079a6:	4003      	ands	r3, r0
 80079a8:	430b      	orrs	r3, r1
 80079aa:	e001      	b.n	80079b0 <Transform.lto_priv.359+0x480>
 80079ac:	08024a90 	.word	0x08024a90
 80079b0:	4413      	add	r3, r2
 80079b2:	930a      	str	r3, [sp, #40]	; 0x28
 80079b4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80079b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80079b8:	4413      	add	r3, r2
 80079ba:	9309      	str	r3, [sp, #36]	; 0x24
 80079bc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80079be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80079c0:	4413      	add	r3, r2
 80079c2:	9305      	str	r3, [sp, #20]
            RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],i+5);
 80079c4:	9c04      	ldr	r4, [sp, #16]
 80079c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80079c8:	2106      	movs	r1, #6
 80079ca:	4618      	mov	r0, r3
 80079cc:	f7ff fce8 	bl	80073a0 <rotrFixed>
 80079d0:	4605      	mov	r5, r0
 80079d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80079d4:	210b      	movs	r1, #11
 80079d6:	4618      	mov	r0, r3
 80079d8:	f7ff fce2 	bl	80073a0 <rotrFixed>
 80079dc:	4603      	mov	r3, r0
 80079de:	405d      	eors	r5, r3
 80079e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80079e2:	2119      	movs	r1, #25
 80079e4:	4618      	mov	r0, r3
 80079e6:	f7ff fcdb 	bl	80073a0 <rotrFixed>
 80079ea:	4603      	mov	r3, r0
 80079ec:	406b      	eors	r3, r5
 80079ee:	18e2      	adds	r2, r4, r3
 80079f0:	9903      	ldr	r1, [sp, #12]
 80079f2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80079f4:	9c02      	ldr	r4, [sp, #8]
 80079f6:	9b03      	ldr	r3, [sp, #12]
 80079f8:	4063      	eors	r3, r4
 80079fa:	4003      	ands	r3, r0
 80079fc:	404b      	eors	r3, r1
 80079fe:	441a      	add	r2, r3
 8007a00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007a02:	3305      	adds	r3, #5
 8007a04:	4980      	ldr	r1, [pc, #512]	; (8007c08 <Transform.lto_priv.359+0x6d8>)
 8007a06:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007a0a:	441a      	add	r2, r3
 8007a0c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007a0e:	3305      	adds	r3, #5
 8007a10:	009b      	lsls	r3, r3, #2
 8007a12:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007a14:	440b      	add	r3, r1
 8007a16:	681b      	ldr	r3, [r3, #0]
 8007a18:	4413      	add	r3, r2
 8007a1a:	930b      	str	r3, [sp, #44]	; 0x2c
 8007a1c:	9b05      	ldr	r3, [sp, #20]
 8007a1e:	2102      	movs	r1, #2
 8007a20:	4618      	mov	r0, r3
 8007a22:	f7ff fcbd 	bl	80073a0 <rotrFixed>
 8007a26:	4604      	mov	r4, r0
 8007a28:	9b05      	ldr	r3, [sp, #20]
 8007a2a:	210d      	movs	r1, #13
 8007a2c:	4618      	mov	r0, r3
 8007a2e:	f7ff fcb7 	bl	80073a0 <rotrFixed>
 8007a32:	4603      	mov	r3, r0
 8007a34:	405c      	eors	r4, r3
 8007a36:	9b05      	ldr	r3, [sp, #20]
 8007a38:	2116      	movs	r1, #22
 8007a3a:	4618      	mov	r0, r3
 8007a3c:	f7ff fcb0 	bl	80073a0 <rotrFixed>
 8007a40:	4603      	mov	r3, r0
 8007a42:	ea84 0203 	eor.w	r2, r4, r3
 8007a46:	9905      	ldr	r1, [sp, #20]
 8007a48:	9b06      	ldr	r3, [sp, #24]
 8007a4a:	4319      	orrs	r1, r3
 8007a4c:	9b07      	ldr	r3, [sp, #28]
 8007a4e:	4019      	ands	r1, r3
 8007a50:	9805      	ldr	r0, [sp, #20]
 8007a52:	9b06      	ldr	r3, [sp, #24]
 8007a54:	4003      	ands	r3, r0
 8007a56:	430b      	orrs	r3, r1
 8007a58:	4413      	add	r3, r2
 8007a5a:	930a      	str	r3, [sp, #40]	; 0x28
 8007a5c:	9a08      	ldr	r2, [sp, #32]
 8007a5e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007a60:	4413      	add	r3, r2
 8007a62:	9308      	str	r3, [sp, #32]
 8007a64:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007a66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007a68:	4413      	add	r3, r2
 8007a6a:	9304      	str	r3, [sp, #16]
            RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],i+6);
 8007a6c:	9c03      	ldr	r4, [sp, #12]
 8007a6e:	9b08      	ldr	r3, [sp, #32]
 8007a70:	2106      	movs	r1, #6
 8007a72:	4618      	mov	r0, r3
 8007a74:	f7ff fc94 	bl	80073a0 <rotrFixed>
 8007a78:	4605      	mov	r5, r0
 8007a7a:	9b08      	ldr	r3, [sp, #32]
 8007a7c:	210b      	movs	r1, #11
 8007a7e:	4618      	mov	r0, r3
 8007a80:	f7ff fc8e 	bl	80073a0 <rotrFixed>
 8007a84:	4603      	mov	r3, r0
 8007a86:	405d      	eors	r5, r3
 8007a88:	9b08      	ldr	r3, [sp, #32]
 8007a8a:	2119      	movs	r1, #25
 8007a8c:	4618      	mov	r0, r3
 8007a8e:	f7ff fc87 	bl	80073a0 <rotrFixed>
 8007a92:	4603      	mov	r3, r0
 8007a94:	406b      	eors	r3, r5
 8007a96:	18e2      	adds	r2, r4, r3
 8007a98:	9902      	ldr	r1, [sp, #8]
 8007a9a:	9808      	ldr	r0, [sp, #32]
 8007a9c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8007a9e:	9b02      	ldr	r3, [sp, #8]
 8007aa0:	4063      	eors	r3, r4
 8007aa2:	4003      	ands	r3, r0
 8007aa4:	404b      	eors	r3, r1
 8007aa6:	441a      	add	r2, r3
 8007aa8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007aaa:	3306      	adds	r3, #6
 8007aac:	4956      	ldr	r1, [pc, #344]	; (8007c08 <Transform.lto_priv.359+0x6d8>)
 8007aae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007ab2:	441a      	add	r2, r3
 8007ab4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007ab6:	3306      	adds	r3, #6
 8007ab8:	009b      	lsls	r3, r3, #2
 8007aba:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007abc:	440b      	add	r3, r1
 8007abe:	681b      	ldr	r3, [r3, #0]
 8007ac0:	4413      	add	r3, r2
 8007ac2:	930b      	str	r3, [sp, #44]	; 0x2c
 8007ac4:	9b04      	ldr	r3, [sp, #16]
 8007ac6:	2102      	movs	r1, #2
 8007ac8:	4618      	mov	r0, r3
 8007aca:	f7ff fc69 	bl	80073a0 <rotrFixed>
 8007ace:	4604      	mov	r4, r0
 8007ad0:	9b04      	ldr	r3, [sp, #16]
 8007ad2:	210d      	movs	r1, #13
 8007ad4:	4618      	mov	r0, r3
 8007ad6:	f7ff fc63 	bl	80073a0 <rotrFixed>
 8007ada:	4603      	mov	r3, r0
 8007adc:	405c      	eors	r4, r3
 8007ade:	9b04      	ldr	r3, [sp, #16]
 8007ae0:	2116      	movs	r1, #22
 8007ae2:	4618      	mov	r0, r3
 8007ae4:	f7ff fc5c 	bl	80073a0 <rotrFixed>
 8007ae8:	4603      	mov	r3, r0
 8007aea:	ea84 0203 	eor.w	r2, r4, r3
 8007aee:	9904      	ldr	r1, [sp, #16]
 8007af0:	9b05      	ldr	r3, [sp, #20]
 8007af2:	4319      	orrs	r1, r3
 8007af4:	9b06      	ldr	r3, [sp, #24]
 8007af6:	4019      	ands	r1, r3
 8007af8:	9804      	ldr	r0, [sp, #16]
 8007afa:	9b05      	ldr	r3, [sp, #20]
 8007afc:	4003      	ands	r3, r0
 8007afe:	430b      	orrs	r3, r1
 8007b00:	4413      	add	r3, r2
 8007b02:	930a      	str	r3, [sp, #40]	; 0x28
 8007b04:	9a07      	ldr	r2, [sp, #28]
 8007b06:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007b08:	4413      	add	r3, r2
 8007b0a:	9307      	str	r3, [sp, #28]
 8007b0c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007b0e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007b10:	4413      	add	r3, r2
 8007b12:	9303      	str	r3, [sp, #12]
            RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],i+7);
 8007b14:	9c02      	ldr	r4, [sp, #8]
 8007b16:	9b07      	ldr	r3, [sp, #28]
 8007b18:	2106      	movs	r1, #6
 8007b1a:	4618      	mov	r0, r3
 8007b1c:	f7ff fc40 	bl	80073a0 <rotrFixed>
 8007b20:	4605      	mov	r5, r0
 8007b22:	9b07      	ldr	r3, [sp, #28]
 8007b24:	210b      	movs	r1, #11
 8007b26:	4618      	mov	r0, r3
 8007b28:	f7ff fc3a 	bl	80073a0 <rotrFixed>
 8007b2c:	4603      	mov	r3, r0
 8007b2e:	405d      	eors	r5, r3
 8007b30:	9b07      	ldr	r3, [sp, #28]
 8007b32:	2119      	movs	r1, #25
 8007b34:	4618      	mov	r0, r3
 8007b36:	f7ff fc33 	bl	80073a0 <rotrFixed>
 8007b3a:	4603      	mov	r3, r0
 8007b3c:	406b      	eors	r3, r5
 8007b3e:	18e2      	adds	r2, r4, r3
 8007b40:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007b42:	9807      	ldr	r0, [sp, #28]
 8007b44:	9c08      	ldr	r4, [sp, #32]
 8007b46:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007b48:	4063      	eors	r3, r4
 8007b4a:	4003      	ands	r3, r0
 8007b4c:	404b      	eors	r3, r1
 8007b4e:	441a      	add	r2, r3
 8007b50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007b52:	3307      	adds	r3, #7
 8007b54:	492c      	ldr	r1, [pc, #176]	; (8007c08 <Transform.lto_priv.359+0x6d8>)
 8007b56:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007b5a:	441a      	add	r2, r3
 8007b5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007b5e:	3307      	adds	r3, #7
 8007b60:	009b      	lsls	r3, r3, #2
 8007b62:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007b64:	440b      	add	r3, r1
 8007b66:	681b      	ldr	r3, [r3, #0]
 8007b68:	4413      	add	r3, r2
 8007b6a:	930b      	str	r3, [sp, #44]	; 0x2c
 8007b6c:	9b03      	ldr	r3, [sp, #12]
 8007b6e:	2102      	movs	r1, #2
 8007b70:	4618      	mov	r0, r3
 8007b72:	f7ff fc15 	bl	80073a0 <rotrFixed>
 8007b76:	4604      	mov	r4, r0
 8007b78:	9b03      	ldr	r3, [sp, #12]
 8007b7a:	210d      	movs	r1, #13
 8007b7c:	4618      	mov	r0, r3
 8007b7e:	f7ff fc0f 	bl	80073a0 <rotrFixed>
 8007b82:	4603      	mov	r3, r0
 8007b84:	405c      	eors	r4, r3
 8007b86:	9b03      	ldr	r3, [sp, #12]
 8007b88:	2116      	movs	r1, #22
 8007b8a:	4618      	mov	r0, r3
 8007b8c:	f7ff fc08 	bl	80073a0 <rotrFixed>
 8007b90:	4603      	mov	r3, r0
 8007b92:	ea84 0203 	eor.w	r2, r4, r3
 8007b96:	9903      	ldr	r1, [sp, #12]
 8007b98:	9b04      	ldr	r3, [sp, #16]
 8007b9a:	4319      	orrs	r1, r3
 8007b9c:	9b05      	ldr	r3, [sp, #20]
 8007b9e:	4019      	ands	r1, r3
 8007ba0:	9803      	ldr	r0, [sp, #12]
 8007ba2:	9b04      	ldr	r3, [sp, #16]
 8007ba4:	4003      	ands	r3, r0
 8007ba6:	430b      	orrs	r3, r1
 8007ba8:	4413      	add	r3, r2
 8007baa:	930a      	str	r3, [sp, #40]	; 0x28
 8007bac:	9a06      	ldr	r2, [sp, #24]
 8007bae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007bb0:	4413      	add	r3, r2
 8007bb2:	9306      	str	r3, [sp, #24]
 8007bb4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007bb6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007bb8:	4413      	add	r3, r2
 8007bba:	9302      	str	r3, [sp, #8]
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8007bbc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bbe:	3308      	adds	r3, #8
 8007bc0:	930d      	str	r3, [sp, #52]	; 0x34
 8007bc2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bc4:	2b3f      	cmp	r3, #63	; 0x3f
 8007bc6:	f77f ad58 	ble.w	800767a <Transform.lto_priv.359+0x14a>
        for (i = 0; i < 8; i++) {
 8007bca:	2300      	movs	r3, #0
 8007bcc:	930d      	str	r3, [sp, #52]	; 0x34
 8007bce:	e011      	b.n	8007bf4 <Transform.lto_priv.359+0x6c4>
            sha256->digest[i] += S[i];
 8007bd0:	9b01      	ldr	r3, [sp, #4]
 8007bd2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007bd4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8007bd8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bda:	009b      	lsls	r3, r3, #2
 8007bdc:	a90e      	add	r1, sp, #56	; 0x38
 8007bde:	440b      	add	r3, r1
 8007be0:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8007be4:	18d1      	adds	r1, r2, r3
 8007be6:	9b01      	ldr	r3, [sp, #4]
 8007be8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8007bea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < 8; i++) {
 8007bee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bf0:	3301      	adds	r3, #1
 8007bf2:	930d      	str	r3, [sp, #52]	; 0x34
 8007bf4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bf6:	2b07      	cmp	r3, #7
 8007bf8:	ddea      	ble.n	8007bd0 <Transform.lto_priv.359+0x6a0>
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8007bfa:	980c      	ldr	r0, [sp, #48]	; 0x30
 8007bfc:	f7fd fe40 	bl	8005880 <chibios_free>
        return 0;
 8007c00:	2300      	movs	r3, #0
    }
 8007c02:	4618      	mov	r0, r3
 8007c04:	b00e      	add	sp, #56	; 0x38
 8007c06:	bd70      	pop	{r4, r5, r6, pc}
 8007c08:	08024a90 	.word	0x08024a90
 8007c0c:	00000000 	.word	0x00000000

08007c10 <AddLength.lto_priv.360>:
{
 8007c10:	b084      	sub	sp, #16
 8007c12:	9001      	str	r0, [sp, #4]
 8007c14:	9100      	str	r1, [sp, #0]
    word32 tmp = sha256->loLen;
 8007c16:	9b01      	ldr	r3, [sp, #4]
 8007c18:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007c1a:	9303      	str	r3, [sp, #12]
    if ( (sha256->loLen += len) < tmp)
 8007c1c:	9b01      	ldr	r3, [sp, #4]
 8007c1e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8007c20:	9b00      	ldr	r3, [sp, #0]
 8007c22:	441a      	add	r2, r3
 8007c24:	9b01      	ldr	r3, [sp, #4]
 8007c26:	665a      	str	r2, [r3, #100]	; 0x64
 8007c28:	9b01      	ldr	r3, [sp, #4]
 8007c2a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8007c2c:	9b03      	ldr	r3, [sp, #12]
 8007c2e:	429a      	cmp	r2, r3
 8007c30:	d204      	bcs.n	8007c3c <AddLength.lto_priv.360+0x2c>
        sha256->hiLen++;                       /* carry low to high */
 8007c32:	9b01      	ldr	r3, [sp, #4]
 8007c34:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007c36:	1c5a      	adds	r2, r3, #1
 8007c38:	9b01      	ldr	r3, [sp, #4]
 8007c3a:	669a      	str	r2, [r3, #104]	; 0x68
}
 8007c3c:	b004      	add	sp, #16
 8007c3e:	4770      	bx	lr

08007c40 <mp_div_2>:
{
 8007c40:	b500      	push	{lr}
 8007c42:	b08b      	sub	sp, #44	; 0x2c
 8007c44:	9001      	str	r0, [sp, #4]
 8007c46:	9100      	str	r1, [sp, #0]
  if (b->alloc < a->used) {
 8007c48:	9b00      	ldr	r3, [sp, #0]
 8007c4a:	685a      	ldr	r2, [r3, #4]
 8007c4c:	9b01      	ldr	r3, [sp, #4]
 8007c4e:	681b      	ldr	r3, [r3, #0]
 8007c50:	429a      	cmp	r2, r3
 8007c52:	da0b      	bge.n	8007c6c <mp_div_2+0x2c>
    if ((res = mp_grow (b, a->used)) != MP_OKAY) {
 8007c54:	9b01      	ldr	r3, [sp, #4]
 8007c56:	681b      	ldr	r3, [r3, #0]
 8007c58:	4619      	mov	r1, r3
 8007c5a:	9800      	ldr	r0, [sp, #0]
 8007c5c:	f002 fec8 	bl	800a9f0 <mp_grow>
 8007c60:	9005      	str	r0, [sp, #20]
 8007c62:	9b05      	ldr	r3, [sp, #20]
 8007c64:	2b00      	cmp	r3, #0
 8007c66:	d001      	beq.n	8007c6c <mp_div_2+0x2c>
      return res;
 8007c68:	9b05      	ldr	r3, [sp, #20]
 8007c6a:	e059      	b.n	8007d20 <mp_div_2+0xe0>
  oldused = b->used;
 8007c6c:	9b00      	ldr	r3, [sp, #0]
 8007c6e:	681b      	ldr	r3, [r3, #0]
 8007c70:	9304      	str	r3, [sp, #16]
  b->used = a->used;
 8007c72:	9b01      	ldr	r3, [sp, #4]
 8007c74:	681a      	ldr	r2, [r3, #0]
 8007c76:	9b00      	ldr	r3, [sp, #0]
 8007c78:	601a      	str	r2, [r3, #0]
    tmpa = a->dp + b->used - 1;
 8007c7a:	9b01      	ldr	r3, [sp, #4]
 8007c7c:	68da      	ldr	r2, [r3, #12]
 8007c7e:	9b00      	ldr	r3, [sp, #0]
 8007c80:	681b      	ldr	r3, [r3, #0]
 8007c82:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007c86:	3b01      	subs	r3, #1
 8007c88:	009b      	lsls	r3, r3, #2
 8007c8a:	4413      	add	r3, r2
 8007c8c:	9307      	str	r3, [sp, #28]
    tmpb = b->dp + b->used - 1;
 8007c8e:	9b00      	ldr	r3, [sp, #0]
 8007c90:	68da      	ldr	r2, [r3, #12]
 8007c92:	9b00      	ldr	r3, [sp, #0]
 8007c94:	681b      	ldr	r3, [r3, #0]
 8007c96:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007c9a:	3b01      	subs	r3, #1
 8007c9c:	009b      	lsls	r3, r3, #2
 8007c9e:	4413      	add	r3, r2
 8007ca0:	9306      	str	r3, [sp, #24]
    r = 0;
 8007ca2:	2300      	movs	r3, #0
 8007ca4:	9308      	str	r3, [sp, #32]
    for (x = b->used - 1; x >= 0; x--) {
 8007ca6:	9b00      	ldr	r3, [sp, #0]
 8007ca8:	681b      	ldr	r3, [r3, #0]
 8007caa:	3b01      	subs	r3, #1
 8007cac:	9309      	str	r3, [sp, #36]	; 0x24
 8007cae:	e015      	b.n	8007cdc <mp_div_2+0x9c>
      rr = *tmpa & 1;
 8007cb0:	9b07      	ldr	r3, [sp, #28]
 8007cb2:	681b      	ldr	r3, [r3, #0]
 8007cb4:	f003 0301 	and.w	r3, r3, #1
 8007cb8:	9303      	str	r3, [sp, #12]
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
 8007cba:	9b06      	ldr	r3, [sp, #24]
 8007cbc:	1f1a      	subs	r2, r3, #4
 8007cbe:	9206      	str	r2, [sp, #24]
 8007cc0:	9a07      	ldr	r2, [sp, #28]
 8007cc2:	1f11      	subs	r1, r2, #4
 8007cc4:	9107      	str	r1, [sp, #28]
 8007cc6:	6812      	ldr	r2, [r2, #0]
 8007cc8:	0851      	lsrs	r1, r2, #1
 8007cca:	9a08      	ldr	r2, [sp, #32]
 8007ccc:	06d2      	lsls	r2, r2, #27
 8007cce:	430a      	orrs	r2, r1
 8007cd0:	601a      	str	r2, [r3, #0]
      r = rr;
 8007cd2:	9b03      	ldr	r3, [sp, #12]
 8007cd4:	9308      	str	r3, [sp, #32]
    for (x = b->used - 1; x >= 0; x--) {
 8007cd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007cd8:	3b01      	subs	r3, #1
 8007cda:	9309      	str	r3, [sp, #36]	; 0x24
 8007cdc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007cde:	2b00      	cmp	r3, #0
 8007ce0:	dae6      	bge.n	8007cb0 <mp_div_2+0x70>
    tmpb = b->dp + b->used;
 8007ce2:	9b00      	ldr	r3, [sp, #0]
 8007ce4:	68da      	ldr	r2, [r3, #12]
 8007ce6:	9b00      	ldr	r3, [sp, #0]
 8007ce8:	681b      	ldr	r3, [r3, #0]
 8007cea:	009b      	lsls	r3, r3, #2
 8007cec:	4413      	add	r3, r2
 8007cee:	9306      	str	r3, [sp, #24]
    for (x = b->used; x < oldused; x++) {
 8007cf0:	9b00      	ldr	r3, [sp, #0]
 8007cf2:	681b      	ldr	r3, [r3, #0]
 8007cf4:	9309      	str	r3, [sp, #36]	; 0x24
 8007cf6:	e007      	b.n	8007d08 <mp_div_2+0xc8>
      *tmpb++ = 0;
 8007cf8:	9b06      	ldr	r3, [sp, #24]
 8007cfa:	1d1a      	adds	r2, r3, #4
 8007cfc:	9206      	str	r2, [sp, #24]
 8007cfe:	2200      	movs	r2, #0
 8007d00:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 8007d02:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007d04:	3301      	adds	r3, #1
 8007d06:	9309      	str	r3, [sp, #36]	; 0x24
 8007d08:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d0a:	9b04      	ldr	r3, [sp, #16]
 8007d0c:	429a      	cmp	r2, r3
 8007d0e:	dbf3      	blt.n	8007cf8 <mp_div_2+0xb8>
  b->sign = a->sign;
 8007d10:	9b01      	ldr	r3, [sp, #4]
 8007d12:	689a      	ldr	r2, [r3, #8]
 8007d14:	9b00      	ldr	r3, [sp, #0]
 8007d16:	609a      	str	r2, [r3, #8]
  mp_clamp (b);
 8007d18:	9800      	ldr	r0, [sp, #0]
 8007d1a:	f002 ff49 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8007d1e:	2300      	movs	r3, #0
}
 8007d20:	4618      	mov	r0, r3
 8007d22:	b00b      	add	sp, #44	; 0x2c
 8007d24:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08007d30 <mp_add>:
{
 8007d30:	b500      	push	{lr}
 8007d32:	b089      	sub	sp, #36	; 0x24
 8007d34:	9003      	str	r0, [sp, #12]
 8007d36:	9102      	str	r1, [sp, #8]
 8007d38:	9201      	str	r2, [sp, #4]
  sa = a->sign;
 8007d3a:	9b03      	ldr	r3, [sp, #12]
 8007d3c:	689b      	ldr	r3, [r3, #8]
 8007d3e:	9306      	str	r3, [sp, #24]
  sb = b->sign;
 8007d40:	9b02      	ldr	r3, [sp, #8]
 8007d42:	689b      	ldr	r3, [r3, #8]
 8007d44:	9305      	str	r3, [sp, #20]
  if (sa == sb) {
 8007d46:	9a06      	ldr	r2, [sp, #24]
 8007d48:	9b05      	ldr	r3, [sp, #20]
 8007d4a:	429a      	cmp	r2, r3
 8007d4c:	d109      	bne.n	8007d62 <mp_add+0x32>
    c->sign = sa;
 8007d4e:	9b01      	ldr	r3, [sp, #4]
 8007d50:	9a06      	ldr	r2, [sp, #24]
 8007d52:	609a      	str	r2, [r3, #8]
    res = s_mp_add (a, b, c);
 8007d54:	9a01      	ldr	r2, [sp, #4]
 8007d56:	9902      	ldr	r1, [sp, #8]
 8007d58:	9803      	ldr	r0, [sp, #12]
 8007d5a:	f000 f829 	bl	8007db0 <s_mp_add>
 8007d5e:	9007      	str	r0, [sp, #28]
 8007d60:	e01a      	b.n	8007d98 <mp_add+0x68>
    if (mp_cmp_mag (a, b) == MP_LT) {
 8007d62:	9902      	ldr	r1, [sp, #8]
 8007d64:	9803      	ldr	r0, [sp, #12]
 8007d66:	f003 fe63 	bl	800ba30 <mp_cmp_mag>
 8007d6a:	4603      	mov	r3, r0
 8007d6c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8007d70:	d109      	bne.n	8007d86 <mp_add+0x56>
      c->sign = sb;
 8007d72:	9b01      	ldr	r3, [sp, #4]
 8007d74:	9a05      	ldr	r2, [sp, #20]
 8007d76:	609a      	str	r2, [r3, #8]
      res = s_mp_sub (b, a, c);
 8007d78:	9a01      	ldr	r2, [sp, #4]
 8007d7a:	9903      	ldr	r1, [sp, #12]
 8007d7c:	9802      	ldr	r0, [sp, #8]
 8007d7e:	f000 f8b7 	bl	8007ef0 <s_mp_sub>
 8007d82:	9007      	str	r0, [sp, #28]
 8007d84:	e008      	b.n	8007d98 <mp_add+0x68>
      c->sign = sa;
 8007d86:	9b01      	ldr	r3, [sp, #4]
 8007d88:	9a06      	ldr	r2, [sp, #24]
 8007d8a:	609a      	str	r2, [r3, #8]
      res = s_mp_sub (a, b, c);
 8007d8c:	9a01      	ldr	r2, [sp, #4]
 8007d8e:	9902      	ldr	r1, [sp, #8]
 8007d90:	9803      	ldr	r0, [sp, #12]
 8007d92:	f000 f8ad 	bl	8007ef0 <s_mp_sub>
 8007d96:	9007      	str	r0, [sp, #28]
  return res;
 8007d98:	9b07      	ldr	r3, [sp, #28]
}
 8007d9a:	4618      	mov	r0, r3
 8007d9c:	b009      	add	sp, #36	; 0x24
 8007d9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007da2:	bf00      	nop
	...

08007db0 <s_mp_add>:
{
 8007db0:	b500      	push	{lr}
 8007db2:	b08f      	sub	sp, #60	; 0x3c
 8007db4:	9003      	str	r0, [sp, #12]
 8007db6:	9102      	str	r1, [sp, #8]
 8007db8:	9201      	str	r2, [sp, #4]
  if (a->used > b->used) {
 8007dba:	9b03      	ldr	r3, [sp, #12]
 8007dbc:	681a      	ldr	r2, [r3, #0]
 8007dbe:	9b02      	ldr	r3, [sp, #8]
 8007dc0:	681b      	ldr	r3, [r3, #0]
 8007dc2:	429a      	cmp	r2, r3
 8007dc4:	dd08      	ble.n	8007dd8 <s_mp_add+0x28>
    min_ab = b->used;
 8007dc6:	9b02      	ldr	r3, [sp, #8]
 8007dc8:	681b      	ldr	r3, [r3, #0]
 8007dca:	930c      	str	r3, [sp, #48]	; 0x30
    max_ab = a->used;
 8007dcc:	9b03      	ldr	r3, [sp, #12]
 8007dce:	681b      	ldr	r3, [r3, #0]
 8007dd0:	930b      	str	r3, [sp, #44]	; 0x2c
    x = a;
 8007dd2:	9b03      	ldr	r3, [sp, #12]
 8007dd4:	930d      	str	r3, [sp, #52]	; 0x34
 8007dd6:	e007      	b.n	8007de8 <s_mp_add+0x38>
    min_ab = a->used;
 8007dd8:	9b03      	ldr	r3, [sp, #12]
 8007dda:	681b      	ldr	r3, [r3, #0]
 8007ddc:	930c      	str	r3, [sp, #48]	; 0x30
    max_ab = b->used;
 8007dde:	9b02      	ldr	r3, [sp, #8]
 8007de0:	681b      	ldr	r3, [r3, #0]
 8007de2:	930b      	str	r3, [sp, #44]	; 0x2c
    x = b;
 8007de4:	9b02      	ldr	r3, [sp, #8]
 8007de6:	930d      	str	r3, [sp, #52]	; 0x34
  if (c->alloc < max_ab + 1) {
 8007de8:	9b01      	ldr	r3, [sp, #4]
 8007dea:	685a      	ldr	r2, [r3, #4]
 8007dec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007dee:	3301      	adds	r3, #1
 8007df0:	429a      	cmp	r2, r3
 8007df2:	da0b      	bge.n	8007e0c <s_mp_add+0x5c>
    if ((res = mp_grow (c, max_ab + 1)) != MP_OKAY) {
 8007df4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007df6:	3301      	adds	r3, #1
 8007df8:	4619      	mov	r1, r3
 8007dfa:	9801      	ldr	r0, [sp, #4]
 8007dfc:	f002 fdf8 	bl	800a9f0 <mp_grow>
 8007e00:	9005      	str	r0, [sp, #20]
 8007e02:	9b05      	ldr	r3, [sp, #20]
 8007e04:	2b00      	cmp	r3, #0
 8007e06:	d001      	beq.n	8007e0c <s_mp_add+0x5c>
      return res;
 8007e08:	9b05      	ldr	r3, [sp, #20]
 8007e0a:	e06d      	b.n	8007ee8 <s_mp_add+0x138>
  olduse = c->used;
 8007e0c:	9b01      	ldr	r3, [sp, #4]
 8007e0e:	681b      	ldr	r3, [r3, #0]
 8007e10:	9304      	str	r3, [sp, #16]
  c->used = max_ab + 1;
 8007e12:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e14:	1c5a      	adds	r2, r3, #1
 8007e16:	9b01      	ldr	r3, [sp, #4]
 8007e18:	601a      	str	r2, [r3, #0]
    tmpa = a->dp;
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	68db      	ldr	r3, [r3, #12]
 8007e1e:	9309      	str	r3, [sp, #36]	; 0x24
    tmpb = b->dp;
 8007e20:	9b02      	ldr	r3, [sp, #8]
 8007e22:	68db      	ldr	r3, [r3, #12]
 8007e24:	9308      	str	r3, [sp, #32]
    tmpc = c->dp;
 8007e26:	9b01      	ldr	r3, [sp, #4]
 8007e28:	68db      	ldr	r3, [r3, #12]
 8007e2a:	9307      	str	r3, [sp, #28]
    u = 0;
 8007e2c:	2300      	movs	r3, #0
 8007e2e:	930a      	str	r3, [sp, #40]	; 0x28
    for (i = 0; i < min_ab; i++) {
 8007e30:	2300      	movs	r3, #0
 8007e32:	9306      	str	r3, [sp, #24]
 8007e34:	e01a      	b.n	8007e6c <s_mp_add+0xbc>
      *tmpc = *tmpa++ + *tmpb++ + u;
 8007e36:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007e38:	1d1a      	adds	r2, r3, #4
 8007e3a:	9209      	str	r2, [sp, #36]	; 0x24
 8007e3c:	681a      	ldr	r2, [r3, #0]
 8007e3e:	9b08      	ldr	r3, [sp, #32]
 8007e40:	1d19      	adds	r1, r3, #4
 8007e42:	9108      	str	r1, [sp, #32]
 8007e44:	681b      	ldr	r3, [r3, #0]
 8007e46:	441a      	add	r2, r3
 8007e48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007e4a:	441a      	add	r2, r3
 8007e4c:	9b07      	ldr	r3, [sp, #28]
 8007e4e:	601a      	str	r2, [r3, #0]
      u = *tmpc >> ((mp_digit)DIGIT_BIT);
 8007e50:	9b07      	ldr	r3, [sp, #28]
 8007e52:	681b      	ldr	r3, [r3, #0]
 8007e54:	0f1b      	lsrs	r3, r3, #28
 8007e56:	930a      	str	r3, [sp, #40]	; 0x28
      *tmpc++ &= MP_MASK;
 8007e58:	9b07      	ldr	r3, [sp, #28]
 8007e5a:	1d1a      	adds	r2, r3, #4
 8007e5c:	9207      	str	r2, [sp, #28]
 8007e5e:	681a      	ldr	r2, [r3, #0]
 8007e60:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8007e64:	601a      	str	r2, [r3, #0]
    for (i = 0; i < min_ab; i++) {
 8007e66:	9b06      	ldr	r3, [sp, #24]
 8007e68:	3301      	adds	r3, #1
 8007e6a:	9306      	str	r3, [sp, #24]
 8007e6c:	9a06      	ldr	r2, [sp, #24]
 8007e6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007e70:	429a      	cmp	r2, r3
 8007e72:	dbe0      	blt.n	8007e36 <s_mp_add+0x86>
    if (min_ab != max_ab) {
 8007e74:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007e76:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e78:	429a      	cmp	r2, r3
 8007e7a:	d118      	bne.n	8007eae <s_mp_add+0xfe>
 8007e7c:	e01b      	b.n	8007eb6 <s_mp_add+0x106>
        *tmpc = x->dp[i] + u;
 8007e7e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007e80:	68da      	ldr	r2, [r3, #12]
 8007e82:	9b06      	ldr	r3, [sp, #24]
 8007e84:	009b      	lsls	r3, r3, #2
 8007e86:	4413      	add	r3, r2
 8007e88:	681a      	ldr	r2, [r3, #0]
 8007e8a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007e8c:	441a      	add	r2, r3
 8007e8e:	9b07      	ldr	r3, [sp, #28]
 8007e90:	601a      	str	r2, [r3, #0]
        u = *tmpc >> ((mp_digit)DIGIT_BIT);
 8007e92:	9b07      	ldr	r3, [sp, #28]
 8007e94:	681b      	ldr	r3, [r3, #0]
 8007e96:	0f1b      	lsrs	r3, r3, #28
 8007e98:	930a      	str	r3, [sp, #40]	; 0x28
        *tmpc++ &= MP_MASK;
 8007e9a:	9b07      	ldr	r3, [sp, #28]
 8007e9c:	1d1a      	adds	r2, r3, #4
 8007e9e:	9207      	str	r2, [sp, #28]
 8007ea0:	681a      	ldr	r2, [r3, #0]
 8007ea2:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8007ea6:	601a      	str	r2, [r3, #0]
      for (; i < max_ab; i++) {
 8007ea8:	9b06      	ldr	r3, [sp, #24]
 8007eaa:	3301      	adds	r3, #1
 8007eac:	9306      	str	r3, [sp, #24]
 8007eae:	9a06      	ldr	r2, [sp, #24]
 8007eb0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007eb2:	429a      	cmp	r2, r3
 8007eb4:	dbe3      	blt.n	8007e7e <s_mp_add+0xce>
    *tmpc++ = u;
 8007eb6:	9b07      	ldr	r3, [sp, #28]
 8007eb8:	1d1a      	adds	r2, r3, #4
 8007eba:	9207      	str	r2, [sp, #28]
 8007ebc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007ebe:	601a      	str	r2, [r3, #0]
    for (i = c->used; i < olduse; i++) {
 8007ec0:	9b01      	ldr	r3, [sp, #4]
 8007ec2:	681b      	ldr	r3, [r3, #0]
 8007ec4:	9306      	str	r3, [sp, #24]
 8007ec6:	e007      	b.n	8007ed8 <s_mp_add+0x128>
      *tmpc++ = 0;
 8007ec8:	9b07      	ldr	r3, [sp, #28]
 8007eca:	1d1a      	adds	r2, r3, #4
 8007ecc:	9207      	str	r2, [sp, #28]
 8007ece:	2200      	movs	r2, #0
 8007ed0:	601a      	str	r2, [r3, #0]
    for (i = c->used; i < olduse; i++) {
 8007ed2:	9b06      	ldr	r3, [sp, #24]
 8007ed4:	3301      	adds	r3, #1
 8007ed6:	9306      	str	r3, [sp, #24]
 8007ed8:	9a06      	ldr	r2, [sp, #24]
 8007eda:	9b04      	ldr	r3, [sp, #16]
 8007edc:	429a      	cmp	r2, r3
 8007ede:	dbf3      	blt.n	8007ec8 <s_mp_add+0x118>
  mp_clamp (c);
 8007ee0:	9801      	ldr	r0, [sp, #4]
 8007ee2:	f002 fe65 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8007ee6:	2300      	movs	r3, #0
}
 8007ee8:	4618      	mov	r0, r3
 8007eea:	b00f      	add	sp, #60	; 0x3c
 8007eec:	f85d fb04 	ldr.w	pc, [sp], #4

08007ef0 <s_mp_sub>:
{
 8007ef0:	b500      	push	{lr}
 8007ef2:	b08f      	sub	sp, #60	; 0x3c
 8007ef4:	9003      	str	r0, [sp, #12]
 8007ef6:	9102      	str	r1, [sp, #8]
 8007ef8:	9201      	str	r2, [sp, #4]
  min_b = b->used;
 8007efa:	9b02      	ldr	r3, [sp, #8]
 8007efc:	681b      	ldr	r3, [r3, #0]
 8007efe:	9308      	str	r3, [sp, #32]
  max_a = a->used;
 8007f00:	9b03      	ldr	r3, [sp, #12]
 8007f02:	681b      	ldr	r3, [r3, #0]
 8007f04:	9307      	str	r3, [sp, #28]
  if (c->alloc < max_a) {
 8007f06:	9b01      	ldr	r3, [sp, #4]
 8007f08:	685a      	ldr	r2, [r3, #4]
 8007f0a:	9b07      	ldr	r3, [sp, #28]
 8007f0c:	429a      	cmp	r2, r3
 8007f0e:	da09      	bge.n	8007f24 <s_mp_sub+0x34>
    if ((res = mp_grow (c, max_a)) != MP_OKAY) {
 8007f10:	9907      	ldr	r1, [sp, #28]
 8007f12:	9801      	ldr	r0, [sp, #4]
 8007f14:	f002 fd6c 	bl	800a9f0 <mp_grow>
 8007f18:	9006      	str	r0, [sp, #24]
 8007f1a:	9b06      	ldr	r3, [sp, #24]
 8007f1c:	2b00      	cmp	r3, #0
 8007f1e:	d001      	beq.n	8007f24 <s_mp_sub+0x34>
      return res;
 8007f20:	9b06      	ldr	r3, [sp, #24]
 8007f22:	e068      	b.n	8007ff6 <s_mp_sub+0x106>
  if (c->dp == NULL)
 8007f24:	9b01      	ldr	r3, [sp, #4]
 8007f26:	68db      	ldr	r3, [r3, #12]
 8007f28:	2b00      	cmp	r3, #0
 8007f2a:	d102      	bne.n	8007f32 <s_mp_sub+0x42>
     return MP_VAL;
 8007f2c:	f06f 0302 	mvn.w	r3, #2
 8007f30:	e061      	b.n	8007ff6 <s_mp_sub+0x106>
  olduse = c->used;
 8007f32:	9b01      	ldr	r3, [sp, #4]
 8007f34:	681b      	ldr	r3, [r3, #0]
 8007f36:	9305      	str	r3, [sp, #20]
  c->used = max_a;
 8007f38:	9b01      	ldr	r3, [sp, #4]
 8007f3a:	9a07      	ldr	r2, [sp, #28]
 8007f3c:	601a      	str	r2, [r3, #0]
    tmpa = a->dp;
 8007f3e:	9b03      	ldr	r3, [sp, #12]
 8007f40:	68db      	ldr	r3, [r3, #12]
 8007f42:	930c      	str	r3, [sp, #48]	; 0x30
    tmpb = b->dp;
 8007f44:	9b02      	ldr	r3, [sp, #8]
 8007f46:	68db      	ldr	r3, [r3, #12]
 8007f48:	930b      	str	r3, [sp, #44]	; 0x2c
    tmpc = c->dp;
 8007f4a:	9b01      	ldr	r3, [sp, #4]
 8007f4c:	68db      	ldr	r3, [r3, #12]
 8007f4e:	930a      	str	r3, [sp, #40]	; 0x28
    u = 0;
 8007f50:	2300      	movs	r3, #0
 8007f52:	930d      	str	r3, [sp, #52]	; 0x34
    for (i = 0; i < min_b; i++) {
 8007f54:	2300      	movs	r3, #0
 8007f56:	9309      	str	r3, [sp, #36]	; 0x24
 8007f58:	e01a      	b.n	8007f90 <s_mp_sub+0xa0>
      *tmpc = *tmpa++ - *tmpb++ - u;
 8007f5a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007f5c:	1d1a      	adds	r2, r3, #4
 8007f5e:	920c      	str	r2, [sp, #48]	; 0x30
 8007f60:	681a      	ldr	r2, [r3, #0]
 8007f62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007f64:	1d19      	adds	r1, r3, #4
 8007f66:	910b      	str	r1, [sp, #44]	; 0x2c
 8007f68:	681b      	ldr	r3, [r3, #0]
 8007f6a:	1ad2      	subs	r2, r2, r3
 8007f6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007f6e:	1ad2      	subs	r2, r2, r3
 8007f70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f72:	601a      	str	r2, [r3, #0]
      u = *tmpc >> ((mp_digit)(CHAR_BIT * sizeof (mp_digit) - 1));
 8007f74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f76:	681b      	ldr	r3, [r3, #0]
 8007f78:	0fdb      	lsrs	r3, r3, #31
 8007f7a:	930d      	str	r3, [sp, #52]	; 0x34
      *tmpc++ &= MP_MASK;
 8007f7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007f7e:	1d1a      	adds	r2, r3, #4
 8007f80:	920a      	str	r2, [sp, #40]	; 0x28
 8007f82:	681a      	ldr	r2, [r3, #0]
 8007f84:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8007f88:	601a      	str	r2, [r3, #0]
    for (i = 0; i < min_b; i++) {
 8007f8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007f8c:	3301      	adds	r3, #1
 8007f8e:	9309      	str	r3, [sp, #36]	; 0x24
 8007f90:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007f92:	9b08      	ldr	r3, [sp, #32]
 8007f94:	429a      	cmp	r2, r3
 8007f96:	dbe0      	blt.n	8007f5a <s_mp_sub+0x6a>
 8007f98:	e015      	b.n	8007fc6 <s_mp_sub+0xd6>
      *tmpc = *tmpa++ - u;
 8007f9a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007f9c:	1d1a      	adds	r2, r3, #4
 8007f9e:	920c      	str	r2, [sp, #48]	; 0x30
 8007fa0:	681a      	ldr	r2, [r3, #0]
 8007fa2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007fa4:	1ad2      	subs	r2, r2, r3
 8007fa6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007fa8:	601a      	str	r2, [r3, #0]
      u = *tmpc >> ((mp_digit)(CHAR_BIT * sizeof (mp_digit) - 1));
 8007faa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007fac:	681b      	ldr	r3, [r3, #0]
 8007fae:	0fdb      	lsrs	r3, r3, #31
 8007fb0:	930d      	str	r3, [sp, #52]	; 0x34
      *tmpc++ &= MP_MASK;
 8007fb2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007fb4:	1d1a      	adds	r2, r3, #4
 8007fb6:	920a      	str	r2, [sp, #40]	; 0x28
 8007fb8:	681a      	ldr	r2, [r3, #0]
 8007fba:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8007fbe:	601a      	str	r2, [r3, #0]
    for (; i < max_a; i++) {
 8007fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007fc2:	3301      	adds	r3, #1
 8007fc4:	9309      	str	r3, [sp, #36]	; 0x24
 8007fc6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007fc8:	9b07      	ldr	r3, [sp, #28]
 8007fca:	429a      	cmp	r2, r3
 8007fcc:	dbe5      	blt.n	8007f9a <s_mp_sub+0xaa>
    for (i = c->used; i < olduse; i++) {
 8007fce:	9b01      	ldr	r3, [sp, #4]
 8007fd0:	681b      	ldr	r3, [r3, #0]
 8007fd2:	9309      	str	r3, [sp, #36]	; 0x24
 8007fd4:	e007      	b.n	8007fe6 <s_mp_sub+0xf6>
      *tmpc++ = 0;
 8007fd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007fd8:	1d1a      	adds	r2, r3, #4
 8007fda:	920a      	str	r2, [sp, #40]	; 0x28
 8007fdc:	2200      	movs	r2, #0
 8007fde:	601a      	str	r2, [r3, #0]
    for (i = c->used; i < olduse; i++) {
 8007fe0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007fe2:	3301      	adds	r3, #1
 8007fe4:	9309      	str	r3, [sp, #36]	; 0x24
 8007fe6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007fe8:	9b05      	ldr	r3, [sp, #20]
 8007fea:	429a      	cmp	r2, r3
 8007fec:	dbf3      	blt.n	8007fd6 <s_mp_sub+0xe6>
  mp_clamp (c);
 8007fee:	9801      	ldr	r0, [sp, #4]
 8007ff0:	f002 fdde 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8007ff4:	2300      	movs	r3, #0
}
 8007ff6:	4618      	mov	r0, r3
 8007ff8:	b00f      	add	sp, #60	; 0x3c
 8007ffa:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ffe:	bf00      	nop

08008000 <mp_sub>:
{
 8008000:	b500      	push	{lr}
 8008002:	b089      	sub	sp, #36	; 0x24
 8008004:	9003      	str	r0, [sp, #12]
 8008006:	9102      	str	r1, [sp, #8]
 8008008:	9201      	str	r2, [sp, #4]
  sa = a->sign;
 800800a:	9b03      	ldr	r3, [sp, #12]
 800800c:	689b      	ldr	r3, [r3, #8]
 800800e:	9306      	str	r3, [sp, #24]
  sb = b->sign;
 8008010:	9b02      	ldr	r3, [sp, #8]
 8008012:	689b      	ldr	r3, [r3, #8]
 8008014:	9305      	str	r3, [sp, #20]
  if (sa != sb) {
 8008016:	9a06      	ldr	r2, [sp, #24]
 8008018:	9b05      	ldr	r3, [sp, #20]
 800801a:	429a      	cmp	r2, r3
 800801c:	d009      	beq.n	8008032 <mp_sub+0x32>
    c->sign = sa;
 800801e:	9b01      	ldr	r3, [sp, #4]
 8008020:	9a06      	ldr	r2, [sp, #24]
 8008022:	609a      	str	r2, [r3, #8]
    res = s_mp_add (a, b, c);
 8008024:	9a01      	ldr	r2, [sp, #4]
 8008026:	9902      	ldr	r1, [sp, #8]
 8008028:	9803      	ldr	r0, [sp, #12]
 800802a:	f7ff fec1 	bl	8007db0 <s_mp_add>
 800802e:	9007      	str	r0, [sp, #28]
 8008030:	e020      	b.n	8008074 <mp_sub+0x74>
    if (mp_cmp_mag (a, b) != MP_LT) {
 8008032:	9902      	ldr	r1, [sp, #8]
 8008034:	9803      	ldr	r0, [sp, #12]
 8008036:	f003 fcfb 	bl	800ba30 <mp_cmp_mag>
 800803a:	4603      	mov	r3, r0
 800803c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008040:	d009      	beq.n	8008056 <mp_sub+0x56>
      c->sign = sa;
 8008042:	9b01      	ldr	r3, [sp, #4]
 8008044:	9a06      	ldr	r2, [sp, #24]
 8008046:	609a      	str	r2, [r3, #8]
      res = s_mp_sub (a, b, c);
 8008048:	9a01      	ldr	r2, [sp, #4]
 800804a:	9902      	ldr	r1, [sp, #8]
 800804c:	9803      	ldr	r0, [sp, #12]
 800804e:	f7ff ff4f 	bl	8007ef0 <s_mp_sub>
 8008052:	9007      	str	r0, [sp, #28]
 8008054:	e00e      	b.n	8008074 <mp_sub+0x74>
      c->sign = (sa == MP_ZPOS) ? MP_NEG : MP_ZPOS;
 8008056:	9b06      	ldr	r3, [sp, #24]
 8008058:	2b00      	cmp	r3, #0
 800805a:	bf0c      	ite	eq
 800805c:	2301      	moveq	r3, #1
 800805e:	2300      	movne	r3, #0
 8008060:	b2db      	uxtb	r3, r3
 8008062:	461a      	mov	r2, r3
 8008064:	9b01      	ldr	r3, [sp, #4]
 8008066:	609a      	str	r2, [r3, #8]
      res = s_mp_sub (b, a, c);
 8008068:	9a01      	ldr	r2, [sp, #4]
 800806a:	9903      	ldr	r1, [sp, #12]
 800806c:	9802      	ldr	r0, [sp, #8]
 800806e:	f7ff ff3f 	bl	8007ef0 <s_mp_sub>
 8008072:	9007      	str	r0, [sp, #28]
  return res;
 8008074:	9b07      	ldr	r3, [sp, #28]
}
 8008076:	4618      	mov	r0, r3
 8008078:	b009      	add	sp, #36	; 0x24
 800807a:	f85d fb04 	ldr.w	pc, [sp], #4
 800807e:	bf00      	nop

08008080 <mp_reduce_is_2k_l>:
{
 8008080:	b084      	sub	sp, #16
 8008082:	9001      	str	r0, [sp, #4]
   if (a->used == 0) {
 8008084:	9b01      	ldr	r3, [sp, #4]
 8008086:	681b      	ldr	r3, [r3, #0]
 8008088:	2b00      	cmp	r3, #0
 800808a:	d101      	bne.n	8008090 <mp_reduce_is_2k_l+0x10>
      return MP_NO;
 800808c:	2300      	movs	r3, #0
 800808e:	e031      	b.n	80080f4 <mp_reduce_is_2k_l+0x74>
   } else if (a->used == 1) {
 8008090:	9b01      	ldr	r3, [sp, #4]
 8008092:	681b      	ldr	r3, [r3, #0]
 8008094:	2b01      	cmp	r3, #1
 8008096:	d101      	bne.n	800809c <mp_reduce_is_2k_l+0x1c>
      return MP_YES;
 8008098:	2301      	movs	r3, #1
 800809a:	e02b      	b.n	80080f4 <mp_reduce_is_2k_l+0x74>
   } else if (a->used > 1) {
 800809c:	9b01      	ldr	r3, [sp, #4]
 800809e:	681b      	ldr	r3, [r3, #0]
 80080a0:	2b01      	cmp	r3, #1
 80080a2:	dd26      	ble.n	80080f2 <mp_reduce_is_2k_l+0x72>
      for (iy = ix = 0; ix < a->used; ix++) {
 80080a4:	2300      	movs	r3, #0
 80080a6:	9303      	str	r3, [sp, #12]
 80080a8:	9b03      	ldr	r3, [sp, #12]
 80080aa:	9302      	str	r3, [sp, #8]
 80080ac:	e00f      	b.n	80080ce <mp_reduce_is_2k_l+0x4e>
          if (a->dp[ix] == MP_MASK) {
 80080ae:	9b01      	ldr	r3, [sp, #4]
 80080b0:	68da      	ldr	r2, [r3, #12]
 80080b2:	9b03      	ldr	r3, [sp, #12]
 80080b4:	009b      	lsls	r3, r3, #2
 80080b6:	4413      	add	r3, r2
 80080b8:	681b      	ldr	r3, [r3, #0]
 80080ba:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80080be:	4293      	cmp	r3, r2
 80080c0:	d102      	bne.n	80080c8 <mp_reduce_is_2k_l+0x48>
              ++iy;
 80080c2:	9b02      	ldr	r3, [sp, #8]
 80080c4:	3301      	adds	r3, #1
 80080c6:	9302      	str	r3, [sp, #8]
      for (iy = ix = 0; ix < a->used; ix++) {
 80080c8:	9b03      	ldr	r3, [sp, #12]
 80080ca:	3301      	adds	r3, #1
 80080cc:	9303      	str	r3, [sp, #12]
 80080ce:	9b01      	ldr	r3, [sp, #4]
 80080d0:	681a      	ldr	r2, [r3, #0]
 80080d2:	9b03      	ldr	r3, [sp, #12]
 80080d4:	429a      	cmp	r2, r3
 80080d6:	dcea      	bgt.n	80080ae <mp_reduce_is_2k_l+0x2e>
      return (iy >= (a->used/2)) ? MP_YES : MP_NO;
 80080d8:	9b01      	ldr	r3, [sp, #4]
 80080da:	681b      	ldr	r3, [r3, #0]
 80080dc:	0fda      	lsrs	r2, r3, #31
 80080de:	4413      	add	r3, r2
 80080e0:	105b      	asrs	r3, r3, #1
 80080e2:	461a      	mov	r2, r3
 80080e4:	9b02      	ldr	r3, [sp, #8]
 80080e6:	429a      	cmp	r2, r3
 80080e8:	bfd4      	ite	le
 80080ea:	2301      	movle	r3, #1
 80080ec:	2300      	movgt	r3, #0
 80080ee:	b2db      	uxtb	r3, r3
 80080f0:	e000      	b.n	80080f4 <mp_reduce_is_2k_l+0x74>
   return MP_NO;
 80080f2:	2300      	movs	r3, #0
}
 80080f4:	4618      	mov	r0, r3
 80080f6:	b004      	add	sp, #16
 80080f8:	4770      	bx	lr
 80080fa:	bf00      	nop
 80080fc:	0000      	movs	r0, r0
	...

08008100 <mp_reduce_is_2k>:
{
 8008100:	b500      	push	{lr}
 8008102:	b087      	sub	sp, #28
 8008104:	9001      	str	r0, [sp, #4]
   if (a->used == 0) {
 8008106:	9b01      	ldr	r3, [sp, #4]
 8008108:	681b      	ldr	r3, [r3, #0]
 800810a:	2b00      	cmp	r3, #0
 800810c:	d101      	bne.n	8008112 <mp_reduce_is_2k+0x12>
      return MP_NO;
 800810e:	2300      	movs	r3, #0
 8008110:	e034      	b.n	800817c <mp_reduce_is_2k+0x7c>
   } else if (a->used == 1) {
 8008112:	9b01      	ldr	r3, [sp, #4]
 8008114:	681b      	ldr	r3, [r3, #0]
 8008116:	2b01      	cmp	r3, #1
 8008118:	d101      	bne.n	800811e <mp_reduce_is_2k+0x1e>
      return MP_YES;
 800811a:	2301      	movs	r3, #1
 800811c:	e02e      	b.n	800817c <mp_reduce_is_2k+0x7c>
   } else if (a->used > 1) {
 800811e:	9b01      	ldr	r3, [sp, #4]
 8008120:	681b      	ldr	r3, [r3, #0]
 8008122:	2b01      	cmp	r3, #1
 8008124:	dd29      	ble.n	800817a <mp_reduce_is_2k+0x7a>
      iy = mp_count_bits(a);
 8008126:	9801      	ldr	r0, [sp, #4]
 8008128:	f002 fb1a 	bl	800a760 <mp_count_bits>
 800812c:	9002      	str	r0, [sp, #8]
      iz = 1;
 800812e:	2301      	movs	r3, #1
 8008130:	9303      	str	r3, [sp, #12]
      iw = 1;
 8008132:	2301      	movs	r3, #1
 8008134:	9304      	str	r3, [sp, #16]
      for (ix = DIGIT_BIT; ix < iy; ix++) {
 8008136:	231c      	movs	r3, #28
 8008138:	9305      	str	r3, [sp, #20]
 800813a:	e01a      	b.n	8008172 <mp_reduce_is_2k+0x72>
          if ((a->dp[iw] & iz) == 0) {
 800813c:	9b01      	ldr	r3, [sp, #4]
 800813e:	68da      	ldr	r2, [r3, #12]
 8008140:	9b04      	ldr	r3, [sp, #16]
 8008142:	009b      	lsls	r3, r3, #2
 8008144:	4413      	add	r3, r2
 8008146:	681a      	ldr	r2, [r3, #0]
 8008148:	9b03      	ldr	r3, [sp, #12]
 800814a:	4013      	ands	r3, r2
 800814c:	2b00      	cmp	r3, #0
 800814e:	d101      	bne.n	8008154 <mp_reduce_is_2k+0x54>
             return MP_NO;
 8008150:	2300      	movs	r3, #0
 8008152:	e013      	b.n	800817c <mp_reduce_is_2k+0x7c>
          iz <<= 1;
 8008154:	9b03      	ldr	r3, [sp, #12]
 8008156:	005b      	lsls	r3, r3, #1
 8008158:	9303      	str	r3, [sp, #12]
          if (iz > (mp_digit)MP_MASK) {
 800815a:	9b03      	ldr	r3, [sp, #12]
 800815c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8008160:	d304      	bcc.n	800816c <mp_reduce_is_2k+0x6c>
             ++iw;
 8008162:	9b04      	ldr	r3, [sp, #16]
 8008164:	3301      	adds	r3, #1
 8008166:	9304      	str	r3, [sp, #16]
             iz = 1;
 8008168:	2301      	movs	r3, #1
 800816a:	9303      	str	r3, [sp, #12]
      for (ix = DIGIT_BIT; ix < iy; ix++) {
 800816c:	9b05      	ldr	r3, [sp, #20]
 800816e:	3301      	adds	r3, #1
 8008170:	9305      	str	r3, [sp, #20]
 8008172:	9a05      	ldr	r2, [sp, #20]
 8008174:	9b02      	ldr	r3, [sp, #8]
 8008176:	429a      	cmp	r2, r3
 8008178:	dbe0      	blt.n	800813c <mp_reduce_is_2k+0x3c>
   return MP_YES;
 800817a:	2301      	movs	r3, #1
}
 800817c:	4618      	mov	r0, r3
 800817e:	b007      	add	sp, #28
 8008180:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008190 <mp_dr_is_modulus>:
{
 8008190:	b084      	sub	sp, #16
 8008192:	9001      	str	r0, [sp, #4]
   if (a->used < 2) {
 8008194:	9b01      	ldr	r3, [sp, #4]
 8008196:	681b      	ldr	r3, [r3, #0]
 8008198:	2b01      	cmp	r3, #1
 800819a:	dc01      	bgt.n	80081a0 <mp_dr_is_modulus+0x10>
      return 0;
 800819c:	2300      	movs	r3, #0
 800819e:	e017      	b.n	80081d0 <mp_dr_is_modulus+0x40>
   for (ix = 1; ix < a->used; ix++) {
 80081a0:	2301      	movs	r3, #1
 80081a2:	9303      	str	r3, [sp, #12]
 80081a4:	e00e      	b.n	80081c4 <mp_dr_is_modulus+0x34>
       if (a->dp[ix] != MP_MASK) {
 80081a6:	9b01      	ldr	r3, [sp, #4]
 80081a8:	68da      	ldr	r2, [r3, #12]
 80081aa:	9b03      	ldr	r3, [sp, #12]
 80081ac:	009b      	lsls	r3, r3, #2
 80081ae:	4413      	add	r3, r2
 80081b0:	681b      	ldr	r3, [r3, #0]
 80081b2:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80081b6:	4293      	cmp	r3, r2
 80081b8:	d001      	beq.n	80081be <mp_dr_is_modulus+0x2e>
          return 0;
 80081ba:	2300      	movs	r3, #0
 80081bc:	e008      	b.n	80081d0 <mp_dr_is_modulus+0x40>
   for (ix = 1; ix < a->used; ix++) {
 80081be:	9b03      	ldr	r3, [sp, #12]
 80081c0:	3301      	adds	r3, #1
 80081c2:	9303      	str	r3, [sp, #12]
 80081c4:	9b01      	ldr	r3, [sp, #4]
 80081c6:	681a      	ldr	r2, [r3, #0]
 80081c8:	9b03      	ldr	r3, [sp, #12]
 80081ca:	429a      	cmp	r2, r3
 80081cc:	dceb      	bgt.n	80081a6 <mp_dr_is_modulus+0x16>
   return 1;
 80081ce:	2301      	movs	r3, #1
}
 80081d0:	4618      	mov	r0, r3
 80081d2:	b004      	add	sp, #16
 80081d4:	4770      	bx	lr
 80081d6:	bf00      	nop
	...

080081e0 <mp_exptmod_fast>:
{
 80081e0:	b500      	push	{lr}
 80081e2:	b097      	sub	sp, #92	; 0x5c
 80081e4:	9003      	str	r0, [sp, #12]
 80081e6:	9102      	str	r1, [sp, #8]
 80081e8:	9201      	str	r2, [sp, #4]
 80081ea:	9300      	str	r3, [sp, #0]
  mp_int* M = NULL;
 80081ec:	2300      	movs	r3, #0
 80081ee:	930a      	str	r3, [sp, #40]	; 0x28
  M = (mp_int*) XMALLOC(sizeof(mp_int) * TAB_SIZE, NULL,
 80081f0:	f44f 7100 	mov.w	r1, #512	; 0x200
 80081f4:	2000      	movs	r0, #0
 80081f6:	f7fd fb33 	bl	8005860 <chibios_alloc>
 80081fa:	900a      	str	r0, [sp, #40]	; 0x28
  if (M == NULL)
 80081fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80081fe:	2b00      	cmp	r3, #0
 8008200:	d102      	bne.n	8008208 <mp_exptmod_fast+0x28>
    return MP_MEM;
 8008202:	f06f 0301 	mvn.w	r3, #1
 8008206:	e289      	b.n	800871c <mp_exptmod_fast+0x53c>
  x = mp_count_bits (X);
 8008208:	9802      	ldr	r0, [sp, #8]
 800820a:	f002 faa9 	bl	800a760 <mp_count_bits>
 800820e:	900e      	str	r0, [sp, #56]	; 0x38
  if (x <= 7) {
 8008210:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008212:	2b07      	cmp	r3, #7
 8008214:	dc02      	bgt.n	800821c <mp_exptmod_fast+0x3c>
    winsize = 2;
 8008216:	2302      	movs	r3, #2
 8008218:	930c      	str	r3, [sp, #48]	; 0x30
 800821a:	e023      	b.n	8008264 <mp_exptmod_fast+0x84>
  } else if (x <= 36) {
 800821c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800821e:	2b24      	cmp	r3, #36	; 0x24
 8008220:	dc02      	bgt.n	8008228 <mp_exptmod_fast+0x48>
    winsize = 3;
 8008222:	2303      	movs	r3, #3
 8008224:	930c      	str	r3, [sp, #48]	; 0x30
 8008226:	e01d      	b.n	8008264 <mp_exptmod_fast+0x84>
  } else if (x <= 140) {
 8008228:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800822a:	2b8c      	cmp	r3, #140	; 0x8c
 800822c:	dc02      	bgt.n	8008234 <mp_exptmod_fast+0x54>
    winsize = 4;
 800822e:	2304      	movs	r3, #4
 8008230:	930c      	str	r3, [sp, #48]	; 0x30
 8008232:	e017      	b.n	8008264 <mp_exptmod_fast+0x84>
  } else if (x <= 450) {
 8008234:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008236:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
 800823a:	dc02      	bgt.n	8008242 <mp_exptmod_fast+0x62>
    winsize = 5;
 800823c:	2305      	movs	r3, #5
 800823e:	930c      	str	r3, [sp, #48]	; 0x30
 8008240:	e010      	b.n	8008264 <mp_exptmod_fast+0x84>
  } else if (x <= 1303) {
 8008242:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008244:	f5b3 6fa3 	cmp.w	r3, #1304	; 0x518
 8008248:	da02      	bge.n	8008250 <mp_exptmod_fast+0x70>
    winsize = 6;
 800824a:	2306      	movs	r3, #6
 800824c:	930c      	str	r3, [sp, #48]	; 0x30
 800824e:	e009      	b.n	8008264 <mp_exptmod_fast+0x84>
  } else if (x <= 3529) {
 8008250:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008252:	f640 52c9 	movw	r2, #3529	; 0xdc9
 8008256:	4293      	cmp	r3, r2
 8008258:	dc02      	bgt.n	8008260 <mp_exptmod_fast+0x80>
    winsize = 7;
 800825a:	2307      	movs	r3, #7
 800825c:	930c      	str	r3, [sp, #48]	; 0x30
 800825e:	e001      	b.n	8008264 <mp_exptmod_fast+0x84>
    winsize = 8;
 8008260:	2308      	movs	r3, #8
 8008262:	930c      	str	r3, [sp, #48]	; 0x30
  if (winsize > 5) {
 8008264:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008266:	2b05      	cmp	r3, #5
 8008268:	dd01      	ble.n	800826e <mp_exptmod_fast+0x8e>
     winsize = 5;
 800826a:	2305      	movs	r3, #5
 800826c:	930c      	str	r3, [sp, #48]	; 0x30
  if ((err = mp_init_size(&M[1], P->alloc)) != MP_OKAY) {
 800826e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008270:	f103 0210 	add.w	r2, r3, #16
 8008274:	9b01      	ldr	r3, [sp, #4]
 8008276:	685b      	ldr	r3, [r3, #4]
 8008278:	4619      	mov	r1, r3
 800827a:	4610      	mov	r0, r2
 800827c:	f001 f868 	bl	8009350 <mp_init_size>
 8008280:	9014      	str	r0, [sp, #80]	; 0x50
 8008282:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008284:	2b00      	cmp	r3, #0
 8008286:	d004      	beq.n	8008292 <mp_exptmod_fast+0xb2>
     XFREE(M, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8008288:	980a      	ldr	r0, [sp, #40]	; 0x28
 800828a:	f7fd faf9 	bl	8005880 <chibios_free>
     return err;
 800828e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008290:	e244      	b.n	800871c <mp_exptmod_fast+0x53c>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 8008292:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008294:	3b01      	subs	r3, #1
 8008296:	2201      	movs	r2, #1
 8008298:	fa02 f303 	lsl.w	r3, r2, r3
 800829c:	930e      	str	r3, [sp, #56]	; 0x38
 800829e:	e02f      	b.n	8008300 <mp_exptmod_fast+0x120>
    if ((err = mp_init_size(&M[x], P->alloc)) != MP_OKAY) {
 80082a0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80082a2:	011b      	lsls	r3, r3, #4
 80082a4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80082a6:	441a      	add	r2, r3
 80082a8:	9b01      	ldr	r3, [sp, #4]
 80082aa:	685b      	ldr	r3, [r3, #4]
 80082ac:	4619      	mov	r1, r3
 80082ae:	4610      	mov	r0, r2
 80082b0:	f001 f84e 	bl	8009350 <mp_init_size>
 80082b4:	9014      	str	r0, [sp, #80]	; 0x50
 80082b6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80082b8:	2b00      	cmp	r3, #0
 80082ba:	d01e      	beq.n	80082fa <mp_exptmod_fast+0x11a>
      for (y = 1<<(winsize-1); y < x; y++) {
 80082bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80082be:	3b01      	subs	r3, #1
 80082c0:	2201      	movs	r2, #1
 80082c2:	fa02 f303 	lsl.w	r3, r2, r3
 80082c6:	930d      	str	r3, [sp, #52]	; 0x34
 80082c8:	e009      	b.n	80082de <mp_exptmod_fast+0xfe>
        mp_clear (&M[y]);
 80082ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80082cc:	011b      	lsls	r3, r3, #4
 80082ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80082d0:	4413      	add	r3, r2
 80082d2:	4618      	mov	r0, r3
 80082d4:	f002 f9ac 	bl	800a630 <mp_clear>
      for (y = 1<<(winsize-1); y < x; y++) {
 80082d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80082da:	3301      	adds	r3, #1
 80082dc:	930d      	str	r3, [sp, #52]	; 0x34
 80082de:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80082e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80082e2:	429a      	cmp	r2, r3
 80082e4:	dbf1      	blt.n	80082ca <mp_exptmod_fast+0xea>
      mp_clear(&M[1]);
 80082e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80082e8:	3310      	adds	r3, #16
 80082ea:	4618      	mov	r0, r3
 80082ec:	f002 f9a0 	bl	800a630 <mp_clear>
      XFREE(M, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80082f0:	980a      	ldr	r0, [sp, #40]	; 0x28
 80082f2:	f7fd fac5 	bl	8005880 <chibios_free>
      return err;
 80082f6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80082f8:	e210      	b.n	800871c <mp_exptmod_fast+0x53c>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 80082fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80082fc:	3301      	adds	r3, #1
 80082fe:	930e      	str	r3, [sp, #56]	; 0x38
 8008300:	2201      	movs	r2, #1
 8008302:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008304:	409a      	lsls	r2, r3
 8008306:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008308:	429a      	cmp	r2, r3
 800830a:	dcc9      	bgt.n	80082a0 <mp_exptmod_fast+0xc0>
  if (redmode == 0) {
 800830c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800830e:	2b00      	cmp	r3, #0
 8008310:	d11a      	bne.n	8008348 <mp_exptmod_fast+0x168>
     if ((err = mp_montgomery_setup (P, &mp)) != MP_OKAY) {
 8008312:	ab05      	add	r3, sp, #20
 8008314:	4619      	mov	r1, r3
 8008316:	9801      	ldr	r0, [sp, #4]
 8008318:	f000 fa0a 	bl	8008730 <mp_montgomery_setup>
 800831c:	9014      	str	r0, [sp, #80]	; 0x50
 800831e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008320:	2b00      	cmp	r3, #0
 8008322:	f040 81db 	bne.w	80086dc <mp_exptmod_fast+0x4fc>
     if (((P->used * 2 + 1) < MP_WARRAY) &&
 8008326:	9b01      	ldr	r3, [sp, #4]
 8008328:	681b      	ldr	r3, [r3, #0]
 800832a:	005b      	lsls	r3, r3, #1
 800832c:	3301      	adds	r3, #1
 800832e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008332:	da06      	bge.n	8008342 <mp_exptmod_fast+0x162>
          P->used < (1 << ((CHAR_BIT * sizeof (mp_word)) - (2 * DIGIT_BIT)))) {
 8008334:	9b01      	ldr	r3, [sp, #4]
 8008336:	681b      	ldr	r3, [r3, #0]
     if (((P->used * 2 + 1) < MP_WARRAY) &&
 8008338:	2bff      	cmp	r3, #255	; 0xff
 800833a:	dc02      	bgt.n	8008342 <mp_exptmod_fast+0x162>
        redux = fast_mp_montgomery_reduce;
 800833c:	4b99      	ldr	r3, [pc, #612]	; (80085a4 <mp_exptmod_fast+0x3c4>)
 800833e:	930b      	str	r3, [sp, #44]	; 0x2c
        redux = mp_montgomery_reduce;
 8008340:	e019      	b.n	8008376 <mp_exptmod_fast+0x196>
 8008342:	4b99      	ldr	r3, [pc, #612]	; (80085a8 <mp_exptmod_fast+0x3c8>)
 8008344:	930b      	str	r3, [sp, #44]	; 0x2c
 8008346:	e016      	b.n	8008376 <mp_exptmod_fast+0x196>
  } else if (redmode == 1) {
 8008348:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800834a:	2b01      	cmp	r3, #1
 800834c:	d107      	bne.n	800835e <mp_exptmod_fast+0x17e>
     mp_dr_setup(P, &mp);
 800834e:	ab05      	add	r3, sp, #20
 8008350:	4619      	mov	r1, r3
 8008352:	9801      	ldr	r0, [sp, #4]
 8008354:	f000 fc2c 	bl	8008bb0 <mp_dr_setup>
     redux = mp_dr_reduce;
 8008358:	4b94      	ldr	r3, [pc, #592]	; (80085ac <mp_exptmod_fast+0x3cc>)
 800835a:	930b      	str	r3, [sp, #44]	; 0x2c
 800835c:	e00b      	b.n	8008376 <mp_exptmod_fast+0x196>
     if ((err = mp_reduce_2k_setup(P, &mp)) != MP_OKAY) {
 800835e:	ab05      	add	r3, sp, #20
 8008360:	4619      	mov	r1, r3
 8008362:	9801      	ldr	r0, [sp, #4]
 8008364:	f000 fd1c 	bl	8008da0 <mp_reduce_2k_setup>
 8008368:	9014      	str	r0, [sp, #80]	; 0x50
 800836a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800836c:	2b00      	cmp	r3, #0
 800836e:	f040 81b5 	bne.w	80086dc <mp_exptmod_fast+0x4fc>
     redux = mp_reduce_2k;
 8008372:	4b8f      	ldr	r3, [pc, #572]	; (80085b0 <mp_exptmod_fast+0x3d0>)
 8008374:	930b      	str	r3, [sp, #44]	; 0x2c
  if ((err = mp_init_size (&res, P->alloc)) != MP_OKAY) {
 8008376:	9b01      	ldr	r3, [sp, #4]
 8008378:	685a      	ldr	r2, [r3, #4]
 800837a:	ab06      	add	r3, sp, #24
 800837c:	4611      	mov	r1, r2
 800837e:	4618      	mov	r0, r3
 8008380:	f000 ffe6 	bl	8009350 <mp_init_size>
 8008384:	9014      	str	r0, [sp, #80]	; 0x50
 8008386:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008388:	2b00      	cmp	r3, #0
 800838a:	f040 81a7 	bne.w	80086dc <mp_exptmod_fast+0x4fc>
  if (redmode == 0) {
 800838e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8008390:	2b00      	cmp	r3, #0
 8008392:	d116      	bne.n	80083c2 <mp_exptmod_fast+0x1e2>
     if ((err = mp_montgomery_calc_normalization (&res, P)) != MP_OKAY) {
 8008394:	ab06      	add	r3, sp, #24
 8008396:	9901      	ldr	r1, [sp, #4]
 8008398:	4618      	mov	r0, r3
 800839a:	f001 fb91 	bl	8009ac0 <mp_montgomery_calc_normalization>
 800839e:	9014      	str	r0, [sp, #80]	; 0x50
 80083a0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80083a2:	2b00      	cmp	r3, #0
 80083a4:	f040 8196 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
     if ((err = mp_mulmod (G, &res, P, &M[1])) != MP_OKAY) {
 80083a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80083aa:	3310      	adds	r3, #16
 80083ac:	a906      	add	r1, sp, #24
 80083ae:	9a01      	ldr	r2, [sp, #4]
 80083b0:	9803      	ldr	r0, [sp, #12]
 80083b2:	f000 fe0d 	bl	8008fd0 <mp_mulmod>
 80083b6:	9014      	str	r0, [sp, #80]	; 0x50
 80083b8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	f040 818a 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
 80083c0:	e015      	b.n	80083ee <mp_exptmod_fast+0x20e>
     if ((err = mp_set(&res, 1)) != MP_OKAY) {
 80083c2:	ab06      	add	r3, sp, #24
 80083c4:	2101      	movs	r1, #1
 80083c6:	4618      	mov	r0, r3
 80083c8:	f003 fbe2 	bl	800bb90 <mp_set>
 80083cc:	9014      	str	r0, [sp, #80]	; 0x50
 80083ce:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80083d0:	2b00      	cmp	r3, #0
 80083d2:	f040 817f 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
     if ((err = mp_mod(G, P, &M[1])) != MP_OKAY) {
 80083d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80083d8:	3310      	adds	r3, #16
 80083da:	461a      	mov	r2, r3
 80083dc:	9901      	ldr	r1, [sp, #4]
 80083de:	9803      	ldr	r0, [sp, #12]
 80083e0:	f003 fbfe 	bl	800bbe0 <mp_mod>
 80083e4:	9014      	str	r0, [sp, #80]	; 0x50
 80083e6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80083e8:	2b00      	cmp	r3, #0
 80083ea:	f040 8173 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
  if ((err = mp_copy (&M[1], &M[(mp_digit)(1 << (winsize - 1))])) != MP_OKAY) {
 80083ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80083f0:	f103 0010 	add.w	r0, r3, #16
 80083f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80083f6:	3b01      	subs	r3, #1
 80083f8:	2210      	movs	r2, #16
 80083fa:	fa02 f303 	lsl.w	r3, r2, r3
 80083fe:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008400:	4413      	add	r3, r2
 8008402:	4619      	mov	r1, r3
 8008404:	f002 fa8c 	bl	800a920 <mp_copy>
 8008408:	9014      	str	r0, [sp, #80]	; 0x50
 800840a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800840c:	2b00      	cmp	r3, #0
 800840e:	f040 8161 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
  for (x = 0; x < (winsize - 1); x++) {
 8008412:	2300      	movs	r3, #0
 8008414:	930e      	str	r3, [sp, #56]	; 0x38
 8008416:	e028      	b.n	800846a <mp_exptmod_fast+0x28a>
    if ((err = mp_sqr (&M[(mp_digit)(1 << (winsize - 1))],
 8008418:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800841a:	3b01      	subs	r3, #1
 800841c:	2210      	movs	r2, #16
 800841e:	fa02 f303 	lsl.w	r3, r2, r3
 8008422:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008424:	18d0      	adds	r0, r2, r3
                       &M[(mp_digit)(1 << (winsize - 1))])) != MP_OKAY) {
 8008426:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008428:	3b01      	subs	r3, #1
 800842a:	2210      	movs	r2, #16
 800842c:	fa02 f303 	lsl.w	r3, r2, r3
    if ((err = mp_sqr (&M[(mp_digit)(1 << (winsize - 1))],
 8008430:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008432:	4413      	add	r3, r2
 8008434:	4619      	mov	r1, r3
 8008436:	f000 fdfb 	bl	8009030 <mp_sqr>
 800843a:	9014      	str	r0, [sp, #80]	; 0x50
 800843c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800843e:	2b00      	cmp	r3, #0
 8008440:	f040 8148 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
    if ((err = redux (&M[(mp_digit)(1 << (winsize - 1))], P, mp)) != MP_OKAY) {
 8008444:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008446:	3b01      	subs	r3, #1
 8008448:	2210      	movs	r2, #16
 800844a:	fa02 f303 	lsl.w	r3, r2, r3
 800844e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008450:	18d0      	adds	r0, r2, r3
 8008452:	9a05      	ldr	r2, [sp, #20]
 8008454:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008456:	9901      	ldr	r1, [sp, #4]
 8008458:	4798      	blx	r3
 800845a:	9014      	str	r0, [sp, #80]	; 0x50
 800845c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800845e:	2b00      	cmp	r3, #0
 8008460:	f040 8138 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
  for (x = 0; x < (winsize - 1); x++) {
 8008464:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008466:	3301      	adds	r3, #1
 8008468:	930e      	str	r3, [sp, #56]	; 0x38
 800846a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800846c:	1e5a      	subs	r2, r3, #1
 800846e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008470:	429a      	cmp	r2, r3
 8008472:	dcd1      	bgt.n	8008418 <mp_exptmod_fast+0x238>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8008474:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008476:	3b01      	subs	r3, #1
 8008478:	2201      	movs	r2, #1
 800847a:	fa02 f303 	lsl.w	r3, r2, r3
 800847e:	3301      	adds	r3, #1
 8008480:	930e      	str	r3, [sp, #56]	; 0x38
 8008482:	e025      	b.n	80084d0 <mp_exptmod_fast+0x2f0>
    if ((err = mp_mul (&M[x - 1], &M[1], &M[x])) != MP_OKAY) {
 8008484:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008486:	f103 5380 	add.w	r3, r3, #268435456	; 0x10000000
 800848a:	3b01      	subs	r3, #1
 800848c:	011b      	lsls	r3, r3, #4
 800848e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008490:	18d0      	adds	r0, r2, r3
 8008492:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008494:	f103 0110 	add.w	r1, r3, #16
 8008498:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800849a:	011b      	lsls	r3, r3, #4
 800849c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800849e:	4413      	add	r3, r2
 80084a0:	461a      	mov	r2, r3
 80084a2:	f000 fded 	bl	8009080 <mp_mul>
 80084a6:	9014      	str	r0, [sp, #80]	; 0x50
 80084a8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80084aa:	2b00      	cmp	r3, #0
 80084ac:	f040 8112 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
    if ((err = redux (&M[x], P, mp)) != MP_OKAY) {
 80084b0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80084b2:	011b      	lsls	r3, r3, #4
 80084b4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80084b6:	18d0      	adds	r0, r2, r3
 80084b8:	9a05      	ldr	r2, [sp, #20]
 80084ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80084bc:	9901      	ldr	r1, [sp, #4]
 80084be:	4798      	blx	r3
 80084c0:	9014      	str	r0, [sp, #80]	; 0x50
 80084c2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80084c4:	2b00      	cmp	r3, #0
 80084c6:	f040 8105 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 80084ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80084cc:	3301      	adds	r3, #1
 80084ce:	930e      	str	r3, [sp, #56]	; 0x38
 80084d0:	2201      	movs	r2, #1
 80084d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80084d4:	409a      	lsls	r2, r3
 80084d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80084d8:	429a      	cmp	r2, r3
 80084da:	dcd3      	bgt.n	8008484 <mp_exptmod_fast+0x2a4>
  mode   = 0;
 80084dc:	2300      	movs	r3, #0
 80084de:	9310      	str	r3, [sp, #64]	; 0x40
  bitcnt = 1;
 80084e0:	2301      	movs	r3, #1
 80084e2:	9311      	str	r3, [sp, #68]	; 0x44
  buf    = 0;
 80084e4:	2300      	movs	r3, #0
 80084e6:	9315      	str	r3, [sp, #84]	; 0x54
  digidx = X->used - 1;
 80084e8:	9b02      	ldr	r3, [sp, #8]
 80084ea:	681b      	ldr	r3, [r3, #0]
 80084ec:	3b01      	subs	r3, #1
 80084ee:	930f      	str	r3, [sp, #60]	; 0x3c
  bitcpy = 0;
 80084f0:	2300      	movs	r3, #0
 80084f2:	9312      	str	r3, [sp, #72]	; 0x48
  bitbuf = 0;
 80084f4:	2300      	movs	r3, #0
 80084f6:	9313      	str	r3, [sp, #76]	; 0x4c
    if (--bitcnt == 0) {
 80084f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80084fa:	3b01      	subs	r3, #1
 80084fc:	9311      	str	r3, [sp, #68]	; 0x44
 80084fe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008500:	2b00      	cmp	r3, #0
 8008502:	d10f      	bne.n	8008524 <mp_exptmod_fast+0x344>
      if (digidx == -1) {
 8008504:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008506:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800850a:	f000 808d 	beq.w	8008628 <mp_exptmod_fast+0x448>
      buf    = X->dp[digidx--];
 800850e:	9b02      	ldr	r3, [sp, #8]
 8008510:	68da      	ldr	r2, [r3, #12]
 8008512:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008514:	1e59      	subs	r1, r3, #1
 8008516:	910f      	str	r1, [sp, #60]	; 0x3c
 8008518:	009b      	lsls	r3, r3, #2
 800851a:	4413      	add	r3, r2
 800851c:	681b      	ldr	r3, [r3, #0]
 800851e:	9315      	str	r3, [sp, #84]	; 0x54
      bitcnt = (int)DIGIT_BIT;
 8008520:	231c      	movs	r3, #28
 8008522:	9311      	str	r3, [sp, #68]	; 0x44
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 8008524:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8008526:	0edb      	lsrs	r3, r3, #27
 8008528:	f003 0301 	and.w	r3, r3, #1
 800852c:	930d      	str	r3, [sp, #52]	; 0x34
    buf <<= (mp_digit)1;
 800852e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8008530:	005b      	lsls	r3, r3, #1
 8008532:	9315      	str	r3, [sp, #84]	; 0x54
    if (mode == 0 && y == 0) {
 8008534:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008536:	2b00      	cmp	r3, #0
 8008538:	d102      	bne.n	8008540 <mp_exptmod_fast+0x360>
 800853a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800853c:	2b00      	cmp	r3, #0
 800853e:	d071      	beq.n	8008624 <mp_exptmod_fast+0x444>
    if (mode == 1 && y == 0) {
 8008540:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008542:	2b01      	cmp	r3, #1
 8008544:	d118      	bne.n	8008578 <mp_exptmod_fast+0x398>
 8008546:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008548:	2b00      	cmp	r3, #0
 800854a:	d115      	bne.n	8008578 <mp_exptmod_fast+0x398>
      if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 800854c:	aa06      	add	r2, sp, #24
 800854e:	ab06      	add	r3, sp, #24
 8008550:	4611      	mov	r1, r2
 8008552:	4618      	mov	r0, r3
 8008554:	f000 fd6c 	bl	8009030 <mp_sqr>
 8008558:	9014      	str	r0, [sp, #80]	; 0x50
 800855a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800855c:	2b00      	cmp	r3, #0
 800855e:	f040 80b9 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
      if ((err = redux (&res, P, mp)) != MP_OKAY) {
 8008562:	9a05      	ldr	r2, [sp, #20]
 8008564:	a806      	add	r0, sp, #24
 8008566:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008568:	9901      	ldr	r1, [sp, #4]
 800856a:	4798      	blx	r3
 800856c:	9014      	str	r0, [sp, #80]	; 0x50
 800856e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008570:	2b00      	cmp	r3, #0
 8008572:	f040 80af 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
      continue;
 8008576:	e7bf      	b.n	80084f8 <mp_exptmod_fast+0x318>
    bitbuf |= (y << (winsize - ++bitcpy));
 8008578:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800857a:	3301      	adds	r3, #1
 800857c:	9312      	str	r3, [sp, #72]	; 0x48
 800857e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008580:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008582:	1ad3      	subs	r3, r2, r3
 8008584:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008586:	fa02 f303 	lsl.w	r3, r2, r3
 800858a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800858c:	4313      	orrs	r3, r2
 800858e:	9313      	str	r3, [sp, #76]	; 0x4c
    mode    = 2;
 8008590:	2302      	movs	r3, #2
 8008592:	9310      	str	r3, [sp, #64]	; 0x40
    if (bitcpy == winsize) {
 8008594:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008596:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008598:	429a      	cmp	r2, r3
 800859a:	d1ad      	bne.n	80084f8 <mp_exptmod_fast+0x318>
      for (x = 0; x < winsize; x++) {
 800859c:	2300      	movs	r3, #0
 800859e:	930e      	str	r3, [sp, #56]	; 0x38
 80085a0:	e01f      	b.n	80085e2 <mp_exptmod_fast+0x402>
 80085a2:	bf00      	nop
 80085a4:	080087b1 	.word	0x080087b1
 80085a8:	08008a31 	.word	0x08008a31
 80085ac:	08008bd1 	.word	0x08008bd1
 80085b0:	08008d01 	.word	0x08008d01
        if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 80085b4:	aa06      	add	r2, sp, #24
 80085b6:	ab06      	add	r3, sp, #24
 80085b8:	4611      	mov	r1, r2
 80085ba:	4618      	mov	r0, r3
 80085bc:	f000 fd38 	bl	8009030 <mp_sqr>
 80085c0:	9014      	str	r0, [sp, #80]	; 0x50
 80085c2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80085c4:	2b00      	cmp	r3, #0
 80085c6:	f040 8085 	bne.w	80086d4 <mp_exptmod_fast+0x4f4>
        if ((err = redux (&res, P, mp)) != MP_OKAY) {
 80085ca:	9a05      	ldr	r2, [sp, #20]
 80085cc:	a806      	add	r0, sp, #24
 80085ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80085d0:	9901      	ldr	r1, [sp, #4]
 80085d2:	4798      	blx	r3
 80085d4:	9014      	str	r0, [sp, #80]	; 0x50
 80085d6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80085d8:	2b00      	cmp	r3, #0
 80085da:	d17b      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
      for (x = 0; x < winsize; x++) {
 80085dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80085de:	3301      	adds	r3, #1
 80085e0:	930e      	str	r3, [sp, #56]	; 0x38
 80085e2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80085e4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80085e6:	429a      	cmp	r2, r3
 80085e8:	dbe4      	blt.n	80085b4 <mp_exptmod_fast+0x3d4>
      if ((err = mp_mul (&res, &M[bitbuf], &res)) != MP_OKAY) {
 80085ea:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80085ec:	011b      	lsls	r3, r3, #4
 80085ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80085f0:	18d1      	adds	r1, r2, r3
 80085f2:	aa06      	add	r2, sp, #24
 80085f4:	ab06      	add	r3, sp, #24
 80085f6:	4618      	mov	r0, r3
 80085f8:	f000 fd42 	bl	8009080 <mp_mul>
 80085fc:	9014      	str	r0, [sp, #80]	; 0x50
 80085fe:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008600:	2b00      	cmp	r3, #0
 8008602:	d167      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
      if ((err = redux (&res, P, mp)) != MP_OKAY) {
 8008604:	9a05      	ldr	r2, [sp, #20]
 8008606:	a806      	add	r0, sp, #24
 8008608:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800860a:	9901      	ldr	r1, [sp, #4]
 800860c:	4798      	blx	r3
 800860e:	9014      	str	r0, [sp, #80]	; 0x50
 8008610:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008612:	2b00      	cmp	r3, #0
 8008614:	d15e      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
      bitcpy = 0;
 8008616:	2300      	movs	r3, #0
 8008618:	9312      	str	r3, [sp, #72]	; 0x48
      bitbuf = 0;
 800861a:	2300      	movs	r3, #0
 800861c:	9313      	str	r3, [sp, #76]	; 0x4c
      mode   = 1;
 800861e:	2301      	movs	r3, #1
 8008620:	9310      	str	r3, [sp, #64]	; 0x40
 8008622:	e769      	b.n	80084f8 <mp_exptmod_fast+0x318>
      continue;
 8008624:	bf00      	nop
 8008626:	e767      	b.n	80084f8 <mp_exptmod_fast+0x318>
  if (mode == 2 && bitcpy > 0) {
 8008628:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800862a:	2b02      	cmp	r3, #2
 800862c:	d13f      	bne.n	80086ae <mp_exptmod_fast+0x4ce>
 800862e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8008630:	2b00      	cmp	r3, #0
 8008632:	dd3c      	ble.n	80086ae <mp_exptmod_fast+0x4ce>
    for (x = 0; x < bitcpy; x++) {
 8008634:	2300      	movs	r3, #0
 8008636:	930e      	str	r3, [sp, #56]	; 0x38
 8008638:	e035      	b.n	80086a6 <mp_exptmod_fast+0x4c6>
      if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 800863a:	aa06      	add	r2, sp, #24
 800863c:	ab06      	add	r3, sp, #24
 800863e:	4611      	mov	r1, r2
 8008640:	4618      	mov	r0, r3
 8008642:	f000 fcf5 	bl	8009030 <mp_sqr>
 8008646:	9014      	str	r0, [sp, #80]	; 0x50
 8008648:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800864a:	2b00      	cmp	r3, #0
 800864c:	d142      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
      if ((err = redux (&res, P, mp)) != MP_OKAY) {
 800864e:	9a05      	ldr	r2, [sp, #20]
 8008650:	a806      	add	r0, sp, #24
 8008652:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008654:	9901      	ldr	r1, [sp, #4]
 8008656:	4798      	blx	r3
 8008658:	9014      	str	r0, [sp, #80]	; 0x50
 800865a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800865c:	2b00      	cmp	r3, #0
 800865e:	d139      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
      bitbuf <<= 1;
 8008660:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8008662:	005b      	lsls	r3, r3, #1
 8008664:	9313      	str	r3, [sp, #76]	; 0x4c
      if ((bitbuf & (1 << winsize)) != 0) {
 8008666:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8008668:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800866a:	fa42 f303 	asr.w	r3, r2, r3
 800866e:	f003 0301 	and.w	r3, r3, #1
 8008672:	2b00      	cmp	r3, #0
 8008674:	d014      	beq.n	80086a0 <mp_exptmod_fast+0x4c0>
        if ((err = mp_mul (&res, &M[1], &res)) != MP_OKAY) {
 8008676:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008678:	f103 0110 	add.w	r1, r3, #16
 800867c:	aa06      	add	r2, sp, #24
 800867e:	ab06      	add	r3, sp, #24
 8008680:	4618      	mov	r0, r3
 8008682:	f000 fcfd 	bl	8009080 <mp_mul>
 8008686:	9014      	str	r0, [sp, #80]	; 0x50
 8008688:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800868a:	2b00      	cmp	r3, #0
 800868c:	d122      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
        if ((err = redux (&res, P, mp)) != MP_OKAY) {
 800868e:	9a05      	ldr	r2, [sp, #20]
 8008690:	a806      	add	r0, sp, #24
 8008692:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008694:	9901      	ldr	r1, [sp, #4]
 8008696:	4798      	blx	r3
 8008698:	9014      	str	r0, [sp, #80]	; 0x50
 800869a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800869c:	2b00      	cmp	r3, #0
 800869e:	d119      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
    for (x = 0; x < bitcpy; x++) {
 80086a0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80086a2:	3301      	adds	r3, #1
 80086a4:	930e      	str	r3, [sp, #56]	; 0x38
 80086a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80086a8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80086aa:	429a      	cmp	r2, r3
 80086ac:	dbc5      	blt.n	800863a <mp_exptmod_fast+0x45a>
  if (redmode == 0) {
 80086ae:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80086b0:	2b00      	cmp	r3, #0
 80086b2:	d108      	bne.n	80086c6 <mp_exptmod_fast+0x4e6>
     if ((err = redux(&res, P, mp)) != MP_OKAY) {
 80086b4:	9a05      	ldr	r2, [sp, #20]
 80086b6:	a806      	add	r0, sp, #24
 80086b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80086ba:	9901      	ldr	r1, [sp, #4]
 80086bc:	4798      	blx	r3
 80086be:	9014      	str	r0, [sp, #80]	; 0x50
 80086c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80086c2:	2b00      	cmp	r3, #0
 80086c4:	d106      	bne.n	80086d4 <mp_exptmod_fast+0x4f4>
  mp_exch (&res, Y);
 80086c6:	ab06      	add	r3, sp, #24
 80086c8:	9900      	ldr	r1, [sp, #0]
 80086ca:	4618      	mov	r0, r3
 80086cc:	f002 fa98 	bl	800ac00 <mp_exch>
  err = MP_OKAY;
 80086d0:	2300      	movs	r3, #0
 80086d2:	9314      	str	r3, [sp, #80]	; 0x50
LBL_RES:mp_clear (&res);
 80086d4:	ab06      	add	r3, sp, #24
 80086d6:	4618      	mov	r0, r3
 80086d8:	f001 ffaa 	bl	800a630 <mp_clear>
  mp_clear(&M[1]);
 80086dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80086de:	3310      	adds	r3, #16
 80086e0:	4618      	mov	r0, r3
 80086e2:	f001 ffa5 	bl	800a630 <mp_clear>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 80086e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80086e8:	3b01      	subs	r3, #1
 80086ea:	2201      	movs	r2, #1
 80086ec:	fa02 f303 	lsl.w	r3, r2, r3
 80086f0:	930e      	str	r3, [sp, #56]	; 0x38
 80086f2:	e009      	b.n	8008708 <mp_exptmod_fast+0x528>
    mp_clear (&M[x]);
 80086f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80086f6:	011b      	lsls	r3, r3, #4
 80086f8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80086fa:	4413      	add	r3, r2
 80086fc:	4618      	mov	r0, r3
 80086fe:	f001 ff97 	bl	800a630 <mp_clear>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 8008702:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008704:	3301      	adds	r3, #1
 8008706:	930e      	str	r3, [sp, #56]	; 0x38
 8008708:	2201      	movs	r2, #1
 800870a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800870c:	409a      	lsls	r2, r3
 800870e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008710:	429a      	cmp	r2, r3
 8008712:	dcef      	bgt.n	80086f4 <mp_exptmod_fast+0x514>
  XFREE(M, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8008714:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008716:	f7fd f8b3 	bl	8005880 <chibios_free>
  return err;
 800871a:	9b14      	ldr	r3, [sp, #80]	; 0x50
}
 800871c:	4618      	mov	r0, r3
 800871e:	b017      	add	sp, #92	; 0x5c
 8008720:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008730 <mp_montgomery_setup>:
{
 8008730:	b084      	sub	sp, #16
 8008732:	9001      	str	r0, [sp, #4]
 8008734:	9100      	str	r1, [sp, #0]
  b = n->dp[0];
 8008736:	9b01      	ldr	r3, [sp, #4]
 8008738:	68db      	ldr	r3, [r3, #12]
 800873a:	681b      	ldr	r3, [r3, #0]
 800873c:	9303      	str	r3, [sp, #12]
  if ((b & 1) == 0) {
 800873e:	9b03      	ldr	r3, [sp, #12]
 8008740:	f003 0301 	and.w	r3, r3, #1
 8008744:	2b00      	cmp	r3, #0
 8008746:	d102      	bne.n	800874e <mp_montgomery_setup+0x1e>
    return MP_VAL;
 8008748:	f06f 0302 	mvn.w	r3, #2
 800874c:	e02c      	b.n	80087a8 <mp_montgomery_setup+0x78>
  x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 800874e:	9b03      	ldr	r3, [sp, #12]
 8008750:	3302      	adds	r3, #2
 8008752:	005b      	lsls	r3, r3, #1
 8008754:	f003 0208 	and.w	r2, r3, #8
 8008758:	9b03      	ldr	r3, [sp, #12]
 800875a:	4413      	add	r3, r2
 800875c:	9302      	str	r3, [sp, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 800875e:	9b03      	ldr	r3, [sp, #12]
 8008760:	9a02      	ldr	r2, [sp, #8]
 8008762:	fb02 f303 	mul.w	r3, r2, r3
 8008766:	f1c3 0202 	rsb	r2, r3, #2
 800876a:	9b02      	ldr	r3, [sp, #8]
 800876c:	fb02 f303 	mul.w	r3, r2, r3
 8008770:	9302      	str	r3, [sp, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 8008772:	9b03      	ldr	r3, [sp, #12]
 8008774:	9a02      	ldr	r2, [sp, #8]
 8008776:	fb02 f303 	mul.w	r3, r2, r3
 800877a:	f1c3 0202 	rsb	r2, r3, #2
 800877e:	9b02      	ldr	r3, [sp, #8]
 8008780:	fb02 f303 	mul.w	r3, r2, r3
 8008784:	9302      	str	r3, [sp, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 8008786:	9b03      	ldr	r3, [sp, #12]
 8008788:	9a02      	ldr	r2, [sp, #8]
 800878a:	fb02 f303 	mul.w	r3, r2, r3
 800878e:	f1c3 0202 	rsb	r2, r3, #2
 8008792:	9b02      	ldr	r3, [sp, #8]
 8008794:	fb02 f303 	mul.w	r3, r2, r3
 8008798:	9302      	str	r3, [sp, #8]
  *rho = (mp_digit)((((mp_digit)1 << ((mp_digit) DIGIT_BIT)) - x) & MP_MASK);
 800879a:	9b02      	ldr	r3, [sp, #8]
 800879c:	425b      	negs	r3, r3
 800879e:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 80087a2:	9b00      	ldr	r3, [sp, #0]
 80087a4:	601a      	str	r2, [r3, #0]
  return MP_OKAY;
 80087a6:	2300      	movs	r3, #0
}
 80087a8:	4618      	mov	r0, r3
 80087aa:	b004      	add	sp, #16
 80087ac:	4770      	bx	lr
 80087ae:	bf00      	nop

080087b0 <fast_mp_montgomery_reduce>:
{
 80087b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80087b4:	b093      	sub	sp, #76	; 0x4c
 80087b6:	9003      	str	r0, [sp, #12]
 80087b8:	9102      	str	r1, [sp, #8]
 80087ba:	9201      	str	r2, [sp, #4]
  olduse = x->used;
 80087bc:	9b03      	ldr	r3, [sp, #12]
 80087be:	681b      	ldr	r3, [r3, #0]
 80087c0:	9308      	str	r3, [sp, #32]
  if (x->alloc < n->used + 1) {
 80087c2:	9b03      	ldr	r3, [sp, #12]
 80087c4:	685a      	ldr	r2, [r3, #4]
 80087c6:	9b02      	ldr	r3, [sp, #8]
 80087c8:	681b      	ldr	r3, [r3, #0]
 80087ca:	3301      	adds	r3, #1
 80087cc:	429a      	cmp	r2, r3
 80087ce:	da0c      	bge.n	80087ea <fast_mp_montgomery_reduce+0x3a>
    if ((res = mp_grow (x, n->used + 1)) != MP_OKAY) {
 80087d0:	9b02      	ldr	r3, [sp, #8]
 80087d2:	681b      	ldr	r3, [r3, #0]
 80087d4:	3301      	adds	r3, #1
 80087d6:	4619      	mov	r1, r3
 80087d8:	9803      	ldr	r0, [sp, #12]
 80087da:	f002 f909 	bl	800a9f0 <mp_grow>
 80087de:	9007      	str	r0, [sp, #28]
 80087e0:	9b07      	ldr	r3, [sp, #28]
 80087e2:	2b00      	cmp	r3, #0
 80087e4:	d001      	beq.n	80087ea <fast_mp_montgomery_reduce+0x3a>
      return res;
 80087e6:	9b07      	ldr	r3, [sp, #28]
 80087e8:	e11e      	b.n	8008a28 <fast_mp_montgomery_reduce+0x278>
  W = (mp_word*)XMALLOC(sizeof(mp_word) * MP_WARRAY, NULL, DYNAMIC_TYPE_BIGINT);
 80087ea:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80087ee:	2000      	movs	r0, #0
 80087f0:	f7fd f836 	bl	8005860 <chibios_alloc>
 80087f4:	9006      	str	r0, [sp, #24]
  if (W == NULL)
 80087f6:	9b06      	ldr	r3, [sp, #24]
 80087f8:	2b00      	cmp	r3, #0
 80087fa:	d102      	bne.n	8008802 <fast_mp_montgomery_reduce+0x52>
    return MP_MEM;
 80087fc:	f06f 0301 	mvn.w	r3, #1
 8008800:	e112      	b.n	8008a28 <fast_mp_montgomery_reduce+0x278>
    _W   = W;
 8008802:	9b06      	ldr	r3, [sp, #24]
 8008804:	9310      	str	r3, [sp, #64]	; 0x40
    tmpx = x->dp;
 8008806:	9b03      	ldr	r3, [sp, #12]
 8008808:	68db      	ldr	r3, [r3, #12]
 800880a:	930f      	str	r3, [sp, #60]	; 0x3c
    for (ix = 0; ix < x->used; ix++) {
 800880c:	2300      	movs	r3, #0
 800880e:	9311      	str	r3, [sp, #68]	; 0x44
 8008810:	e00f      	b.n	8008832 <fast_mp_montgomery_reduce+0x82>
      *_W++ = *tmpx++;
 8008812:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008814:	f101 0308 	add.w	r3, r1, #8
 8008818:	9310      	str	r3, [sp, #64]	; 0x40
 800881a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800881c:	1d1a      	adds	r2, r3, #4
 800881e:	920f      	str	r2, [sp, #60]	; 0x3c
 8008820:	681b      	ldr	r3, [r3, #0]
 8008822:	461a      	mov	r2, r3
 8008824:	f04f 0300 	mov.w	r3, #0
 8008828:	e9c1 2300 	strd	r2, r3, [r1]
    for (ix = 0; ix < x->used; ix++) {
 800882c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800882e:	3301      	adds	r3, #1
 8008830:	9311      	str	r3, [sp, #68]	; 0x44
 8008832:	9b03      	ldr	r3, [sp, #12]
 8008834:	681a      	ldr	r2, [r3, #0]
 8008836:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008838:	429a      	cmp	r2, r3
 800883a:	dcea      	bgt.n	8008812 <fast_mp_montgomery_reduce+0x62>
 800883c:	e00c      	b.n	8008858 <fast_mp_montgomery_reduce+0xa8>
      *_W++ = 0;
 800883e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008840:	f103 0208 	add.w	r2, r3, #8
 8008844:	9210      	str	r2, [sp, #64]	; 0x40
 8008846:	f04f 0100 	mov.w	r1, #0
 800884a:	f04f 0200 	mov.w	r2, #0
 800884e:	e9c3 1200 	strd	r1, r2, [r3]
    for (; ix < n->used * 2 + 1; ix++) {
 8008852:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008854:	3301      	adds	r3, #1
 8008856:	9311      	str	r3, [sp, #68]	; 0x44
 8008858:	9b02      	ldr	r3, [sp, #8]
 800885a:	681b      	ldr	r3, [r3, #0]
 800885c:	005b      	lsls	r3, r3, #1
 800885e:	1c5a      	adds	r2, r3, #1
 8008860:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008862:	429a      	cmp	r2, r3
 8008864:	dceb      	bgt.n	800883e <fast_mp_montgomery_reduce+0x8e>
  for (ix = 0; ix < n->used; ix++) {
 8008866:	2300      	movs	r3, #0
 8008868:	9311      	str	r3, [sp, #68]	; 0x44
 800886a:	e061      	b.n	8008930 <fast_mp_montgomery_reduce+0x180>
    mu = (mp_digit) (((W[ix] & MP_MASK) * rho) & MP_MASK);
 800886c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800886e:	00db      	lsls	r3, r3, #3
 8008870:	9a06      	ldr	r2, [sp, #24]
 8008872:	4413      	add	r3, r2
 8008874:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008878:	4613      	mov	r3, r2
 800887a:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800887e:	9a01      	ldr	r2, [sp, #4]
 8008880:	fb02 f303 	mul.w	r3, r2, r3
 8008884:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8008888:	9305      	str	r3, [sp, #20]
      tmpn = n->dp;
 800888a:	9b02      	ldr	r3, [sp, #8]
 800888c:	68db      	ldr	r3, [r3, #12]
 800888e:	930d      	str	r3, [sp, #52]	; 0x34
      _W = W + ix;
 8008890:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008892:	00db      	lsls	r3, r3, #3
 8008894:	9a06      	ldr	r2, [sp, #24]
 8008896:	4413      	add	r3, r2
 8008898:	930c      	str	r3, [sp, #48]	; 0x30
      for (iy = 0; iy < n->used; iy++) {
 800889a:	2300      	movs	r3, #0
 800889c:	930e      	str	r3, [sp, #56]	; 0x38
 800889e:	e023      	b.n	80088e8 <fast_mp_montgomery_reduce+0x138>
          *_W++ += ((mp_word)mu) * ((mp_word)*tmpn++);
 80088a0:	9b05      	ldr	r3, [sp, #20]
 80088a2:	4618      	mov	r0, r3
 80088a4:	f04f 0100 	mov.w	r1, #0
 80088a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80088aa:	1d1a      	adds	r2, r3, #4
 80088ac:	920d      	str	r2, [sp, #52]	; 0x34
 80088ae:	681b      	ldr	r3, [r3, #0]
 80088b0:	461a      	mov	r2, r3
 80088b2:	f04f 0300 	mov.w	r3, #0
 80088b6:	fb02 fc01 	mul.w	ip, r2, r1
 80088ba:	fb00 fe03 	mul.w	lr, r0, r3
 80088be:	44e6      	add	lr, ip
 80088c0:	fba0 2302 	umull	r2, r3, r0, r2
 80088c4:	eb0e 0103 	add.w	r1, lr, r3
 80088c8:	460b      	mov	r3, r1
 80088ca:	990c      	ldr	r1, [sp, #48]	; 0x30
 80088cc:	f101 0008 	add.w	r0, r1, #8
 80088d0:	900c      	str	r0, [sp, #48]	; 0x30
 80088d2:	e9d1 8900 	ldrd	r8, r9, [r1]
 80088d6:	eb12 0208 	adds.w	r2, r2, r8
 80088da:	eb43 0309 	adc.w	r3, r3, r9
 80088de:	e9c1 2300 	strd	r2, r3, [r1]
      for (iy = 0; iy < n->used; iy++) {
 80088e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80088e4:	3301      	adds	r3, #1
 80088e6:	930e      	str	r3, [sp, #56]	; 0x38
 80088e8:	9b02      	ldr	r3, [sp, #8]
 80088ea:	681a      	ldr	r2, [r3, #0]
 80088ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80088ee:	429a      	cmp	r2, r3
 80088f0:	dcd6      	bgt.n	80088a0 <fast_mp_montgomery_reduce+0xf0>
    W[ix + 1] += W[ix] >> ((mp_word) DIGIT_BIT);
 80088f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80088f4:	3301      	adds	r3, #1
 80088f6:	00db      	lsls	r3, r3, #3
 80088f8:	9a06      	ldr	r2, [sp, #24]
 80088fa:	eb02 0e03 	add.w	lr, r2, r3
 80088fe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008900:	3301      	adds	r3, #1
 8008902:	00db      	lsls	r3, r3, #3
 8008904:	9a06      	ldr	r2, [sp, #24]
 8008906:	4413      	add	r3, r2
 8008908:	e9d3 0100 	ldrd	r0, r1, [r3]
 800890c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800890e:	00db      	lsls	r3, r3, #3
 8008910:	9a06      	ldr	r2, [sp, #24]
 8008912:	4413      	add	r3, r2
 8008914:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008918:	0f16      	lsrs	r6, r2, #28
 800891a:	ea46 1603 	orr.w	r6, r6, r3, lsl #4
 800891e:	0f1f      	lsrs	r7, r3, #28
 8008920:	1982      	adds	r2, r0, r6
 8008922:	eb41 0307 	adc.w	r3, r1, r7
 8008926:	e9ce 2300 	strd	r2, r3, [lr]
  for (ix = 0; ix < n->used; ix++) {
 800892a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800892c:	3301      	adds	r3, #1
 800892e:	9311      	str	r3, [sp, #68]	; 0x44
 8008930:	9b02      	ldr	r3, [sp, #8]
 8008932:	681a      	ldr	r2, [r3, #0]
 8008934:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008936:	429a      	cmp	r2, r3
 8008938:	dc98      	bgt.n	800886c <fast_mp_montgomery_reduce+0xbc>
    _W1 = W + ix;
 800893a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800893c:	00db      	lsls	r3, r3, #3
 800893e:	9a06      	ldr	r2, [sp, #24]
 8008940:	4413      	add	r3, r2
 8008942:	9309      	str	r3, [sp, #36]	; 0x24
    _W = W + ++ix;
 8008944:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008946:	3301      	adds	r3, #1
 8008948:	9311      	str	r3, [sp, #68]	; 0x44
 800894a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800894c:	00db      	lsls	r3, r3, #3
 800894e:	9a06      	ldr	r2, [sp, #24]
 8008950:	4413      	add	r3, r2
 8008952:	930a      	str	r3, [sp, #40]	; 0x28
 8008954:	e017      	b.n	8008986 <fast_mp_montgomery_reduce+0x1d6>
      *_W++ += *_W1++ >> ((mp_word) DIGIT_BIT);
 8008956:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008958:	f103 0208 	add.w	r2, r3, #8
 800895c:	9209      	str	r2, [sp, #36]	; 0x24
 800895e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008962:	0f14      	lsrs	r4, r2, #28
 8008964:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8008968:	0f1d      	lsrs	r5, r3, #28
 800896a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800896c:	f103 0208 	add.w	r2, r3, #8
 8008970:	920a      	str	r2, [sp, #40]	; 0x28
 8008972:	e9d3 1200 	ldrd	r1, r2, [r3]
 8008976:	1909      	adds	r1, r1, r4
 8008978:	eb42 0205 	adc.w	r2, r2, r5
 800897c:	e9c3 1200 	strd	r1, r2, [r3]
    for (; ix <= n->used * 2 + 1; ix++) {
 8008980:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008982:	3301      	adds	r3, #1
 8008984:	9311      	str	r3, [sp, #68]	; 0x44
 8008986:	9b02      	ldr	r3, [sp, #8]
 8008988:	681b      	ldr	r3, [r3, #0]
 800898a:	005b      	lsls	r3, r3, #1
 800898c:	1c5a      	adds	r2, r3, #1
 800898e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008990:	429a      	cmp	r2, r3
 8008992:	dae0      	bge.n	8008956 <fast_mp_montgomery_reduce+0x1a6>
    tmpx = x->dp;
 8008994:	9b03      	ldr	r3, [sp, #12]
 8008996:	68db      	ldr	r3, [r3, #12]
 8008998:	930b      	str	r3, [sp, #44]	; 0x2c
    _W = W + n->used;
 800899a:	9b02      	ldr	r3, [sp, #8]
 800899c:	681b      	ldr	r3, [r3, #0]
 800899e:	00db      	lsls	r3, r3, #3
 80089a0:	9a06      	ldr	r2, [sp, #24]
 80089a2:	4413      	add	r3, r2
 80089a4:	930a      	str	r3, [sp, #40]	; 0x28
    for (ix = 0; ix < n->used + 1; ix++) {
 80089a6:	2300      	movs	r3, #0
 80089a8:	9311      	str	r3, [sp, #68]	; 0x44
 80089aa:	e00f      	b.n	80089cc <fast_mp_montgomery_reduce+0x21c>
      *tmpx++ = (mp_digit)(*_W++ & ((mp_word) MP_MASK));
 80089ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80089ae:	1d1a      	adds	r2, r3, #4
 80089b0:	920b      	str	r2, [sp, #44]	; 0x2c
 80089b2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80089b4:	f102 0108 	add.w	r1, r2, #8
 80089b8:	910a      	str	r1, [sp, #40]	; 0x28
 80089ba:	e9d2 1200 	ldrd	r1, r2, [r2]
 80089be:	460a      	mov	r2, r1
 80089c0:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80089c4:	601a      	str	r2, [r3, #0]
    for (ix = 0; ix < n->used + 1; ix++) {
 80089c6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80089c8:	3301      	adds	r3, #1
 80089ca:	9311      	str	r3, [sp, #68]	; 0x44
 80089cc:	9b02      	ldr	r3, [sp, #8]
 80089ce:	681b      	ldr	r3, [r3, #0]
 80089d0:	1c5a      	adds	r2, r3, #1
 80089d2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80089d4:	429a      	cmp	r2, r3
 80089d6:	dce9      	bgt.n	80089ac <fast_mp_montgomery_reduce+0x1fc>
 80089d8:	e007      	b.n	80089ea <fast_mp_montgomery_reduce+0x23a>
      *tmpx++ = 0;
 80089da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80089dc:	1d1a      	adds	r2, r3, #4
 80089de:	920b      	str	r2, [sp, #44]	; 0x2c
 80089e0:	2200      	movs	r2, #0
 80089e2:	601a      	str	r2, [r3, #0]
    for (; ix < olduse; ix++) {
 80089e4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80089e6:	3301      	adds	r3, #1
 80089e8:	9311      	str	r3, [sp, #68]	; 0x44
 80089ea:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80089ec:	9b08      	ldr	r3, [sp, #32]
 80089ee:	429a      	cmp	r2, r3
 80089f0:	dbf3      	blt.n	80089da <fast_mp_montgomery_reduce+0x22a>
  x->used = n->used + 1;
 80089f2:	9b02      	ldr	r3, [sp, #8]
 80089f4:	681b      	ldr	r3, [r3, #0]
 80089f6:	1c5a      	adds	r2, r3, #1
 80089f8:	9b03      	ldr	r3, [sp, #12]
 80089fa:	601a      	str	r2, [r3, #0]
  mp_clamp (x);
 80089fc:	9803      	ldr	r0, [sp, #12]
 80089fe:	f002 f8d7 	bl	800abb0 <mp_clamp>
  XFREE(W, NULL, DYNAMIC_TYPE_BIGINT);
 8008a02:	9806      	ldr	r0, [sp, #24]
 8008a04:	f7fc ff3c 	bl	8005880 <chibios_free>
  if (mp_cmp_mag (x, n) != MP_LT) {
 8008a08:	9902      	ldr	r1, [sp, #8]
 8008a0a:	9803      	ldr	r0, [sp, #12]
 8008a0c:	f003 f810 	bl	800ba30 <mp_cmp_mag>
 8008a10:	4603      	mov	r3, r0
 8008a12:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008a16:	d006      	beq.n	8008a26 <fast_mp_montgomery_reduce+0x276>
    return s_mp_sub (x, n, x);
 8008a18:	9a03      	ldr	r2, [sp, #12]
 8008a1a:	9902      	ldr	r1, [sp, #8]
 8008a1c:	9803      	ldr	r0, [sp, #12]
 8008a1e:	f7ff fa67 	bl	8007ef0 <s_mp_sub>
 8008a22:	4603      	mov	r3, r0
 8008a24:	e000      	b.n	8008a28 <fast_mp_montgomery_reduce+0x278>
  return MP_OKAY;
 8008a26:	2300      	movs	r3, #0
}
 8008a28:	4618      	mov	r0, r3
 8008a2a:	b013      	add	sp, #76	; 0x4c
 8008a2c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08008a30 <mp_montgomery_reduce>:
{
 8008a30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008a32:	b08f      	sub	sp, #60	; 0x3c
 8008a34:	9003      	str	r0, [sp, #12]
 8008a36:	9102      	str	r1, [sp, #8]
 8008a38:	9201      	str	r2, [sp, #4]
  digs = n->used * 2 + 1;
 8008a3a:	9b02      	ldr	r3, [sp, #8]
 8008a3c:	681b      	ldr	r3, [r3, #0]
 8008a3e:	005b      	lsls	r3, r3, #1
 8008a40:	3301      	adds	r3, #1
 8008a42:	9308      	str	r3, [sp, #32]
  if ((digs < MP_WARRAY) &&
 8008a44:	9b08      	ldr	r3, [sp, #32]
 8008a46:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008a4a:	da0a      	bge.n	8008a62 <mp_montgomery_reduce+0x32>
      n->used <
 8008a4c:	9b02      	ldr	r3, [sp, #8]
 8008a4e:	681b      	ldr	r3, [r3, #0]
  if ((digs < MP_WARRAY) &&
 8008a50:	2bff      	cmp	r3, #255	; 0xff
 8008a52:	dc06      	bgt.n	8008a62 <mp_montgomery_reduce+0x32>
    return fast_mp_montgomery_reduce (x, n, rho);
 8008a54:	9a01      	ldr	r2, [sp, #4]
 8008a56:	9902      	ldr	r1, [sp, #8]
 8008a58:	9803      	ldr	r0, [sp, #12]
 8008a5a:	f7ff fea9 	bl	80087b0 <fast_mp_montgomery_reduce>
 8008a5e:	4603      	mov	r3, r0
 8008a60:	e0a0      	b.n	8008ba4 <mp_montgomery_reduce+0x174>
  if (x->alloc < digs) {
 8008a62:	9b03      	ldr	r3, [sp, #12]
 8008a64:	685a      	ldr	r2, [r3, #4]
 8008a66:	9b08      	ldr	r3, [sp, #32]
 8008a68:	429a      	cmp	r2, r3
 8008a6a:	da09      	bge.n	8008a80 <mp_montgomery_reduce+0x50>
    if ((res = mp_grow (x, digs)) != MP_OKAY) {
 8008a6c:	9908      	ldr	r1, [sp, #32]
 8008a6e:	9803      	ldr	r0, [sp, #12]
 8008a70:	f001 ffbe 	bl	800a9f0 <mp_grow>
 8008a74:	9007      	str	r0, [sp, #28]
 8008a76:	9b07      	ldr	r3, [sp, #28]
 8008a78:	2b00      	cmp	r3, #0
 8008a7a:	d001      	beq.n	8008a80 <mp_montgomery_reduce+0x50>
      return res;
 8008a7c:	9b07      	ldr	r3, [sp, #28]
 8008a7e:	e091      	b.n	8008ba4 <mp_montgomery_reduce+0x174>
  x->used = digs;
 8008a80:	9b03      	ldr	r3, [sp, #12]
 8008a82:	9a08      	ldr	r2, [sp, #32]
 8008a84:	601a      	str	r2, [r3, #0]
  for (ix = 0; ix < n->used; ix++) {
 8008a86:	2300      	movs	r3, #0
 8008a88:	930d      	str	r3, [sp, #52]	; 0x34
 8008a8a:	e06d      	b.n	8008b68 <mp_montgomery_reduce+0x138>
    mu = (mp_digit) (((mp_word)x->dp[ix]) * ((mp_word)rho) & MP_MASK);
 8008a8c:	9b03      	ldr	r3, [sp, #12]
 8008a8e:	68da      	ldr	r2, [r3, #12]
 8008a90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008a92:	009b      	lsls	r3, r3, #2
 8008a94:	4413      	add	r3, r2
 8008a96:	681b      	ldr	r3, [r3, #0]
 8008a98:	9a01      	ldr	r2, [sp, #4]
 8008a9a:	fb02 f303 	mul.w	r3, r2, r3
 8008a9e:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8008aa2:	9306      	str	r3, [sp, #24]
      tmpn = n->dp;
 8008aa4:	9b02      	ldr	r3, [sp, #8]
 8008aa6:	68db      	ldr	r3, [r3, #12]
 8008aa8:	930b      	str	r3, [sp, #44]	; 0x2c
      tmpx = x->dp + ix;
 8008aaa:	9b03      	ldr	r3, [sp, #12]
 8008aac:	68da      	ldr	r2, [r3, #12]
 8008aae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008ab0:	009b      	lsls	r3, r3, #2
 8008ab2:	4413      	add	r3, r2
 8008ab4:	930a      	str	r3, [sp, #40]	; 0x28
      u = 0;
 8008ab6:	2300      	movs	r3, #0
 8008ab8:	9309      	str	r3, [sp, #36]	; 0x24
      for (iy = 0; iy < n->used; iy++) {
 8008aba:	2300      	movs	r3, #0
 8008abc:	930c      	str	r3, [sp, #48]	; 0x30
 8008abe:	e036      	b.n	8008b2e <mp_montgomery_reduce+0xfe>
        r       = ((mp_word)mu) * ((mp_word)*tmpn++) +
 8008ac0:	9b06      	ldr	r3, [sp, #24]
 8008ac2:	4618      	mov	r0, r3
 8008ac4:	f04f 0100 	mov.w	r1, #0
 8008ac8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008aca:	1d1a      	adds	r2, r3, #4
 8008acc:	920b      	str	r2, [sp, #44]	; 0x2c
 8008ace:	681b      	ldr	r3, [r3, #0]
 8008ad0:	461a      	mov	r2, r3
 8008ad2:	f04f 0300 	mov.w	r3, #0
 8008ad6:	fb02 f701 	mul.w	r7, r2, r1
 8008ada:	fb00 f603 	mul.w	r6, r0, r3
 8008ade:	443e      	add	r6, r7
 8008ae0:	fba0 2302 	umull	r2, r3, r0, r2
 8008ae4:	18f1      	adds	r1, r6, r3
 8008ae6:	460b      	mov	r3, r1
                  ((mp_word) u) + ((mp_word) * tmpx);
 8008ae8:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008aea:	4608      	mov	r0, r1
 8008aec:	f04f 0100 	mov.w	r1, #0
        r       = ((mp_word)mu) * ((mp_word)*tmpn++) +
 8008af0:	1880      	adds	r0, r0, r2
 8008af2:	eb41 0103 	adc.w	r1, r1, r3
                  ((mp_word) u) + ((mp_word) * tmpx);
 8008af6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008af8:	681b      	ldr	r3, [r3, #0]
 8008afa:	461a      	mov	r2, r3
 8008afc:	f04f 0300 	mov.w	r3, #0
        r       = ((mp_word)mu) * ((mp_word)*tmpn++) +
 8008b00:	1812      	adds	r2, r2, r0
 8008b02:	eb43 0301 	adc.w	r3, r3, r1
 8008b06:	e9cd 2304 	strd	r2, r3, [sp, #16]
        u       = (mp_digit)(r >> ((mp_word) DIGIT_BIT));
 8008b0a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008b0e:	0f14      	lsrs	r4, r2, #28
 8008b10:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8008b14:	0f1d      	lsrs	r5, r3, #28
 8008b16:	4623      	mov	r3, r4
 8008b18:	9309      	str	r3, [sp, #36]	; 0x24
        *tmpx++ = (mp_digit)(r & ((mp_word) MP_MASK));
 8008b1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008b1c:	1d1a      	adds	r2, r3, #4
 8008b1e:	920a      	str	r2, [sp, #40]	; 0x28
 8008b20:	9a04      	ldr	r2, [sp, #16]
 8008b22:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8008b26:	601a      	str	r2, [r3, #0]
      for (iy = 0; iy < n->used; iy++) {
 8008b28:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008b2a:	3301      	adds	r3, #1
 8008b2c:	930c      	str	r3, [sp, #48]	; 0x30
 8008b2e:	9b02      	ldr	r3, [sp, #8]
 8008b30:	681a      	ldr	r2, [r3, #0]
 8008b32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008b34:	429a      	cmp	r2, r3
 8008b36:	dcc3      	bgt.n	8008ac0 <mp_montgomery_reduce+0x90>
 8008b38:	e010      	b.n	8008b5c <mp_montgomery_reduce+0x12c>
        *tmpx   += u;
 8008b3a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008b3c:	681a      	ldr	r2, [r3, #0]
 8008b3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008b40:	441a      	add	r2, r3
 8008b42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008b44:	601a      	str	r2, [r3, #0]
        u        = *tmpx >> DIGIT_BIT;
 8008b46:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008b48:	681b      	ldr	r3, [r3, #0]
 8008b4a:	0f1b      	lsrs	r3, r3, #28
 8008b4c:	9309      	str	r3, [sp, #36]	; 0x24
        *tmpx++ &= MP_MASK;
 8008b4e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008b50:	1d1a      	adds	r2, r3, #4
 8008b52:	920a      	str	r2, [sp, #40]	; 0x28
 8008b54:	681a      	ldr	r2, [r3, #0]
 8008b56:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8008b5a:	601a      	str	r2, [r3, #0]
      while (u) {
 8008b5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008b5e:	2b00      	cmp	r3, #0
 8008b60:	d1eb      	bne.n	8008b3a <mp_montgomery_reduce+0x10a>
  for (ix = 0; ix < n->used; ix++) {
 8008b62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008b64:	3301      	adds	r3, #1
 8008b66:	930d      	str	r3, [sp, #52]	; 0x34
 8008b68:	9b02      	ldr	r3, [sp, #8]
 8008b6a:	681a      	ldr	r2, [r3, #0]
 8008b6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008b6e:	429a      	cmp	r2, r3
 8008b70:	dc8c      	bgt.n	8008a8c <mp_montgomery_reduce+0x5c>
  mp_clamp(x);
 8008b72:	9803      	ldr	r0, [sp, #12]
 8008b74:	f002 f81c 	bl	800abb0 <mp_clamp>
  mp_rshd (x, n->used);
 8008b78:	9b02      	ldr	r3, [sp, #8]
 8008b7a:	681b      	ldr	r3, [r3, #0]
 8008b7c:	4619      	mov	r1, r3
 8008b7e:	9803      	ldr	r0, [sp, #12]
 8008b80:	f002 f8a6 	bl	800acd0 <mp_rshd>
  if (mp_cmp_mag (x, n) != MP_LT) {
 8008b84:	9902      	ldr	r1, [sp, #8]
 8008b86:	9803      	ldr	r0, [sp, #12]
 8008b88:	f002 ff52 	bl	800ba30 <mp_cmp_mag>
 8008b8c:	4603      	mov	r3, r0
 8008b8e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008b92:	d006      	beq.n	8008ba2 <mp_montgomery_reduce+0x172>
    return s_mp_sub (x, n, x);
 8008b94:	9a03      	ldr	r2, [sp, #12]
 8008b96:	9902      	ldr	r1, [sp, #8]
 8008b98:	9803      	ldr	r0, [sp, #12]
 8008b9a:	f7ff f9a9 	bl	8007ef0 <s_mp_sub>
 8008b9e:	4603      	mov	r3, r0
 8008ba0:	e000      	b.n	8008ba4 <mp_montgomery_reduce+0x174>
  return MP_OKAY;
 8008ba2:	2300      	movs	r3, #0
}
 8008ba4:	4618      	mov	r0, r3
 8008ba6:	b00f      	add	sp, #60	; 0x3c
 8008ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008baa:	bf00      	nop
 8008bac:	0000      	movs	r0, r0
	...

08008bb0 <mp_dr_setup>:
{
 8008bb0:	b082      	sub	sp, #8
 8008bb2:	9001      	str	r0, [sp, #4]
 8008bb4:	9100      	str	r1, [sp, #0]
        ((mp_word)a->dp[0]));
 8008bb6:	9b01      	ldr	r3, [sp, #4]
 8008bb8:	68db      	ldr	r3, [r3, #12]
 8008bba:	681b      	ldr	r3, [r3, #0]
   *d = (mp_digit)((((mp_word)1) << ((mp_word)DIGIT_BIT)) -
 8008bbc:	f1c3 5280 	rsb	r2, r3, #268435456	; 0x10000000
 8008bc0:	9b00      	ldr	r3, [sp, #0]
 8008bc2:	601a      	str	r2, [r3, #0]
}
 8008bc4:	b002      	add	sp, #8
 8008bc6:	4770      	bx	lr
	...

08008bd0 <mp_dr_reduce>:
{
 8008bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008bd2:	b08d      	sub	sp, #52	; 0x34
 8008bd4:	9003      	str	r0, [sp, #12]
 8008bd6:	9102      	str	r1, [sp, #8]
 8008bd8:	9201      	str	r2, [sp, #4]
  m = n->used;
 8008bda:	9b02      	ldr	r3, [sp, #8]
 8008bdc:	681b      	ldr	r3, [r3, #0]
 8008bde:	9307      	str	r3, [sp, #28]
  if (x->alloc < m + m) {
 8008be0:	9b03      	ldr	r3, [sp, #12]
 8008be2:	685a      	ldr	r2, [r3, #4]
 8008be4:	9907      	ldr	r1, [sp, #28]
 8008be6:	9b07      	ldr	r3, [sp, #28]
 8008be8:	440b      	add	r3, r1
 8008bea:	429a      	cmp	r2, r3
 8008bec:	da0c      	bge.n	8008c08 <mp_dr_reduce+0x38>
    if ((err = mp_grow (x, m + m)) != MP_OKAY) {
 8008bee:	9a07      	ldr	r2, [sp, #28]
 8008bf0:	9b07      	ldr	r3, [sp, #28]
 8008bf2:	4413      	add	r3, r2
 8008bf4:	4619      	mov	r1, r3
 8008bf6:	9803      	ldr	r0, [sp, #12]
 8008bf8:	f001 fefa 	bl	800a9f0 <mp_grow>
 8008bfc:	9006      	str	r0, [sp, #24]
 8008bfe:	9b06      	ldr	r3, [sp, #24]
 8008c00:	2b00      	cmp	r3, #0
 8008c02:	d001      	beq.n	8008c08 <mp_dr_reduce+0x38>
      return err;
 8008c04:	9b06      	ldr	r3, [sp, #24]
 8008c06:	e075      	b.n	8008cf4 <mp_dr_reduce+0x124>
  tmpx1 = x->dp;
 8008c08:	9b03      	ldr	r3, [sp, #12]
 8008c0a:	68db      	ldr	r3, [r3, #12]
 8008c0c:	9309      	str	r3, [sp, #36]	; 0x24
  tmpx2 = x->dp + m;
 8008c0e:	9b03      	ldr	r3, [sp, #12]
 8008c10:	68da      	ldr	r2, [r3, #12]
 8008c12:	9b07      	ldr	r3, [sp, #28]
 8008c14:	009b      	lsls	r3, r3, #2
 8008c16:	4413      	add	r3, r2
 8008c18:	9308      	str	r3, [sp, #32]
  mu = 0;
 8008c1a:	2300      	movs	r3, #0
 8008c1c:	930a      	str	r3, [sp, #40]	; 0x28
  for (i = 0; i < m; i++) {
 8008c1e:	2300      	movs	r3, #0
 8008c20:	930b      	str	r3, [sp, #44]	; 0x2c
 8008c22:	e036      	b.n	8008c92 <mp_dr_reduce+0xc2>
      r         = ((mp_word)*tmpx2++) * ((mp_word)k) + *tmpx1 + mu;
 8008c24:	9b08      	ldr	r3, [sp, #32]
 8008c26:	1d1a      	adds	r2, r3, #4
 8008c28:	9208      	str	r2, [sp, #32]
 8008c2a:	681b      	ldr	r3, [r3, #0]
 8008c2c:	4618      	mov	r0, r3
 8008c2e:	f04f 0100 	mov.w	r1, #0
 8008c32:	9b01      	ldr	r3, [sp, #4]
 8008c34:	461a      	mov	r2, r3
 8008c36:	f04f 0300 	mov.w	r3, #0
 8008c3a:	fb02 f701 	mul.w	r7, r2, r1
 8008c3e:	fb00 f603 	mul.w	r6, r0, r3
 8008c42:	443e      	add	r6, r7
 8008c44:	fba0 2302 	umull	r2, r3, r0, r2
 8008c48:	18f1      	adds	r1, r6, r3
 8008c4a:	460b      	mov	r3, r1
 8008c4c:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008c4e:	6809      	ldr	r1, [r1, #0]
 8008c50:	4608      	mov	r0, r1
 8008c52:	f04f 0100 	mov.w	r1, #0
 8008c56:	1880      	adds	r0, r0, r2
 8008c58:	eb41 0103 	adc.w	r1, r1, r3
 8008c5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008c5e:	461a      	mov	r2, r3
 8008c60:	f04f 0300 	mov.w	r3, #0
 8008c64:	1812      	adds	r2, r2, r0
 8008c66:	eb43 0301 	adc.w	r3, r3, r1
 8008c6a:	e9cd 2304 	strd	r2, r3, [sp, #16]
      *tmpx1++  = (mp_digit)(r & MP_MASK);
 8008c6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008c70:	1d1a      	adds	r2, r3, #4
 8008c72:	9209      	str	r2, [sp, #36]	; 0x24
 8008c74:	9a04      	ldr	r2, [sp, #16]
 8008c76:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8008c7a:	601a      	str	r2, [r3, #0]
      mu        = (mp_digit)(r >> ((mp_word)DIGIT_BIT));
 8008c7c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008c80:	0f14      	lsrs	r4, r2, #28
 8008c82:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8008c86:	0f1d      	lsrs	r5, r3, #28
 8008c88:	4623      	mov	r3, r4
 8008c8a:	930a      	str	r3, [sp, #40]	; 0x28
  for (i = 0; i < m; i++) {
 8008c8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008c8e:	3301      	adds	r3, #1
 8008c90:	930b      	str	r3, [sp, #44]	; 0x2c
 8008c92:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008c94:	9b07      	ldr	r3, [sp, #28]
 8008c96:	429a      	cmp	r2, r3
 8008c98:	dbc4      	blt.n	8008c24 <mp_dr_reduce+0x54>
  *tmpx1++ = mu;
 8008c9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008c9c:	1d1a      	adds	r2, r3, #4
 8008c9e:	9209      	str	r2, [sp, #36]	; 0x24
 8008ca0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008ca2:	601a      	str	r2, [r3, #0]
  for (i = m + 1; i < x->used; i++) {
 8008ca4:	9b07      	ldr	r3, [sp, #28]
 8008ca6:	3301      	adds	r3, #1
 8008ca8:	930b      	str	r3, [sp, #44]	; 0x2c
 8008caa:	e007      	b.n	8008cbc <mp_dr_reduce+0xec>
      *tmpx1++ = 0;
 8008cac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008cae:	1d1a      	adds	r2, r3, #4
 8008cb0:	9209      	str	r2, [sp, #36]	; 0x24
 8008cb2:	2200      	movs	r2, #0
 8008cb4:	601a      	str	r2, [r3, #0]
  for (i = m + 1; i < x->used; i++) {
 8008cb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008cb8:	3301      	adds	r3, #1
 8008cba:	930b      	str	r3, [sp, #44]	; 0x2c
 8008cbc:	9b03      	ldr	r3, [sp, #12]
 8008cbe:	681a      	ldr	r2, [r3, #0]
 8008cc0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008cc2:	429a      	cmp	r2, r3
 8008cc4:	dcf2      	bgt.n	8008cac <mp_dr_reduce+0xdc>
  mp_clamp (x);
 8008cc6:	9803      	ldr	r0, [sp, #12]
 8008cc8:	f001 ff72 	bl	800abb0 <mp_clamp>
  if (mp_cmp_mag (x, n) != MP_LT) {
 8008ccc:	9902      	ldr	r1, [sp, #8]
 8008cce:	9803      	ldr	r0, [sp, #12]
 8008cd0:	f002 feae 	bl	800ba30 <mp_cmp_mag>
 8008cd4:	4603      	mov	r3, r0
 8008cd6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008cda:	d00a      	beq.n	8008cf2 <mp_dr_reduce+0x122>
    if ((err = s_mp_sub(x, n, x)) != MP_OKAY) {
 8008cdc:	9a03      	ldr	r2, [sp, #12]
 8008cde:	9902      	ldr	r1, [sp, #8]
 8008ce0:	9803      	ldr	r0, [sp, #12]
 8008ce2:	f7ff f905 	bl	8007ef0 <s_mp_sub>
 8008ce6:	9006      	str	r0, [sp, #24]
 8008ce8:	9b06      	ldr	r3, [sp, #24]
 8008cea:	2b00      	cmp	r3, #0
 8008cec:	d08c      	beq.n	8008c08 <mp_dr_reduce+0x38>
        return err;
 8008cee:	9b06      	ldr	r3, [sp, #24]
 8008cf0:	e000      	b.n	8008cf4 <mp_dr_reduce+0x124>
  return MP_OKAY;
 8008cf2:	2300      	movs	r3, #0
}
 8008cf4:	4618      	mov	r0, r3
 8008cf6:	b00d      	add	sp, #52	; 0x34
 8008cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008cfa:	bf00      	nop
 8008cfc:	0000      	movs	r0, r0
	...

08008d00 <mp_reduce_2k>:
{
 8008d00:	b500      	push	{lr}
 8008d02:	b08b      	sub	sp, #44	; 0x2c
 8008d04:	9003      	str	r0, [sp, #12]
 8008d06:	9102      	str	r1, [sp, #8]
 8008d08:	9201      	str	r2, [sp, #4]
   if ((res = mp_init(&q)) != MP_OKAY) {
 8008d0a:	ab04      	add	r3, sp, #16
 8008d0c:	4618      	mov	r0, r3
 8008d0e:	f001 fc77 	bl	800a600 <mp_init>
 8008d12:	9009      	str	r0, [sp, #36]	; 0x24
 8008d14:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d16:	2b00      	cmp	r3, #0
 8008d18:	d001      	beq.n	8008d1e <mp_reduce_2k+0x1e>
      return res;
 8008d1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d1c:	e03a      	b.n	8008d94 <mp_reduce_2k+0x94>
   p = mp_count_bits(n);
 8008d1e:	9802      	ldr	r0, [sp, #8]
 8008d20:	f001 fd1e 	bl	800a760 <mp_count_bits>
 8008d24:	9008      	str	r0, [sp, #32]
   if ((res = mp_div_2d(a, p, &q, a)) != MP_OKAY) {
 8008d26:	aa04      	add	r2, sp, #16
 8008d28:	9b03      	ldr	r3, [sp, #12]
 8008d2a:	9908      	ldr	r1, [sp, #32]
 8008d2c:	9803      	ldr	r0, [sp, #12]
 8008d2e:	f001 fe9f 	bl	800aa70 <mp_div_2d>
 8008d32:	9009      	str	r0, [sp, #36]	; 0x24
 8008d34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d36:	2b00      	cmp	r3, #0
 8008d38:	d127      	bne.n	8008d8a <mp_reduce_2k+0x8a>
   if (d != 1) {
 8008d3a:	9b01      	ldr	r3, [sp, #4]
 8008d3c:	2b01      	cmp	r3, #1
 8008d3e:	d009      	beq.n	8008d54 <mp_reduce_2k+0x54>
      if ((res = mp_mul_d(&q, d, &q)) != MP_OKAY) {
 8008d40:	aa04      	add	r2, sp, #16
 8008d42:	ab04      	add	r3, sp, #16
 8008d44:	9901      	ldr	r1, [sp, #4]
 8008d46:	4618      	mov	r0, r3
 8008d48:	f000 f8c2 	bl	8008ed0 <mp_mul_d>
 8008d4c:	9009      	str	r0, [sp, #36]	; 0x24
 8008d4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d50:	2b00      	cmp	r3, #0
 8008d52:	d11a      	bne.n	8008d8a <mp_reduce_2k+0x8a>
   if ((res = s_mp_add(a, &q, a)) != MP_OKAY) {
 8008d54:	ab04      	add	r3, sp, #16
 8008d56:	9a03      	ldr	r2, [sp, #12]
 8008d58:	4619      	mov	r1, r3
 8008d5a:	9803      	ldr	r0, [sp, #12]
 8008d5c:	f7ff f828 	bl	8007db0 <s_mp_add>
 8008d60:	9009      	str	r0, [sp, #36]	; 0x24
 8008d62:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d64:	2b00      	cmp	r3, #0
 8008d66:	d110      	bne.n	8008d8a <mp_reduce_2k+0x8a>
   if (mp_cmp_mag(a, n) != MP_LT) {
 8008d68:	9902      	ldr	r1, [sp, #8]
 8008d6a:	9803      	ldr	r0, [sp, #12]
 8008d6c:	f002 fe60 	bl	800ba30 <mp_cmp_mag>
 8008d70:	4603      	mov	r3, r0
 8008d72:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008d76:	d008      	beq.n	8008d8a <mp_reduce_2k+0x8a>
      if ((res = s_mp_sub(a, n, a)) != MP_OKAY) {
 8008d78:	9a03      	ldr	r2, [sp, #12]
 8008d7a:	9902      	ldr	r1, [sp, #8]
 8008d7c:	9803      	ldr	r0, [sp, #12]
 8008d7e:	f7ff f8b7 	bl	8007ef0 <s_mp_sub>
 8008d82:	9009      	str	r0, [sp, #36]	; 0x24
 8008d84:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d86:	2b00      	cmp	r3, #0
 8008d88:	d0cd      	beq.n	8008d26 <mp_reduce_2k+0x26>
   mp_clear(&q);
 8008d8a:	ab04      	add	r3, sp, #16
 8008d8c:	4618      	mov	r0, r3
 8008d8e:	f001 fc4f 	bl	800a630 <mp_clear>
   return res;
 8008d92:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8008d94:	4618      	mov	r0, r3
 8008d96:	b00b      	add	sp, #44	; 0x2c
 8008d98:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d9c:	0000      	movs	r0, r0
	...

08008da0 <mp_reduce_2k_setup>:
{
 8008da0:	b500      	push	{lr}
 8008da2:	b089      	sub	sp, #36	; 0x24
 8008da4:	9001      	str	r0, [sp, #4]
 8008da6:	9100      	str	r1, [sp, #0]
   if ((res = mp_init(&tmp)) != MP_OKAY) {
 8008da8:	ab02      	add	r3, sp, #8
 8008daa:	4618      	mov	r0, r3
 8008dac:	f001 fc28 	bl	800a600 <mp_init>
 8008db0:	9007      	str	r0, [sp, #28]
 8008db2:	9b07      	ldr	r3, [sp, #28]
 8008db4:	2b00      	cmp	r3, #0
 8008db6:	d001      	beq.n	8008dbc <mp_reduce_2k_setup+0x1c>
      return res;
 8008db8:	9b07      	ldr	r3, [sp, #28]
 8008dba:	e02b      	b.n	8008e14 <mp_reduce_2k_setup+0x74>
   p = mp_count_bits(a);
 8008dbc:	9801      	ldr	r0, [sp, #4]
 8008dbe:	f001 fccf 	bl	800a760 <mp_count_bits>
 8008dc2:	9006      	str	r0, [sp, #24]
   if ((res = mp_2expt(&tmp, p)) != MP_OKAY) {
 8008dc4:	ab02      	add	r3, sp, #8
 8008dc6:	9906      	ldr	r1, [sp, #24]
 8008dc8:	4618      	mov	r0, r3
 8008dca:	f000 f871 	bl	8008eb0 <mp_2expt>
 8008dce:	9007      	str	r0, [sp, #28]
 8008dd0:	9b07      	ldr	r3, [sp, #28]
 8008dd2:	2b00      	cmp	r3, #0
 8008dd4:	d005      	beq.n	8008de2 <mp_reduce_2k_setup+0x42>
      mp_clear(&tmp);
 8008dd6:	ab02      	add	r3, sp, #8
 8008dd8:	4618      	mov	r0, r3
 8008dda:	f001 fc29 	bl	800a630 <mp_clear>
      return res;
 8008dde:	9b07      	ldr	r3, [sp, #28]
 8008de0:	e018      	b.n	8008e14 <mp_reduce_2k_setup+0x74>
   if ((res = s_mp_sub(&tmp, a, &tmp)) != MP_OKAY) {
 8008de2:	aa02      	add	r2, sp, #8
 8008de4:	ab02      	add	r3, sp, #8
 8008de6:	9901      	ldr	r1, [sp, #4]
 8008de8:	4618      	mov	r0, r3
 8008dea:	f7ff f881 	bl	8007ef0 <s_mp_sub>
 8008dee:	9007      	str	r0, [sp, #28]
 8008df0:	9b07      	ldr	r3, [sp, #28]
 8008df2:	2b00      	cmp	r3, #0
 8008df4:	d005      	beq.n	8008e02 <mp_reduce_2k_setup+0x62>
      mp_clear(&tmp);
 8008df6:	ab02      	add	r3, sp, #8
 8008df8:	4618      	mov	r0, r3
 8008dfa:	f001 fc19 	bl	800a630 <mp_clear>
      return res;
 8008dfe:	9b07      	ldr	r3, [sp, #28]
 8008e00:	e008      	b.n	8008e14 <mp_reduce_2k_setup+0x74>
   *d = tmp.dp[0];
 8008e02:	9b05      	ldr	r3, [sp, #20]
 8008e04:	681a      	ldr	r2, [r3, #0]
 8008e06:	9b00      	ldr	r3, [sp, #0]
 8008e08:	601a      	str	r2, [r3, #0]
   mp_clear(&tmp);
 8008e0a:	ab02      	add	r3, sp, #8
 8008e0c:	4618      	mov	r0, r3
 8008e0e:	f001 fc0f 	bl	800a630 <mp_clear>
   return MP_OKAY;
 8008e12:	2300      	movs	r3, #0
}
 8008e14:	4618      	mov	r0, r3
 8008e16:	b009      	add	sp, #36	; 0x24
 8008e18:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e1c:	0000      	movs	r0, r0
	...

08008e20 <mp_set_bit>:
{
 8008e20:	b510      	push	{r4, lr}
 8008e22:	b084      	sub	sp, #16
 8008e24:	9001      	str	r0, [sp, #4]
 8008e26:	9100      	str	r1, [sp, #0]
    int i = b / DIGIT_BIT, res;
 8008e28:	9b00      	ldr	r3, [sp, #0]
 8008e2a:	4a1f      	ldr	r2, [pc, #124]	; (8008ea8 <mp_set_bit+0x88>)
 8008e2c:	fb82 1203 	smull	r1, r2, r2, r3
 8008e30:	441a      	add	r2, r3
 8008e32:	1112      	asrs	r2, r2, #4
 8008e34:	17db      	asrs	r3, r3, #31
 8008e36:	1ad3      	subs	r3, r2, r3
 8008e38:	9303      	str	r3, [sp, #12]
    if (a->used < (int)(i + 1)) {
 8008e3a:	9b01      	ldr	r3, [sp, #4]
 8008e3c:	681a      	ldr	r2, [r3, #0]
 8008e3e:	9b03      	ldr	r3, [sp, #12]
 8008e40:	3301      	adds	r3, #1
 8008e42:	429a      	cmp	r2, r3
 8008e44:	da0f      	bge.n	8008e66 <mp_set_bit+0x46>
        if ((res = mp_grow (a, i + 1)) != MP_OKAY) {
 8008e46:	9b03      	ldr	r3, [sp, #12]
 8008e48:	3301      	adds	r3, #1
 8008e4a:	4619      	mov	r1, r3
 8008e4c:	9801      	ldr	r0, [sp, #4]
 8008e4e:	f001 fdcf 	bl	800a9f0 <mp_grow>
 8008e52:	9002      	str	r0, [sp, #8]
 8008e54:	9b02      	ldr	r3, [sp, #8]
 8008e56:	2b00      	cmp	r3, #0
 8008e58:	d001      	beq.n	8008e5e <mp_set_bit+0x3e>
            return res;
 8008e5a:	9b02      	ldr	r3, [sp, #8]
 8008e5c:	e020      	b.n	8008ea0 <mp_set_bit+0x80>
        a->used = (int)(i + 1);
 8008e5e:	9b03      	ldr	r3, [sp, #12]
 8008e60:	1c5a      	adds	r2, r3, #1
 8008e62:	9b01      	ldr	r3, [sp, #4]
 8008e64:	601a      	str	r2, [r3, #0]
    a->dp[i] |= ((mp_digit)1) << (b % DIGIT_BIT);
 8008e66:	9b01      	ldr	r3, [sp, #4]
 8008e68:	68da      	ldr	r2, [r3, #12]
 8008e6a:	9b03      	ldr	r3, [sp, #12]
 8008e6c:	009b      	lsls	r3, r3, #2
 8008e6e:	18d0      	adds	r0, r2, r3
 8008e70:	9b01      	ldr	r3, [sp, #4]
 8008e72:	68da      	ldr	r2, [r3, #12]
 8008e74:	9b03      	ldr	r3, [sp, #12]
 8008e76:	009b      	lsls	r3, r3, #2
 8008e78:	4413      	add	r3, r2
 8008e7a:	681c      	ldr	r4, [r3, #0]
 8008e7c:	9a00      	ldr	r2, [sp, #0]
 8008e7e:	4b0a      	ldr	r3, [pc, #40]	; (8008ea8 <mp_set_bit+0x88>)
 8008e80:	fb83 1302 	smull	r1, r3, r3, r2
 8008e84:	4413      	add	r3, r2
 8008e86:	1119      	asrs	r1, r3, #4
 8008e88:	17d3      	asrs	r3, r2, #31
 8008e8a:	1ac9      	subs	r1, r1, r3
 8008e8c:	460b      	mov	r3, r1
 8008e8e:	00db      	lsls	r3, r3, #3
 8008e90:	1a5b      	subs	r3, r3, r1
 8008e92:	009b      	lsls	r3, r3, #2
 8008e94:	1ad1      	subs	r1, r2, r3
 8008e96:	2301      	movs	r3, #1
 8008e98:	408b      	lsls	r3, r1
 8008e9a:	4323      	orrs	r3, r4
 8008e9c:	6003      	str	r3, [r0, #0]
    return MP_OKAY;
 8008e9e:	2300      	movs	r3, #0
}
 8008ea0:	4618      	mov	r0, r3
 8008ea2:	b004      	add	sp, #16
 8008ea4:	bd10      	pop	{r4, pc}
 8008ea6:	bf00      	nop
 8008ea8:	92492493 	.word	0x92492493
 8008eac:	00000000 	.word	0x00000000

08008eb0 <mp_2expt>:
{
 8008eb0:	b500      	push	{lr}
 8008eb2:	b083      	sub	sp, #12
 8008eb4:	9001      	str	r0, [sp, #4]
 8008eb6:	9100      	str	r1, [sp, #0]
    mp_zero (a);
 8008eb8:	9801      	ldr	r0, [sp, #4]
 8008eba:	f001 fe59 	bl	800ab70 <mp_zero>
    return mp_set_bit(a, b);
 8008ebe:	9900      	ldr	r1, [sp, #0]
 8008ec0:	9801      	ldr	r0, [sp, #4]
 8008ec2:	f7ff ffad 	bl	8008e20 <mp_set_bit>
 8008ec6:	4603      	mov	r3, r0
}
 8008ec8:	4618      	mov	r0, r3
 8008eca:	b003      	add	sp, #12
 8008ecc:	f85d fb04 	ldr.w	pc, [sp], #4

08008ed0 <mp_mul_d>:
{
 8008ed0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008ed2:	b08d      	sub	sp, #52	; 0x34
 8008ed4:	9003      	str	r0, [sp, #12]
 8008ed6:	9102      	str	r1, [sp, #8]
 8008ed8:	9201      	str	r2, [sp, #4]
  if (c->alloc < a->used + 1) {
 8008eda:	9b01      	ldr	r3, [sp, #4]
 8008edc:	685a      	ldr	r2, [r3, #4]
 8008ede:	9b03      	ldr	r3, [sp, #12]
 8008ee0:	681b      	ldr	r3, [r3, #0]
 8008ee2:	3301      	adds	r3, #1
 8008ee4:	429a      	cmp	r2, r3
 8008ee6:	da0c      	bge.n	8008f02 <mp_mul_d+0x32>
    if ((res = mp_grow (c, a->used + 1)) != MP_OKAY) {
 8008ee8:	9b03      	ldr	r3, [sp, #12]
 8008eea:	681b      	ldr	r3, [r3, #0]
 8008eec:	3301      	adds	r3, #1
 8008eee:	4619      	mov	r1, r3
 8008ef0:	9801      	ldr	r0, [sp, #4]
 8008ef2:	f001 fd7d 	bl	800a9f0 <mp_grow>
 8008ef6:	9007      	str	r0, [sp, #28]
 8008ef8:	9b07      	ldr	r3, [sp, #28]
 8008efa:	2b00      	cmp	r3, #0
 8008efc:	d001      	beq.n	8008f02 <mp_mul_d+0x32>
      return res;
 8008efe:	9b07      	ldr	r3, [sp, #28]
 8008f00:	e063      	b.n	8008fca <mp_mul_d+0xfa>
  olduse = c->used;
 8008f02:	9b01      	ldr	r3, [sp, #4]
 8008f04:	681b      	ldr	r3, [r3, #0]
 8008f06:	9306      	str	r3, [sp, #24]
  c->sign = a->sign;
 8008f08:	9b03      	ldr	r3, [sp, #12]
 8008f0a:	689a      	ldr	r2, [r3, #8]
 8008f0c:	9b01      	ldr	r3, [sp, #4]
 8008f0e:	609a      	str	r2, [r3, #8]
  tmpa = a->dp;
 8008f10:	9b03      	ldr	r3, [sp, #12]
 8008f12:	68db      	ldr	r3, [r3, #12]
 8008f14:	930a      	str	r3, [sp, #40]	; 0x28
  tmpc = c->dp;
 8008f16:	9b01      	ldr	r3, [sp, #4]
 8008f18:	68db      	ldr	r3, [r3, #12]
 8008f1a:	9309      	str	r3, [sp, #36]	; 0x24
  u = 0;
 8008f1c:	2300      	movs	r3, #0
 8008f1e:	930b      	str	r3, [sp, #44]	; 0x2c
  for (ix = 0; ix < a->used; ix++) {
 8008f20:	2300      	movs	r3, #0
 8008f22:	9308      	str	r3, [sp, #32]
 8008f24:	e02f      	b.n	8008f86 <mp_mul_d+0xb6>
    r       = ((mp_word) u) + ((mp_word)*tmpa++) * ((mp_word)b);
 8008f26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008f28:	461e      	mov	r6, r3
 8008f2a:	f04f 0700 	mov.w	r7, #0
 8008f2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008f30:	1d1a      	adds	r2, r3, #4
 8008f32:	920a      	str	r2, [sp, #40]	; 0x28
 8008f34:	681b      	ldr	r3, [r3, #0]
 8008f36:	4618      	mov	r0, r3
 8008f38:	f04f 0100 	mov.w	r1, #0
 8008f3c:	9b02      	ldr	r3, [sp, #8]
 8008f3e:	461a      	mov	r2, r3
 8008f40:	f04f 0300 	mov.w	r3, #0
 8008f44:	fb02 fc01 	mul.w	ip, r2, r1
 8008f48:	fb00 fe03 	mul.w	lr, r0, r3
 8008f4c:	44e6      	add	lr, ip
 8008f4e:	fba0 2302 	umull	r2, r3, r0, r2
 8008f52:	eb0e 0103 	add.w	r1, lr, r3
 8008f56:	460b      	mov	r3, r1
 8008f58:	1992      	adds	r2, r2, r6
 8008f5a:	eb43 0307 	adc.w	r3, r3, r7
 8008f5e:	e9cd 2304 	strd	r2, r3, [sp, #16]
    *tmpc++ = (mp_digit) (r & ((mp_word) MP_MASK));
 8008f62:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008f64:	1d1a      	adds	r2, r3, #4
 8008f66:	9209      	str	r2, [sp, #36]	; 0x24
 8008f68:	9a04      	ldr	r2, [sp, #16]
 8008f6a:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8008f6e:	601a      	str	r2, [r3, #0]
    u       = (mp_digit) (r >> ((mp_word) DIGIT_BIT));
 8008f70:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008f74:	0f14      	lsrs	r4, r2, #28
 8008f76:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8008f7a:	0f1d      	lsrs	r5, r3, #28
 8008f7c:	4623      	mov	r3, r4
 8008f7e:	930b      	str	r3, [sp, #44]	; 0x2c
  for (ix = 0; ix < a->used; ix++) {
 8008f80:	9b08      	ldr	r3, [sp, #32]
 8008f82:	3301      	adds	r3, #1
 8008f84:	9308      	str	r3, [sp, #32]
 8008f86:	9b03      	ldr	r3, [sp, #12]
 8008f88:	681a      	ldr	r2, [r3, #0]
 8008f8a:	9b08      	ldr	r3, [sp, #32]
 8008f8c:	429a      	cmp	r2, r3
 8008f8e:	dcca      	bgt.n	8008f26 <mp_mul_d+0x56>
  *tmpc++ = u;
 8008f90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008f92:	1d1a      	adds	r2, r3, #4
 8008f94:	9209      	str	r2, [sp, #36]	; 0x24
 8008f96:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008f98:	601a      	str	r2, [r3, #0]
  ++ix;
 8008f9a:	9b08      	ldr	r3, [sp, #32]
 8008f9c:	3301      	adds	r3, #1
 8008f9e:	9308      	str	r3, [sp, #32]
 8008fa0:	e004      	b.n	8008fac <mp_mul_d+0xdc>
     *tmpc++ = 0;
 8008fa2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008fa4:	1d1a      	adds	r2, r3, #4
 8008fa6:	9209      	str	r2, [sp, #36]	; 0x24
 8008fa8:	2200      	movs	r2, #0
 8008faa:	601a      	str	r2, [r3, #0]
  while (ix++ < olduse) {
 8008fac:	9b08      	ldr	r3, [sp, #32]
 8008fae:	1c5a      	adds	r2, r3, #1
 8008fb0:	9208      	str	r2, [sp, #32]
 8008fb2:	9a06      	ldr	r2, [sp, #24]
 8008fb4:	4293      	cmp	r3, r2
 8008fb6:	dbf4      	blt.n	8008fa2 <mp_mul_d+0xd2>
  c->used = a->used + 1;
 8008fb8:	9b03      	ldr	r3, [sp, #12]
 8008fba:	681b      	ldr	r3, [r3, #0]
 8008fbc:	1c5a      	adds	r2, r3, #1
 8008fbe:	9b01      	ldr	r3, [sp, #4]
 8008fc0:	601a      	str	r2, [r3, #0]
  mp_clamp(c);
 8008fc2:	9801      	ldr	r0, [sp, #4]
 8008fc4:	f001 fdf4 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 8008fc8:	2300      	movs	r3, #0
}
 8008fca:	4618      	mov	r0, r3
 8008fcc:	b00d      	add	sp, #52	; 0x34
 8008fce:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008fd0 <mp_mulmod>:
{
 8008fd0:	b500      	push	{lr}
 8008fd2:	b08b      	sub	sp, #44	; 0x2c
 8008fd4:	9003      	str	r0, [sp, #12]
 8008fd6:	9102      	str	r1, [sp, #8]
 8008fd8:	9201      	str	r2, [sp, #4]
 8008fda:	9300      	str	r3, [sp, #0]
  if ((res = mp_init_size (&t, c->used)) != MP_OKAY) {
 8008fdc:	9b01      	ldr	r3, [sp, #4]
 8008fde:	681a      	ldr	r2, [r3, #0]
 8008fe0:	ab05      	add	r3, sp, #20
 8008fe2:	4611      	mov	r1, r2
 8008fe4:	4618      	mov	r0, r3
 8008fe6:	f000 f9b3 	bl	8009350 <mp_init_size>
 8008fea:	9009      	str	r0, [sp, #36]	; 0x24
 8008fec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008fee:	2b00      	cmp	r3, #0
 8008ff0:	d001      	beq.n	8008ff6 <mp_mulmod+0x26>
    return res;
 8008ff2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008ff4:	e015      	b.n	8009022 <mp_mulmod+0x52>
  res = mp_mul (a, b, &t);
 8008ff6:	ab05      	add	r3, sp, #20
 8008ff8:	461a      	mov	r2, r3
 8008ffa:	9902      	ldr	r1, [sp, #8]
 8008ffc:	9803      	ldr	r0, [sp, #12]
 8008ffe:	f000 f83f 	bl	8009080 <mp_mul>
 8009002:	9009      	str	r0, [sp, #36]	; 0x24
  if (res == MP_OKAY) {
 8009004:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009006:	2b00      	cmp	r3, #0
 8009008:	d106      	bne.n	8009018 <mp_mulmod+0x48>
      res = mp_mod (&t, c, d);
 800900a:	ab05      	add	r3, sp, #20
 800900c:	9a00      	ldr	r2, [sp, #0]
 800900e:	9901      	ldr	r1, [sp, #4]
 8009010:	4618      	mov	r0, r3
 8009012:	f002 fde5 	bl	800bbe0 <mp_mod>
 8009016:	9009      	str	r0, [sp, #36]	; 0x24
  mp_clear (&t);
 8009018:	ab05      	add	r3, sp, #20
 800901a:	4618      	mov	r0, r3
 800901c:	f001 fb08 	bl	800a630 <mp_clear>
  return res;
 8009020:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8009022:	4618      	mov	r0, r3
 8009024:	b00b      	add	sp, #44	; 0x2c
 8009026:	f85d fb04 	ldr.w	pc, [sp], #4
 800902a:	bf00      	nop
 800902c:	0000      	movs	r0, r0
	...

08009030 <mp_sqr>:
{
 8009030:	b500      	push	{lr}
 8009032:	b085      	sub	sp, #20
 8009034:	9001      	str	r0, [sp, #4]
 8009036:	9100      	str	r1, [sp, #0]
    if ((a->used * 2 + 1) < MP_WARRAY &&
 8009038:	9b01      	ldr	r3, [sp, #4]
 800903a:	681b      	ldr	r3, [r3, #0]
 800903c:	005b      	lsls	r3, r3, #1
 800903e:	3301      	adds	r3, #1
 8009040:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009044:	da09      	bge.n	800905a <mp_sqr+0x2a>
         a->used <
 8009046:	9b01      	ldr	r3, [sp, #4]
 8009048:	681b      	ldr	r3, [r3, #0]
    if ((a->used * 2 + 1) < MP_WARRAY &&
 800904a:	2b7f      	cmp	r3, #127	; 0x7f
 800904c:	dc05      	bgt.n	800905a <mp_sqr+0x2a>
      res = fast_s_mp_sqr (a, b);
 800904e:	9900      	ldr	r1, [sp, #0]
 8009050:	9801      	ldr	r0, [sp, #4]
 8009052:	f000 f9b5 	bl	80093c0 <fast_s_mp_sqr>
 8009056:	9003      	str	r0, [sp, #12]
 8009058:	e004      	b.n	8009064 <mp_sqr+0x34>
      res = s_mp_sqr (a, b);
 800905a:	9900      	ldr	r1, [sp, #0]
 800905c:	9801      	ldr	r0, [sp, #4]
 800905e:	f000 fb97 	bl	8009790 <s_mp_sqr>
 8009062:	9003      	str	r0, [sp, #12]
  b->sign = MP_ZPOS;
 8009064:	9b00      	ldr	r3, [sp, #0]
 8009066:	2200      	movs	r2, #0
 8009068:	609a      	str	r2, [r3, #8]
  return res;
 800906a:	9b03      	ldr	r3, [sp, #12]
}
 800906c:	4618      	mov	r0, r3
 800906e:	b005      	add	sp, #20
 8009070:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009080 <mp_mul>:
{
 8009080:	b500      	push	{lr}
 8009082:	b089      	sub	sp, #36	; 0x24
 8009084:	9003      	str	r0, [sp, #12]
 8009086:	9102      	str	r1, [sp, #8]
 8009088:	9201      	str	r2, [sp, #4]
  neg = (a->sign == b->sign) ? MP_ZPOS : MP_NEG;
 800908a:	9b03      	ldr	r3, [sp, #12]
 800908c:	689a      	ldr	r2, [r3, #8]
 800908e:	9b02      	ldr	r3, [sp, #8]
 8009090:	689b      	ldr	r3, [r3, #8]
 8009092:	429a      	cmp	r2, r3
 8009094:	bf14      	ite	ne
 8009096:	2301      	movne	r3, #1
 8009098:	2300      	moveq	r3, #0
 800909a:	b2db      	uxtb	r3, r3
 800909c:	9306      	str	r3, [sp, #24]
    int     digs = a->used + b->used + 1;
 800909e:	9b03      	ldr	r3, [sp, #12]
 80090a0:	681a      	ldr	r2, [r3, #0]
 80090a2:	9b02      	ldr	r3, [sp, #8]
 80090a4:	681b      	ldr	r3, [r3, #0]
 80090a6:	4413      	add	r3, r2
 80090a8:	3301      	adds	r3, #1
 80090aa:	9305      	str	r3, [sp, #20]
    if ((digs < MP_WARRAY) &&
 80090ac:	9b05      	ldr	r3, [sp, #20]
 80090ae:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80090b2:	da11      	bge.n	80090d8 <mp_mul+0x58>
        MIN(a->used, b->used) <=
 80090b4:	9b02      	ldr	r3, [sp, #8]
 80090b6:	681a      	ldr	r2, [r3, #0]
 80090b8:	9b03      	ldr	r3, [sp, #12]
 80090ba:	681b      	ldr	r3, [r3, #0]
 80090bc:	4293      	cmp	r3, r2
 80090be:	bfa8      	it	ge
 80090c0:	4613      	movge	r3, r2
    if ((digs < MP_WARRAY) &&
 80090c2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80090c6:	dc07      	bgt.n	80090d8 <mp_mul+0x58>
      res = fast_s_mp_mul_digs (a, b, c, digs);
 80090c8:	9b05      	ldr	r3, [sp, #20]
 80090ca:	9a01      	ldr	r2, [sp, #4]
 80090cc:	9902      	ldr	r1, [sp, #8]
 80090ce:	9803      	ldr	r0, [sp, #12]
 80090d0:	f000 fa8e 	bl	80095f0 <fast_s_mp_mul_digs>
 80090d4:	9007      	str	r0, [sp, #28]
 80090d6:	e00b      	b.n	80090f0 <mp_mul+0x70>
      res = s_mp_mul (a, b, c); /* uses s_mp_mul_digs */
 80090d8:	9b03      	ldr	r3, [sp, #12]
 80090da:	681a      	ldr	r2, [r3, #0]
 80090dc:	9b02      	ldr	r3, [sp, #8]
 80090de:	681b      	ldr	r3, [r3, #0]
 80090e0:	4413      	add	r3, r2
 80090e2:	3301      	adds	r3, #1
 80090e4:	9a01      	ldr	r2, [sp, #4]
 80090e6:	9902      	ldr	r1, [sp, #8]
 80090e8:	9803      	ldr	r0, [sp, #12]
 80090ea:	f000 fc41 	bl	8009970 <s_mp_mul_digs>
 80090ee:	9007      	str	r0, [sp, #28]
  c->sign = (c->used > 0) ? neg : MP_ZPOS;
 80090f0:	9b01      	ldr	r3, [sp, #4]
 80090f2:	681b      	ldr	r3, [r3, #0]
 80090f4:	2b00      	cmp	r3, #0
 80090f6:	dd01      	ble.n	80090fc <mp_mul+0x7c>
 80090f8:	9b06      	ldr	r3, [sp, #24]
 80090fa:	e000      	b.n	80090fe <mp_mul+0x7e>
 80090fc:	2300      	movs	r3, #0
 80090fe:	9a01      	ldr	r2, [sp, #4]
 8009100:	6093      	str	r3, [r2, #8]
  return res;
 8009102:	9b07      	ldr	r3, [sp, #28]
}
 8009104:	4618      	mov	r0, r3
 8009106:	b009      	add	sp, #36	; 0x24
 8009108:	f85d fb04 	ldr.w	pc, [sp], #4
 800910c:	0000      	movs	r0, r0
	...

08009110 <mp_mul_2>:
{
 8009110:	b500      	push	{lr}
 8009112:	b08b      	sub	sp, #44	; 0x2c
 8009114:	9001      	str	r0, [sp, #4]
 8009116:	9100      	str	r1, [sp, #0]
  if (b->alloc < a->used + 1) {
 8009118:	9b00      	ldr	r3, [sp, #0]
 800911a:	685a      	ldr	r2, [r3, #4]
 800911c:	9b01      	ldr	r3, [sp, #4]
 800911e:	681b      	ldr	r3, [r3, #0]
 8009120:	3301      	adds	r3, #1
 8009122:	429a      	cmp	r2, r3
 8009124:	da0c      	bge.n	8009140 <mp_mul_2+0x30>
    if ((res = mp_grow (b, a->used + 1)) != MP_OKAY) {
 8009126:	9b01      	ldr	r3, [sp, #4]
 8009128:	681b      	ldr	r3, [r3, #0]
 800912a:	3301      	adds	r3, #1
 800912c:	4619      	mov	r1, r3
 800912e:	9800      	ldr	r0, [sp, #0]
 8009130:	f001 fc5e 	bl	800a9f0 <mp_grow>
 8009134:	9005      	str	r0, [sp, #20]
 8009136:	9b05      	ldr	r3, [sp, #20]
 8009138:	2b00      	cmp	r3, #0
 800913a:	d001      	beq.n	8009140 <mp_mul_2+0x30>
      return res;
 800913c:	9b05      	ldr	r3, [sp, #20]
 800913e:	e053      	b.n	80091e8 <mp_mul_2+0xd8>
  oldused = b->used;
 8009140:	9b00      	ldr	r3, [sp, #0]
 8009142:	681b      	ldr	r3, [r3, #0]
 8009144:	9304      	str	r3, [sp, #16]
  b->used = a->used;
 8009146:	9b01      	ldr	r3, [sp, #4]
 8009148:	681a      	ldr	r2, [r3, #0]
 800914a:	9b00      	ldr	r3, [sp, #0]
 800914c:	601a      	str	r2, [r3, #0]
    tmpa = a->dp;
 800914e:	9b01      	ldr	r3, [sp, #4]
 8009150:	68db      	ldr	r3, [r3, #12]
 8009152:	9307      	str	r3, [sp, #28]
    tmpb = b->dp;
 8009154:	9b00      	ldr	r3, [sp, #0]
 8009156:	68db      	ldr	r3, [r3, #12]
 8009158:	9306      	str	r3, [sp, #24]
    r = 0;
 800915a:	2300      	movs	r3, #0
 800915c:	9308      	str	r3, [sp, #32]
    for (x = 0; x < a->used; x++) {
 800915e:	2300      	movs	r3, #0
 8009160:	9309      	str	r3, [sp, #36]	; 0x24
 8009162:	e015      	b.n	8009190 <mp_mul_2+0x80>
      rr = *tmpa >> ((mp_digit)(DIGIT_BIT - 1));
 8009164:	9b07      	ldr	r3, [sp, #28]
 8009166:	681b      	ldr	r3, [r3, #0]
 8009168:	0edb      	lsrs	r3, r3, #27
 800916a:	9303      	str	r3, [sp, #12]
      *tmpb++ = (mp_digit)(((*tmpa++ << ((mp_digit)1)) | r) & MP_MASK);
 800916c:	9b06      	ldr	r3, [sp, #24]
 800916e:	1d1a      	adds	r2, r3, #4
 8009170:	9206      	str	r2, [sp, #24]
 8009172:	9a07      	ldr	r2, [sp, #28]
 8009174:	1d11      	adds	r1, r2, #4
 8009176:	9107      	str	r1, [sp, #28]
 8009178:	6812      	ldr	r2, [r2, #0]
 800917a:	0051      	lsls	r1, r2, #1
 800917c:	9a08      	ldr	r2, [sp, #32]
 800917e:	430a      	orrs	r2, r1
 8009180:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8009184:	601a      	str	r2, [r3, #0]
      r = rr;
 8009186:	9b03      	ldr	r3, [sp, #12]
 8009188:	9308      	str	r3, [sp, #32]
    for (x = 0; x < a->used; x++) {
 800918a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800918c:	3301      	adds	r3, #1
 800918e:	9309      	str	r3, [sp, #36]	; 0x24
 8009190:	9b01      	ldr	r3, [sp, #4]
 8009192:	681a      	ldr	r2, [r3, #0]
 8009194:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009196:	429a      	cmp	r2, r3
 8009198:	dce4      	bgt.n	8009164 <mp_mul_2+0x54>
    if (r != 0) {
 800919a:	9b08      	ldr	r3, [sp, #32]
 800919c:	2b00      	cmp	r3, #0
 800919e:	d007      	beq.n	80091b0 <mp_mul_2+0xa0>
      *tmpb = 1;
 80091a0:	9b06      	ldr	r3, [sp, #24]
 80091a2:	2201      	movs	r2, #1
 80091a4:	601a      	str	r2, [r3, #0]
      ++(b->used);
 80091a6:	9b00      	ldr	r3, [sp, #0]
 80091a8:	681b      	ldr	r3, [r3, #0]
 80091aa:	1c5a      	adds	r2, r3, #1
 80091ac:	9b00      	ldr	r3, [sp, #0]
 80091ae:	601a      	str	r2, [r3, #0]
    tmpb = b->dp + b->used;
 80091b0:	9b00      	ldr	r3, [sp, #0]
 80091b2:	68da      	ldr	r2, [r3, #12]
 80091b4:	9b00      	ldr	r3, [sp, #0]
 80091b6:	681b      	ldr	r3, [r3, #0]
 80091b8:	009b      	lsls	r3, r3, #2
 80091ba:	4413      	add	r3, r2
 80091bc:	9306      	str	r3, [sp, #24]
    for (x = b->used; x < oldused; x++) {
 80091be:	9b00      	ldr	r3, [sp, #0]
 80091c0:	681b      	ldr	r3, [r3, #0]
 80091c2:	9309      	str	r3, [sp, #36]	; 0x24
 80091c4:	e007      	b.n	80091d6 <mp_mul_2+0xc6>
      *tmpb++ = 0;
 80091c6:	9b06      	ldr	r3, [sp, #24]
 80091c8:	1d1a      	adds	r2, r3, #4
 80091ca:	9206      	str	r2, [sp, #24]
 80091cc:	2200      	movs	r2, #0
 80091ce:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 80091d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80091d2:	3301      	adds	r3, #1
 80091d4:	9309      	str	r3, [sp, #36]	; 0x24
 80091d6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80091d8:	9b04      	ldr	r3, [sp, #16]
 80091da:	429a      	cmp	r2, r3
 80091dc:	dbf3      	blt.n	80091c6 <mp_mul_2+0xb6>
  b->sign = a->sign;
 80091de:	9b01      	ldr	r3, [sp, #4]
 80091e0:	689a      	ldr	r2, [r3, #8]
 80091e2:	9b00      	ldr	r3, [sp, #0]
 80091e4:	609a      	str	r2, [r3, #8]
  return MP_OKAY;
 80091e6:	2300      	movs	r3, #0
}
 80091e8:	4618      	mov	r0, r3
 80091ea:	b00b      	add	sp, #44	; 0x2c
 80091ec:	f85d fb04 	ldr.w	pc, [sp], #4

080091f0 <mp_div_3>:
{
 80091f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80091f4:	b090      	sub	sp, #64	; 0x40
 80091f6:	9003      	str	r0, [sp, #12]
 80091f8:	9102      	str	r1, [sp, #8]
 80091fa:	9201      	str	r2, [sp, #4]
  b = (mp_digit) ( (((mp_word)1) << ((mp_word)DIGIT_BIT)) / ((mp_word)3) );
 80091fc:	4b52      	ldr	r3, [pc, #328]	; (8009348 <mp_div_3+0x158>)
 80091fe:	930a      	str	r3, [sp, #40]	; 0x28
  if ((res = mp_init_size(&q, a->used)) != MP_OKAY) {
 8009200:	9b03      	ldr	r3, [sp, #12]
 8009202:	681a      	ldr	r2, [r3, #0]
 8009204:	ab05      	add	r3, sp, #20
 8009206:	4611      	mov	r1, r2
 8009208:	4618      	mov	r0, r3
 800920a:	f000 f8a1 	bl	8009350 <mp_init_size>
 800920e:	9009      	str	r0, [sp, #36]	; 0x24
 8009210:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009212:	2b00      	cmp	r3, #0
 8009214:	d001      	beq.n	800921a <mp_div_3+0x2a>
     return res;
 8009216:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009218:	e092      	b.n	8009340 <mp_div_3+0x150>
  q.used = a->used;
 800921a:	9b03      	ldr	r3, [sp, #12]
 800921c:	681b      	ldr	r3, [r3, #0]
 800921e:	9305      	str	r3, [sp, #20]
  q.sign = a->sign;
 8009220:	9b03      	ldr	r3, [sp, #12]
 8009222:	689b      	ldr	r3, [r3, #8]
 8009224:	9307      	str	r3, [sp, #28]
  w = 0;
 8009226:	f04f 0300 	mov.w	r3, #0
 800922a:	f04f 0400 	mov.w	r4, #0
 800922e:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
  for (ix = a->used - 1; ix >= 0; ix--) {
 8009232:	9b03      	ldr	r3, [sp, #12]
 8009234:	681b      	ldr	r3, [r3, #0]
 8009236:	3b01      	subs	r3, #1
 8009238:	930b      	str	r3, [sp, #44]	; 0x2c
 800923a:	e067      	b.n	800930c <mp_div_3+0x11c>
     w = (w << ((mp_word)DIGIT_BIT)) | ((mp_word)a->dp[ix]);
 800923c:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
 8009240:	0726      	lsls	r6, r4, #28
 8009242:	ea46 1613 	orr.w	r6, r6, r3, lsr #4
 8009246:	071d      	lsls	r5, r3, #28
 8009248:	9b03      	ldr	r3, [sp, #12]
 800924a:	68da      	ldr	r2, [r3, #12]
 800924c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800924e:	009b      	lsls	r3, r3, #2
 8009250:	4413      	add	r3, r2
 8009252:	681b      	ldr	r3, [r3, #0]
 8009254:	f04f 0400 	mov.w	r4, #0
 8009258:	ea43 0305 	orr.w	r3, r3, r5
 800925c:	ea44 0406 	orr.w	r4, r4, r6
 8009260:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
     if (w >= 3) {
 8009264:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
 8009268:	2c00      	cmp	r4, #0
 800926a:	bf08      	it	eq
 800926c:	2b03      	cmpeq	r3, #3
 800926e:	d33e      	bcc.n	80092ee <mp_div_3+0xfe>
        t = (w * ((mp_word)b)) >> ((mp_word)DIGIT_BIT);
 8009270:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009272:	f04f 0400 	mov.w	r4, #0
 8009276:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009278:	fb04 f102 	mul.w	r1, r4, r2
 800927c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800927e:	fb03 f202 	mul.w	r2, r3, r2
 8009282:	440a      	add	r2, r1
 8009284:	990e      	ldr	r1, [sp, #56]	; 0x38
 8009286:	fba1 3403 	umull	r3, r4, r1, r3
 800928a:	4422      	add	r2, r4
 800928c:	4614      	mov	r4, r2
 800928e:	0f1f      	lsrs	r7, r3, #28
 8009290:	ea47 1704 	orr.w	r7, r7, r4, lsl #4
 8009294:	ea4f 7814 	mov.w	r8, r4, lsr #28
 8009298:	e9cd 780c 	strd	r7, r8, [sp, #48]	; 0x30
        w -= t+t+t;
 800929c:	e9dd 120c 	ldrd	r1, r2, [sp, #48]	; 0x30
 80092a0:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 80092a4:	18c9      	adds	r1, r1, r3
 80092a6:	eb42 0204 	adc.w	r2, r2, r4
 80092aa:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 80092ae:	185b      	adds	r3, r3, r1
 80092b0:	eb44 0402 	adc.w	r4, r4, r2
 80092b4:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
 80092b8:	1acb      	subs	r3, r1, r3
 80092ba:	eb62 0404 	sbc.w	r4, r2, r4
 80092be:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
 80092c2:	e00d      	b.n	80092e0 <mp_div_3+0xf0>
           t += 1;
 80092c4:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 80092c8:	3301      	adds	r3, #1
 80092ca:	f144 0400 	adc.w	r4, r4, #0
 80092ce:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
           w -= 3;
 80092d2:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
 80092d6:	3b03      	subs	r3, #3
 80092d8:	f144 34ff 	adc.w	r4, r4, #4294967295	; 0xffffffff
 80092dc:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
        while (w >= 3) {
 80092e0:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
 80092e4:	2c00      	cmp	r4, #0
 80092e6:	bf08      	it	eq
 80092e8:	2b03      	cmpeq	r3, #3
 80092ea:	d2eb      	bcs.n	80092c4 <mp_div_3+0xd4>
 80092ec:	e005      	b.n	80092fa <mp_div_3+0x10a>
        t = 0;
 80092ee:	f04f 0300 	mov.w	r3, #0
 80092f2:	f04f 0400 	mov.w	r4, #0
 80092f6:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
      q.dp[ix] = (mp_digit)t;
 80092fa:	9a08      	ldr	r2, [sp, #32]
 80092fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80092fe:	009b      	lsls	r3, r3, #2
 8009300:	4413      	add	r3, r2
 8009302:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009304:	601a      	str	r2, [r3, #0]
  for (ix = a->used - 1; ix >= 0; ix--) {
 8009306:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009308:	3b01      	subs	r3, #1
 800930a:	930b      	str	r3, [sp, #44]	; 0x2c
 800930c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800930e:	2b00      	cmp	r3, #0
 8009310:	da94      	bge.n	800923c <mp_div_3+0x4c>
  if (d != NULL) {
 8009312:	9b01      	ldr	r3, [sp, #4]
 8009314:	2b00      	cmp	r3, #0
 8009316:	d002      	beq.n	800931e <mp_div_3+0x12e>
     *d = (mp_digit)w;
 8009318:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800931a:	9b01      	ldr	r3, [sp, #4]
 800931c:	601a      	str	r2, [r3, #0]
  if (c != NULL) {
 800931e:	9b02      	ldr	r3, [sp, #8]
 8009320:	2b00      	cmp	r3, #0
 8009322:	d008      	beq.n	8009336 <mp_div_3+0x146>
     mp_clamp(&q);
 8009324:	ab05      	add	r3, sp, #20
 8009326:	4618      	mov	r0, r3
 8009328:	f001 fc42 	bl	800abb0 <mp_clamp>
     mp_exch(&q, c);
 800932c:	ab05      	add	r3, sp, #20
 800932e:	9902      	ldr	r1, [sp, #8]
 8009330:	4618      	mov	r0, r3
 8009332:	f001 fc65 	bl	800ac00 <mp_exch>
  mp_clear(&q);
 8009336:	ab05      	add	r3, sp, #20
 8009338:	4618      	mov	r0, r3
 800933a:	f001 f979 	bl	800a630 <mp_clear>
  return res;
 800933e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8009340:	4618      	mov	r0, r3
 8009342:	b010      	add	sp, #64	; 0x40
 8009344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009348:	05555555 	.word	0x05555555
 800934c:	00000000 	.word	0x00000000

08009350 <mp_init_size>:
{
 8009350:	b500      	push	{lr}
 8009352:	b085      	sub	sp, #20
 8009354:	9001      	str	r0, [sp, #4]
 8009356:	9100      	str	r1, [sp, #0]
  size += (MP_PREC * 2) - (size % MP_PREC);
 8009358:	9b00      	ldr	r3, [sp, #0]
 800935a:	3302      	adds	r3, #2
 800935c:	9300      	str	r3, [sp, #0]
  a->dp = OPT_CAST(mp_digit) XMALLOC (sizeof (mp_digit) * size, NULL,
 800935e:	9b00      	ldr	r3, [sp, #0]
 8009360:	009b      	lsls	r3, r3, #2
 8009362:	4619      	mov	r1, r3
 8009364:	2000      	movs	r0, #0
 8009366:	f7fc fa7b 	bl	8005860 <chibios_alloc>
 800936a:	4602      	mov	r2, r0
 800936c:	9b01      	ldr	r3, [sp, #4]
 800936e:	60da      	str	r2, [r3, #12]
  if (a->dp == NULL) {
 8009370:	9b01      	ldr	r3, [sp, #4]
 8009372:	68db      	ldr	r3, [r3, #12]
 8009374:	2b00      	cmp	r3, #0
 8009376:	d102      	bne.n	800937e <mp_init_size+0x2e>
    return MP_MEM;
 8009378:	f06f 0301 	mvn.w	r3, #1
 800937c:	e01a      	b.n	80093b4 <mp_init_size+0x64>
  a->used  = 0;
 800937e:	9b01      	ldr	r3, [sp, #4]
 8009380:	2200      	movs	r2, #0
 8009382:	601a      	str	r2, [r3, #0]
  a->alloc = size;
 8009384:	9b01      	ldr	r3, [sp, #4]
 8009386:	9a00      	ldr	r2, [sp, #0]
 8009388:	605a      	str	r2, [r3, #4]
  a->sign  = MP_ZPOS;
 800938a:	9b01      	ldr	r3, [sp, #4]
 800938c:	2200      	movs	r2, #0
 800938e:	609a      	str	r2, [r3, #8]
  for (x = 0; x < size; x++) {
 8009390:	2300      	movs	r3, #0
 8009392:	9303      	str	r3, [sp, #12]
 8009394:	e009      	b.n	80093aa <mp_init_size+0x5a>
      a->dp[x] = 0;
 8009396:	9b01      	ldr	r3, [sp, #4]
 8009398:	68da      	ldr	r2, [r3, #12]
 800939a:	9b03      	ldr	r3, [sp, #12]
 800939c:	009b      	lsls	r3, r3, #2
 800939e:	4413      	add	r3, r2
 80093a0:	2200      	movs	r2, #0
 80093a2:	601a      	str	r2, [r3, #0]
  for (x = 0; x < size; x++) {
 80093a4:	9b03      	ldr	r3, [sp, #12]
 80093a6:	3301      	adds	r3, #1
 80093a8:	9303      	str	r3, [sp, #12]
 80093aa:	9a03      	ldr	r2, [sp, #12]
 80093ac:	9b00      	ldr	r3, [sp, #0]
 80093ae:	429a      	cmp	r2, r3
 80093b0:	dbf1      	blt.n	8009396 <mp_init_size+0x46>
  return MP_OKAY;
 80093b2:	2300      	movs	r3, #0
}
 80093b4:	4618      	mov	r0, r3
 80093b6:	b005      	add	sp, #20
 80093b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80093bc:	0000      	movs	r0, r0
	...

080093c0 <fast_s_mp_sqr>:
{
 80093c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80093c2:	b095      	sub	sp, #84	; 0x54
 80093c4:	9001      	str	r0, [sp, #4]
 80093c6:	9100      	str	r1, [sp, #0]
  pa = a->used + a->used;
 80093c8:	9b01      	ldr	r3, [sp, #4]
 80093ca:	681a      	ldr	r2, [r3, #0]
 80093cc:	9b01      	ldr	r3, [sp, #4]
 80093ce:	681b      	ldr	r3, [r3, #0]
 80093d0:	4413      	add	r3, r2
 80093d2:	9309      	str	r3, [sp, #36]	; 0x24
  if (b->alloc < pa) {
 80093d4:	9b00      	ldr	r3, [sp, #0]
 80093d6:	685a      	ldr	r2, [r3, #4]
 80093d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80093da:	429a      	cmp	r2, r3
 80093dc:	da09      	bge.n	80093f2 <fast_s_mp_sqr+0x32>
    if ((res = mp_grow (b, pa)) != MP_OKAY) {
 80093de:	9909      	ldr	r1, [sp, #36]	; 0x24
 80093e0:	9800      	ldr	r0, [sp, #0]
 80093e2:	f001 fb05 	bl	800a9f0 <mp_grow>
 80093e6:	9008      	str	r0, [sp, #32]
 80093e8:	9b08      	ldr	r3, [sp, #32]
 80093ea:	2b00      	cmp	r3, #0
 80093ec:	d001      	beq.n	80093f2 <fast_s_mp_sqr+0x32>
      return res;
 80093ee:	9b08      	ldr	r3, [sp, #32]
 80093f0:	e0fa      	b.n	80095e8 <fast_s_mp_sqr+0x228>
  if (pa > MP_WARRAY)
 80093f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80093f4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80093f8:	dd02      	ble.n	8009400 <fast_s_mp_sqr+0x40>
    return MP_RANGE;  /* TAO range check */
 80093fa:	f06f 0303 	mvn.w	r3, #3
 80093fe:	e0f3      	b.n	80095e8 <fast_s_mp_sqr+0x228>
  W = (mp_digit*)XMALLOC(sizeof(mp_digit) * MP_WARRAY, NULL, DYNAMIC_TYPE_BIGINT);
 8009400:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8009404:	2000      	movs	r0, #0
 8009406:	f7fc fa2b 	bl	8005860 <chibios_alloc>
 800940a:	9007      	str	r0, [sp, #28]
  if (W == NULL)
 800940c:	9b07      	ldr	r3, [sp, #28]
 800940e:	2b00      	cmp	r3, #0
 8009410:	d102      	bne.n	8009418 <fast_s_mp_sqr+0x58>
    return MP_MEM;
 8009412:	f06f 0301 	mvn.w	r3, #1
 8009416:	e0e7      	b.n	80095e8 <fast_s_mp_sqr+0x228>
  W1 = 0;
 8009418:	f04f 0200 	mov.w	r2, #0
 800941c:	f04f 0300 	mov.w	r3, #0
 8009420:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  for (ix = 0; ix < pa; ix++) {
 8009424:	2300      	movs	r3, #0
 8009426:	9313      	str	r3, [sp, #76]	; 0x4c
 8009428:	e0a3      	b.n	8009572 <fast_s_mp_sqr+0x1b2>
      _W = 0;
 800942a:	f04f 0200 	mov.w	r2, #0
 800942e:	f04f 0300 	mov.w	r3, #0
 8009432:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
      ty = MIN(a->used-1, ix);
 8009436:	9b01      	ldr	r3, [sp, #4]
 8009438:	681b      	ldr	r3, [r3, #0]
 800943a:	1e5a      	subs	r2, r3, #1
 800943c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800943e:	4293      	cmp	r3, r2
 8009440:	bfa8      	it	ge
 8009442:	4613      	movge	r3, r2
 8009444:	9306      	str	r3, [sp, #24]
      tx = ix - ty;
 8009446:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009448:	9b06      	ldr	r3, [sp, #24]
 800944a:	1ad3      	subs	r3, r2, r3
 800944c:	9305      	str	r3, [sp, #20]
      tmpx = a->dp + tx;
 800944e:	9b01      	ldr	r3, [sp, #4]
 8009450:	68da      	ldr	r2, [r3, #12]
 8009452:	9b05      	ldr	r3, [sp, #20]
 8009454:	009b      	lsls	r3, r3, #2
 8009456:	4413      	add	r3, r2
 8009458:	9311      	str	r3, [sp, #68]	; 0x44
      tmpy = a->dp + ty;
 800945a:	9b01      	ldr	r3, [sp, #4]
 800945c:	68da      	ldr	r2, [r3, #12]
 800945e:	9b06      	ldr	r3, [sp, #24]
 8009460:	009b      	lsls	r3, r3, #2
 8009462:	4413      	add	r3, r2
 8009464:	930b      	str	r3, [sp, #44]	; 0x2c
      iy = MIN(a->used-tx, ty+1);
 8009466:	9b06      	ldr	r3, [sp, #24]
 8009468:	1c5a      	adds	r2, r3, #1
 800946a:	9b01      	ldr	r3, [sp, #4]
 800946c:	6819      	ldr	r1, [r3, #0]
 800946e:	9b05      	ldr	r3, [sp, #20]
 8009470:	1acb      	subs	r3, r1, r3
 8009472:	4293      	cmp	r3, r2
 8009474:	bfa8      	it	ge
 8009476:	4613      	movge	r3, r2
 8009478:	9304      	str	r3, [sp, #16]
      iy = MIN(iy, (ty-tx+1)>>1);
 800947a:	9a06      	ldr	r2, [sp, #24]
 800947c:	9b05      	ldr	r3, [sp, #20]
 800947e:	1ad3      	subs	r3, r2, r3
 8009480:	3301      	adds	r3, #1
 8009482:	105b      	asrs	r3, r3, #1
 8009484:	9a04      	ldr	r2, [sp, #16]
 8009486:	4293      	cmp	r3, r2
 8009488:	bfa8      	it	ge
 800948a:	4613      	movge	r3, r2
 800948c:	9304      	str	r3, [sp, #16]
      for (iz = 0; iz < iy; iz++) {
 800948e:	2300      	movs	r3, #0
 8009490:	9312      	str	r3, [sp, #72]	; 0x48
 8009492:	e020      	b.n	80094d6 <fast_s_mp_sqr+0x116>
         _W += ((mp_word)*tmpx++)*((mp_word)*tmpy--);
 8009494:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009496:	1d1a      	adds	r2, r3, #4
 8009498:	9211      	str	r2, [sp, #68]	; 0x44
 800949a:	681b      	ldr	r3, [r3, #0]
 800949c:	4618      	mov	r0, r3
 800949e:	f04f 0100 	mov.w	r1, #0
 80094a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80094a4:	1f1a      	subs	r2, r3, #4
 80094a6:	920b      	str	r2, [sp, #44]	; 0x2c
 80094a8:	681b      	ldr	r3, [r3, #0]
 80094aa:	461a      	mov	r2, r3
 80094ac:	f04f 0300 	mov.w	r3, #0
 80094b0:	fb02 f701 	mul.w	r7, r2, r1
 80094b4:	fb00 f603 	mul.w	r6, r0, r3
 80094b8:	443e      	add	r6, r7
 80094ba:	fba0 2302 	umull	r2, r3, r0, r2
 80094be:	18f1      	adds	r1, r6, r3
 80094c0:	460b      	mov	r3, r1
 80094c2:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80094c6:	1812      	adds	r2, r2, r0
 80094c8:	eb43 0301 	adc.w	r3, r3, r1
 80094cc:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
      for (iz = 0; iz < iy; iz++) {
 80094d0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80094d2:	3301      	adds	r3, #1
 80094d4:	9312      	str	r3, [sp, #72]	; 0x48
 80094d6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80094d8:	9b04      	ldr	r3, [sp, #16]
 80094da:	429a      	cmp	r2, r3
 80094dc:	dbda      	blt.n	8009494 <fast_s_mp_sqr+0xd4>
      _W = _W + _W + W1;
 80094de:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80094e2:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80094e6:	1880      	adds	r0, r0, r2
 80094e8:	eb41 0103 	adc.w	r1, r1, r3
 80094ec:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 80094f0:	1812      	adds	r2, r2, r0
 80094f2:	eb43 0301 	adc.w	r3, r3, r1
 80094f6:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
      if ((ix&1) == 0) {
 80094fa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80094fc:	f003 0301 	and.w	r3, r3, #1
 8009500:	2b00      	cmp	r3, #0
 8009502:	d123      	bne.n	800954c <fast_s_mp_sqr+0x18c>
         _W += ((mp_word)a->dp[ix>>1])*((mp_word)a->dp[ix>>1]);
 8009504:	9b01      	ldr	r3, [sp, #4]
 8009506:	68da      	ldr	r2, [r3, #12]
 8009508:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800950a:	105b      	asrs	r3, r3, #1
 800950c:	009b      	lsls	r3, r3, #2
 800950e:	4413      	add	r3, r2
 8009510:	681b      	ldr	r3, [r3, #0]
 8009512:	4618      	mov	r0, r3
 8009514:	f04f 0100 	mov.w	r1, #0
 8009518:	9b01      	ldr	r3, [sp, #4]
 800951a:	68da      	ldr	r2, [r3, #12]
 800951c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800951e:	105b      	asrs	r3, r3, #1
 8009520:	009b      	lsls	r3, r3, #2
 8009522:	4413      	add	r3, r2
 8009524:	681b      	ldr	r3, [r3, #0]
 8009526:	461a      	mov	r2, r3
 8009528:	f04f 0300 	mov.w	r3, #0
 800952c:	fb02 f701 	mul.w	r7, r2, r1
 8009530:	fb00 f603 	mul.w	r6, r0, r3
 8009534:	443e      	add	r6, r7
 8009536:	fba0 2302 	umull	r2, r3, r0, r2
 800953a:	18f1      	adds	r1, r6, r3
 800953c:	460b      	mov	r3, r1
 800953e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8009542:	1812      	adds	r2, r2, r0
 8009544:	eb43 0301 	adc.w	r3, r3, r1
 8009548:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
      W[ix] = (mp_digit)(_W & MP_MASK);
 800954c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800954e:	009b      	lsls	r3, r3, #2
 8009550:	9a07      	ldr	r2, [sp, #28]
 8009552:	4413      	add	r3, r2
 8009554:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009556:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800955a:	601a      	str	r2, [r3, #0]
      W1 = _W >> ((mp_word)DIGIT_BIT);
 800955c:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 8009560:	0f14      	lsrs	r4, r2, #28
 8009562:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8009566:	0f1d      	lsrs	r5, r3, #28
 8009568:	e9cd 450e 	strd	r4, r5, [sp, #56]	; 0x38
  for (ix = 0; ix < pa; ix++) {
 800956c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800956e:	3301      	adds	r3, #1
 8009570:	9313      	str	r3, [sp, #76]	; 0x4c
 8009572:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009574:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009576:	429a      	cmp	r2, r3
 8009578:	f6ff af57 	blt.w	800942a <fast_s_mp_sqr+0x6a>
  olduse  = b->used;
 800957c:	9b00      	ldr	r3, [sp, #0]
 800957e:	681b      	ldr	r3, [r3, #0]
 8009580:	9303      	str	r3, [sp, #12]
  b->used = a->used+a->used;
 8009582:	9b01      	ldr	r3, [sp, #4]
 8009584:	681a      	ldr	r2, [r3, #0]
 8009586:	9b01      	ldr	r3, [sp, #4]
 8009588:	681b      	ldr	r3, [r3, #0]
 800958a:	441a      	add	r2, r3
 800958c:	9b00      	ldr	r3, [sp, #0]
 800958e:	601a      	str	r2, [r3, #0]
    tmpb = b->dp;
 8009590:	9b00      	ldr	r3, [sp, #0]
 8009592:	68db      	ldr	r3, [r3, #12]
 8009594:	930a      	str	r3, [sp, #40]	; 0x28
    for (ix = 0; ix < pa; ix++) {
 8009596:	2300      	movs	r3, #0
 8009598:	9313      	str	r3, [sp, #76]	; 0x4c
 800959a:	e00d      	b.n	80095b8 <fast_s_mp_sqr+0x1f8>
      *tmpb++ = (mp_digit)(W[ix] & MP_MASK);
 800959c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800959e:	1d1a      	adds	r2, r3, #4
 80095a0:	920a      	str	r2, [sp, #40]	; 0x28
 80095a2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80095a4:	0092      	lsls	r2, r2, #2
 80095a6:	9907      	ldr	r1, [sp, #28]
 80095a8:	440a      	add	r2, r1
 80095aa:	6812      	ldr	r2, [r2, #0]
 80095ac:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80095b0:	601a      	str	r2, [r3, #0]
    for (ix = 0; ix < pa; ix++) {
 80095b2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80095b4:	3301      	adds	r3, #1
 80095b6:	9313      	str	r3, [sp, #76]	; 0x4c
 80095b8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80095ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80095bc:	429a      	cmp	r2, r3
 80095be:	dbed      	blt.n	800959c <fast_s_mp_sqr+0x1dc>
 80095c0:	e007      	b.n	80095d2 <fast_s_mp_sqr+0x212>
      *tmpb++ = 0;
 80095c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80095c4:	1d1a      	adds	r2, r3, #4
 80095c6:	920a      	str	r2, [sp, #40]	; 0x28
 80095c8:	2200      	movs	r2, #0
 80095ca:	601a      	str	r2, [r3, #0]
    for (; ix < olduse; ix++) {
 80095cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80095ce:	3301      	adds	r3, #1
 80095d0:	9313      	str	r3, [sp, #76]	; 0x4c
 80095d2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80095d4:	9b03      	ldr	r3, [sp, #12]
 80095d6:	429a      	cmp	r2, r3
 80095d8:	dbf3      	blt.n	80095c2 <fast_s_mp_sqr+0x202>
  mp_clamp (b);
 80095da:	9800      	ldr	r0, [sp, #0]
 80095dc:	f001 fae8 	bl	800abb0 <mp_clamp>
  XFREE(W, NULL, DYNAMIC_TYPE_BIGINT);
 80095e0:	9807      	ldr	r0, [sp, #28]
 80095e2:	f7fc f94d 	bl	8005880 <chibios_free>
  return MP_OKAY;
 80095e6:	2300      	movs	r3, #0
}
 80095e8:	4618      	mov	r0, r3
 80095ea:	b015      	add	sp, #84	; 0x54
 80095ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80095ee:	bf00      	nop

080095f0 <fast_s_mp_mul_digs>:
{
 80095f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80095f2:	b093      	sub	sp, #76	; 0x4c
 80095f4:	9003      	str	r0, [sp, #12]
 80095f6:	9102      	str	r1, [sp, #8]
 80095f8:	9201      	str	r2, [sp, #4]
 80095fa:	9300      	str	r3, [sp, #0]
  if (c->alloc < digs) {
 80095fc:	9b01      	ldr	r3, [sp, #4]
 80095fe:	685a      	ldr	r2, [r3, #4]
 8009600:	9b00      	ldr	r3, [sp, #0]
 8009602:	429a      	cmp	r2, r3
 8009604:	da09      	bge.n	800961a <fast_s_mp_mul_digs+0x2a>
    if ((res = mp_grow (c, digs)) != MP_OKAY) {
 8009606:	9900      	ldr	r1, [sp, #0]
 8009608:	9801      	ldr	r0, [sp, #4]
 800960a:	f001 f9f1 	bl	800a9f0 <mp_grow>
 800960e:	900a      	str	r0, [sp, #40]	; 0x28
 8009610:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009612:	2b00      	cmp	r3, #0
 8009614:	d001      	beq.n	800961a <fast_s_mp_mul_digs+0x2a>
      return res;
 8009616:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009618:	e0b6      	b.n	8009788 <fast_s_mp_mul_digs+0x198>
  pa = MIN(digs, a->used + b->used);
 800961a:	9b03      	ldr	r3, [sp, #12]
 800961c:	681a      	ldr	r2, [r3, #0]
 800961e:	9b02      	ldr	r3, [sp, #8]
 8009620:	681b      	ldr	r3, [r3, #0]
 8009622:	441a      	add	r2, r3
 8009624:	9b00      	ldr	r3, [sp, #0]
 8009626:	4293      	cmp	r3, r2
 8009628:	bfa8      	it	ge
 800962a:	4613      	movge	r3, r2
 800962c:	9309      	str	r3, [sp, #36]	; 0x24
  if (pa > MP_WARRAY)
 800962e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009630:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009634:	dd02      	ble.n	800963c <fast_s_mp_mul_digs+0x4c>
    return MP_RANGE;  /* TAO range check */
 8009636:	f06f 0303 	mvn.w	r3, #3
 800963a:	e0a5      	b.n	8009788 <fast_s_mp_mul_digs+0x198>
  W = (mp_digit*)XMALLOC(sizeof(mp_digit) * MP_WARRAY, NULL, DYNAMIC_TYPE_BIGINT);
 800963c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8009640:	2000      	movs	r0, #0
 8009642:	f7fc f90d 	bl	8005860 <chibios_alloc>
 8009646:	9008      	str	r0, [sp, #32]
  if (W == NULL)
 8009648:	9b08      	ldr	r3, [sp, #32]
 800964a:	2b00      	cmp	r3, #0
 800964c:	d102      	bne.n	8009654 <fast_s_mp_mul_digs+0x64>
    return MP_MEM;
 800964e:	f06f 0301 	mvn.w	r3, #1
 8009652:	e099      	b.n	8009788 <fast_s_mp_mul_digs+0x198>
  _W = 0;
 8009654:	f04f 0200 	mov.w	r2, #0
 8009658:	f04f 0300 	mov.w	r3, #0
 800965c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  for (ix = 0; ix < pa; ix++) {
 8009660:	2300      	movs	r3, #0
 8009662:	9311      	str	r3, [sp, #68]	; 0x44
 8009664:	e05c      	b.n	8009720 <fast_s_mp_mul_digs+0x130>
      ty = MIN(b->used-1, ix);
 8009666:	9b02      	ldr	r3, [sp, #8]
 8009668:	681b      	ldr	r3, [r3, #0]
 800966a:	1e5a      	subs	r2, r3, #1
 800966c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800966e:	4293      	cmp	r3, r2
 8009670:	bfa8      	it	ge
 8009672:	4613      	movge	r3, r2
 8009674:	9307      	str	r3, [sp, #28]
      tx = ix - ty;
 8009676:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009678:	9b07      	ldr	r3, [sp, #28]
 800967a:	1ad3      	subs	r3, r2, r3
 800967c:	9306      	str	r3, [sp, #24]
      tmpx = a->dp + tx;
 800967e:	9b03      	ldr	r3, [sp, #12]
 8009680:	68da      	ldr	r2, [r3, #12]
 8009682:	9b06      	ldr	r3, [sp, #24]
 8009684:	009b      	lsls	r3, r3, #2
 8009686:	4413      	add	r3, r2
 8009688:	930d      	str	r3, [sp, #52]	; 0x34
      tmpy = b->dp + ty;
 800968a:	9b02      	ldr	r3, [sp, #8]
 800968c:	68da      	ldr	r2, [r3, #12]
 800968e:	9b07      	ldr	r3, [sp, #28]
 8009690:	009b      	lsls	r3, r3, #2
 8009692:	4413      	add	r3, r2
 8009694:	930c      	str	r3, [sp, #48]	; 0x30
      iy = MIN(a->used-tx, ty+1);
 8009696:	9b07      	ldr	r3, [sp, #28]
 8009698:	1c5a      	adds	r2, r3, #1
 800969a:	9b03      	ldr	r3, [sp, #12]
 800969c:	6819      	ldr	r1, [r3, #0]
 800969e:	9b06      	ldr	r3, [sp, #24]
 80096a0:	1acb      	subs	r3, r1, r3
 80096a2:	4293      	cmp	r3, r2
 80096a4:	bfa8      	it	ge
 80096a6:	4613      	movge	r3, r2
 80096a8:	9305      	str	r3, [sp, #20]
      for (iz = 0; iz < iy; ++iz) {
 80096aa:	2300      	movs	r3, #0
 80096ac:	9310      	str	r3, [sp, #64]	; 0x40
 80096ae:	e020      	b.n	80096f2 <fast_s_mp_mul_digs+0x102>
         _W += ((mp_word)*tmpx++)*((mp_word)*tmpy--);
 80096b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80096b2:	1d1a      	adds	r2, r3, #4
 80096b4:	920d      	str	r2, [sp, #52]	; 0x34
 80096b6:	681b      	ldr	r3, [r3, #0]
 80096b8:	4618      	mov	r0, r3
 80096ba:	f04f 0100 	mov.w	r1, #0
 80096be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80096c0:	1f1a      	subs	r2, r3, #4
 80096c2:	920c      	str	r2, [sp, #48]	; 0x30
 80096c4:	681b      	ldr	r3, [r3, #0]
 80096c6:	461a      	mov	r2, r3
 80096c8:	f04f 0300 	mov.w	r3, #0
 80096cc:	fb02 f701 	mul.w	r7, r2, r1
 80096d0:	fb00 f603 	mul.w	r6, r0, r3
 80096d4:	443e      	add	r6, r7
 80096d6:	fba0 2302 	umull	r2, r3, r0, r2
 80096da:	18f1      	adds	r1, r6, r3
 80096dc:	460b      	mov	r3, r1
 80096de:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80096e2:	1812      	adds	r2, r2, r0
 80096e4:	eb43 0301 	adc.w	r3, r3, r1
 80096e8:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
      for (iz = 0; iz < iy; ++iz) {
 80096ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80096ee:	3301      	adds	r3, #1
 80096f0:	9310      	str	r3, [sp, #64]	; 0x40
 80096f2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80096f4:	9b05      	ldr	r3, [sp, #20]
 80096f6:	429a      	cmp	r2, r3
 80096f8:	dbda      	blt.n	80096b0 <fast_s_mp_mul_digs+0xc0>
      W[ix] = (mp_digit)(((mp_digit)_W) & MP_MASK);
 80096fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80096fc:	009b      	lsls	r3, r3, #2
 80096fe:	9a08      	ldr	r2, [sp, #32]
 8009700:	4413      	add	r3, r2
 8009702:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009704:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8009708:	601a      	str	r2, [r3, #0]
      _W = _W >> ((mp_word)DIGIT_BIT);
 800970a:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 800970e:	0f14      	lsrs	r4, r2, #28
 8009710:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8009714:	0f1d      	lsrs	r5, r3, #28
 8009716:	e9cd 450e 	strd	r4, r5, [sp, #56]	; 0x38
  for (ix = 0; ix < pa; ix++) {
 800971a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800971c:	3301      	adds	r3, #1
 800971e:	9311      	str	r3, [sp, #68]	; 0x44
 8009720:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009722:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009724:	429a      	cmp	r2, r3
 8009726:	db9e      	blt.n	8009666 <fast_s_mp_mul_digs+0x76>
  olduse  = c->used;
 8009728:	9b01      	ldr	r3, [sp, #4]
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	9304      	str	r3, [sp, #16]
  c->used = pa;
 800972e:	9b01      	ldr	r3, [sp, #4]
 8009730:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009732:	601a      	str	r2, [r3, #0]
    tmpc = c->dp;
 8009734:	9b01      	ldr	r3, [sp, #4]
 8009736:	68db      	ldr	r3, [r3, #12]
 8009738:	930b      	str	r3, [sp, #44]	; 0x2c
    for (ix = 0; ix < pa; ix++) { /* JRB, +1 could read uninitialized data */
 800973a:	2300      	movs	r3, #0
 800973c:	9311      	str	r3, [sp, #68]	; 0x44
 800973e:	e00b      	b.n	8009758 <fast_s_mp_mul_digs+0x168>
      *tmpc++ = W[ix];
 8009740:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009742:	1d1a      	adds	r2, r3, #4
 8009744:	920b      	str	r2, [sp, #44]	; 0x2c
 8009746:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009748:	0092      	lsls	r2, r2, #2
 800974a:	9908      	ldr	r1, [sp, #32]
 800974c:	440a      	add	r2, r1
 800974e:	6812      	ldr	r2, [r2, #0]
 8009750:	601a      	str	r2, [r3, #0]
    for (ix = 0; ix < pa; ix++) { /* JRB, +1 could read uninitialized data */
 8009752:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009754:	3301      	adds	r3, #1
 8009756:	9311      	str	r3, [sp, #68]	; 0x44
 8009758:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800975a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800975c:	429a      	cmp	r2, r3
 800975e:	dbef      	blt.n	8009740 <fast_s_mp_mul_digs+0x150>
 8009760:	e007      	b.n	8009772 <fast_s_mp_mul_digs+0x182>
      *tmpc++ = 0;
 8009762:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009764:	1d1a      	adds	r2, r3, #4
 8009766:	920b      	str	r2, [sp, #44]	; 0x2c
 8009768:	2200      	movs	r2, #0
 800976a:	601a      	str	r2, [r3, #0]
    for (; ix < olduse; ix++) {
 800976c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800976e:	3301      	adds	r3, #1
 8009770:	9311      	str	r3, [sp, #68]	; 0x44
 8009772:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009774:	9b04      	ldr	r3, [sp, #16]
 8009776:	429a      	cmp	r2, r3
 8009778:	dbf3      	blt.n	8009762 <fast_s_mp_mul_digs+0x172>
  mp_clamp (c);
 800977a:	9801      	ldr	r0, [sp, #4]
 800977c:	f001 fa18 	bl	800abb0 <mp_clamp>
  XFREE(W, NULL, DYNAMIC_TYPE_BIGINT);
 8009780:	9808      	ldr	r0, [sp, #32]
 8009782:	f7fc f87d 	bl	8005880 <chibios_free>
  return MP_OKAY;
 8009786:	2300      	movs	r3, #0
}
 8009788:	4618      	mov	r0, r3
 800978a:	b013      	add	sp, #76	; 0x4c
 800978c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800978e:	bf00      	nop

08009790 <s_mp_sqr>:
{
 8009790:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009794:	b091      	sub	sp, #68	; 0x44
 8009796:	9001      	str	r0, [sp, #4]
 8009798:	9100      	str	r1, [sp, #0]
  pa = a->used;
 800979a:	9b01      	ldr	r3, [sp, #4]
 800979c:	681b      	ldr	r3, [r3, #0]
 800979e:	930b      	str	r3, [sp, #44]	; 0x2c
  if ((res = mp_init_size (&t, 2*pa + 1)) != MP_OKAY) {
 80097a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80097a2:	005b      	lsls	r3, r3, #1
 80097a4:	1c5a      	adds	r2, r3, #1
 80097a6:	ab03      	add	r3, sp, #12
 80097a8:	4611      	mov	r1, r2
 80097aa:	4618      	mov	r0, r3
 80097ac:	f7ff fdd0 	bl	8009350 <mp_init_size>
 80097b0:	900a      	str	r0, [sp, #40]	; 0x28
 80097b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80097b4:	2b00      	cmp	r3, #0
 80097b6:	d001      	beq.n	80097bc <s_mp_sqr+0x2c>
    return res;
 80097b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80097ba:	e0d3      	b.n	8009964 <s_mp_sqr+0x1d4>
  t.used = 2*pa + 1;
 80097bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80097be:	005b      	lsls	r3, r3, #1
 80097c0:	3301      	adds	r3, #1
 80097c2:	9303      	str	r3, [sp, #12]
  for (ix = 0; ix < pa; ix++) {
 80097c4:	2300      	movs	r3, #0
 80097c6:	930f      	str	r3, [sp, #60]	; 0x3c
 80097c8:	e0b9      	b.n	800993e <s_mp_sqr+0x1ae>
    r = ((mp_word) t.dp[2*ix]) +
 80097ca:	9b06      	ldr	r3, [sp, #24]
 80097cc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80097ce:	00d2      	lsls	r2, r2, #3
 80097d0:	4413      	add	r3, r2
 80097d2:	681b      	ldr	r3, [r3, #0]
 80097d4:	469a      	mov	sl, r3
 80097d6:	f04f 0b00 	mov.w	fp, #0
        ((mp_word)a->dp[ix])*((mp_word)a->dp[ix]);
 80097da:	9b01      	ldr	r3, [sp, #4]
 80097dc:	68da      	ldr	r2, [r3, #12]
 80097de:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80097e0:	009b      	lsls	r3, r3, #2
 80097e2:	4413      	add	r3, r2
 80097e4:	681b      	ldr	r3, [r3, #0]
 80097e6:	4618      	mov	r0, r3
 80097e8:	f04f 0100 	mov.w	r1, #0
 80097ec:	9b01      	ldr	r3, [sp, #4]
 80097ee:	68da      	ldr	r2, [r3, #12]
 80097f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80097f2:	009b      	lsls	r3, r3, #2
 80097f4:	4413      	add	r3, r2
 80097f6:	681b      	ldr	r3, [r3, #0]
 80097f8:	461a      	mov	r2, r3
 80097fa:	f04f 0300 	mov.w	r3, #0
 80097fe:	fb02 fc01 	mul.w	ip, r2, r1
 8009802:	fb00 fe03 	mul.w	lr, r0, r3
 8009806:	44e6      	add	lr, ip
 8009808:	fba0 2302 	umull	r2, r3, r0, r2
 800980c:	eb0e 0103 	add.w	r1, lr, r3
 8009810:	460b      	mov	r3, r1
    r = ((mp_word) t.dp[2*ix]) +
 8009812:	eb12 020a 	adds.w	r2, r2, sl
 8009816:	eb43 030b 	adc.w	r3, r3, fp
 800981a:	e9cd 2308 	strd	r2, r3, [sp, #32]
    t.dp[ix+ix] = (mp_digit) (r & ((mp_word) MP_MASK));
 800981e:	9a06      	ldr	r2, [sp, #24]
 8009820:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009822:	00db      	lsls	r3, r3, #3
 8009824:	4413      	add	r3, r2
 8009826:	9a08      	ldr	r2, [sp, #32]
 8009828:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800982c:	601a      	str	r2, [r3, #0]
    u           = (mp_digit)(r >> ((mp_word) DIGIT_BIT));
 800982e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8009832:	0f14      	lsrs	r4, r2, #28
 8009834:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8009838:	0f1d      	lsrs	r5, r3, #28
 800983a:	4623      	mov	r3, r4
 800983c:	930d      	str	r3, [sp, #52]	; 0x34
    tmpx        = a->dp[ix];
 800983e:	9b01      	ldr	r3, [sp, #4]
 8009840:	68da      	ldr	r2, [r3, #12]
 8009842:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009844:	009b      	lsls	r3, r3, #2
 8009846:	4413      	add	r3, r2
 8009848:	681b      	ldr	r3, [r3, #0]
 800984a:	9307      	str	r3, [sp, #28]
    tmpt        = t.dp + (2*ix + 1);
 800984c:	9a06      	ldr	r2, [sp, #24]
 800984e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009850:	00db      	lsls	r3, r3, #3
 8009852:	3304      	adds	r3, #4
 8009854:	4413      	add	r3, r2
 8009856:	930c      	str	r3, [sp, #48]	; 0x30
    for (iy = ix + 1; iy < pa; iy++) {
 8009858:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800985a:	3301      	adds	r3, #1
 800985c:	930e      	str	r3, [sp, #56]	; 0x38
 800985e:	e044      	b.n	80098ea <s_mp_sqr+0x15a>
      r       = ((mp_word)tmpx) * ((mp_word)a->dp[iy]);
 8009860:	9b07      	ldr	r3, [sp, #28]
 8009862:	4618      	mov	r0, r3
 8009864:	f04f 0100 	mov.w	r1, #0
 8009868:	9b01      	ldr	r3, [sp, #4]
 800986a:	68da      	ldr	r2, [r3, #12]
 800986c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800986e:	009b      	lsls	r3, r3, #2
 8009870:	4413      	add	r3, r2
 8009872:	681b      	ldr	r3, [r3, #0]
 8009874:	461a      	mov	r2, r3
 8009876:	f04f 0300 	mov.w	r3, #0
 800987a:	fb02 fc01 	mul.w	ip, r2, r1
 800987e:	fb00 fe03 	mul.w	lr, r0, r3
 8009882:	44e6      	add	lr, ip
 8009884:	fba0 2302 	umull	r2, r3, r0, r2
 8009888:	eb0e 0103 	add.w	r1, lr, r3
 800988c:	460b      	mov	r3, r1
 800988e:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8009892:	e9cd 2308 	strd	r2, r3, [sp, #32]
      r       = ((mp_word) *tmpt) + r + r + ((mp_word) u);
 8009896:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009898:	681b      	ldr	r3, [r3, #0]
 800989a:	4618      	mov	r0, r3
 800989c:	f04f 0100 	mov.w	r1, #0
 80098a0:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80098a4:	1880      	adds	r0, r0, r2
 80098a6:	eb41 0103 	adc.w	r1, r1, r3
 80098aa:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80098ae:	1880      	adds	r0, r0, r2
 80098b0:	eb41 0103 	adc.w	r1, r1, r3
 80098b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80098b6:	461a      	mov	r2, r3
 80098b8:	f04f 0300 	mov.w	r3, #0
 80098bc:	1812      	adds	r2, r2, r0
 80098be:	eb43 0301 	adc.w	r3, r3, r1
 80098c2:	e9cd 2308 	strd	r2, r3, [sp, #32]
      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));
 80098c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80098c8:	1d1a      	adds	r2, r3, #4
 80098ca:	920c      	str	r2, [sp, #48]	; 0x30
 80098cc:	9a08      	ldr	r2, [sp, #32]
 80098ce:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80098d2:	601a      	str	r2, [r3, #0]
      u       = (mp_digit)(r >> ((mp_word) DIGIT_BIT));
 80098d4:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80098d8:	0f16      	lsrs	r6, r2, #28
 80098da:	ea46 1603 	orr.w	r6, r6, r3, lsl #4
 80098de:	0f1f      	lsrs	r7, r3, #28
 80098e0:	4633      	mov	r3, r6
 80098e2:	930d      	str	r3, [sp, #52]	; 0x34
    for (iy = ix + 1; iy < pa; iy++) {
 80098e4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80098e6:	3301      	adds	r3, #1
 80098e8:	930e      	str	r3, [sp, #56]	; 0x38
 80098ea:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80098ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80098ee:	429a      	cmp	r2, r3
 80098f0:	dbb6      	blt.n	8009860 <s_mp_sqr+0xd0>
 80098f2:	e01e      	b.n	8009932 <s_mp_sqr+0x1a2>
      r       = ((mp_word) *tmpt) + ((mp_word) u);
 80098f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80098f6:	681b      	ldr	r3, [r3, #0]
 80098f8:	4618      	mov	r0, r3
 80098fa:	f04f 0100 	mov.w	r1, #0
 80098fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009900:	461a      	mov	r2, r3
 8009902:	f04f 0300 	mov.w	r3, #0
 8009906:	1812      	adds	r2, r2, r0
 8009908:	eb43 0301 	adc.w	r3, r3, r1
 800990c:	e9cd 2308 	strd	r2, r3, [sp, #32]
      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));
 8009910:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009912:	1d1a      	adds	r2, r3, #4
 8009914:	920c      	str	r2, [sp, #48]	; 0x30
 8009916:	9a08      	ldr	r2, [sp, #32]
 8009918:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800991c:	601a      	str	r2, [r3, #0]
      u       = (mp_digit)(r >> ((mp_word) DIGIT_BIT));
 800991e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8009922:	ea4f 7812 	mov.w	r8, r2, lsr #28
 8009926:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
 800992a:	ea4f 7913 	mov.w	r9, r3, lsr #28
 800992e:	4643      	mov	r3, r8
 8009930:	930d      	str	r3, [sp, #52]	; 0x34
    while (u != ((mp_digit) 0)) {
 8009932:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009934:	2b00      	cmp	r3, #0
 8009936:	d1dd      	bne.n	80098f4 <s_mp_sqr+0x164>
  for (ix = 0; ix < pa; ix++) {
 8009938:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800993a:	3301      	adds	r3, #1
 800993c:	930f      	str	r3, [sp, #60]	; 0x3c
 800993e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8009940:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009942:	429a      	cmp	r2, r3
 8009944:	f6ff af41 	blt.w	80097ca <s_mp_sqr+0x3a>
  mp_clamp (&t);
 8009948:	ab03      	add	r3, sp, #12
 800994a:	4618      	mov	r0, r3
 800994c:	f001 f930 	bl	800abb0 <mp_clamp>
  mp_exch (&t, b);
 8009950:	ab03      	add	r3, sp, #12
 8009952:	9900      	ldr	r1, [sp, #0]
 8009954:	4618      	mov	r0, r3
 8009956:	f001 f953 	bl	800ac00 <mp_exch>
  mp_clear (&t);
 800995a:	ab03      	add	r3, sp, #12
 800995c:	4618      	mov	r0, r3
 800995e:	f000 fe67 	bl	800a630 <mp_clear>
  return MP_OKAY;
 8009962:	2300      	movs	r3, #0
}
 8009964:	4618      	mov	r0, r3
 8009966:	b011      	add	sp, #68	; 0x44
 8009968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800996c:	0000      	movs	r0, r0
	...

08009970 <s_mp_mul_digs>:
{
 8009970:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009972:	b095      	sub	sp, #84	; 0x54
 8009974:	9003      	str	r0, [sp, #12]
 8009976:	9102      	str	r1, [sp, #8]
 8009978:	9201      	str	r2, [sp, #4]
 800997a:	9300      	str	r3, [sp, #0]
  if (((digs) < MP_WARRAY) &&
 800997c:	9b00      	ldr	r3, [sp, #0]
 800997e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009982:	da10      	bge.n	80099a6 <s_mp_mul_digs+0x36>
      MIN (a->used, b->used) <
 8009984:	9b02      	ldr	r3, [sp, #8]
 8009986:	681a      	ldr	r2, [r3, #0]
 8009988:	9b03      	ldr	r3, [sp, #12]
 800998a:	681b      	ldr	r3, [r3, #0]
 800998c:	4293      	cmp	r3, r2
 800998e:	bfa8      	it	ge
 8009990:	4613      	movge	r3, r2
  if (((digs) < MP_WARRAY) &&
 8009992:	2bff      	cmp	r3, #255	; 0xff
 8009994:	dc07      	bgt.n	80099a6 <s_mp_mul_digs+0x36>
    return fast_s_mp_mul_digs (a, b, c, digs);
 8009996:	9b00      	ldr	r3, [sp, #0]
 8009998:	9a01      	ldr	r2, [sp, #4]
 800999a:	9902      	ldr	r1, [sp, #8]
 800999c:	9803      	ldr	r0, [sp, #12]
 800999e:	f7ff fe27 	bl	80095f0 <fast_s_mp_mul_digs>
 80099a2:	4603      	mov	r3, r0
 80099a4:	e089      	b.n	8009aba <s_mp_mul_digs+0x14a>
  if ((res = mp_init_size (&t, digs)) != MP_OKAY) {
 80099a6:	ab04      	add	r3, sp, #16
 80099a8:	9900      	ldr	r1, [sp, #0]
 80099aa:	4618      	mov	r0, r3
 80099ac:	f7ff fcd0 	bl	8009350 <mp_init_size>
 80099b0:	900e      	str	r0, [sp, #56]	; 0x38
 80099b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80099b4:	2b00      	cmp	r3, #0
 80099b6:	d001      	beq.n	80099bc <s_mp_mul_digs+0x4c>
    return res;
 80099b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80099ba:	e07e      	b.n	8009aba <s_mp_mul_digs+0x14a>
  t.used = digs;
 80099bc:	9b00      	ldr	r3, [sp, #0]
 80099be:	9304      	str	r3, [sp, #16]
  pa = a->used;
 80099c0:	9b03      	ldr	r3, [sp, #12]
 80099c2:	681b      	ldr	r3, [r3, #0]
 80099c4:	930d      	str	r3, [sp, #52]	; 0x34
  for (ix = 0; ix < pa; ix++) {
 80099c6:	2300      	movs	r3, #0
 80099c8:	9313      	str	r3, [sp, #76]	; 0x4c
 80099ca:	e064      	b.n	8009a96 <s_mp_mul_digs+0x126>
    u = 0;
 80099cc:	2300      	movs	r3, #0
 80099ce:	9311      	str	r3, [sp, #68]	; 0x44
    pb = MIN (b->used, digs - ix);
 80099d0:	9a00      	ldr	r2, [sp, #0]
 80099d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80099d4:	1ad2      	subs	r2, r2, r3
 80099d6:	9b02      	ldr	r3, [sp, #8]
 80099d8:	681b      	ldr	r3, [r3, #0]
 80099da:	4293      	cmp	r3, r2
 80099dc:	bfa8      	it	ge
 80099de:	4613      	movge	r3, r2
 80099e0:	930c      	str	r3, [sp, #48]	; 0x30
    tmpx = a->dp[ix];
 80099e2:	9b03      	ldr	r3, [sp, #12]
 80099e4:	68da      	ldr	r2, [r3, #12]
 80099e6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80099e8:	009b      	lsls	r3, r3, #2
 80099ea:	4413      	add	r3, r2
 80099ec:	681b      	ldr	r3, [r3, #0]
 80099ee:	930b      	str	r3, [sp, #44]	; 0x2c
    tmpt = t.dp + ix;
 80099f0:	9a07      	ldr	r2, [sp, #28]
 80099f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80099f4:	009b      	lsls	r3, r3, #2
 80099f6:	4413      	add	r3, r2
 80099f8:	9310      	str	r3, [sp, #64]	; 0x40
    tmpy = b->dp;
 80099fa:	9b02      	ldr	r3, [sp, #8]
 80099fc:	68db      	ldr	r3, [r3, #12]
 80099fe:	930f      	str	r3, [sp, #60]	; 0x3c
    for (iy = 0; iy < pb; iy++) {
 8009a00:	2300      	movs	r3, #0
 8009a02:	9312      	str	r3, [sp, #72]	; 0x48
 8009a04:	e037      	b.n	8009a76 <s_mp_mul_digs+0x106>
      r       = ((mp_word)*tmpt) +
 8009a06:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009a08:	681b      	ldr	r3, [r3, #0]
 8009a0a:	461e      	mov	r6, r3
 8009a0c:	f04f 0700 	mov.w	r7, #0
                ((mp_word)tmpx) * ((mp_word)*tmpy++) +
 8009a10:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009a12:	4618      	mov	r0, r3
 8009a14:	f04f 0100 	mov.w	r1, #0
 8009a18:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009a1a:	1d1a      	adds	r2, r3, #4
 8009a1c:	920f      	str	r2, [sp, #60]	; 0x3c
 8009a1e:	681b      	ldr	r3, [r3, #0]
 8009a20:	461a      	mov	r2, r3
 8009a22:	f04f 0300 	mov.w	r3, #0
 8009a26:	fb02 fc01 	mul.w	ip, r2, r1
 8009a2a:	fb00 fe03 	mul.w	lr, r0, r3
 8009a2e:	44e6      	add	lr, ip
 8009a30:	fba0 2302 	umull	r2, r3, r0, r2
 8009a34:	eb0e 0103 	add.w	r1, lr, r3
 8009a38:	460b      	mov	r3, r1
      r       = ((mp_word)*tmpt) +
 8009a3a:	18b0      	adds	r0, r6, r2
 8009a3c:	eb47 0103 	adc.w	r1, r7, r3
                ((mp_word) u);
 8009a40:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009a42:	461a      	mov	r2, r3
 8009a44:	f04f 0300 	mov.w	r3, #0
      r       = ((mp_word)*tmpt) +
 8009a48:	1812      	adds	r2, r2, r0
 8009a4a:	eb43 0301 	adc.w	r3, r3, r1
 8009a4e:	e9cd 2308 	strd	r2, r3, [sp, #32]
      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));
 8009a52:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009a54:	1d1a      	adds	r2, r3, #4
 8009a56:	9210      	str	r2, [sp, #64]	; 0x40
 8009a58:	9a08      	ldr	r2, [sp, #32]
 8009a5a:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8009a5e:	601a      	str	r2, [r3, #0]
      u       = (mp_digit) (r >> ((mp_word) DIGIT_BIT));
 8009a60:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8009a64:	0f14      	lsrs	r4, r2, #28
 8009a66:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 8009a6a:	0f1d      	lsrs	r5, r3, #28
 8009a6c:	4623      	mov	r3, r4
 8009a6e:	9311      	str	r3, [sp, #68]	; 0x44
    for (iy = 0; iy < pb; iy++) {
 8009a70:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8009a72:	3301      	adds	r3, #1
 8009a74:	9312      	str	r3, [sp, #72]	; 0x48
 8009a76:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8009a78:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009a7a:	429a      	cmp	r2, r3
 8009a7c:	dbc3      	blt.n	8009a06 <s_mp_mul_digs+0x96>
    if (ix + iy < digs) {
 8009a7e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009a80:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8009a82:	441a      	add	r2, r3
 8009a84:	9b00      	ldr	r3, [sp, #0]
 8009a86:	429a      	cmp	r2, r3
 8009a88:	da02      	bge.n	8009a90 <s_mp_mul_digs+0x120>
      *tmpt = u;
 8009a8a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009a8c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009a8e:	601a      	str	r2, [r3, #0]
  for (ix = 0; ix < pa; ix++) {
 8009a90:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009a92:	3301      	adds	r3, #1
 8009a94:	9313      	str	r3, [sp, #76]	; 0x4c
 8009a96:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009a98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009a9a:	429a      	cmp	r2, r3
 8009a9c:	db96      	blt.n	80099cc <s_mp_mul_digs+0x5c>
  mp_clamp (&t);
 8009a9e:	ab04      	add	r3, sp, #16
 8009aa0:	4618      	mov	r0, r3
 8009aa2:	f001 f885 	bl	800abb0 <mp_clamp>
  mp_exch (&t, c);
 8009aa6:	ab04      	add	r3, sp, #16
 8009aa8:	9901      	ldr	r1, [sp, #4]
 8009aaa:	4618      	mov	r0, r3
 8009aac:	f001 f8a8 	bl	800ac00 <mp_exch>
  mp_clear (&t);
 8009ab0:	ab04      	add	r3, sp, #16
 8009ab2:	4618      	mov	r0, r3
 8009ab4:	f000 fdbc 	bl	800a630 <mp_clear>
  return MP_OKAY;
 8009ab8:	2300      	movs	r3, #0
}
 8009aba:	4618      	mov	r0, r3
 8009abc:	b015      	add	sp, #84	; 0x54
 8009abe:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009ac0 <mp_montgomery_calc_normalization>:
{
 8009ac0:	b500      	push	{lr}
 8009ac2:	b087      	sub	sp, #28
 8009ac4:	9001      	str	r0, [sp, #4]
 8009ac6:	9100      	str	r1, [sp, #0]
  bits = mp_count_bits (b) % DIGIT_BIT;
 8009ac8:	9800      	ldr	r0, [sp, #0]
 8009aca:	f000 fe49 	bl	800a760 <mp_count_bits>
 8009ace:	4602      	mov	r2, r0
 8009ad0:	4b2e      	ldr	r3, [pc, #184]	; (8009b8c <mp_montgomery_calc_normalization+0xcc>)
 8009ad2:	fb83 1302 	smull	r1, r3, r3, r2
 8009ad6:	4413      	add	r3, r2
 8009ad8:	1119      	asrs	r1, r3, #4
 8009ada:	17d3      	asrs	r3, r2, #31
 8009adc:	1ac9      	subs	r1, r1, r3
 8009ade:	460b      	mov	r3, r1
 8009ae0:	00db      	lsls	r3, r3, #3
 8009ae2:	1a5b      	subs	r3, r3, r1
 8009ae4:	009b      	lsls	r3, r3, #2
 8009ae6:	1ad3      	subs	r3, r2, r3
 8009ae8:	9304      	str	r3, [sp, #16]
  if (b->used > 1) {
 8009aea:	9b00      	ldr	r3, [sp, #0]
 8009aec:	681b      	ldr	r3, [r3, #0]
 8009aee:	2b01      	cmp	r3, #1
 8009af0:	dd14      	ble.n	8009b1c <mp_montgomery_calc_normalization+0x5c>
     if ((res = mp_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1))
 8009af2:	9b00      	ldr	r3, [sp, #0]
 8009af4:	681b      	ldr	r3, [r3, #0]
 8009af6:	1e5a      	subs	r2, r3, #1
 8009af8:	4613      	mov	r3, r2
 8009afa:	00db      	lsls	r3, r3, #3
 8009afc:	1a9b      	subs	r3, r3, r2
 8009afe:	009b      	lsls	r3, r3, #2
 8009b00:	461a      	mov	r2, r3
 8009b02:	9b04      	ldr	r3, [sp, #16]
 8009b04:	4413      	add	r3, r2
 8009b06:	3b01      	subs	r3, #1
 8009b08:	4619      	mov	r1, r3
 8009b0a:	9801      	ldr	r0, [sp, #4]
 8009b0c:	f7ff f9d0 	bl	8008eb0 <mp_2expt>
 8009b10:	9003      	str	r0, [sp, #12]
 8009b12:	9b03      	ldr	r3, [sp, #12]
 8009b14:	2b00      	cmp	r3, #0
 8009b16:	d00d      	beq.n	8009b34 <mp_montgomery_calc_normalization+0x74>
        return res;
 8009b18:	9b03      	ldr	r3, [sp, #12]
 8009b1a:	e033      	b.n	8009b84 <mp_montgomery_calc_normalization+0xc4>
     if ((res = mp_set(a, 1)) != MP_OKAY) {
 8009b1c:	2101      	movs	r1, #1
 8009b1e:	9801      	ldr	r0, [sp, #4]
 8009b20:	f002 f836 	bl	800bb90 <mp_set>
 8009b24:	9003      	str	r0, [sp, #12]
 8009b26:	9b03      	ldr	r3, [sp, #12]
 8009b28:	2b00      	cmp	r3, #0
 8009b2a:	d001      	beq.n	8009b30 <mp_montgomery_calc_normalization+0x70>
        return res;
 8009b2c:	9b03      	ldr	r3, [sp, #12]
 8009b2e:	e029      	b.n	8009b84 <mp_montgomery_calc_normalization+0xc4>
     bits = 1;
 8009b30:	2301      	movs	r3, #1
 8009b32:	9304      	str	r3, [sp, #16]
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8009b34:	9b04      	ldr	r3, [sp, #16]
 8009b36:	3b01      	subs	r3, #1
 8009b38:	9305      	str	r3, [sp, #20]
 8009b3a:	e01f      	b.n	8009b7c <mp_montgomery_calc_normalization+0xbc>
    if ((res = mp_mul_2 (a, a)) != MP_OKAY) {
 8009b3c:	9901      	ldr	r1, [sp, #4]
 8009b3e:	9801      	ldr	r0, [sp, #4]
 8009b40:	f7ff fae6 	bl	8009110 <mp_mul_2>
 8009b44:	9003      	str	r0, [sp, #12]
 8009b46:	9b03      	ldr	r3, [sp, #12]
 8009b48:	2b00      	cmp	r3, #0
 8009b4a:	d001      	beq.n	8009b50 <mp_montgomery_calc_normalization+0x90>
      return res;
 8009b4c:	9b03      	ldr	r3, [sp, #12]
 8009b4e:	e019      	b.n	8009b84 <mp_montgomery_calc_normalization+0xc4>
    if (mp_cmp_mag (a, b) != MP_LT) {
 8009b50:	9900      	ldr	r1, [sp, #0]
 8009b52:	9801      	ldr	r0, [sp, #4]
 8009b54:	f001 ff6c 	bl	800ba30 <mp_cmp_mag>
 8009b58:	4603      	mov	r3, r0
 8009b5a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009b5e:	d00a      	beq.n	8009b76 <mp_montgomery_calc_normalization+0xb6>
      if ((res = s_mp_sub (a, b, a)) != MP_OKAY) {
 8009b60:	9a01      	ldr	r2, [sp, #4]
 8009b62:	9900      	ldr	r1, [sp, #0]
 8009b64:	9801      	ldr	r0, [sp, #4]
 8009b66:	f7fe f9c3 	bl	8007ef0 <s_mp_sub>
 8009b6a:	9003      	str	r0, [sp, #12]
 8009b6c:	9b03      	ldr	r3, [sp, #12]
 8009b6e:	2b00      	cmp	r3, #0
 8009b70:	d001      	beq.n	8009b76 <mp_montgomery_calc_normalization+0xb6>
        return res;
 8009b72:	9b03      	ldr	r3, [sp, #12]
 8009b74:	e006      	b.n	8009b84 <mp_montgomery_calc_normalization+0xc4>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8009b76:	9b05      	ldr	r3, [sp, #20]
 8009b78:	3301      	adds	r3, #1
 8009b7a:	9305      	str	r3, [sp, #20]
 8009b7c:	9b05      	ldr	r3, [sp, #20]
 8009b7e:	2b1b      	cmp	r3, #27
 8009b80:	dddc      	ble.n	8009b3c <mp_montgomery_calc_normalization+0x7c>
  return MP_OKAY;
 8009b82:	2300      	movs	r3, #0
}
 8009b84:	4618      	mov	r0, r3
 8009b86:	b007      	add	sp, #28
 8009b88:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b8c:	92492493 	.word	0x92492493

08009b90 <s_mp_exptmod>:
{
 8009b90:	b510      	push	{r4, lr}
 8009b92:	f5ad 7d18 	sub.w	sp, sp, #608	; 0x260
 8009b96:	ac03      	add	r4, sp, #12
 8009b98:	6020      	str	r0, [r4, #0]
 8009b9a:	a802      	add	r0, sp, #8
 8009b9c:	6001      	str	r1, [r0, #0]
 8009b9e:	a901      	add	r1, sp, #4
 8009ba0:	600a      	str	r2, [r1, #0]
 8009ba2:	466a      	mov	r2, sp
 8009ba4:	6013      	str	r3, [r2, #0]
  x = mp_count_bits (X);
 8009ba6:	ab02      	add	r3, sp, #8
 8009ba8:	6818      	ldr	r0, [r3, #0]
 8009baa:	f000 fdd9 	bl	800a760 <mp_count_bits>
 8009bae:	9090      	str	r0, [sp, #576]	; 0x240
  if (x <= 7) {
 8009bb0:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009bb2:	2b07      	cmp	r3, #7
 8009bb4:	dc02      	bgt.n	8009bbc <s_mp_exptmod+0x2c>
    winsize = 2;
 8009bb6:	2302      	movs	r3, #2
 8009bb8:	938e      	str	r3, [sp, #568]	; 0x238
 8009bba:	e023      	b.n	8009c04 <s_mp_exptmod+0x74>
  } else if (x <= 36) {
 8009bbc:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009bbe:	2b24      	cmp	r3, #36	; 0x24
 8009bc0:	dc02      	bgt.n	8009bc8 <s_mp_exptmod+0x38>
    winsize = 3;
 8009bc2:	2303      	movs	r3, #3
 8009bc4:	938e      	str	r3, [sp, #568]	; 0x238
 8009bc6:	e01d      	b.n	8009c04 <s_mp_exptmod+0x74>
  } else if (x <= 140) {
 8009bc8:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009bca:	2b8c      	cmp	r3, #140	; 0x8c
 8009bcc:	dc02      	bgt.n	8009bd4 <s_mp_exptmod+0x44>
    winsize = 4;
 8009bce:	2304      	movs	r3, #4
 8009bd0:	938e      	str	r3, [sp, #568]	; 0x238
 8009bd2:	e017      	b.n	8009c04 <s_mp_exptmod+0x74>
  } else if (x <= 450) {
 8009bd4:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009bd6:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
 8009bda:	dc02      	bgt.n	8009be2 <s_mp_exptmod+0x52>
    winsize = 5;
 8009bdc:	2305      	movs	r3, #5
 8009bde:	938e      	str	r3, [sp, #568]	; 0x238
 8009be0:	e010      	b.n	8009c04 <s_mp_exptmod+0x74>
  } else if (x <= 1303) {
 8009be2:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009be4:	f5b3 6fa3 	cmp.w	r3, #1304	; 0x518
 8009be8:	da02      	bge.n	8009bf0 <s_mp_exptmod+0x60>
    winsize = 6;
 8009bea:	2306      	movs	r3, #6
 8009bec:	938e      	str	r3, [sp, #568]	; 0x238
 8009bee:	e009      	b.n	8009c04 <s_mp_exptmod+0x74>
  } else if (x <= 3529) {
 8009bf0:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009bf2:	f640 52c9 	movw	r2, #3529	; 0xdc9
 8009bf6:	4293      	cmp	r3, r2
 8009bf8:	dc02      	bgt.n	8009c00 <s_mp_exptmod+0x70>
    winsize = 7;
 8009bfa:	2307      	movs	r3, #7
 8009bfc:	938e      	str	r3, [sp, #568]	; 0x238
 8009bfe:	e001      	b.n	8009c04 <s_mp_exptmod+0x74>
    winsize = 8;
 8009c00:	2308      	movs	r3, #8
 8009c02:	938e      	str	r3, [sp, #568]	; 0x238
    if (winsize > 5) {
 8009c04:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009c06:	2b05      	cmp	r3, #5
 8009c08:	dd01      	ble.n	8009c0e <s_mp_exptmod+0x7e>
       winsize = 5;
 8009c0a:	2305      	movs	r3, #5
 8009c0c:	938e      	str	r3, [sp, #568]	; 0x238
  if ((err = mp_init(&M[1])) != MP_OKAY) {
 8009c0e:	ab0d      	add	r3, sp, #52	; 0x34
 8009c10:	3310      	adds	r3, #16
 8009c12:	4618      	mov	r0, r3
 8009c14:	f000 fcf4 	bl	800a600 <mp_init>
 8009c18:	9096      	str	r0, [sp, #600]	; 0x258
 8009c1a:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009c1c:	2b00      	cmp	r3, #0
 8009c1e:	d001      	beq.n	8009c24 <s_mp_exptmod+0x94>
     return err;
 8009c20:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009c22:	e211      	b.n	800a048 <s_mp_exptmod+0x4b8>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 8009c24:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009c26:	3b01      	subs	r3, #1
 8009c28:	2201      	movs	r2, #1
 8009c2a:	fa02 f303 	lsl.w	r3, r2, r3
 8009c2e:	9390      	str	r3, [sp, #576]	; 0x240
 8009c30:	e029      	b.n	8009c86 <s_mp_exptmod+0xf6>
    if ((err = mp_init(&M[x])) != MP_OKAY) {
 8009c32:	aa0d      	add	r2, sp, #52	; 0x34
 8009c34:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009c36:	011b      	lsls	r3, r3, #4
 8009c38:	4413      	add	r3, r2
 8009c3a:	4618      	mov	r0, r3
 8009c3c:	f000 fce0 	bl	800a600 <mp_init>
 8009c40:	9096      	str	r0, [sp, #600]	; 0x258
 8009c42:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009c44:	2b00      	cmp	r3, #0
 8009c46:	d01b      	beq.n	8009c80 <s_mp_exptmod+0xf0>
      for (y = 1<<(winsize-1); y < x; y++) {
 8009c48:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009c4a:	3b01      	subs	r3, #1
 8009c4c:	2201      	movs	r2, #1
 8009c4e:	fa02 f303 	lsl.w	r3, r2, r3
 8009c52:	938f      	str	r3, [sp, #572]	; 0x23c
 8009c54:	e009      	b.n	8009c6a <s_mp_exptmod+0xda>
        mp_clear (&M[y]);
 8009c56:	aa0d      	add	r2, sp, #52	; 0x34
 8009c58:	9b8f      	ldr	r3, [sp, #572]	; 0x23c
 8009c5a:	011b      	lsls	r3, r3, #4
 8009c5c:	4413      	add	r3, r2
 8009c5e:	4618      	mov	r0, r3
 8009c60:	f000 fce6 	bl	800a630 <mp_clear>
      for (y = 1<<(winsize-1); y < x; y++) {
 8009c64:	9b8f      	ldr	r3, [sp, #572]	; 0x23c
 8009c66:	3301      	adds	r3, #1
 8009c68:	938f      	str	r3, [sp, #572]	; 0x23c
 8009c6a:	9a8f      	ldr	r2, [sp, #572]	; 0x23c
 8009c6c:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009c6e:	429a      	cmp	r2, r3
 8009c70:	dbf1      	blt.n	8009c56 <s_mp_exptmod+0xc6>
      mp_clear(&M[1]);
 8009c72:	ab0d      	add	r3, sp, #52	; 0x34
 8009c74:	3310      	adds	r3, #16
 8009c76:	4618      	mov	r0, r3
 8009c78:	f000 fcda 	bl	800a630 <mp_clear>
      return err;
 8009c7c:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009c7e:	e1e3      	b.n	800a048 <s_mp_exptmod+0x4b8>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 8009c80:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009c82:	3301      	adds	r3, #1
 8009c84:	9390      	str	r3, [sp, #576]	; 0x240
 8009c86:	2201      	movs	r2, #1
 8009c88:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009c8a:	409a      	lsls	r2, r3
 8009c8c:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009c8e:	429a      	cmp	r2, r3
 8009c90:	dccf      	bgt.n	8009c32 <s_mp_exptmod+0xa2>
  if ((err = mp_init (&mu)) != MP_OKAY) {
 8009c92:	ab05      	add	r3, sp, #20
 8009c94:	4618      	mov	r0, r3
 8009c96:	f000 fcb3 	bl	800a600 <mp_init>
 8009c9a:	9096      	str	r0, [sp, #600]	; 0x258
 8009c9c:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009c9e:	2b00      	cmp	r3, #0
 8009ca0:	f040 81b5 	bne.w	800a00e <s_mp_exptmod+0x47e>
  if (redmode == 0) {
 8009ca4:	9b9a      	ldr	r3, [sp, #616]	; 0x268
 8009ca6:	2b00      	cmp	r3, #0
 8009ca8:	d10d      	bne.n	8009cc6 <s_mp_exptmod+0x136>
     if ((err = mp_reduce_setup (&mu, P)) != MP_OKAY) {
 8009caa:	ab01      	add	r3, sp, #4
 8009cac:	aa05      	add	r2, sp, #20
 8009cae:	6819      	ldr	r1, [r3, #0]
 8009cb0:	4610      	mov	r0, r2
 8009cb2:	f000 f9cd 	bl	800a050 <mp_reduce_setup>
 8009cb6:	9096      	str	r0, [sp, #600]	; 0x258
 8009cb8:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009cba:	2b00      	cmp	r3, #0
 8009cbc:	f040 81a3 	bne.w	800a006 <s_mp_exptmod+0x476>
     redux = mp_reduce;
 8009cc0:	4ba6      	ldr	r3, [pc, #664]	; (8009f5c <s_mp_exptmod+0x3cc>)
 8009cc2:	938d      	str	r3, [sp, #564]	; 0x234
 8009cc4:	e00c      	b.n	8009ce0 <s_mp_exptmod+0x150>
     if ((err = mp_reduce_2k_setup_l (P, &mu)) != MP_OKAY) {
 8009cc6:	aa05      	add	r2, sp, #20
 8009cc8:	ab01      	add	r3, sp, #4
 8009cca:	4611      	mov	r1, r2
 8009ccc:	6818      	ldr	r0, [r3, #0]
 8009cce:	f000 facf 	bl	800a270 <mp_reduce_2k_setup_l>
 8009cd2:	9096      	str	r0, [sp, #600]	; 0x258
 8009cd4:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009cd6:	2b00      	cmp	r3, #0
 8009cd8:	f040 8195 	bne.w	800a006 <s_mp_exptmod+0x476>
     redux = mp_reduce_2k_l;
 8009cdc:	4ba0      	ldr	r3, [pc, #640]	; (8009f60 <s_mp_exptmod+0x3d0>)
 8009cde:	938d      	str	r3, [sp, #564]	; 0x234
  if ((err = mp_mod (G, P, &M[1])) != MP_OKAY) {
 8009ce0:	ab0d      	add	r3, sp, #52	; 0x34
 8009ce2:	f103 0210 	add.w	r2, r3, #16
 8009ce6:	a901      	add	r1, sp, #4
 8009ce8:	ab03      	add	r3, sp, #12
 8009cea:	6809      	ldr	r1, [r1, #0]
 8009cec:	6818      	ldr	r0, [r3, #0]
 8009cee:	f001 ff77 	bl	800bbe0 <mp_mod>
 8009cf2:	9096      	str	r0, [sp, #600]	; 0x258
 8009cf4:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009cf6:	2b00      	cmp	r3, #0
 8009cf8:	f040 8185 	bne.w	800a006 <s_mp_exptmod+0x476>
  if ((err = mp_copy (&M[1], &M[(mp_digit)(1 << (winsize - 1))])) != MP_OKAY) {
 8009cfc:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009cfe:	3b01      	subs	r3, #1
 8009d00:	2201      	movs	r2, #1
 8009d02:	fa02 f303 	lsl.w	r3, r2, r3
 8009d06:	aa0d      	add	r2, sp, #52	; 0x34
 8009d08:	011b      	lsls	r3, r3, #4
 8009d0a:	441a      	add	r2, r3
 8009d0c:	ab0d      	add	r3, sp, #52	; 0x34
 8009d0e:	3310      	adds	r3, #16
 8009d10:	4611      	mov	r1, r2
 8009d12:	4618      	mov	r0, r3
 8009d14:	f000 fe04 	bl	800a920 <mp_copy>
 8009d18:	9096      	str	r0, [sp, #600]	; 0x258
 8009d1a:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009d1c:	2b00      	cmp	r3, #0
 8009d1e:	f040 8172 	bne.w	800a006 <s_mp_exptmod+0x476>
  for (x = 0; x < (winsize - 1); x++) {
 8009d22:	2300      	movs	r3, #0
 8009d24:	9390      	str	r3, [sp, #576]	; 0x240
 8009d26:	e02c      	b.n	8009d82 <s_mp_exptmod+0x1f2>
    if ((err = mp_sqr (&M[(mp_digit)(1 << (winsize - 1))],
 8009d28:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009d2a:	3b01      	subs	r3, #1
 8009d2c:	2201      	movs	r2, #1
 8009d2e:	fa02 f303 	lsl.w	r3, r2, r3
 8009d32:	aa0d      	add	r2, sp, #52	; 0x34
 8009d34:	011b      	lsls	r3, r3, #4
 8009d36:	18d0      	adds	r0, r2, r3
                       &M[(mp_digit)(1 << (winsize - 1))])) != MP_OKAY) {
 8009d38:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009d3a:	3b01      	subs	r3, #1
 8009d3c:	2201      	movs	r2, #1
 8009d3e:	fa02 f303 	lsl.w	r3, r2, r3
    if ((err = mp_sqr (&M[(mp_digit)(1 << (winsize - 1))],
 8009d42:	aa0d      	add	r2, sp, #52	; 0x34
 8009d44:	011b      	lsls	r3, r3, #4
 8009d46:	4413      	add	r3, r2
 8009d48:	4619      	mov	r1, r3
 8009d4a:	f7ff f971 	bl	8009030 <mp_sqr>
 8009d4e:	9096      	str	r0, [sp, #600]	; 0x258
 8009d50:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009d52:	2b00      	cmp	r3, #0
 8009d54:	f040 8157 	bne.w	800a006 <s_mp_exptmod+0x476>
    if ((err = redux (&M[(mp_digit)(1 << (winsize - 1))], P, &mu)) != MP_OKAY) {
 8009d58:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009d5a:	3b01      	subs	r3, #1
 8009d5c:	2201      	movs	r2, #1
 8009d5e:	fa02 f303 	lsl.w	r3, r2, r3
 8009d62:	aa0d      	add	r2, sp, #52	; 0x34
 8009d64:	011b      	lsls	r3, r3, #4
 8009d66:	18d0      	adds	r0, r2, r3
 8009d68:	aa05      	add	r2, sp, #20
 8009d6a:	a901      	add	r1, sp, #4
 8009d6c:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009d6e:	6809      	ldr	r1, [r1, #0]
 8009d70:	4798      	blx	r3
 8009d72:	9096      	str	r0, [sp, #600]	; 0x258
 8009d74:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009d76:	2b00      	cmp	r3, #0
 8009d78:	f040 8145 	bne.w	800a006 <s_mp_exptmod+0x476>
  for (x = 0; x < (winsize - 1); x++) {
 8009d7c:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009d7e:	3301      	adds	r3, #1
 8009d80:	9390      	str	r3, [sp, #576]	; 0x240
 8009d82:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009d84:	1e5a      	subs	r2, r3, #1
 8009d86:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009d88:	429a      	cmp	r2, r3
 8009d8a:	dccd      	bgt.n	8009d28 <s_mp_exptmod+0x198>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8009d8c:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009d8e:	3b01      	subs	r3, #1
 8009d90:	2201      	movs	r2, #1
 8009d92:	fa02 f303 	lsl.w	r3, r2, r3
 8009d96:	3301      	adds	r3, #1
 8009d98:	9390      	str	r3, [sp, #576]	; 0x240
 8009d9a:	e023      	b.n	8009de4 <s_mp_exptmod+0x254>
    if ((err = mp_mul (&M[x - 1], &M[1], &M[x])) != MP_OKAY) {
 8009d9c:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009d9e:	3b01      	subs	r3, #1
 8009da0:	aa0d      	add	r2, sp, #52	; 0x34
 8009da2:	011b      	lsls	r3, r3, #4
 8009da4:	18d0      	adds	r0, r2, r3
 8009da6:	aa0d      	add	r2, sp, #52	; 0x34
 8009da8:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009daa:	011b      	lsls	r3, r3, #4
 8009dac:	441a      	add	r2, r3
 8009dae:	ab0d      	add	r3, sp, #52	; 0x34
 8009db0:	3310      	adds	r3, #16
 8009db2:	4619      	mov	r1, r3
 8009db4:	f7ff f964 	bl	8009080 <mp_mul>
 8009db8:	9096      	str	r0, [sp, #600]	; 0x258
 8009dba:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009dbc:	2b00      	cmp	r3, #0
 8009dbe:	f040 8122 	bne.w	800a006 <s_mp_exptmod+0x476>
    if ((err = redux (&M[x], P, &mu)) != MP_OKAY) {
 8009dc2:	aa0d      	add	r2, sp, #52	; 0x34
 8009dc4:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009dc6:	011b      	lsls	r3, r3, #4
 8009dc8:	18d0      	adds	r0, r2, r3
 8009dca:	aa05      	add	r2, sp, #20
 8009dcc:	a901      	add	r1, sp, #4
 8009dce:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009dd0:	6809      	ldr	r1, [r1, #0]
 8009dd2:	4798      	blx	r3
 8009dd4:	9096      	str	r0, [sp, #600]	; 0x258
 8009dd6:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009dd8:	2b00      	cmp	r3, #0
 8009dda:	f040 8114 	bne.w	800a006 <s_mp_exptmod+0x476>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8009dde:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009de0:	3301      	adds	r3, #1
 8009de2:	9390      	str	r3, [sp, #576]	; 0x240
 8009de4:	2201      	movs	r2, #1
 8009de6:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009de8:	409a      	lsls	r2, r3
 8009dea:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009dec:	429a      	cmp	r2, r3
 8009dee:	dcd5      	bgt.n	8009d9c <s_mp_exptmod+0x20c>
  if ((err = mp_init (&res)) != MP_OKAY) {
 8009df0:	ab09      	add	r3, sp, #36	; 0x24
 8009df2:	4618      	mov	r0, r3
 8009df4:	f000 fc04 	bl	800a600 <mp_init>
 8009df8:	9096      	str	r0, [sp, #600]	; 0x258
 8009dfa:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009dfc:	2b00      	cmp	r3, #0
 8009dfe:	f040 8102 	bne.w	800a006 <s_mp_exptmod+0x476>
  if ((err = mp_set (&res, 1)) != MP_OKAY) {
 8009e02:	ab09      	add	r3, sp, #36	; 0x24
 8009e04:	2101      	movs	r1, #1
 8009e06:	4618      	mov	r0, r3
 8009e08:	f001 fec2 	bl	800bb90 <mp_set>
 8009e0c:	9096      	str	r0, [sp, #600]	; 0x258
 8009e0e:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009e10:	2b00      	cmp	r3, #0
 8009e12:	f040 80f8 	bne.w	800a006 <s_mp_exptmod+0x476>
  mode   = 0;
 8009e16:	2300      	movs	r3, #0
 8009e18:	9392      	str	r3, [sp, #584]	; 0x248
  bitcnt = 1;
 8009e1a:	2301      	movs	r3, #1
 8009e1c:	9393      	str	r3, [sp, #588]	; 0x24c
  buf    = 0;
 8009e1e:	2300      	movs	r3, #0
 8009e20:	9397      	str	r3, [sp, #604]	; 0x25c
  digidx = X->used - 1;
 8009e22:	ab02      	add	r3, sp, #8
 8009e24:	681b      	ldr	r3, [r3, #0]
 8009e26:	681b      	ldr	r3, [r3, #0]
 8009e28:	3b01      	subs	r3, #1
 8009e2a:	9391      	str	r3, [sp, #580]	; 0x244
  bitcpy = 0;
 8009e2c:	2300      	movs	r3, #0
 8009e2e:	9394      	str	r3, [sp, #592]	; 0x250
  bitbuf = 0;
 8009e30:	2300      	movs	r3, #0
 8009e32:	9395      	str	r3, [sp, #596]	; 0x254
    if (--bitcnt == 0) {
 8009e34:	9b93      	ldr	r3, [sp, #588]	; 0x24c
 8009e36:	3b01      	subs	r3, #1
 8009e38:	9393      	str	r3, [sp, #588]	; 0x24c
 8009e3a:	9b93      	ldr	r3, [sp, #588]	; 0x24c
 8009e3c:	2b00      	cmp	r3, #0
 8009e3e:	d110      	bne.n	8009e62 <s_mp_exptmod+0x2d2>
      if (digidx == -1) {
 8009e40:	9b91      	ldr	r3, [sp, #580]	; 0x244
 8009e42:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009e46:	f000 808d 	beq.w	8009f64 <s_mp_exptmod+0x3d4>
      buf    = X->dp[digidx--];
 8009e4a:	ab02      	add	r3, sp, #8
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	68da      	ldr	r2, [r3, #12]
 8009e50:	9b91      	ldr	r3, [sp, #580]	; 0x244
 8009e52:	1e59      	subs	r1, r3, #1
 8009e54:	9191      	str	r1, [sp, #580]	; 0x244
 8009e56:	009b      	lsls	r3, r3, #2
 8009e58:	4413      	add	r3, r2
 8009e5a:	681b      	ldr	r3, [r3, #0]
 8009e5c:	9397      	str	r3, [sp, #604]	; 0x25c
      bitcnt = (int) DIGIT_BIT;
 8009e5e:	231c      	movs	r3, #28
 8009e60:	9393      	str	r3, [sp, #588]	; 0x24c
    y     = (int)(buf >> (mp_digit)(DIGIT_BIT - 1)) & 1;
 8009e62:	9b97      	ldr	r3, [sp, #604]	; 0x25c
 8009e64:	0edb      	lsrs	r3, r3, #27
 8009e66:	f003 0301 	and.w	r3, r3, #1
 8009e6a:	938f      	str	r3, [sp, #572]	; 0x23c
    buf <<= (mp_digit)1;
 8009e6c:	9b97      	ldr	r3, [sp, #604]	; 0x25c
 8009e6e:	005b      	lsls	r3, r3, #1
 8009e70:	9397      	str	r3, [sp, #604]	; 0x25c
    if (mode == 0 && y == 0) {
 8009e72:	9b92      	ldr	r3, [sp, #584]	; 0x248
 8009e74:	2b00      	cmp	r3, #0
 8009e76:	d102      	bne.n	8009e7e <s_mp_exptmod+0x2ee>
 8009e78:	9b8f      	ldr	r3, [sp, #572]	; 0x23c
 8009e7a:	2b00      	cmp	r3, #0
 8009e7c:	d06b      	beq.n	8009f56 <s_mp_exptmod+0x3c6>
    if (mode == 1 && y == 0) {
 8009e7e:	9b92      	ldr	r3, [sp, #584]	; 0x248
 8009e80:	2b01      	cmp	r3, #1
 8009e82:	d119      	bne.n	8009eb8 <s_mp_exptmod+0x328>
 8009e84:	9b8f      	ldr	r3, [sp, #572]	; 0x23c
 8009e86:	2b00      	cmp	r3, #0
 8009e88:	d116      	bne.n	8009eb8 <s_mp_exptmod+0x328>
      if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 8009e8a:	aa09      	add	r2, sp, #36	; 0x24
 8009e8c:	ab09      	add	r3, sp, #36	; 0x24
 8009e8e:	4611      	mov	r1, r2
 8009e90:	4618      	mov	r0, r3
 8009e92:	f7ff f8cd 	bl	8009030 <mp_sqr>
 8009e96:	9096      	str	r0, [sp, #600]	; 0x258
 8009e98:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009e9a:	2b00      	cmp	r3, #0
 8009e9c:	f040 80af 	bne.w	8009ffe <s_mp_exptmod+0x46e>
      if ((err = redux (&res, P, &mu)) != MP_OKAY) {
 8009ea0:	aa05      	add	r2, sp, #20
 8009ea2:	a901      	add	r1, sp, #4
 8009ea4:	a809      	add	r0, sp, #36	; 0x24
 8009ea6:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009ea8:	6809      	ldr	r1, [r1, #0]
 8009eaa:	4798      	blx	r3
 8009eac:	9096      	str	r0, [sp, #600]	; 0x258
 8009eae:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009eb0:	2b00      	cmp	r3, #0
 8009eb2:	f040 80a4 	bne.w	8009ffe <s_mp_exptmod+0x46e>
      continue;
 8009eb6:	e7bd      	b.n	8009e34 <s_mp_exptmod+0x2a4>
    bitbuf |= (y << (winsize - ++bitcpy));
 8009eb8:	9b94      	ldr	r3, [sp, #592]	; 0x250
 8009eba:	3301      	adds	r3, #1
 8009ebc:	9394      	str	r3, [sp, #592]	; 0x250
 8009ebe:	9a8e      	ldr	r2, [sp, #568]	; 0x238
 8009ec0:	9b94      	ldr	r3, [sp, #592]	; 0x250
 8009ec2:	1ad3      	subs	r3, r2, r3
 8009ec4:	9a8f      	ldr	r2, [sp, #572]	; 0x23c
 8009ec6:	fa02 f303 	lsl.w	r3, r2, r3
 8009eca:	9a95      	ldr	r2, [sp, #596]	; 0x254
 8009ecc:	4313      	orrs	r3, r2
 8009ece:	9395      	str	r3, [sp, #596]	; 0x254
    mode    = 2;
 8009ed0:	2302      	movs	r3, #2
 8009ed2:	9392      	str	r3, [sp, #584]	; 0x248
    if (bitcpy == winsize) {
 8009ed4:	9a94      	ldr	r2, [sp, #592]	; 0x250
 8009ed6:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009ed8:	429a      	cmp	r2, r3
 8009eda:	d1ab      	bne.n	8009e34 <s_mp_exptmod+0x2a4>
      for (x = 0; x < winsize; x++) {
 8009edc:	2300      	movs	r3, #0
 8009ede:	9390      	str	r3, [sp, #576]	; 0x240
 8009ee0:	e017      	b.n	8009f12 <s_mp_exptmod+0x382>
        if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 8009ee2:	aa09      	add	r2, sp, #36	; 0x24
 8009ee4:	ab09      	add	r3, sp, #36	; 0x24
 8009ee6:	4611      	mov	r1, r2
 8009ee8:	4618      	mov	r0, r3
 8009eea:	f7ff f8a1 	bl	8009030 <mp_sqr>
 8009eee:	9096      	str	r0, [sp, #600]	; 0x258
 8009ef0:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009ef2:	2b00      	cmp	r3, #0
 8009ef4:	f040 8083 	bne.w	8009ffe <s_mp_exptmod+0x46e>
        if ((err = redux (&res, P, &mu)) != MP_OKAY) {
 8009ef8:	aa05      	add	r2, sp, #20
 8009efa:	a901      	add	r1, sp, #4
 8009efc:	a809      	add	r0, sp, #36	; 0x24
 8009efe:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009f00:	6809      	ldr	r1, [r1, #0]
 8009f02:	4798      	blx	r3
 8009f04:	9096      	str	r0, [sp, #600]	; 0x258
 8009f06:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009f08:	2b00      	cmp	r3, #0
 8009f0a:	d178      	bne.n	8009ffe <s_mp_exptmod+0x46e>
      for (x = 0; x < winsize; x++) {
 8009f0c:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009f0e:	3301      	adds	r3, #1
 8009f10:	9390      	str	r3, [sp, #576]	; 0x240
 8009f12:	9a90      	ldr	r2, [sp, #576]	; 0x240
 8009f14:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009f16:	429a      	cmp	r2, r3
 8009f18:	dbe3      	blt.n	8009ee2 <s_mp_exptmod+0x352>
      if ((err = mp_mul (&res, &M[bitbuf], &res)) != MP_OKAY) {
 8009f1a:	aa0d      	add	r2, sp, #52	; 0x34
 8009f1c:	9b95      	ldr	r3, [sp, #596]	; 0x254
 8009f1e:	011b      	lsls	r3, r3, #4
 8009f20:	18d1      	adds	r1, r2, r3
 8009f22:	aa09      	add	r2, sp, #36	; 0x24
 8009f24:	ab09      	add	r3, sp, #36	; 0x24
 8009f26:	4618      	mov	r0, r3
 8009f28:	f7ff f8aa 	bl	8009080 <mp_mul>
 8009f2c:	9096      	str	r0, [sp, #600]	; 0x258
 8009f2e:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009f30:	2b00      	cmp	r3, #0
 8009f32:	d164      	bne.n	8009ffe <s_mp_exptmod+0x46e>
      if ((err = redux (&res, P, &mu)) != MP_OKAY) {
 8009f34:	aa05      	add	r2, sp, #20
 8009f36:	a901      	add	r1, sp, #4
 8009f38:	a809      	add	r0, sp, #36	; 0x24
 8009f3a:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009f3c:	6809      	ldr	r1, [r1, #0]
 8009f3e:	4798      	blx	r3
 8009f40:	9096      	str	r0, [sp, #600]	; 0x258
 8009f42:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009f44:	2b00      	cmp	r3, #0
 8009f46:	d15a      	bne.n	8009ffe <s_mp_exptmod+0x46e>
      bitcpy = 0;
 8009f48:	2300      	movs	r3, #0
 8009f4a:	9394      	str	r3, [sp, #592]	; 0x250
      bitbuf = 0;
 8009f4c:	2300      	movs	r3, #0
 8009f4e:	9395      	str	r3, [sp, #596]	; 0x254
      mode   = 1;
 8009f50:	2301      	movs	r3, #1
 8009f52:	9392      	str	r3, [sp, #584]	; 0x248
 8009f54:	e76e      	b.n	8009e34 <s_mp_exptmod+0x2a4>
      continue;
 8009f56:	bf00      	nop
 8009f58:	e76c      	b.n	8009e34 <s_mp_exptmod+0x2a4>
 8009f5a:	bf00      	nop
 8009f5c:	0800a091 	.word	0x0800a091
 8009f60:	0800a1d1 	.word	0x0800a1d1
  if (mode == 2 && bitcpy > 0) {
 8009f64:	9b92      	ldr	r3, [sp, #584]	; 0x248
 8009f66:	2b02      	cmp	r3, #2
 8009f68:	d141      	bne.n	8009fee <s_mp_exptmod+0x45e>
 8009f6a:	9b94      	ldr	r3, [sp, #592]	; 0x250
 8009f6c:	2b00      	cmp	r3, #0
 8009f6e:	dd3e      	ble.n	8009fee <s_mp_exptmod+0x45e>
    for (x = 0; x < bitcpy; x++) {
 8009f70:	2300      	movs	r3, #0
 8009f72:	9390      	str	r3, [sp, #576]	; 0x240
 8009f74:	e037      	b.n	8009fe6 <s_mp_exptmod+0x456>
      if ((err = mp_sqr (&res, &res)) != MP_OKAY) {
 8009f76:	aa09      	add	r2, sp, #36	; 0x24
 8009f78:	ab09      	add	r3, sp, #36	; 0x24
 8009f7a:	4611      	mov	r1, r2
 8009f7c:	4618      	mov	r0, r3
 8009f7e:	f7ff f857 	bl	8009030 <mp_sqr>
 8009f82:	9096      	str	r0, [sp, #600]	; 0x258
 8009f84:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009f86:	2b00      	cmp	r3, #0
 8009f88:	d139      	bne.n	8009ffe <s_mp_exptmod+0x46e>
      if ((err = redux (&res, P, &mu)) != MP_OKAY) {
 8009f8a:	aa05      	add	r2, sp, #20
 8009f8c:	a901      	add	r1, sp, #4
 8009f8e:	a809      	add	r0, sp, #36	; 0x24
 8009f90:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009f92:	6809      	ldr	r1, [r1, #0]
 8009f94:	4798      	blx	r3
 8009f96:	9096      	str	r0, [sp, #600]	; 0x258
 8009f98:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009f9a:	2b00      	cmp	r3, #0
 8009f9c:	d12f      	bne.n	8009ffe <s_mp_exptmod+0x46e>
      bitbuf <<= 1;
 8009f9e:	9b95      	ldr	r3, [sp, #596]	; 0x254
 8009fa0:	005b      	lsls	r3, r3, #1
 8009fa2:	9395      	str	r3, [sp, #596]	; 0x254
      if ((bitbuf & (1 << winsize)) != 0) {
 8009fa4:	9a95      	ldr	r2, [sp, #596]	; 0x254
 8009fa6:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 8009fa8:	fa42 f303 	asr.w	r3, r2, r3
 8009fac:	f003 0301 	and.w	r3, r3, #1
 8009fb0:	2b00      	cmp	r3, #0
 8009fb2:	d015      	beq.n	8009fe0 <s_mp_exptmod+0x450>
        if ((err = mp_mul (&res, &M[1], &res)) != MP_OKAY) {
 8009fb4:	aa09      	add	r2, sp, #36	; 0x24
 8009fb6:	ab0d      	add	r3, sp, #52	; 0x34
 8009fb8:	f103 0110 	add.w	r1, r3, #16
 8009fbc:	ab09      	add	r3, sp, #36	; 0x24
 8009fbe:	4618      	mov	r0, r3
 8009fc0:	f7ff f85e 	bl	8009080 <mp_mul>
 8009fc4:	9096      	str	r0, [sp, #600]	; 0x258
 8009fc6:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009fc8:	2b00      	cmp	r3, #0
 8009fca:	d118      	bne.n	8009ffe <s_mp_exptmod+0x46e>
        if ((err = redux (&res, P, &mu)) != MP_OKAY) {
 8009fcc:	aa05      	add	r2, sp, #20
 8009fce:	a901      	add	r1, sp, #4
 8009fd0:	a809      	add	r0, sp, #36	; 0x24
 8009fd2:	9b8d      	ldr	r3, [sp, #564]	; 0x234
 8009fd4:	6809      	ldr	r1, [r1, #0]
 8009fd6:	4798      	blx	r3
 8009fd8:	9096      	str	r0, [sp, #600]	; 0x258
 8009fda:	9b96      	ldr	r3, [sp, #600]	; 0x258
 8009fdc:	2b00      	cmp	r3, #0
 8009fde:	d10e      	bne.n	8009ffe <s_mp_exptmod+0x46e>
    for (x = 0; x < bitcpy; x++) {
 8009fe0:	9b90      	ldr	r3, [sp, #576]	; 0x240
 8009fe2:	3301      	adds	r3, #1
 8009fe4:	9390      	str	r3, [sp, #576]	; 0x240
 8009fe6:	9a90      	ldr	r2, [sp, #576]	; 0x240
 8009fe8:	9b94      	ldr	r3, [sp, #592]	; 0x250
 8009fea:	429a      	cmp	r2, r3
 8009fec:	dbc3      	blt.n	8009f76 <s_mp_exptmod+0x3e6>
  mp_exch (&res, Y);
 8009fee:	466b      	mov	r3, sp
 8009ff0:	aa09      	add	r2, sp, #36	; 0x24
 8009ff2:	6819      	ldr	r1, [r3, #0]
 8009ff4:	4610      	mov	r0, r2
 8009ff6:	f000 fe03 	bl	800ac00 <mp_exch>
  err = MP_OKAY;
 8009ffa:	2300      	movs	r3, #0
 8009ffc:	9396      	str	r3, [sp, #600]	; 0x258
LBL_RES:mp_clear (&res);
 8009ffe:	ab09      	add	r3, sp, #36	; 0x24
 800a000:	4618      	mov	r0, r3
 800a002:	f000 fb15 	bl	800a630 <mp_clear>
LBL_MU:mp_clear (&mu);
 800a006:	ab05      	add	r3, sp, #20
 800a008:	4618      	mov	r0, r3
 800a00a:	f000 fb11 	bl	800a630 <mp_clear>
  mp_clear(&M[1]);
 800a00e:	ab0d      	add	r3, sp, #52	; 0x34
 800a010:	3310      	adds	r3, #16
 800a012:	4618      	mov	r0, r3
 800a014:	f000 fb0c 	bl	800a630 <mp_clear>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 800a018:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 800a01a:	3b01      	subs	r3, #1
 800a01c:	2201      	movs	r2, #1
 800a01e:	fa02 f303 	lsl.w	r3, r2, r3
 800a022:	9390      	str	r3, [sp, #576]	; 0x240
 800a024:	e009      	b.n	800a03a <s_mp_exptmod+0x4aa>
    mp_clear (&M[x]);
 800a026:	aa0d      	add	r2, sp, #52	; 0x34
 800a028:	9b90      	ldr	r3, [sp, #576]	; 0x240
 800a02a:	011b      	lsls	r3, r3, #4
 800a02c:	4413      	add	r3, r2
 800a02e:	4618      	mov	r0, r3
 800a030:	f000 fafe 	bl	800a630 <mp_clear>
  for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
 800a034:	9b90      	ldr	r3, [sp, #576]	; 0x240
 800a036:	3301      	adds	r3, #1
 800a038:	9390      	str	r3, [sp, #576]	; 0x240
 800a03a:	2201      	movs	r2, #1
 800a03c:	9b8e      	ldr	r3, [sp, #568]	; 0x238
 800a03e:	409a      	lsls	r2, r3
 800a040:	9b90      	ldr	r3, [sp, #576]	; 0x240
 800a042:	429a      	cmp	r2, r3
 800a044:	dcef      	bgt.n	800a026 <s_mp_exptmod+0x496>
  return err;
 800a046:	9b96      	ldr	r3, [sp, #600]	; 0x258
}
 800a048:	4618      	mov	r0, r3
 800a04a:	f50d 7d18 	add.w	sp, sp, #608	; 0x260
 800a04e:	bd10      	pop	{r4, pc}

0800a050 <mp_reduce_setup>:
{
 800a050:	b500      	push	{lr}
 800a052:	b085      	sub	sp, #20
 800a054:	9001      	str	r0, [sp, #4]
 800a056:	9100      	str	r1, [sp, #0]
  if ((res = mp_2expt (a, b->used * 2 * DIGIT_BIT)) != MP_OKAY) {
 800a058:	9b00      	ldr	r3, [sp, #0]
 800a05a:	681a      	ldr	r2, [r3, #0]
 800a05c:	4613      	mov	r3, r2
 800a05e:	00db      	lsls	r3, r3, #3
 800a060:	1a9b      	subs	r3, r3, r2
 800a062:	00db      	lsls	r3, r3, #3
 800a064:	4619      	mov	r1, r3
 800a066:	9801      	ldr	r0, [sp, #4]
 800a068:	f7fe ff22 	bl	8008eb0 <mp_2expt>
 800a06c:	9003      	str	r0, [sp, #12]
 800a06e:	9b03      	ldr	r3, [sp, #12]
 800a070:	2b00      	cmp	r3, #0
 800a072:	d001      	beq.n	800a078 <mp_reduce_setup+0x28>
    return res;
 800a074:	9b03      	ldr	r3, [sp, #12]
 800a076:	e006      	b.n	800a086 <mp_reduce_setup+0x36>
  return mp_div (a, b, a, NULL);
 800a078:	2300      	movs	r3, #0
 800a07a:	9a01      	ldr	r2, [sp, #4]
 800a07c:	9900      	ldr	r1, [sp, #0]
 800a07e:	9801      	ldr	r0, [sp, #4]
 800a080:	f001 fdf6 	bl	800bc70 <mp_div>
 800a084:	4603      	mov	r3, r0
}
 800a086:	4618      	mov	r0, r3
 800a088:	b005      	add	sp, #20
 800a08a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a08e:	bf00      	nop

0800a090 <mp_reduce>:
{
 800a090:	b500      	push	{lr}
 800a092:	b08b      	sub	sp, #44	; 0x2c
 800a094:	9003      	str	r0, [sp, #12]
 800a096:	9102      	str	r1, [sp, #8]
 800a098:	9201      	str	r2, [sp, #4]
  int     res, um = m->used;
 800a09a:	9b02      	ldr	r3, [sp, #8]
 800a09c:	681b      	ldr	r3, [r3, #0]
 800a09e:	9308      	str	r3, [sp, #32]
  if ((res = mp_init_copy (&q, x)) != MP_OKAY) {
 800a0a0:	ab04      	add	r3, sp, #16
 800a0a2:	9903      	ldr	r1, [sp, #12]
 800a0a4:	4618      	mov	r0, r3
 800a0a6:	f000 fc1b 	bl	800a8e0 <mp_init_copy>
 800a0aa:	9009      	str	r0, [sp, #36]	; 0x24
 800a0ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a0ae:	2b00      	cmp	r3, #0
 800a0b0:	d001      	beq.n	800a0b6 <mp_reduce+0x26>
    return res;
 800a0b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a0b4:	e087      	b.n	800a1c6 <mp_reduce+0x136>
  mp_rshd (&q, um - 1);
 800a0b6:	9b08      	ldr	r3, [sp, #32]
 800a0b8:	1e5a      	subs	r2, r3, #1
 800a0ba:	ab04      	add	r3, sp, #16
 800a0bc:	4611      	mov	r1, r2
 800a0be:	4618      	mov	r0, r3
 800a0c0:	f000 fe06 	bl	800acd0 <mp_rshd>
  if (((mp_word) um) > (((mp_digit)1) << (DIGIT_BIT - 1))) {
 800a0c4:	9b08      	ldr	r3, [sp, #32]
 800a0c6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800a0ca:	d90a      	bls.n	800a0e2 <mp_reduce+0x52>
    if ((res = mp_mul (&q, mu, &q)) != MP_OKAY) {
 800a0cc:	aa04      	add	r2, sp, #16
 800a0ce:	ab04      	add	r3, sp, #16
 800a0d0:	9901      	ldr	r1, [sp, #4]
 800a0d2:	4618      	mov	r0, r3
 800a0d4:	f7fe ffd4 	bl	8009080 <mp_mul>
 800a0d8:	9009      	str	r0, [sp, #36]	; 0x24
 800a0da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a0dc:	2b00      	cmp	r3, #0
 800a0de:	d16d      	bne.n	800a1bc <mp_reduce+0x12c>
 800a0e0:	e009      	b.n	800a0f6 <mp_reduce+0x66>
    if ((res = s_mp_mul_high_digs (&q, mu, &q, um)) != MP_OKAY) {
 800a0e2:	aa04      	add	r2, sp, #16
 800a0e4:	a804      	add	r0, sp, #16
 800a0e6:	9b08      	ldr	r3, [sp, #32]
 800a0e8:	9901      	ldr	r1, [sp, #4]
 800a0ea:	f000 f8f1 	bl	800a2d0 <s_mp_mul_high_digs>
 800a0ee:	9009      	str	r0, [sp, #36]	; 0x24
 800a0f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a0f2:	2b00      	cmp	r3, #0
 800a0f4:	d162      	bne.n	800a1bc <mp_reduce+0x12c>
  mp_rshd (&q, um + 1);
 800a0f6:	9b08      	ldr	r3, [sp, #32]
 800a0f8:	1c5a      	adds	r2, r3, #1
 800a0fa:	ab04      	add	r3, sp, #16
 800a0fc:	4611      	mov	r1, r2
 800a0fe:	4618      	mov	r0, r3
 800a100:	f000 fde6 	bl	800acd0 <mp_rshd>
  if ((res = mp_mod_2d (x, DIGIT_BIT * (um + 1), x)) != MP_OKAY) {
 800a104:	9b08      	ldr	r3, [sp, #32]
 800a106:	1c5a      	adds	r2, r3, #1
 800a108:	4613      	mov	r3, r2
 800a10a:	00db      	lsls	r3, r3, #3
 800a10c:	1a9b      	subs	r3, r3, r2
 800a10e:	009b      	lsls	r3, r3, #2
 800a110:	9a03      	ldr	r2, [sp, #12]
 800a112:	4619      	mov	r1, r3
 800a114:	9803      	ldr	r0, [sp, #12]
 800a116:	f000 fe23 	bl	800ad60 <mp_mod_2d>
 800a11a:	9009      	str	r0, [sp, #36]	; 0x24
 800a11c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a11e:	2b00      	cmp	r3, #0
 800a120:	d14c      	bne.n	800a1bc <mp_reduce+0x12c>
  if ((res = s_mp_mul_digs (&q, m, &q, um + 1)) != MP_OKAY) {
 800a122:	9b08      	ldr	r3, [sp, #32]
 800a124:	3301      	adds	r3, #1
 800a126:	aa04      	add	r2, sp, #16
 800a128:	a804      	add	r0, sp, #16
 800a12a:	9902      	ldr	r1, [sp, #8]
 800a12c:	f7ff fc20 	bl	8009970 <s_mp_mul_digs>
 800a130:	9009      	str	r0, [sp, #36]	; 0x24
 800a132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a134:	2b00      	cmp	r3, #0
 800a136:	d141      	bne.n	800a1bc <mp_reduce+0x12c>
  if ((res = mp_sub (x, &q, x)) != MP_OKAY) {
 800a138:	ab04      	add	r3, sp, #16
 800a13a:	9a03      	ldr	r2, [sp, #12]
 800a13c:	4619      	mov	r1, r3
 800a13e:	9803      	ldr	r0, [sp, #12]
 800a140:	f7fd ff5e 	bl	8008000 <mp_sub>
 800a144:	9009      	str	r0, [sp, #36]	; 0x24
 800a146:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a148:	2b00      	cmp	r3, #0
 800a14a:	d137      	bne.n	800a1bc <mp_reduce+0x12c>
  if (mp_cmp_d (x, 0) == MP_LT) {
 800a14c:	2100      	movs	r1, #0
 800a14e:	9803      	ldr	r0, [sp, #12]
 800a150:	f001 fce6 	bl	800bb20 <mp_cmp_d>
 800a154:	4603      	mov	r3, r0
 800a156:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800a15a:	d127      	bne.n	800a1ac <mp_reduce+0x11c>
    if ((res = mp_set (&q, 1)) != MP_OKAY)
 800a15c:	ab04      	add	r3, sp, #16
 800a15e:	2101      	movs	r1, #1
 800a160:	4618      	mov	r0, r3
 800a162:	f001 fd15 	bl	800bb90 <mp_set>
 800a166:	9009      	str	r0, [sp, #36]	; 0x24
 800a168:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a16a:	2b00      	cmp	r3, #0
 800a16c:	d126      	bne.n	800a1bc <mp_reduce+0x12c>
    if ((res = mp_lshd (&q, um + 1)) != MP_OKAY)
 800a16e:	9b08      	ldr	r3, [sp, #32]
 800a170:	1c5a      	adds	r2, r3, #1
 800a172:	ab04      	add	r3, sp, #16
 800a174:	4611      	mov	r1, r2
 800a176:	4618      	mov	r0, r3
 800a178:	f000 ff62 	bl	800b040 <mp_lshd>
 800a17c:	9009      	str	r0, [sp, #36]	; 0x24
 800a17e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a180:	2b00      	cmp	r3, #0
 800a182:	d11b      	bne.n	800a1bc <mp_reduce+0x12c>
    if ((res = mp_add (x, &q, x)) != MP_OKAY)
 800a184:	ab04      	add	r3, sp, #16
 800a186:	9a03      	ldr	r2, [sp, #12]
 800a188:	4619      	mov	r1, r3
 800a18a:	9803      	ldr	r0, [sp, #12]
 800a18c:	f7fd fdd0 	bl	8007d30 <mp_add>
 800a190:	9009      	str	r0, [sp, #36]	; 0x24
 800a192:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a194:	2b00      	cmp	r3, #0
 800a196:	d111      	bne.n	800a1bc <mp_reduce+0x12c>
 800a198:	e008      	b.n	800a1ac <mp_reduce+0x11c>
    if ((res = s_mp_sub (x, m, x)) != MP_OKAY) {
 800a19a:	9a03      	ldr	r2, [sp, #12]
 800a19c:	9902      	ldr	r1, [sp, #8]
 800a19e:	9803      	ldr	r0, [sp, #12]
 800a1a0:	f7fd fea6 	bl	8007ef0 <s_mp_sub>
 800a1a4:	9009      	str	r0, [sp, #36]	; 0x24
 800a1a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a1a8:	2b00      	cmp	r3, #0
 800a1aa:	d107      	bne.n	800a1bc <mp_reduce+0x12c>
  while (mp_cmp (x, m) != MP_LT) {
 800a1ac:	9902      	ldr	r1, [sp, #8]
 800a1ae:	9803      	ldr	r0, [sp, #12]
 800a1b0:	f001 fc8e 	bl	800bad0 <mp_cmp>
 800a1b4:	4603      	mov	r3, r0
 800a1b6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800a1ba:	d1ee      	bne.n	800a19a <mp_reduce+0x10a>
  mp_clear (&q);
 800a1bc:	ab04      	add	r3, sp, #16
 800a1be:	4618      	mov	r0, r3
 800a1c0:	f000 fa36 	bl	800a630 <mp_clear>
  return res;
 800a1c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800a1c6:	4618      	mov	r0, r3
 800a1c8:	b00b      	add	sp, #44	; 0x2c
 800a1ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800a1ce:	bf00      	nop

0800a1d0 <mp_reduce_2k_l>:
{
 800a1d0:	b500      	push	{lr}
 800a1d2:	b08b      	sub	sp, #44	; 0x2c
 800a1d4:	9003      	str	r0, [sp, #12]
 800a1d6:	9102      	str	r1, [sp, #8]
 800a1d8:	9201      	str	r2, [sp, #4]
   if ((res = mp_init(&q)) != MP_OKAY) {
 800a1da:	ab04      	add	r3, sp, #16
 800a1dc:	4618      	mov	r0, r3
 800a1de:	f000 fa0f 	bl	800a600 <mp_init>
 800a1e2:	9009      	str	r0, [sp, #36]	; 0x24
 800a1e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a1e6:	2b00      	cmp	r3, #0
 800a1e8:	d001      	beq.n	800a1ee <mp_reduce_2k_l+0x1e>
      return res;
 800a1ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a1ec:	e037      	b.n	800a25e <mp_reduce_2k_l+0x8e>
   p = mp_count_bits(n);
 800a1ee:	9802      	ldr	r0, [sp, #8]
 800a1f0:	f000 fab6 	bl	800a760 <mp_count_bits>
 800a1f4:	9008      	str	r0, [sp, #32]
   if ((res = mp_div_2d(a, p, &q, a)) != MP_OKAY) {
 800a1f6:	aa04      	add	r2, sp, #16
 800a1f8:	9b03      	ldr	r3, [sp, #12]
 800a1fa:	9908      	ldr	r1, [sp, #32]
 800a1fc:	9803      	ldr	r0, [sp, #12]
 800a1fe:	f000 fc37 	bl	800aa70 <mp_div_2d>
 800a202:	9009      	str	r0, [sp, #36]	; 0x24
 800a204:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a206:	2b00      	cmp	r3, #0
 800a208:	d124      	bne.n	800a254 <mp_reduce_2k_l+0x84>
   if ((res = mp_mul(&q, d, &q)) != MP_OKAY) {
 800a20a:	aa04      	add	r2, sp, #16
 800a20c:	ab04      	add	r3, sp, #16
 800a20e:	9901      	ldr	r1, [sp, #4]
 800a210:	4618      	mov	r0, r3
 800a212:	f7fe ff35 	bl	8009080 <mp_mul>
 800a216:	9009      	str	r0, [sp, #36]	; 0x24
 800a218:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a21a:	2b00      	cmp	r3, #0
 800a21c:	d11a      	bne.n	800a254 <mp_reduce_2k_l+0x84>
   if ((res = s_mp_add(a, &q, a)) != MP_OKAY) {
 800a21e:	ab04      	add	r3, sp, #16
 800a220:	9a03      	ldr	r2, [sp, #12]
 800a222:	4619      	mov	r1, r3
 800a224:	9803      	ldr	r0, [sp, #12]
 800a226:	f7fd fdc3 	bl	8007db0 <s_mp_add>
 800a22a:	9009      	str	r0, [sp, #36]	; 0x24
 800a22c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a22e:	2b00      	cmp	r3, #0
 800a230:	d110      	bne.n	800a254 <mp_reduce_2k_l+0x84>
   if (mp_cmp_mag(a, n) != MP_LT) {
 800a232:	9902      	ldr	r1, [sp, #8]
 800a234:	9803      	ldr	r0, [sp, #12]
 800a236:	f001 fbfb 	bl	800ba30 <mp_cmp_mag>
 800a23a:	4603      	mov	r3, r0
 800a23c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800a240:	d008      	beq.n	800a254 <mp_reduce_2k_l+0x84>
      if ((res = s_mp_sub(a, n, a)) != MP_OKAY) {
 800a242:	9a03      	ldr	r2, [sp, #12]
 800a244:	9902      	ldr	r1, [sp, #8]
 800a246:	9803      	ldr	r0, [sp, #12]
 800a248:	f7fd fe52 	bl	8007ef0 <s_mp_sub>
 800a24c:	9009      	str	r0, [sp, #36]	; 0x24
 800a24e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a250:	2b00      	cmp	r3, #0
 800a252:	d0d0      	beq.n	800a1f6 <mp_reduce_2k_l+0x26>
   mp_clear(&q);
 800a254:	ab04      	add	r3, sp, #16
 800a256:	4618      	mov	r0, r3
 800a258:	f000 f9ea 	bl	800a630 <mp_clear>
   return res;
 800a25c:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800a25e:	4618      	mov	r0, r3
 800a260:	b00b      	add	sp, #44	; 0x2c
 800a262:	f85d fb04 	ldr.w	pc, [sp], #4
 800a266:	bf00      	nop
	...

0800a270 <mp_reduce_2k_setup_l>:
{
 800a270:	b500      	push	{lr}
 800a272:	b089      	sub	sp, #36	; 0x24
 800a274:	9001      	str	r0, [sp, #4]
 800a276:	9100      	str	r1, [sp, #0]
   if ((res = mp_init(&tmp)) != MP_OKAY) {
 800a278:	ab03      	add	r3, sp, #12
 800a27a:	4618      	mov	r0, r3
 800a27c:	f000 f9c0 	bl	800a600 <mp_init>
 800a280:	9007      	str	r0, [sp, #28]
 800a282:	9b07      	ldr	r3, [sp, #28]
 800a284:	2b00      	cmp	r3, #0
 800a286:	d001      	beq.n	800a28c <mp_reduce_2k_setup_l+0x1c>
      return res;
 800a288:	9b07      	ldr	r3, [sp, #28]
 800a28a:	e018      	b.n	800a2be <mp_reduce_2k_setup_l+0x4e>
   if ((res = mp_2expt(&tmp, mp_count_bits(a))) != MP_OKAY) {
 800a28c:	9801      	ldr	r0, [sp, #4]
 800a28e:	f000 fa67 	bl	800a760 <mp_count_bits>
 800a292:	4602      	mov	r2, r0
 800a294:	ab03      	add	r3, sp, #12
 800a296:	4611      	mov	r1, r2
 800a298:	4618      	mov	r0, r3
 800a29a:	f7fe fe09 	bl	8008eb0 <mp_2expt>
 800a29e:	9007      	str	r0, [sp, #28]
 800a2a0:	9b07      	ldr	r3, [sp, #28]
 800a2a2:	2b00      	cmp	r3, #0
 800a2a4:	d106      	bne.n	800a2b4 <mp_reduce_2k_setup_l+0x44>
   if ((res = s_mp_sub(&tmp, a, d)) != MP_OKAY) {
 800a2a6:	ab03      	add	r3, sp, #12
 800a2a8:	9a00      	ldr	r2, [sp, #0]
 800a2aa:	9901      	ldr	r1, [sp, #4]
 800a2ac:	4618      	mov	r0, r3
 800a2ae:	f7fd fe1f 	bl	8007ef0 <s_mp_sub>
 800a2b2:	9007      	str	r0, [sp, #28]
   mp_clear(&tmp);
 800a2b4:	ab03      	add	r3, sp, #12
 800a2b6:	4618      	mov	r0, r3
 800a2b8:	f000 f9ba 	bl	800a630 <mp_clear>
   return res;
 800a2bc:	9b07      	ldr	r3, [sp, #28]
}
 800a2be:	4618      	mov	r0, r3
 800a2c0:	b009      	add	sp, #36	; 0x24
 800a2c2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2c6:	bf00      	nop
	...

0800a2d0 <s_mp_mul_high_digs>:
{
 800a2d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a2d2:	b095      	sub	sp, #84	; 0x54
 800a2d4:	9003      	str	r0, [sp, #12]
 800a2d6:	9102      	str	r1, [sp, #8]
 800a2d8:	9201      	str	r2, [sp, #4]
 800a2da:	9300      	str	r3, [sp, #0]
  if (((a->used + b->used + 1) < MP_WARRAY)
 800a2dc:	9b03      	ldr	r3, [sp, #12]
 800a2de:	681a      	ldr	r2, [r3, #0]
 800a2e0:	9b02      	ldr	r3, [sp, #8]
 800a2e2:	681b      	ldr	r3, [r3, #0]
 800a2e4:	4413      	add	r3, r2
 800a2e6:	3301      	adds	r3, #1
 800a2e8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a2ec:	da10      	bge.n	800a310 <s_mp_mul_high_digs+0x40>
      && MIN (a->used, b->used) <
 800a2ee:	9b02      	ldr	r3, [sp, #8]
 800a2f0:	681a      	ldr	r2, [r3, #0]
 800a2f2:	9b03      	ldr	r3, [sp, #12]
 800a2f4:	681b      	ldr	r3, [r3, #0]
 800a2f6:	4293      	cmp	r3, r2
 800a2f8:	bfa8      	it	ge
 800a2fa:	4613      	movge	r3, r2
 800a2fc:	2bff      	cmp	r3, #255	; 0xff
 800a2fe:	dc07      	bgt.n	800a310 <s_mp_mul_high_digs+0x40>
    return fast_s_mp_mul_high_digs (a, b, c, digs);
 800a300:	9b00      	ldr	r3, [sp, #0]
 800a302:	9a01      	ldr	r2, [sp, #4]
 800a304:	9902      	ldr	r1, [sp, #8]
 800a306:	9803      	ldr	r0, [sp, #12]
 800a308:	f000 f89a 	bl	800a440 <fast_s_mp_mul_high_digs>
 800a30c:	4603      	mov	r3, r0
 800a30e:	e093      	b.n	800a438 <s_mp_mul_high_digs+0x168>
  if ((res = mp_init_size (&t, a->used + b->used + 1)) != MP_OKAY) {
 800a310:	9b03      	ldr	r3, [sp, #12]
 800a312:	681a      	ldr	r2, [r3, #0]
 800a314:	9b02      	ldr	r3, [sp, #8]
 800a316:	681b      	ldr	r3, [r3, #0]
 800a318:	4413      	add	r3, r2
 800a31a:	1c5a      	adds	r2, r3, #1
 800a31c:	ab04      	add	r3, sp, #16
 800a31e:	4611      	mov	r1, r2
 800a320:	4618      	mov	r0, r3
 800a322:	f7ff f815 	bl	8009350 <mp_init_size>
 800a326:	900e      	str	r0, [sp, #56]	; 0x38
 800a328:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d001      	beq.n	800a332 <s_mp_mul_high_digs+0x62>
    return res;
 800a32e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a330:	e082      	b.n	800a438 <s_mp_mul_high_digs+0x168>
  t.used = a->used + b->used + 1;
 800a332:	9b03      	ldr	r3, [sp, #12]
 800a334:	681a      	ldr	r2, [r3, #0]
 800a336:	9b02      	ldr	r3, [sp, #8]
 800a338:	681b      	ldr	r3, [r3, #0]
 800a33a:	4413      	add	r3, r2
 800a33c:	3301      	adds	r3, #1
 800a33e:	9304      	str	r3, [sp, #16]
  pa = a->used;
 800a340:	9b03      	ldr	r3, [sp, #12]
 800a342:	681b      	ldr	r3, [r3, #0]
 800a344:	930d      	str	r3, [sp, #52]	; 0x34
  pb = b->used;
 800a346:	9b02      	ldr	r3, [sp, #8]
 800a348:	681b      	ldr	r3, [r3, #0]
 800a34a:	930c      	str	r3, [sp, #48]	; 0x30
  for (ix = 0; ix < pa && a->dp; ix++) {
 800a34c:	2300      	movs	r3, #0
 800a34e:	9313      	str	r3, [sp, #76]	; 0x4c
 800a350:	e05c      	b.n	800a40c <s_mp_mul_high_digs+0x13c>
    u = 0;
 800a352:	2300      	movs	r3, #0
 800a354:	9311      	str	r3, [sp, #68]	; 0x44
    tmpx = a->dp[ix];
 800a356:	9b03      	ldr	r3, [sp, #12]
 800a358:	68da      	ldr	r2, [r3, #12]
 800a35a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a35c:	009b      	lsls	r3, r3, #2
 800a35e:	4413      	add	r3, r2
 800a360:	681b      	ldr	r3, [r3, #0]
 800a362:	930b      	str	r3, [sp, #44]	; 0x2c
    tmpt = &(t.dp[digs]);
 800a364:	9a07      	ldr	r2, [sp, #28]
 800a366:	9b00      	ldr	r3, [sp, #0]
 800a368:	009b      	lsls	r3, r3, #2
 800a36a:	4413      	add	r3, r2
 800a36c:	9310      	str	r3, [sp, #64]	; 0x40
    tmpy = b->dp + (digs - ix);
 800a36e:	9b02      	ldr	r3, [sp, #8]
 800a370:	68da      	ldr	r2, [r3, #12]
 800a372:	9900      	ldr	r1, [sp, #0]
 800a374:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a376:	1acb      	subs	r3, r1, r3
 800a378:	009b      	lsls	r3, r3, #2
 800a37a:	4413      	add	r3, r2
 800a37c:	930f      	str	r3, [sp, #60]	; 0x3c
    for (iy = digs - ix; iy < pb; iy++) {
 800a37e:	9a00      	ldr	r2, [sp, #0]
 800a380:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a382:	1ad3      	subs	r3, r2, r3
 800a384:	9312      	str	r3, [sp, #72]	; 0x48
 800a386:	e037      	b.n	800a3f8 <s_mp_mul_high_digs+0x128>
      r       = ((mp_word)*tmpt) +
 800a388:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a38a:	681b      	ldr	r3, [r3, #0]
 800a38c:	461e      	mov	r6, r3
 800a38e:	f04f 0700 	mov.w	r7, #0
                ((mp_word)tmpx) * ((mp_word)*tmpy++) +
 800a392:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a394:	4618      	mov	r0, r3
 800a396:	f04f 0100 	mov.w	r1, #0
 800a39a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a39c:	1d1a      	adds	r2, r3, #4
 800a39e:	920f      	str	r2, [sp, #60]	; 0x3c
 800a3a0:	681b      	ldr	r3, [r3, #0]
 800a3a2:	461a      	mov	r2, r3
 800a3a4:	f04f 0300 	mov.w	r3, #0
 800a3a8:	fb02 fc01 	mul.w	ip, r2, r1
 800a3ac:	fb00 fe03 	mul.w	lr, r0, r3
 800a3b0:	44e6      	add	lr, ip
 800a3b2:	fba0 2302 	umull	r2, r3, r0, r2
 800a3b6:	eb0e 0103 	add.w	r1, lr, r3
 800a3ba:	460b      	mov	r3, r1
      r       = ((mp_word)*tmpt) +
 800a3bc:	18b0      	adds	r0, r6, r2
 800a3be:	eb47 0103 	adc.w	r1, r7, r3
                ((mp_word) u);
 800a3c2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a3c4:	461a      	mov	r2, r3
 800a3c6:	f04f 0300 	mov.w	r3, #0
      r       = ((mp_word)*tmpt) +
 800a3ca:	1812      	adds	r2, r2, r0
 800a3cc:	eb43 0301 	adc.w	r3, r3, r1
 800a3d0:	e9cd 2308 	strd	r2, r3, [sp, #32]
      *tmpt++ = (mp_digit) (r & ((mp_word) MP_MASK));
 800a3d4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a3d6:	1d1a      	adds	r2, r3, #4
 800a3d8:	9210      	str	r2, [sp, #64]	; 0x40
 800a3da:	9a08      	ldr	r2, [sp, #32]
 800a3dc:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800a3e0:	601a      	str	r2, [r3, #0]
      u       = (mp_digit) (r >> ((mp_word) DIGIT_BIT));
 800a3e2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800a3e6:	0f14      	lsrs	r4, r2, #28
 800a3e8:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 800a3ec:	0f1d      	lsrs	r5, r3, #28
 800a3ee:	4623      	mov	r3, r4
 800a3f0:	9311      	str	r3, [sp, #68]	; 0x44
    for (iy = digs - ix; iy < pb; iy++) {
 800a3f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800a3f4:	3301      	adds	r3, #1
 800a3f6:	9312      	str	r3, [sp, #72]	; 0x48
 800a3f8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800a3fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a3fc:	429a      	cmp	r2, r3
 800a3fe:	dbc3      	blt.n	800a388 <s_mp_mul_high_digs+0xb8>
    *tmpt = u;
 800a400:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a402:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a404:	601a      	str	r2, [r3, #0]
  for (ix = 0; ix < pa && a->dp; ix++) {
 800a406:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a408:	3301      	adds	r3, #1
 800a40a:	9313      	str	r3, [sp, #76]	; 0x4c
 800a40c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800a40e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800a410:	429a      	cmp	r2, r3
 800a412:	da03      	bge.n	800a41c <s_mp_mul_high_digs+0x14c>
 800a414:	9b03      	ldr	r3, [sp, #12]
 800a416:	68db      	ldr	r3, [r3, #12]
 800a418:	2b00      	cmp	r3, #0
 800a41a:	d19a      	bne.n	800a352 <s_mp_mul_high_digs+0x82>
  mp_clamp (&t);
 800a41c:	ab04      	add	r3, sp, #16
 800a41e:	4618      	mov	r0, r3
 800a420:	f000 fbc6 	bl	800abb0 <mp_clamp>
  mp_exch (&t, c);
 800a424:	ab04      	add	r3, sp, #16
 800a426:	9901      	ldr	r1, [sp, #4]
 800a428:	4618      	mov	r0, r3
 800a42a:	f000 fbe9 	bl	800ac00 <mp_exch>
  mp_clear (&t);
 800a42e:	ab04      	add	r3, sp, #16
 800a430:	4618      	mov	r0, r3
 800a432:	f000 f8fd 	bl	800a630 <mp_clear>
  return MP_OKAY;
 800a436:	2300      	movs	r3, #0
}
 800a438:	4618      	mov	r0, r3
 800a43a:	b015      	add	sp, #84	; 0x54
 800a43c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a43e:	bf00      	nop

0800a440 <fast_s_mp_mul_high_digs>:
{
 800a440:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a442:	b093      	sub	sp, #76	; 0x4c
 800a444:	9003      	str	r0, [sp, #12]
 800a446:	9102      	str	r1, [sp, #8]
 800a448:	9201      	str	r2, [sp, #4]
 800a44a:	9300      	str	r3, [sp, #0]
  if (a->dp == NULL) { /* JRB, avoid reading uninitialized values */
 800a44c:	9b03      	ldr	r3, [sp, #12]
 800a44e:	68db      	ldr	r3, [r3, #12]
 800a450:	2b00      	cmp	r3, #0
 800a452:	d102      	bne.n	800a45a <fast_s_mp_mul_high_digs+0x1a>
      return MP_VAL;
 800a454:	f06f 0302 	mvn.w	r3, #2
 800a458:	e0ca      	b.n	800a5f0 <fast_s_mp_mul_high_digs+0x1b0>
  pa = a->used + b->used;
 800a45a:	9b03      	ldr	r3, [sp, #12]
 800a45c:	681a      	ldr	r2, [r3, #0]
 800a45e:	9b02      	ldr	r3, [sp, #8]
 800a460:	681b      	ldr	r3, [r3, #0]
 800a462:	4413      	add	r3, r2
 800a464:	930a      	str	r3, [sp, #40]	; 0x28
  if (c->alloc < pa) {
 800a466:	9b01      	ldr	r3, [sp, #4]
 800a468:	685a      	ldr	r2, [r3, #4]
 800a46a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a46c:	429a      	cmp	r2, r3
 800a46e:	da09      	bge.n	800a484 <fast_s_mp_mul_high_digs+0x44>
    if ((res = mp_grow (c, pa)) != MP_OKAY) {
 800a470:	990a      	ldr	r1, [sp, #40]	; 0x28
 800a472:	9801      	ldr	r0, [sp, #4]
 800a474:	f000 fabc 	bl	800a9f0 <mp_grow>
 800a478:	9009      	str	r0, [sp, #36]	; 0x24
 800a47a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a47c:	2b00      	cmp	r3, #0
 800a47e:	d001      	beq.n	800a484 <fast_s_mp_mul_high_digs+0x44>
      return res;
 800a480:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a482:	e0b5      	b.n	800a5f0 <fast_s_mp_mul_high_digs+0x1b0>
  if (pa > MP_WARRAY)
 800a484:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a486:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a48a:	dd02      	ble.n	800a492 <fast_s_mp_mul_high_digs+0x52>
    return MP_RANGE;  /* TAO range check */
 800a48c:	f06f 0303 	mvn.w	r3, #3
 800a490:	e0ae      	b.n	800a5f0 <fast_s_mp_mul_high_digs+0x1b0>
  W = (mp_digit*)XMALLOC(sizeof(mp_digit) * MP_WARRAY, NULL, DYNAMIC_TYPE_BIGINT);
 800a492:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a496:	2000      	movs	r0, #0
 800a498:	f7fb f9e2 	bl	8005860 <chibios_alloc>
 800a49c:	9008      	str	r0, [sp, #32]
  if (W == NULL)
 800a49e:	9b08      	ldr	r3, [sp, #32]
 800a4a0:	2b00      	cmp	r3, #0
 800a4a2:	d102      	bne.n	800a4aa <fast_s_mp_mul_high_digs+0x6a>
    return MP_MEM;
 800a4a4:	f06f 0301 	mvn.w	r3, #1
 800a4a8:	e0a2      	b.n	800a5f0 <fast_s_mp_mul_high_digs+0x1b0>
  pa = a->used + b->used;
 800a4aa:	9b03      	ldr	r3, [sp, #12]
 800a4ac:	681a      	ldr	r2, [r3, #0]
 800a4ae:	9b02      	ldr	r3, [sp, #8]
 800a4b0:	681b      	ldr	r3, [r3, #0]
 800a4b2:	4413      	add	r3, r2
 800a4b4:	930a      	str	r3, [sp, #40]	; 0x28
  _W = 0;
 800a4b6:	f04f 0200 	mov.w	r2, #0
 800a4ba:	f04f 0300 	mov.w	r3, #0
 800a4be:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  for (ix = digs; ix < pa; ix++) { /* JRB, have a->dp check at top of function*/
 800a4c2:	9b00      	ldr	r3, [sp, #0]
 800a4c4:	9311      	str	r3, [sp, #68]	; 0x44
 800a4c6:	e05c      	b.n	800a582 <fast_s_mp_mul_high_digs+0x142>
      ty = MIN(b->used-1, ix);
 800a4c8:	9b02      	ldr	r3, [sp, #8]
 800a4ca:	681b      	ldr	r3, [r3, #0]
 800a4cc:	1e5a      	subs	r2, r3, #1
 800a4ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a4d0:	4293      	cmp	r3, r2
 800a4d2:	bfa8      	it	ge
 800a4d4:	4613      	movge	r3, r2
 800a4d6:	9307      	str	r3, [sp, #28]
      tx = ix - ty;
 800a4d8:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a4da:	9b07      	ldr	r3, [sp, #28]
 800a4dc:	1ad3      	subs	r3, r2, r3
 800a4de:	9306      	str	r3, [sp, #24]
      tmpx = a->dp + tx;
 800a4e0:	9b03      	ldr	r3, [sp, #12]
 800a4e2:	68da      	ldr	r2, [r3, #12]
 800a4e4:	9b06      	ldr	r3, [sp, #24]
 800a4e6:	009b      	lsls	r3, r3, #2
 800a4e8:	4413      	add	r3, r2
 800a4ea:	930d      	str	r3, [sp, #52]	; 0x34
      tmpy = b->dp + ty;
 800a4ec:	9b02      	ldr	r3, [sp, #8]
 800a4ee:	68da      	ldr	r2, [r3, #12]
 800a4f0:	9b07      	ldr	r3, [sp, #28]
 800a4f2:	009b      	lsls	r3, r3, #2
 800a4f4:	4413      	add	r3, r2
 800a4f6:	930c      	str	r3, [sp, #48]	; 0x30
      iy = MIN(a->used-tx, ty+1);
 800a4f8:	9b07      	ldr	r3, [sp, #28]
 800a4fa:	1c5a      	adds	r2, r3, #1
 800a4fc:	9b03      	ldr	r3, [sp, #12]
 800a4fe:	6819      	ldr	r1, [r3, #0]
 800a500:	9b06      	ldr	r3, [sp, #24]
 800a502:	1acb      	subs	r3, r1, r3
 800a504:	4293      	cmp	r3, r2
 800a506:	bfa8      	it	ge
 800a508:	4613      	movge	r3, r2
 800a50a:	9305      	str	r3, [sp, #20]
      for (iz = 0; iz < iy; iz++) {
 800a50c:	2300      	movs	r3, #0
 800a50e:	9310      	str	r3, [sp, #64]	; 0x40
 800a510:	e020      	b.n	800a554 <fast_s_mp_mul_high_digs+0x114>
         _W += ((mp_word)*tmpx++)*((mp_word)*tmpy--);
 800a512:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800a514:	1d1a      	adds	r2, r3, #4
 800a516:	920d      	str	r2, [sp, #52]	; 0x34
 800a518:	681b      	ldr	r3, [r3, #0]
 800a51a:	4618      	mov	r0, r3
 800a51c:	f04f 0100 	mov.w	r1, #0
 800a520:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a522:	1f1a      	subs	r2, r3, #4
 800a524:	920c      	str	r2, [sp, #48]	; 0x30
 800a526:	681b      	ldr	r3, [r3, #0]
 800a528:	461a      	mov	r2, r3
 800a52a:	f04f 0300 	mov.w	r3, #0
 800a52e:	fb02 f701 	mul.w	r7, r2, r1
 800a532:	fb00 f603 	mul.w	r6, r0, r3
 800a536:	443e      	add	r6, r7
 800a538:	fba0 2302 	umull	r2, r3, r0, r2
 800a53c:	18f1      	adds	r1, r6, r3
 800a53e:	460b      	mov	r3, r1
 800a540:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 800a544:	1812      	adds	r2, r2, r0
 800a546:	eb43 0301 	adc.w	r3, r3, r1
 800a54a:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
      for (iz = 0; iz < iy; iz++) {
 800a54e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800a550:	3301      	adds	r3, #1
 800a552:	9310      	str	r3, [sp, #64]	; 0x40
 800a554:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800a556:	9b05      	ldr	r3, [sp, #20]
 800a558:	429a      	cmp	r2, r3
 800a55a:	dbda      	blt.n	800a512 <fast_s_mp_mul_high_digs+0xd2>
      W[ix] = (mp_digit)(((mp_digit)_W) & MP_MASK);
 800a55c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a55e:	009b      	lsls	r3, r3, #2
 800a560:	9a08      	ldr	r2, [sp, #32]
 800a562:	4413      	add	r3, r2
 800a564:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800a566:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800a56a:	601a      	str	r2, [r3, #0]
      _W = _W >> ((mp_word)DIGIT_BIT);
 800a56c:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 800a570:	0f14      	lsrs	r4, r2, #28
 800a572:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 800a576:	0f1d      	lsrs	r5, r3, #28
 800a578:	e9cd 450e 	strd	r4, r5, [sp, #56]	; 0x38
  for (ix = digs; ix < pa; ix++) { /* JRB, have a->dp check at top of function*/
 800a57c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a57e:	3301      	adds	r3, #1
 800a580:	9311      	str	r3, [sp, #68]	; 0x44
 800a582:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a584:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a586:	429a      	cmp	r2, r3
 800a588:	db9e      	blt.n	800a4c8 <fast_s_mp_mul_high_digs+0x88>
  olduse  = c->used;
 800a58a:	9b01      	ldr	r3, [sp, #4]
 800a58c:	681b      	ldr	r3, [r3, #0]
 800a58e:	9304      	str	r3, [sp, #16]
  c->used = pa;
 800a590:	9b01      	ldr	r3, [sp, #4]
 800a592:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a594:	601a      	str	r2, [r3, #0]
    tmpc = c->dp + digs;
 800a596:	9b01      	ldr	r3, [sp, #4]
 800a598:	68da      	ldr	r2, [r3, #12]
 800a59a:	9b00      	ldr	r3, [sp, #0]
 800a59c:	009b      	lsls	r3, r3, #2
 800a59e:	4413      	add	r3, r2
 800a5a0:	930b      	str	r3, [sp, #44]	; 0x2c
    for (ix = digs; ix < pa; ix++) {   /* TAO, <= could potentially overwrite */
 800a5a2:	9b00      	ldr	r3, [sp, #0]
 800a5a4:	9311      	str	r3, [sp, #68]	; 0x44
 800a5a6:	e00b      	b.n	800a5c0 <fast_s_mp_mul_high_digs+0x180>
      *tmpc++ = W[ix];
 800a5a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a5aa:	1d1a      	adds	r2, r3, #4
 800a5ac:	920b      	str	r2, [sp, #44]	; 0x2c
 800a5ae:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a5b0:	0092      	lsls	r2, r2, #2
 800a5b2:	9908      	ldr	r1, [sp, #32]
 800a5b4:	440a      	add	r2, r1
 800a5b6:	6812      	ldr	r2, [r2, #0]
 800a5b8:	601a      	str	r2, [r3, #0]
    for (ix = digs; ix < pa; ix++) {   /* TAO, <= could potentially overwrite */
 800a5ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a5bc:	3301      	adds	r3, #1
 800a5be:	9311      	str	r3, [sp, #68]	; 0x44
 800a5c0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a5c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a5c4:	429a      	cmp	r2, r3
 800a5c6:	dbef      	blt.n	800a5a8 <fast_s_mp_mul_high_digs+0x168>
 800a5c8:	e007      	b.n	800a5da <fast_s_mp_mul_high_digs+0x19a>
      *tmpc++ = 0;
 800a5ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a5cc:	1d1a      	adds	r2, r3, #4
 800a5ce:	920b      	str	r2, [sp, #44]	; 0x2c
 800a5d0:	2200      	movs	r2, #0
 800a5d2:	601a      	str	r2, [r3, #0]
    for (; ix < olduse; ix++) {
 800a5d4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800a5d6:	3301      	adds	r3, #1
 800a5d8:	9311      	str	r3, [sp, #68]	; 0x44
 800a5da:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800a5dc:	9b04      	ldr	r3, [sp, #16]
 800a5de:	429a      	cmp	r2, r3
 800a5e0:	dbf3      	blt.n	800a5ca <fast_s_mp_mul_high_digs+0x18a>
  mp_clamp (c);
 800a5e2:	9801      	ldr	r0, [sp, #4]
 800a5e4:	f000 fae4 	bl	800abb0 <mp_clamp>
  XFREE(W, NULL, DYNAMIC_TYPE_BIGINT);
 800a5e8:	9808      	ldr	r0, [sp, #32]
 800a5ea:	f7fb f949 	bl	8005880 <chibios_free>
  return MP_OKAY;
 800a5ee:	2300      	movs	r3, #0
}
 800a5f0:	4618      	mov	r0, r3
 800a5f2:	b013      	add	sp, #76	; 0x4c
 800a5f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a5f6:	bf00      	nop
	...

0800a600 <mp_init>:
{
 800a600:	b082      	sub	sp, #8
 800a602:	9001      	str	r0, [sp, #4]
  if (a == NULL)
 800a604:	9b01      	ldr	r3, [sp, #4]
 800a606:	2b00      	cmp	r3, #0
 800a608:	d102      	bne.n	800a610 <mp_init+0x10>
    return MP_VAL;
 800a60a:	f06f 0302 	mvn.w	r3, #2
 800a60e:	e00c      	b.n	800a62a <mp_init+0x2a>
  a->dp = NULL;
 800a610:	9b01      	ldr	r3, [sp, #4]
 800a612:	2200      	movs	r2, #0
 800a614:	60da      	str	r2, [r3, #12]
  a->used  = 0;
 800a616:	9b01      	ldr	r3, [sp, #4]
 800a618:	2200      	movs	r2, #0
 800a61a:	601a      	str	r2, [r3, #0]
  a->alloc = 0;
 800a61c:	9b01      	ldr	r3, [sp, #4]
 800a61e:	2200      	movs	r2, #0
 800a620:	605a      	str	r2, [r3, #4]
  a->sign  = MP_ZPOS;
 800a622:	9b01      	ldr	r3, [sp, #4]
 800a624:	2200      	movs	r2, #0
 800a626:	609a      	str	r2, [r3, #8]
  return MP_OKAY;
 800a628:	2300      	movs	r3, #0
}
 800a62a:	4618      	mov	r0, r3
 800a62c:	b002      	add	sp, #8
 800a62e:	4770      	bx	lr

0800a630 <mp_clear>:
{
 800a630:	b500      	push	{lr}
 800a632:	b085      	sub	sp, #20
 800a634:	9001      	str	r0, [sp, #4]
  if (a == NULL)
 800a636:	9b01      	ldr	r3, [sp, #4]
 800a638:	2b00      	cmp	r3, #0
 800a63a:	d022      	beq.n	800a682 <mp_clear+0x52>
  if (a->dp != NULL) {
 800a63c:	9b01      	ldr	r3, [sp, #4]
 800a63e:	68db      	ldr	r3, [r3, #12]
 800a640:	2b00      	cmp	r3, #0
 800a642:	d01e      	beq.n	800a682 <mp_clear+0x52>
    for (i = 0; i < a->used; i++) {
 800a644:	2300      	movs	r3, #0
 800a646:	9303      	str	r3, [sp, #12]
 800a648:	e009      	b.n	800a65e <mp_clear+0x2e>
        a->dp[i] = 0;
 800a64a:	9b01      	ldr	r3, [sp, #4]
 800a64c:	68da      	ldr	r2, [r3, #12]
 800a64e:	9b03      	ldr	r3, [sp, #12]
 800a650:	009b      	lsls	r3, r3, #2
 800a652:	4413      	add	r3, r2
 800a654:	2200      	movs	r2, #0
 800a656:	601a      	str	r2, [r3, #0]
    for (i = 0; i < a->used; i++) {
 800a658:	9b03      	ldr	r3, [sp, #12]
 800a65a:	3301      	adds	r3, #1
 800a65c:	9303      	str	r3, [sp, #12]
 800a65e:	9b01      	ldr	r3, [sp, #4]
 800a660:	681a      	ldr	r2, [r3, #0]
 800a662:	9b03      	ldr	r3, [sp, #12]
 800a664:	429a      	cmp	r2, r3
 800a666:	dcf0      	bgt.n	800a64a <mp_clear+0x1a>
    mp_free(a);
 800a668:	9801      	ldr	r0, [sp, #4]
 800a66a:	f000 f811 	bl	800a690 <mp_free>
    a->alloc = a->used = 0;
 800a66e:	9b01      	ldr	r3, [sp, #4]
 800a670:	2200      	movs	r2, #0
 800a672:	601a      	str	r2, [r3, #0]
 800a674:	9b01      	ldr	r3, [sp, #4]
 800a676:	681a      	ldr	r2, [r3, #0]
 800a678:	9b01      	ldr	r3, [sp, #4]
 800a67a:	605a      	str	r2, [r3, #4]
    a->sign  = MP_ZPOS;
 800a67c:	9b01      	ldr	r3, [sp, #4]
 800a67e:	2200      	movs	r2, #0
 800a680:	609a      	str	r2, [r3, #8]
}
 800a682:	b005      	add	sp, #20
 800a684:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a690 <mp_free>:
{
 800a690:	b500      	push	{lr}
 800a692:	b083      	sub	sp, #12
 800a694:	9001      	str	r0, [sp, #4]
  if (a->dp != NULL) {
 800a696:	9b01      	ldr	r3, [sp, #4]
 800a698:	68db      	ldr	r3, [r3, #12]
 800a69a:	2b00      	cmp	r3, #0
 800a69c:	d007      	beq.n	800a6ae <mp_free+0x1e>
    XFREE(a->dp, 0, DYNAMIC_TYPE_BIGINT);
 800a69e:	9b01      	ldr	r3, [sp, #4]
 800a6a0:	68db      	ldr	r3, [r3, #12]
 800a6a2:	4618      	mov	r0, r3
 800a6a4:	f7fb f8ec 	bl	8005880 <chibios_free>
    a->dp    = NULL;
 800a6a8:	9b01      	ldr	r3, [sp, #4]
 800a6aa:	2200      	movs	r2, #0
 800a6ac:	60da      	str	r2, [r3, #12]
}
 800a6ae:	b003      	add	sp, #12
 800a6b0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a6c0 <mp_forcezero>:
{
 800a6c0:	b500      	push	{lr}
 800a6c2:	b083      	sub	sp, #12
 800a6c4:	9001      	str	r0, [sp, #4]
    if (a == NULL)
 800a6c6:	9b01      	ldr	r3, [sp, #4]
 800a6c8:	2b00      	cmp	r3, #0
 800a6ca:	d01f      	beq.n	800a70c <mp_forcezero+0x4c>
    if (a->dp != NULL) {
 800a6cc:	9b01      	ldr	r3, [sp, #4]
 800a6ce:	68db      	ldr	r3, [r3, #12]
 800a6d0:	2b00      	cmp	r3, #0
 800a6d2:	d015      	beq.n	800a700 <mp_forcezero+0x40>
      ForceZero(a->dp, a->used * sizeof(mp_digit));
 800a6d4:	9b01      	ldr	r3, [sp, #4]
 800a6d6:	68da      	ldr	r2, [r3, #12]
 800a6d8:	9b01      	ldr	r3, [sp, #4]
 800a6da:	681b      	ldr	r3, [r3, #0]
 800a6dc:	009b      	lsls	r3, r3, #2
 800a6de:	4619      	mov	r1, r3
 800a6e0:	4610      	mov	r0, r2
 800a6e2:	f002 f98d 	bl	800ca00 <ForceZero.lto_priv.365>
      mp_free(a);
 800a6e6:	9801      	ldr	r0, [sp, #4]
 800a6e8:	f7ff ffd2 	bl	800a690 <mp_free>
      a->alloc = a->used = 0;
 800a6ec:	9b01      	ldr	r3, [sp, #4]
 800a6ee:	2200      	movs	r2, #0
 800a6f0:	601a      	str	r2, [r3, #0]
 800a6f2:	9b01      	ldr	r3, [sp, #4]
 800a6f4:	681a      	ldr	r2, [r3, #0]
 800a6f6:	9b01      	ldr	r3, [sp, #4]
 800a6f8:	605a      	str	r2, [r3, #4]
      a->sign  = MP_ZPOS;
 800a6fa:	9b01      	ldr	r3, [sp, #4]
 800a6fc:	2200      	movs	r2, #0
 800a6fe:	609a      	str	r2, [r3, #8]
    a->sign = MP_ZPOS;
 800a700:	9b01      	ldr	r3, [sp, #4]
 800a702:	2200      	movs	r2, #0
 800a704:	609a      	str	r2, [r3, #8]
    a->used = 0;
 800a706:	9b01      	ldr	r3, [sp, #4]
 800a708:	2200      	movs	r2, #0
 800a70a:	601a      	str	r2, [r3, #0]
}
 800a70c:	b003      	add	sp, #12
 800a70e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a712:	bf00      	nop
	...

0800a720 <mp_unsigned_bin_size>:
{
 800a720:	b500      	push	{lr}
 800a722:	b085      	sub	sp, #20
 800a724:	9001      	str	r0, [sp, #4]
  int     size = mp_count_bits (a);
 800a726:	9801      	ldr	r0, [sp, #4]
 800a728:	f000 f81a 	bl	800a760 <mp_count_bits>
 800a72c:	9003      	str	r0, [sp, #12]
  return (size / 8 + ((size & 7) != 0 ? 1 : 0));
 800a72e:	9b03      	ldr	r3, [sp, #12]
 800a730:	2b00      	cmp	r3, #0
 800a732:	da00      	bge.n	800a736 <mp_unsigned_bin_size+0x16>
 800a734:	3307      	adds	r3, #7
 800a736:	10db      	asrs	r3, r3, #3
 800a738:	461a      	mov	r2, r3
 800a73a:	9b03      	ldr	r3, [sp, #12]
 800a73c:	f003 0307 	and.w	r3, r3, #7
 800a740:	2b00      	cmp	r3, #0
 800a742:	bf14      	ite	ne
 800a744:	2301      	movne	r3, #1
 800a746:	2300      	moveq	r3, #0
 800a748:	b2db      	uxtb	r3, r3
 800a74a:	4413      	add	r3, r2
}
 800a74c:	4618      	mov	r0, r3
 800a74e:	b005      	add	sp, #20
 800a750:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a760 <mp_count_bits>:
{
 800a760:	b084      	sub	sp, #16
 800a762:	9001      	str	r0, [sp, #4]
  if (a->used == 0) {
 800a764:	9b01      	ldr	r3, [sp, #4]
 800a766:	681b      	ldr	r3, [r3, #0]
 800a768:	2b00      	cmp	r3, #0
 800a76a:	d101      	bne.n	800a770 <mp_count_bits+0x10>
    return 0;
 800a76c:	2300      	movs	r3, #0
 800a76e:	e01d      	b.n	800a7ac <mp_count_bits+0x4c>
  r = (a->used - 1) * DIGIT_BIT;
 800a770:	9b01      	ldr	r3, [sp, #4]
 800a772:	681b      	ldr	r3, [r3, #0]
 800a774:	1e5a      	subs	r2, r3, #1
 800a776:	4613      	mov	r3, r2
 800a778:	00db      	lsls	r3, r3, #3
 800a77a:	1a9b      	subs	r3, r3, r2
 800a77c:	009b      	lsls	r3, r3, #2
 800a77e:	9303      	str	r3, [sp, #12]
  q = a->dp[a->used - 1];
 800a780:	9b01      	ldr	r3, [sp, #4]
 800a782:	68da      	ldr	r2, [r3, #12]
 800a784:	9b01      	ldr	r3, [sp, #4]
 800a786:	681b      	ldr	r3, [r3, #0]
 800a788:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800a78c:	3b01      	subs	r3, #1
 800a78e:	009b      	lsls	r3, r3, #2
 800a790:	4413      	add	r3, r2
 800a792:	681b      	ldr	r3, [r3, #0]
 800a794:	9302      	str	r3, [sp, #8]
 800a796:	e005      	b.n	800a7a4 <mp_count_bits+0x44>
    ++r;
 800a798:	9b03      	ldr	r3, [sp, #12]
 800a79a:	3301      	adds	r3, #1
 800a79c:	9303      	str	r3, [sp, #12]
    q >>= ((mp_digit) 1);
 800a79e:	9b02      	ldr	r3, [sp, #8]
 800a7a0:	085b      	lsrs	r3, r3, #1
 800a7a2:	9302      	str	r3, [sp, #8]
  while (q > ((mp_digit) 0)) {
 800a7a4:	9b02      	ldr	r3, [sp, #8]
 800a7a6:	2b00      	cmp	r3, #0
 800a7a8:	d1f6      	bne.n	800a798 <mp_count_bits+0x38>
  return r;
 800a7aa:	9b03      	ldr	r3, [sp, #12]
}
 800a7ac:	4618      	mov	r0, r3
 800a7ae:	b004      	add	sp, #16
 800a7b0:	4770      	bx	lr
 800a7b2:	bf00      	nop
	...

0800a7c0 <mp_leading_bit>:
{
 800a7c0:	b500      	push	{lr}
 800a7c2:	b089      	sub	sp, #36	; 0x24
 800a7c4:	9001      	str	r0, [sp, #4]
    int bit = 0;
 800a7c6:	2300      	movs	r3, #0
 800a7c8:	9307      	str	r3, [sp, #28]
    if (mp_init_copy(&t, a) != MP_OKAY)
 800a7ca:	ab03      	add	r3, sp, #12
 800a7cc:	9901      	ldr	r1, [sp, #4]
 800a7ce:	4618      	mov	r0, r3
 800a7d0:	f000 f886 	bl	800a8e0 <mp_init_copy>
 800a7d4:	4603      	mov	r3, r0
 800a7d6:	2b00      	cmp	r3, #0
 800a7d8:	d014      	beq.n	800a804 <mp_leading_bit+0x44>
        return 0;
 800a7da:	2300      	movs	r3, #0
 800a7dc:	e01a      	b.n	800a814 <mp_leading_bit+0x54>
        bit = (t.dp[0] & 0x80) != 0;
 800a7de:	9b06      	ldr	r3, [sp, #24]
 800a7e0:	681b      	ldr	r3, [r3, #0]
 800a7e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a7e6:	2b00      	cmp	r3, #0
 800a7e8:	bf14      	ite	ne
 800a7ea:	2301      	movne	r3, #1
 800a7ec:	2300      	moveq	r3, #0
 800a7ee:	b2db      	uxtb	r3, r3
 800a7f0:	9307      	str	r3, [sp, #28]
        if (mp_div_2d (&t, 8, &t, NULL) != MP_OKAY)
 800a7f2:	aa03      	add	r2, sp, #12
 800a7f4:	a803      	add	r0, sp, #12
 800a7f6:	2300      	movs	r3, #0
 800a7f8:	2108      	movs	r1, #8
 800a7fa:	f000 f939 	bl	800aa70 <mp_div_2d>
 800a7fe:	4603      	mov	r3, r0
 800a800:	2b00      	cmp	r3, #0
 800a802:	d102      	bne.n	800a80a <mp_leading_bit+0x4a>
    while (mp_iszero(&t) == MP_NO) {
 800a804:	9b03      	ldr	r3, [sp, #12]
 800a806:	2b00      	cmp	r3, #0
 800a808:	d1e9      	bne.n	800a7de <mp_leading_bit+0x1e>
    mp_clear(&t);
 800a80a:	ab03      	add	r3, sp, #12
 800a80c:	4618      	mov	r0, r3
 800a80e:	f7ff ff0f 	bl	800a630 <mp_clear>
    return bit;
 800a812:	9b07      	ldr	r3, [sp, #28]
}
 800a814:	4618      	mov	r0, r3
 800a816:	b009      	add	sp, #36	; 0x24
 800a818:	f85d fb04 	ldr.w	pc, [sp], #4
 800a81c:	0000      	movs	r0, r0
	...

0800a820 <mp_to_unsigned_bin_at_pos>:
{
 800a820:	b500      	push	{lr}
 800a822:	b087      	sub	sp, #28
 800a824:	9003      	str	r0, [sp, #12]
 800a826:	9102      	str	r1, [sp, #8]
 800a828:	9201      	str	r2, [sp, #4]
  int res = 0;
 800a82a:	2300      	movs	r3, #0
 800a82c:	9305      	str	r3, [sp, #20]
 800a82e:	e018      	b.n	800a862 <mp_to_unsigned_bin_at_pos+0x42>
      b[x++] = (unsigned char) (t->dp[0] & 255);
 800a830:	9b03      	ldr	r3, [sp, #12]
 800a832:	1c5a      	adds	r2, r3, #1
 800a834:	9203      	str	r2, [sp, #12]
 800a836:	461a      	mov	r2, r3
 800a838:	9b01      	ldr	r3, [sp, #4]
 800a83a:	4413      	add	r3, r2
 800a83c:	9a02      	ldr	r2, [sp, #8]
 800a83e:	68d2      	ldr	r2, [r2, #12]
 800a840:	6812      	ldr	r2, [r2, #0]
 800a842:	b2d2      	uxtb	r2, r2
 800a844:	701a      	strb	r2, [r3, #0]
    if ((res = mp_div_2d (t, 8, t, NULL)) != MP_OKAY) {
 800a846:	2300      	movs	r3, #0
 800a848:	9a02      	ldr	r2, [sp, #8]
 800a84a:	2108      	movs	r1, #8
 800a84c:	9802      	ldr	r0, [sp, #8]
 800a84e:	f000 f90f 	bl	800aa70 <mp_div_2d>
 800a852:	9005      	str	r0, [sp, #20]
 800a854:	9b05      	ldr	r3, [sp, #20]
 800a856:	2b00      	cmp	r3, #0
 800a858:	d001      	beq.n	800a85e <mp_to_unsigned_bin_at_pos+0x3e>
      return res;
 800a85a:	9b05      	ldr	r3, [sp, #20]
 800a85c:	e006      	b.n	800a86c <mp_to_unsigned_bin_at_pos+0x4c>
    res = x;
 800a85e:	9b03      	ldr	r3, [sp, #12]
 800a860:	9305      	str	r3, [sp, #20]
  while (mp_iszero(t) == MP_NO) {
 800a862:	9b02      	ldr	r3, [sp, #8]
 800a864:	681b      	ldr	r3, [r3, #0]
 800a866:	2b00      	cmp	r3, #0
 800a868:	d1e2      	bne.n	800a830 <mp_to_unsigned_bin_at_pos+0x10>
  return res;
 800a86a:	9b05      	ldr	r3, [sp, #20]
}
 800a86c:	4618      	mov	r0, r3
 800a86e:	b007      	add	sp, #28
 800a870:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a880 <mp_to_unsigned_bin>:
{
 800a880:	b500      	push	{lr}
 800a882:	b089      	sub	sp, #36	; 0x24
 800a884:	9001      	str	r0, [sp, #4]
 800a886:	9100      	str	r1, [sp, #0]
  if ((res = mp_init_copy (&t, a)) != MP_OKAY) {
 800a888:	ab02      	add	r3, sp, #8
 800a88a:	9901      	ldr	r1, [sp, #4]
 800a88c:	4618      	mov	r0, r3
 800a88e:	f000 f827 	bl	800a8e0 <mp_init_copy>
 800a892:	9007      	str	r0, [sp, #28]
 800a894:	9b07      	ldr	r3, [sp, #28]
 800a896:	2b00      	cmp	r3, #0
 800a898:	d001      	beq.n	800a89e <mp_to_unsigned_bin+0x1e>
    return res;
 800a89a:	9b07      	ldr	r3, [sp, #28]
 800a89c:	e018      	b.n	800a8d0 <mp_to_unsigned_bin+0x50>
  x = mp_to_unsigned_bin_at_pos(0, &t, b);
 800a89e:	ab02      	add	r3, sp, #8
 800a8a0:	9a00      	ldr	r2, [sp, #0]
 800a8a2:	4619      	mov	r1, r3
 800a8a4:	2000      	movs	r0, #0
 800a8a6:	f7ff ffbb 	bl	800a820 <mp_to_unsigned_bin_at_pos>
 800a8aa:	9006      	str	r0, [sp, #24]
  if (x < 0) {
 800a8ac:	9b06      	ldr	r3, [sp, #24]
 800a8ae:	2b00      	cmp	r3, #0
 800a8b0:	da05      	bge.n	800a8be <mp_to_unsigned_bin+0x3e>
    mp_clear(&t);
 800a8b2:	ab02      	add	r3, sp, #8
 800a8b4:	4618      	mov	r0, r3
 800a8b6:	f7ff febb 	bl	800a630 <mp_clear>
    return x;
 800a8ba:	9b06      	ldr	r3, [sp, #24]
 800a8bc:	e008      	b.n	800a8d0 <mp_to_unsigned_bin+0x50>
  bn_reverse (b, x);
 800a8be:	9906      	ldr	r1, [sp, #24]
 800a8c0:	9800      	ldr	r0, [sp, #0]
 800a8c2:	f002 f8b5 	bl	800ca30 <bn_reverse.lto_priv.364>
  mp_clear (&t);
 800a8c6:	ab02      	add	r3, sp, #8
 800a8c8:	4618      	mov	r0, r3
 800a8ca:	f7ff feb1 	bl	800a630 <mp_clear>
  return res;
 800a8ce:	9b07      	ldr	r3, [sp, #28]
}
 800a8d0:	4618      	mov	r0, r3
 800a8d2:	b009      	add	sp, #36	; 0x24
 800a8d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a8e0 <mp_init_copy>:
{
 800a8e0:	b500      	push	{lr}
 800a8e2:	b085      	sub	sp, #20
 800a8e4:	9001      	str	r0, [sp, #4]
 800a8e6:	9100      	str	r1, [sp, #0]
  if ((res = mp_init_size (a, b->used)) != MP_OKAY) {
 800a8e8:	9b00      	ldr	r3, [sp, #0]
 800a8ea:	681b      	ldr	r3, [r3, #0]
 800a8ec:	4619      	mov	r1, r3
 800a8ee:	9801      	ldr	r0, [sp, #4]
 800a8f0:	f7fe fd2e 	bl	8009350 <mp_init_size>
 800a8f4:	9003      	str	r0, [sp, #12]
 800a8f6:	9b03      	ldr	r3, [sp, #12]
 800a8f8:	2b00      	cmp	r3, #0
 800a8fa:	d001      	beq.n	800a900 <mp_init_copy+0x20>
    return res;
 800a8fc:	9b03      	ldr	r3, [sp, #12]
 800a8fe:	e00b      	b.n	800a918 <mp_init_copy+0x38>
  if((res = mp_copy (b, a)) != MP_OKAY) {
 800a900:	9901      	ldr	r1, [sp, #4]
 800a902:	9800      	ldr	r0, [sp, #0]
 800a904:	f000 f80c 	bl	800a920 <mp_copy>
 800a908:	9003      	str	r0, [sp, #12]
 800a90a:	9b03      	ldr	r3, [sp, #12]
 800a90c:	2b00      	cmp	r3, #0
 800a90e:	d002      	beq.n	800a916 <mp_init_copy+0x36>
    mp_clear(a);
 800a910:	9801      	ldr	r0, [sp, #4]
 800a912:	f7ff fe8d 	bl	800a630 <mp_clear>
  return res;
 800a916:	9b03      	ldr	r3, [sp, #12]
}
 800a918:	4618      	mov	r0, r3
 800a91a:	b005      	add	sp, #20
 800a91c:	f85d fb04 	ldr.w	pc, [sp], #4

0800a920 <mp_copy>:
{
 800a920:	b500      	push	{lr}
 800a922:	b087      	sub	sp, #28
 800a924:	9001      	str	r0, [sp, #4]
 800a926:	9100      	str	r1, [sp, #0]
  if (a == NULL || b == NULL)
 800a928:	9b01      	ldr	r3, [sp, #4]
 800a92a:	2b00      	cmp	r3, #0
 800a92c:	d002      	beq.n	800a934 <mp_copy+0x14>
 800a92e:	9b00      	ldr	r3, [sp, #0]
 800a930:	2b00      	cmp	r3, #0
 800a932:	d102      	bne.n	800a93a <mp_copy+0x1a>
    return MP_VAL;
 800a934:	f06f 0302 	mvn.w	r3, #2
 800a938:	e04f      	b.n	800a9da <mp_copy+0xba>
  if (a == b) {
 800a93a:	9a01      	ldr	r2, [sp, #4]
 800a93c:	9b00      	ldr	r3, [sp, #0]
 800a93e:	429a      	cmp	r2, r3
 800a940:	d101      	bne.n	800a946 <mp_copy+0x26>
    return MP_OKAY;
 800a942:	2300      	movs	r3, #0
 800a944:	e049      	b.n	800a9da <mp_copy+0xba>
  if (b->alloc < a->used || b->alloc == 0) {
 800a946:	9b00      	ldr	r3, [sp, #0]
 800a948:	685a      	ldr	r2, [r3, #4]
 800a94a:	9b01      	ldr	r3, [sp, #4]
 800a94c:	681b      	ldr	r3, [r3, #0]
 800a94e:	429a      	cmp	r2, r3
 800a950:	db03      	blt.n	800a95a <mp_copy+0x3a>
 800a952:	9b00      	ldr	r3, [sp, #0]
 800a954:	685b      	ldr	r3, [r3, #4]
 800a956:	2b00      	cmp	r3, #0
 800a958:	d10b      	bne.n	800a972 <mp_copy+0x52>
     if ((res = mp_grow (b, a->used)) != MP_OKAY) {
 800a95a:	9b01      	ldr	r3, [sp, #4]
 800a95c:	681b      	ldr	r3, [r3, #0]
 800a95e:	4619      	mov	r1, r3
 800a960:	9800      	ldr	r0, [sp, #0]
 800a962:	f000 f845 	bl	800a9f0 <mp_grow>
 800a966:	9002      	str	r0, [sp, #8]
 800a968:	9b02      	ldr	r3, [sp, #8]
 800a96a:	2b00      	cmp	r3, #0
 800a96c:	d001      	beq.n	800a972 <mp_copy+0x52>
        return res;
 800a96e:	9b02      	ldr	r3, [sp, #8]
 800a970:	e033      	b.n	800a9da <mp_copy+0xba>
    tmpa = a->dp;
 800a972:	9b01      	ldr	r3, [sp, #4]
 800a974:	68db      	ldr	r3, [r3, #12]
 800a976:	9304      	str	r3, [sp, #16]
    tmpb = b->dp;
 800a978:	9b00      	ldr	r3, [sp, #0]
 800a97a:	68db      	ldr	r3, [r3, #12]
 800a97c:	9303      	str	r3, [sp, #12]
    for (n = 0; n < a->used; n++) {
 800a97e:	2300      	movs	r3, #0
 800a980:	9305      	str	r3, [sp, #20]
 800a982:	e00a      	b.n	800a99a <mp_copy+0x7a>
      *tmpb++ = *tmpa++;
 800a984:	9b03      	ldr	r3, [sp, #12]
 800a986:	1d1a      	adds	r2, r3, #4
 800a988:	9203      	str	r2, [sp, #12]
 800a98a:	9a04      	ldr	r2, [sp, #16]
 800a98c:	1d11      	adds	r1, r2, #4
 800a98e:	9104      	str	r1, [sp, #16]
 800a990:	6812      	ldr	r2, [r2, #0]
 800a992:	601a      	str	r2, [r3, #0]
    for (n = 0; n < a->used; n++) {
 800a994:	9b05      	ldr	r3, [sp, #20]
 800a996:	3301      	adds	r3, #1
 800a998:	9305      	str	r3, [sp, #20]
 800a99a:	9b01      	ldr	r3, [sp, #4]
 800a99c:	681a      	ldr	r2, [r3, #0]
 800a99e:	9b05      	ldr	r3, [sp, #20]
 800a9a0:	429a      	cmp	r2, r3
 800a9a2:	dcef      	bgt.n	800a984 <mp_copy+0x64>
 800a9a4:	e007      	b.n	800a9b6 <mp_copy+0x96>
      *tmpb++ = 0;
 800a9a6:	9b03      	ldr	r3, [sp, #12]
 800a9a8:	1d1a      	adds	r2, r3, #4
 800a9aa:	9203      	str	r2, [sp, #12]
 800a9ac:	2200      	movs	r2, #0
 800a9ae:	601a      	str	r2, [r3, #0]
    for (; n < b->used && b->dp; n++) {
 800a9b0:	9b05      	ldr	r3, [sp, #20]
 800a9b2:	3301      	adds	r3, #1
 800a9b4:	9305      	str	r3, [sp, #20]
 800a9b6:	9b00      	ldr	r3, [sp, #0]
 800a9b8:	681a      	ldr	r2, [r3, #0]
 800a9ba:	9b05      	ldr	r3, [sp, #20]
 800a9bc:	429a      	cmp	r2, r3
 800a9be:	dd03      	ble.n	800a9c8 <mp_copy+0xa8>
 800a9c0:	9b00      	ldr	r3, [sp, #0]
 800a9c2:	68db      	ldr	r3, [r3, #12]
 800a9c4:	2b00      	cmp	r3, #0
 800a9c6:	d1ee      	bne.n	800a9a6 <mp_copy+0x86>
  b->used = a->used;
 800a9c8:	9b01      	ldr	r3, [sp, #4]
 800a9ca:	681a      	ldr	r2, [r3, #0]
 800a9cc:	9b00      	ldr	r3, [sp, #0]
 800a9ce:	601a      	str	r2, [r3, #0]
  b->sign = a->sign;
 800a9d0:	9b01      	ldr	r3, [sp, #4]
 800a9d2:	689a      	ldr	r2, [r3, #8]
 800a9d4:	9b00      	ldr	r3, [sp, #0]
 800a9d6:	609a      	str	r2, [r3, #8]
  return MP_OKAY;
 800a9d8:	2300      	movs	r3, #0
}
 800a9da:	4618      	mov	r0, r3
 800a9dc:	b007      	add	sp, #28
 800a9de:	f85d fb04 	ldr.w	pc, [sp], #4
 800a9e2:	bf00      	nop
	...

0800a9f0 <mp_grow>:
{
 800a9f0:	b500      	push	{lr}
 800a9f2:	b085      	sub	sp, #20
 800a9f4:	9001      	str	r0, [sp, #4]
 800a9f6:	9100      	str	r1, [sp, #0]
  if (a->alloc < size || size == 0) {
 800a9f8:	9b01      	ldr	r3, [sp, #4]
 800a9fa:	685a      	ldr	r2, [r3, #4]
 800a9fc:	9b00      	ldr	r3, [sp, #0]
 800a9fe:	429a      	cmp	r2, r3
 800aa00:	db02      	blt.n	800aa08 <mp_grow+0x18>
 800aa02:	9b00      	ldr	r3, [sp, #0]
 800aa04:	2b00      	cmp	r3, #0
 800aa06:	d12a      	bne.n	800aa5e <mp_grow+0x6e>
    size += (MP_PREC * 2) - (size % MP_PREC);
 800aa08:	9b00      	ldr	r3, [sp, #0]
 800aa0a:	3302      	adds	r3, #2
 800aa0c:	9300      	str	r3, [sp, #0]
    tmp = OPT_CAST(mp_digit) XREALLOC (a->dp, sizeof (mp_digit) * size, NULL,
 800aa0e:	9b01      	ldr	r3, [sp, #4]
 800aa10:	68da      	ldr	r2, [r3, #12]
 800aa12:	9b00      	ldr	r3, [sp, #0]
 800aa14:	009b      	lsls	r3, r3, #2
 800aa16:	4619      	mov	r1, r3
 800aa18:	4610      	mov	r0, r2
 800aa1a:	f7fa fee1 	bl	80057e0 <chHeapRealloc>
 800aa1e:	9002      	str	r0, [sp, #8]
    if (tmp == NULL) {
 800aa20:	9b02      	ldr	r3, [sp, #8]
 800aa22:	2b00      	cmp	r3, #0
 800aa24:	d102      	bne.n	800aa2c <mp_grow+0x3c>
      return MP_MEM;
 800aa26:	f06f 0301 	mvn.w	r3, #1
 800aa2a:	e019      	b.n	800aa60 <mp_grow+0x70>
    a->dp = tmp;
 800aa2c:	9b01      	ldr	r3, [sp, #4]
 800aa2e:	9a02      	ldr	r2, [sp, #8]
 800aa30:	60da      	str	r2, [r3, #12]
    i        = a->alloc;
 800aa32:	9b01      	ldr	r3, [sp, #4]
 800aa34:	685b      	ldr	r3, [r3, #4]
 800aa36:	9303      	str	r3, [sp, #12]
    a->alloc = size;
 800aa38:	9b01      	ldr	r3, [sp, #4]
 800aa3a:	9a00      	ldr	r2, [sp, #0]
 800aa3c:	605a      	str	r2, [r3, #4]
 800aa3e:	e009      	b.n	800aa54 <mp_grow+0x64>
      a->dp[i] = 0;
 800aa40:	9b01      	ldr	r3, [sp, #4]
 800aa42:	68da      	ldr	r2, [r3, #12]
 800aa44:	9b03      	ldr	r3, [sp, #12]
 800aa46:	009b      	lsls	r3, r3, #2
 800aa48:	4413      	add	r3, r2
 800aa4a:	2200      	movs	r2, #0
 800aa4c:	601a      	str	r2, [r3, #0]
    for (; i < a->alloc; i++) {
 800aa4e:	9b03      	ldr	r3, [sp, #12]
 800aa50:	3301      	adds	r3, #1
 800aa52:	9303      	str	r3, [sp, #12]
 800aa54:	9b01      	ldr	r3, [sp, #4]
 800aa56:	685a      	ldr	r2, [r3, #4]
 800aa58:	9b03      	ldr	r3, [sp, #12]
 800aa5a:	429a      	cmp	r2, r3
 800aa5c:	dcf0      	bgt.n	800aa40 <mp_grow+0x50>
  return MP_OKAY;
 800aa5e:	2300      	movs	r3, #0
}
 800aa60:	4618      	mov	r0, r3
 800aa62:	b005      	add	sp, #20
 800aa64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800aa70 <mp_div_2d>:
{
 800aa70:	b500      	push	{lr}
 800aa72:	b08b      	sub	sp, #44	; 0x2c
 800aa74:	9003      	str	r0, [sp, #12]
 800aa76:	9102      	str	r1, [sp, #8]
 800aa78:	9201      	str	r2, [sp, #4]
 800aa7a:	9300      	str	r3, [sp, #0]
  if (b <= 0) {
 800aa7c:	9b02      	ldr	r3, [sp, #8]
 800aa7e:	2b00      	cmp	r3, #0
 800aa80:	dc0c      	bgt.n	800aa9c <mp_div_2d+0x2c>
    res = mp_copy (a, c);
 800aa82:	9901      	ldr	r1, [sp, #4]
 800aa84:	9803      	ldr	r0, [sp, #12]
 800aa86:	f7ff ff4b 	bl	800a920 <mp_copy>
 800aa8a:	9009      	str	r0, [sp, #36]	; 0x24
    if (d != NULL) {
 800aa8c:	9b00      	ldr	r3, [sp, #0]
 800aa8e:	2b00      	cmp	r3, #0
 800aa90:	d002      	beq.n	800aa98 <mp_div_2d+0x28>
      mp_zero (d);
 800aa92:	9800      	ldr	r0, [sp, #0]
 800aa94:	f000 f86c 	bl	800ab70 <mp_zero>
    return res;
 800aa98:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aa9a:	e05e      	b.n	800ab5a <mp_div_2d+0xea>
  if ((res = mp_init (&t)) != MP_OKAY) {
 800aa9c:	ab04      	add	r3, sp, #16
 800aa9e:	4618      	mov	r0, r3
 800aaa0:	f7ff fdae 	bl	800a600 <mp_init>
 800aaa4:	9009      	str	r0, [sp, #36]	; 0x24
 800aaa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aaa8:	2b00      	cmp	r3, #0
 800aaaa:	d001      	beq.n	800aab0 <mp_div_2d+0x40>
    return res;
 800aaac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aaae:	e054      	b.n	800ab5a <mp_div_2d+0xea>
  if (d != NULL) {
 800aab0:	9b00      	ldr	r3, [sp, #0]
 800aab2:	2b00      	cmp	r3, #0
 800aab4:	d00f      	beq.n	800aad6 <mp_div_2d+0x66>
    if ((res = mp_mod_2d (a, b, &t)) != MP_OKAY) {
 800aab6:	ab04      	add	r3, sp, #16
 800aab8:	461a      	mov	r2, r3
 800aaba:	9902      	ldr	r1, [sp, #8]
 800aabc:	9803      	ldr	r0, [sp, #12]
 800aabe:	f000 f94f 	bl	800ad60 <mp_mod_2d>
 800aac2:	9009      	str	r0, [sp, #36]	; 0x24
 800aac4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aac6:	2b00      	cmp	r3, #0
 800aac8:	d005      	beq.n	800aad6 <mp_div_2d+0x66>
      mp_clear (&t);
 800aaca:	ab04      	add	r3, sp, #16
 800aacc:	4618      	mov	r0, r3
 800aace:	f7ff fdaf 	bl	800a630 <mp_clear>
      return res;
 800aad2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aad4:	e041      	b.n	800ab5a <mp_div_2d+0xea>
  if ((res = mp_copy (a, c)) != MP_OKAY) {
 800aad6:	9901      	ldr	r1, [sp, #4]
 800aad8:	9803      	ldr	r0, [sp, #12]
 800aada:	f7ff ff21 	bl	800a920 <mp_copy>
 800aade:	9009      	str	r0, [sp, #36]	; 0x24
 800aae0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aae2:	2b00      	cmp	r3, #0
 800aae4:	d005      	beq.n	800aaf2 <mp_div_2d+0x82>
    mp_clear (&t);
 800aae6:	ab04      	add	r3, sp, #16
 800aae8:	4618      	mov	r0, r3
 800aaea:	f7ff fda1 	bl	800a630 <mp_clear>
    return res;
 800aaee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aaf0:	e033      	b.n	800ab5a <mp_div_2d+0xea>
  if (b >= (int)DIGIT_BIT) {
 800aaf2:	9b02      	ldr	r3, [sp, #8]
 800aaf4:	2b1b      	cmp	r3, #27
 800aaf6:	dd0b      	ble.n	800ab10 <mp_div_2d+0xa0>
    mp_rshd (c, b / DIGIT_BIT);
 800aaf8:	9b02      	ldr	r3, [sp, #8]
 800aafa:	4a1a      	ldr	r2, [pc, #104]	; (800ab64 <mp_div_2d+0xf4>)
 800aafc:	fb82 1203 	smull	r1, r2, r2, r3
 800ab00:	441a      	add	r2, r3
 800ab02:	1112      	asrs	r2, r2, #4
 800ab04:	17db      	asrs	r3, r3, #31
 800ab06:	1ad3      	subs	r3, r2, r3
 800ab08:	4619      	mov	r1, r3
 800ab0a:	9801      	ldr	r0, [sp, #4]
 800ab0c:	f000 f8e0 	bl	800acd0 <mp_rshd>
  D = (b % DIGIT_BIT);
 800ab10:	9a02      	ldr	r2, [sp, #8]
 800ab12:	4b14      	ldr	r3, [pc, #80]	; (800ab64 <mp_div_2d+0xf4>)
 800ab14:	fb83 1302 	smull	r1, r3, r3, r2
 800ab18:	4413      	add	r3, r2
 800ab1a:	1119      	asrs	r1, r3, #4
 800ab1c:	17d3      	asrs	r3, r2, #31
 800ab1e:	1ac9      	subs	r1, r1, r3
 800ab20:	460b      	mov	r3, r1
 800ab22:	00db      	lsls	r3, r3, #3
 800ab24:	1a5b      	subs	r3, r3, r1
 800ab26:	009b      	lsls	r3, r3, #2
 800ab28:	1ad3      	subs	r3, r2, r3
 800ab2a:	9308      	str	r3, [sp, #32]
  if (D != 0) {
 800ab2c:	9b08      	ldr	r3, [sp, #32]
 800ab2e:	2b00      	cmp	r3, #0
 800ab30:	d003      	beq.n	800ab3a <mp_div_2d+0xca>
    mp_rshb(c, D);
 800ab32:	9908      	ldr	r1, [sp, #32]
 800ab34:	9801      	ldr	r0, [sp, #4]
 800ab36:	f000 f883 	bl	800ac40 <mp_rshb>
  mp_clamp (c);
 800ab3a:	9801      	ldr	r0, [sp, #4]
 800ab3c:	f000 f838 	bl	800abb0 <mp_clamp>
  if (d != NULL) {
 800ab40:	9b00      	ldr	r3, [sp, #0]
 800ab42:	2b00      	cmp	r3, #0
 800ab44:	d004      	beq.n	800ab50 <mp_div_2d+0xe0>
    mp_exch (&t, d);
 800ab46:	ab04      	add	r3, sp, #16
 800ab48:	9900      	ldr	r1, [sp, #0]
 800ab4a:	4618      	mov	r0, r3
 800ab4c:	f000 f858 	bl	800ac00 <mp_exch>
  mp_clear (&t);
 800ab50:	ab04      	add	r3, sp, #16
 800ab52:	4618      	mov	r0, r3
 800ab54:	f7ff fd6c 	bl	800a630 <mp_clear>
  return MP_OKAY;
 800ab58:	2300      	movs	r3, #0
}
 800ab5a:	4618      	mov	r0, r3
 800ab5c:	b00b      	add	sp, #44	; 0x2c
 800ab5e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ab62:	bf00      	nop
 800ab64:	92492493 	.word	0x92492493
	...

0800ab70 <mp_zero>:
{
 800ab70:	b084      	sub	sp, #16
 800ab72:	9001      	str	r0, [sp, #4]
  if (a == NULL)
 800ab74:	9b01      	ldr	r3, [sp, #4]
 800ab76:	2b00      	cmp	r3, #0
 800ab78:	d018      	beq.n	800abac <mp_zero+0x3c>
  a->sign = MP_ZPOS;
 800ab7a:	9b01      	ldr	r3, [sp, #4]
 800ab7c:	2200      	movs	r2, #0
 800ab7e:	609a      	str	r2, [r3, #8]
  a->used = 0;
 800ab80:	9b01      	ldr	r3, [sp, #4]
 800ab82:	2200      	movs	r2, #0
 800ab84:	601a      	str	r2, [r3, #0]
  tmp = a->dp;
 800ab86:	9b01      	ldr	r3, [sp, #4]
 800ab88:	68db      	ldr	r3, [r3, #12]
 800ab8a:	9302      	str	r3, [sp, #8]
  for (n = 0; n < a->alloc; n++) {
 800ab8c:	2300      	movs	r3, #0
 800ab8e:	9303      	str	r3, [sp, #12]
 800ab90:	e007      	b.n	800aba2 <mp_zero+0x32>
     *tmp++ = 0;
 800ab92:	9b02      	ldr	r3, [sp, #8]
 800ab94:	1d1a      	adds	r2, r3, #4
 800ab96:	9202      	str	r2, [sp, #8]
 800ab98:	2200      	movs	r2, #0
 800ab9a:	601a      	str	r2, [r3, #0]
  for (n = 0; n < a->alloc; n++) {
 800ab9c:	9b03      	ldr	r3, [sp, #12]
 800ab9e:	3301      	adds	r3, #1
 800aba0:	9303      	str	r3, [sp, #12]
 800aba2:	9b01      	ldr	r3, [sp, #4]
 800aba4:	685a      	ldr	r2, [r3, #4]
 800aba6:	9b03      	ldr	r3, [sp, #12]
 800aba8:	429a      	cmp	r2, r3
 800abaa:	dcf2      	bgt.n	800ab92 <mp_zero+0x22>
}
 800abac:	b004      	add	sp, #16
 800abae:	4770      	bx	lr

0800abb0 <mp_clamp>:
{
 800abb0:	b082      	sub	sp, #8
 800abb2:	9001      	str	r0, [sp, #4]
 800abb4:	e004      	b.n	800abc0 <mp_clamp+0x10>
    --(a->used);
 800abb6:	9b01      	ldr	r3, [sp, #4]
 800abb8:	681b      	ldr	r3, [r3, #0]
 800abba:	1e5a      	subs	r2, r3, #1
 800abbc:	9b01      	ldr	r3, [sp, #4]
 800abbe:	601a      	str	r2, [r3, #0]
  while (a->used > 0 && a->dp[a->used - 1] == 0) {
 800abc0:	9b01      	ldr	r3, [sp, #4]
 800abc2:	681b      	ldr	r3, [r3, #0]
 800abc4:	2b00      	cmp	r3, #0
 800abc6:	dd0b      	ble.n	800abe0 <mp_clamp+0x30>
 800abc8:	9b01      	ldr	r3, [sp, #4]
 800abca:	68da      	ldr	r2, [r3, #12]
 800abcc:	9b01      	ldr	r3, [sp, #4]
 800abce:	681b      	ldr	r3, [r3, #0]
 800abd0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800abd4:	3b01      	subs	r3, #1
 800abd6:	009b      	lsls	r3, r3, #2
 800abd8:	4413      	add	r3, r2
 800abda:	681b      	ldr	r3, [r3, #0]
 800abdc:	2b00      	cmp	r3, #0
 800abde:	d0ea      	beq.n	800abb6 <mp_clamp+0x6>
  if (a->used == 0) {
 800abe0:	9b01      	ldr	r3, [sp, #4]
 800abe2:	681b      	ldr	r3, [r3, #0]
 800abe4:	2b00      	cmp	r3, #0
 800abe6:	d102      	bne.n	800abee <mp_clamp+0x3e>
    a->sign = MP_ZPOS;
 800abe8:	9b01      	ldr	r3, [sp, #4]
 800abea:	2200      	movs	r2, #0
 800abec:	609a      	str	r2, [r3, #8]
}
 800abee:	b002      	add	sp, #8
 800abf0:	4770      	bx	lr
 800abf2:	bf00      	nop
	...

0800ac00 <mp_exch>:
{
 800ac00:	b410      	push	{r4}
 800ac02:	b087      	sub	sp, #28
 800ac04:	9001      	str	r0, [sp, #4]
 800ac06:	9100      	str	r1, [sp, #0]
  t  = *a;
 800ac08:	9b01      	ldr	r3, [sp, #4]
 800ac0a:	ac02      	add	r4, sp, #8
 800ac0c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800ac0e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  *a = *b;
 800ac12:	9a01      	ldr	r2, [sp, #4]
 800ac14:	9b00      	ldr	r3, [sp, #0]
 800ac16:	4614      	mov	r4, r2
 800ac18:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800ac1a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  *b = t;
 800ac1e:	9b00      	ldr	r3, [sp, #0]
 800ac20:	461c      	mov	r4, r3
 800ac22:	ab02      	add	r3, sp, #8
 800ac24:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800ac26:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 800ac2a:	b007      	add	sp, #28
 800ac2c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ac30:	4770      	bx	lr
 800ac32:	bf00      	nop
	...

0800ac40 <mp_rshb>:
{
 800ac40:	b500      	push	{lr}
 800ac42:	b089      	sub	sp, #36	; 0x24
 800ac44:	9001      	str	r0, [sp, #4]
 800ac46:	9100      	str	r1, [sp, #0]
    mp_digit D = x;
 800ac48:	9b00      	ldr	r3, [sp, #0]
 800ac4a:	9305      	str	r3, [sp, #20]
    mask = (((mp_digit)1) << D) - 1;
 800ac4c:	2201      	movs	r2, #1
 800ac4e:	9b05      	ldr	r3, [sp, #20]
 800ac50:	fa02 f303 	lsl.w	r3, r2, r3
 800ac54:	3b01      	subs	r3, #1
 800ac56:	9304      	str	r3, [sp, #16]
    shift = DIGIT_BIT - D;
 800ac58:	9b05      	ldr	r3, [sp, #20]
 800ac5a:	f1c3 031c 	rsb	r3, r3, #28
 800ac5e:	9303      	str	r3, [sp, #12]
    tmpc = c->dp + (c->used - 1);
 800ac60:	9b01      	ldr	r3, [sp, #4]
 800ac62:	68da      	ldr	r2, [r3, #12]
 800ac64:	9b01      	ldr	r3, [sp, #4]
 800ac66:	681b      	ldr	r3, [r3, #0]
 800ac68:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800ac6c:	3b01      	subs	r3, #1
 800ac6e:	009b      	lsls	r3, r3, #2
 800ac70:	4413      	add	r3, r2
 800ac72:	9307      	str	r3, [sp, #28]
    r = 0;
 800ac74:	2300      	movs	r3, #0
 800ac76:	9306      	str	r3, [sp, #24]
    for (x = c->used - 1; x >= 0; x--) {
 800ac78:	9b01      	ldr	r3, [sp, #4]
 800ac7a:	681b      	ldr	r3, [r3, #0]
 800ac7c:	3b01      	subs	r3, #1
 800ac7e:	9300      	str	r3, [sp, #0]
 800ac80:	e017      	b.n	800acb2 <mp_rshb+0x72>
      rr = *tmpc & mask;
 800ac82:	9b07      	ldr	r3, [sp, #28]
 800ac84:	681a      	ldr	r2, [r3, #0]
 800ac86:	9b04      	ldr	r3, [sp, #16]
 800ac88:	4013      	ands	r3, r2
 800ac8a:	9302      	str	r3, [sp, #8]
      *tmpc = (*tmpc >> D) | (r << shift);
 800ac8c:	9b07      	ldr	r3, [sp, #28]
 800ac8e:	681a      	ldr	r2, [r3, #0]
 800ac90:	9b05      	ldr	r3, [sp, #20]
 800ac92:	40da      	lsrs	r2, r3
 800ac94:	9906      	ldr	r1, [sp, #24]
 800ac96:	9b03      	ldr	r3, [sp, #12]
 800ac98:	fa01 f303 	lsl.w	r3, r1, r3
 800ac9c:	431a      	orrs	r2, r3
 800ac9e:	9b07      	ldr	r3, [sp, #28]
 800aca0:	601a      	str	r2, [r3, #0]
      --tmpc;
 800aca2:	9b07      	ldr	r3, [sp, #28]
 800aca4:	3b04      	subs	r3, #4
 800aca6:	9307      	str	r3, [sp, #28]
      r = rr;
 800aca8:	9b02      	ldr	r3, [sp, #8]
 800acaa:	9306      	str	r3, [sp, #24]
    for (x = c->used - 1; x >= 0; x--) {
 800acac:	9b00      	ldr	r3, [sp, #0]
 800acae:	3b01      	subs	r3, #1
 800acb0:	9300      	str	r3, [sp, #0]
 800acb2:	9b00      	ldr	r3, [sp, #0]
 800acb4:	2b00      	cmp	r3, #0
 800acb6:	dae4      	bge.n	800ac82 <mp_rshb+0x42>
    mp_clamp(c);
 800acb8:	9801      	ldr	r0, [sp, #4]
 800acba:	f7ff ff79 	bl	800abb0 <mp_clamp>
}
 800acbe:	b009      	add	sp, #36	; 0x24
 800acc0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800acd0 <mp_rshd>:
{
 800acd0:	b500      	push	{lr}
 800acd2:	b087      	sub	sp, #28
 800acd4:	9001      	str	r0, [sp, #4]
 800acd6:	9100      	str	r1, [sp, #0]
  if (b <= 0) {
 800acd8:	9b00      	ldr	r3, [sp, #0]
 800acda:	2b00      	cmp	r3, #0
 800acdc:	dd3a      	ble.n	800ad54 <mp_rshd+0x84>
  if (a->used <= b) {
 800acde:	9b01      	ldr	r3, [sp, #4]
 800ace0:	681a      	ldr	r2, [r3, #0]
 800ace2:	9b00      	ldr	r3, [sp, #0]
 800ace4:	429a      	cmp	r2, r3
 800ace6:	dc03      	bgt.n	800acf0 <mp_rshd+0x20>
    mp_zero (a);
 800ace8:	9801      	ldr	r0, [sp, #4]
 800acea:	f7ff ff41 	bl	800ab70 <mp_zero>
 800acee:	e031      	b.n	800ad54 <mp_rshd+0x84>
    bottom = a->dp;
 800acf0:	9b01      	ldr	r3, [sp, #4]
 800acf2:	68db      	ldr	r3, [r3, #12]
 800acf4:	9304      	str	r3, [sp, #16]
    top = a->dp + b;
 800acf6:	9b01      	ldr	r3, [sp, #4]
 800acf8:	68da      	ldr	r2, [r3, #12]
 800acfa:	9b00      	ldr	r3, [sp, #0]
 800acfc:	009b      	lsls	r3, r3, #2
 800acfe:	4413      	add	r3, r2
 800ad00:	9303      	str	r3, [sp, #12]
    for (x = 0; x < (a->used - b); x++) {
 800ad02:	2300      	movs	r3, #0
 800ad04:	9305      	str	r3, [sp, #20]
 800ad06:	e00a      	b.n	800ad1e <mp_rshd+0x4e>
      *bottom++ = *top++;
 800ad08:	9b04      	ldr	r3, [sp, #16]
 800ad0a:	1d1a      	adds	r2, r3, #4
 800ad0c:	9204      	str	r2, [sp, #16]
 800ad0e:	9a03      	ldr	r2, [sp, #12]
 800ad10:	1d11      	adds	r1, r2, #4
 800ad12:	9103      	str	r1, [sp, #12]
 800ad14:	6812      	ldr	r2, [r2, #0]
 800ad16:	601a      	str	r2, [r3, #0]
    for (x = 0; x < (a->used - b); x++) {
 800ad18:	9b05      	ldr	r3, [sp, #20]
 800ad1a:	3301      	adds	r3, #1
 800ad1c:	9305      	str	r3, [sp, #20]
 800ad1e:	9b01      	ldr	r3, [sp, #4]
 800ad20:	681a      	ldr	r2, [r3, #0]
 800ad22:	9b00      	ldr	r3, [sp, #0]
 800ad24:	1ad2      	subs	r2, r2, r3
 800ad26:	9b05      	ldr	r3, [sp, #20]
 800ad28:	429a      	cmp	r2, r3
 800ad2a:	dced      	bgt.n	800ad08 <mp_rshd+0x38>
 800ad2c:	e007      	b.n	800ad3e <mp_rshd+0x6e>
      *bottom++ = 0;
 800ad2e:	9b04      	ldr	r3, [sp, #16]
 800ad30:	1d1a      	adds	r2, r3, #4
 800ad32:	9204      	str	r2, [sp, #16]
 800ad34:	2200      	movs	r2, #0
 800ad36:	601a      	str	r2, [r3, #0]
    for (; x < a->used; x++) {
 800ad38:	9b05      	ldr	r3, [sp, #20]
 800ad3a:	3301      	adds	r3, #1
 800ad3c:	9305      	str	r3, [sp, #20]
 800ad3e:	9b01      	ldr	r3, [sp, #4]
 800ad40:	681a      	ldr	r2, [r3, #0]
 800ad42:	9b05      	ldr	r3, [sp, #20]
 800ad44:	429a      	cmp	r2, r3
 800ad46:	dcf2      	bgt.n	800ad2e <mp_rshd+0x5e>
  a->used -= b;
 800ad48:	9b01      	ldr	r3, [sp, #4]
 800ad4a:	681a      	ldr	r2, [r3, #0]
 800ad4c:	9b00      	ldr	r3, [sp, #0]
 800ad4e:	1ad2      	subs	r2, r2, r3
 800ad50:	9b01      	ldr	r3, [sp, #4]
 800ad52:	601a      	str	r2, [r3, #0]
}
 800ad54:	b007      	add	sp, #28
 800ad56:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad5a:	bf00      	nop
 800ad5c:	0000      	movs	r0, r0
	...

0800ad60 <mp_mod_2d>:
{
 800ad60:	b510      	push	{r4, lr}
 800ad62:	b086      	sub	sp, #24
 800ad64:	9003      	str	r0, [sp, #12]
 800ad66:	9102      	str	r1, [sp, #8]
 800ad68:	9201      	str	r2, [sp, #4]
  if (b <= 0) {
 800ad6a:	9b02      	ldr	r3, [sp, #8]
 800ad6c:	2b00      	cmp	r3, #0
 800ad6e:	dc04      	bgt.n	800ad7a <mp_mod_2d+0x1a>
    mp_zero (c);
 800ad70:	9801      	ldr	r0, [sp, #4]
 800ad72:	f7ff fefd 	bl	800ab70 <mp_zero>
    return MP_OKAY;
 800ad76:	2300      	movs	r3, #0
 800ad78:	e06d      	b.n	800ae56 <mp_mod_2d+0xf6>
  if (b >= (int) (a->used * DIGIT_BIT)) {
 800ad7a:	9b03      	ldr	r3, [sp, #12]
 800ad7c:	681a      	ldr	r2, [r3, #0]
 800ad7e:	4613      	mov	r3, r2
 800ad80:	00db      	lsls	r3, r3, #3
 800ad82:	1a9b      	subs	r3, r3, r2
 800ad84:	009b      	lsls	r3, r3, #2
 800ad86:	461a      	mov	r2, r3
 800ad88:	9b02      	ldr	r3, [sp, #8]
 800ad8a:	429a      	cmp	r2, r3
 800ad8c:	dc06      	bgt.n	800ad9c <mp_mod_2d+0x3c>
    res = mp_copy (a, c);
 800ad8e:	9901      	ldr	r1, [sp, #4]
 800ad90:	9803      	ldr	r0, [sp, #12]
 800ad92:	f7ff fdc5 	bl	800a920 <mp_copy>
 800ad96:	9004      	str	r0, [sp, #16]
    return res;
 800ad98:	9b04      	ldr	r3, [sp, #16]
 800ad9a:	e05c      	b.n	800ae56 <mp_mod_2d+0xf6>
  if ((res = mp_copy (a, c)) != MP_OKAY) {
 800ad9c:	9901      	ldr	r1, [sp, #4]
 800ad9e:	9803      	ldr	r0, [sp, #12]
 800ada0:	f7ff fdbe 	bl	800a920 <mp_copy>
 800ada4:	9004      	str	r0, [sp, #16]
 800ada6:	9b04      	ldr	r3, [sp, #16]
 800ada8:	2b00      	cmp	r3, #0
 800adaa:	d001      	beq.n	800adb0 <mp_mod_2d+0x50>
    return res;
 800adac:	9b04      	ldr	r3, [sp, #16]
 800adae:	e052      	b.n	800ae56 <mp_mod_2d+0xf6>
  for (x = (b / DIGIT_BIT) + ((b % DIGIT_BIT) == 0 ? 0 : 1); x < c->used; x++) {
 800adb0:	9b02      	ldr	r3, [sp, #8]
 800adb2:	4a2a      	ldr	r2, [pc, #168]	; (800ae5c <mp_mod_2d+0xfc>)
 800adb4:	fb82 1203 	smull	r1, r2, r2, r3
 800adb8:	441a      	add	r2, r3
 800adba:	1112      	asrs	r2, r2, #4
 800adbc:	17db      	asrs	r3, r3, #31
 800adbe:	1ad0      	subs	r0, r2, r3
 800adc0:	9a02      	ldr	r2, [sp, #8]
 800adc2:	4b26      	ldr	r3, [pc, #152]	; (800ae5c <mp_mod_2d+0xfc>)
 800adc4:	fb83 1302 	smull	r1, r3, r3, r2
 800adc8:	4413      	add	r3, r2
 800adca:	1119      	asrs	r1, r3, #4
 800adcc:	17d3      	asrs	r3, r2, #31
 800adce:	1ac9      	subs	r1, r1, r3
 800add0:	460b      	mov	r3, r1
 800add2:	00db      	lsls	r3, r3, #3
 800add4:	1a5b      	subs	r3, r3, r1
 800add6:	009b      	lsls	r3, r3, #2
 800add8:	1ad1      	subs	r1, r2, r3
 800adda:	2900      	cmp	r1, #0
 800addc:	bf14      	ite	ne
 800adde:	2301      	movne	r3, #1
 800ade0:	2300      	moveq	r3, #0
 800ade2:	b2db      	uxtb	r3, r3
 800ade4:	4403      	add	r3, r0
 800ade6:	9305      	str	r3, [sp, #20]
 800ade8:	e009      	b.n	800adfe <mp_mod_2d+0x9e>
    c->dp[x] = 0;
 800adea:	9b01      	ldr	r3, [sp, #4]
 800adec:	68da      	ldr	r2, [r3, #12]
 800adee:	9b05      	ldr	r3, [sp, #20]
 800adf0:	009b      	lsls	r3, r3, #2
 800adf2:	4413      	add	r3, r2
 800adf4:	2200      	movs	r2, #0
 800adf6:	601a      	str	r2, [r3, #0]
  for (x = (b / DIGIT_BIT) + ((b % DIGIT_BIT) == 0 ? 0 : 1); x < c->used; x++) {
 800adf8:	9b05      	ldr	r3, [sp, #20]
 800adfa:	3301      	adds	r3, #1
 800adfc:	9305      	str	r3, [sp, #20]
 800adfe:	9b01      	ldr	r3, [sp, #4]
 800ae00:	681a      	ldr	r2, [r3, #0]
 800ae02:	9b05      	ldr	r3, [sp, #20]
 800ae04:	429a      	cmp	r2, r3
 800ae06:	dcf0      	bgt.n	800adea <mp_mod_2d+0x8a>
  c->dp[b / DIGIT_BIT] &= (mp_digit) ((((mp_digit) 1) <<
 800ae08:	9b01      	ldr	r3, [sp, #4]
 800ae0a:	68da      	ldr	r2, [r3, #12]
 800ae0c:	9b02      	ldr	r3, [sp, #8]
 800ae0e:	4913      	ldr	r1, [pc, #76]	; (800ae5c <mp_mod_2d+0xfc>)
 800ae10:	fb81 0103 	smull	r0, r1, r1, r3
 800ae14:	4419      	add	r1, r3
 800ae16:	1109      	asrs	r1, r1, #4
 800ae18:	17db      	asrs	r3, r3, #31
 800ae1a:	1ac9      	subs	r1, r1, r3
 800ae1c:	460b      	mov	r3, r1
 800ae1e:	009b      	lsls	r3, r3, #2
 800ae20:	18d0      	adds	r0, r2, r3
 800ae22:	9b01      	ldr	r3, [sp, #4]
 800ae24:	68da      	ldr	r2, [r3, #12]
 800ae26:	460b      	mov	r3, r1
 800ae28:	009b      	lsls	r3, r3, #2
 800ae2a:	4413      	add	r3, r2
 800ae2c:	681c      	ldr	r4, [r3, #0]
              (((mp_digit) b) % DIGIT_BIT)) - ((mp_digit) 1));
 800ae2e:	9a02      	ldr	r2, [sp, #8]
 800ae30:	0893      	lsrs	r3, r2, #2
 800ae32:	490b      	ldr	r1, [pc, #44]	; (800ae60 <mp_mod_2d+0x100>)
 800ae34:	fba1 3103 	umull	r3, r1, r1, r3
 800ae38:	460b      	mov	r3, r1
 800ae3a:	00db      	lsls	r3, r3, #3
 800ae3c:	1a5b      	subs	r3, r3, r1
 800ae3e:	009b      	lsls	r3, r3, #2
 800ae40:	1ad3      	subs	r3, r2, r3
  c->dp[b / DIGIT_BIT] &= (mp_digit) ((((mp_digit) 1) <<
 800ae42:	2201      	movs	r2, #1
 800ae44:	fa02 f303 	lsl.w	r3, r2, r3
 800ae48:	3b01      	subs	r3, #1
 800ae4a:	4023      	ands	r3, r4
 800ae4c:	6003      	str	r3, [r0, #0]
  mp_clamp (c);
 800ae4e:	9801      	ldr	r0, [sp, #4]
 800ae50:	f7ff feae 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 800ae54:	2300      	movs	r3, #0
}
 800ae56:	4618      	mov	r0, r3
 800ae58:	b006      	add	sp, #24
 800ae5a:	bd10      	pop	{r4, pc}
 800ae5c:	92492493 	.word	0x92492493
 800ae60:	24924925 	.word	0x24924925
	...

0800ae70 <mp_read_unsigned_bin>:
{
 800ae70:	b500      	push	{lr}
 800ae72:	b087      	sub	sp, #28
 800ae74:	9003      	str	r0, [sp, #12]
 800ae76:	9102      	str	r1, [sp, #8]
 800ae78:	9201      	str	r2, [sp, #4]
  if (a->alloc < 2) {
 800ae7a:	9b03      	ldr	r3, [sp, #12]
 800ae7c:	685b      	ldr	r3, [r3, #4]
 800ae7e:	2b01      	cmp	r3, #1
 800ae80:	dc09      	bgt.n	800ae96 <mp_read_unsigned_bin+0x26>
     if ((res = mp_grow(a, 2)) != MP_OKAY) {
 800ae82:	2102      	movs	r1, #2
 800ae84:	9803      	ldr	r0, [sp, #12]
 800ae86:	f7ff fdb3 	bl	800a9f0 <mp_grow>
 800ae8a:	9005      	str	r0, [sp, #20]
 800ae8c:	9b05      	ldr	r3, [sp, #20]
 800ae8e:	2b00      	cmp	r3, #0
 800ae90:	d001      	beq.n	800ae96 <mp_read_unsigned_bin+0x26>
        return res;
 800ae92:	9b05      	ldr	r3, [sp, #20]
 800ae94:	e027      	b.n	800aee6 <mp_read_unsigned_bin+0x76>
  mp_zero (a);
 800ae96:	9803      	ldr	r0, [sp, #12]
 800ae98:	f7ff fe6a 	bl	800ab70 <mp_zero>
 800ae9c:	e01a      	b.n	800aed4 <mp_read_unsigned_bin+0x64>
    if ((res = mp_mul_2d (a, 8, a)) != MP_OKAY) {
 800ae9e:	9a03      	ldr	r2, [sp, #12]
 800aea0:	2108      	movs	r1, #8
 800aea2:	9803      	ldr	r0, [sp, #12]
 800aea4:	f000 f824 	bl	800aef0 <mp_mul_2d>
 800aea8:	9005      	str	r0, [sp, #20]
 800aeaa:	9b05      	ldr	r3, [sp, #20]
 800aeac:	2b00      	cmp	r3, #0
 800aeae:	d001      	beq.n	800aeb4 <mp_read_unsigned_bin+0x44>
      return res;
 800aeb0:	9b05      	ldr	r3, [sp, #20]
 800aeb2:	e018      	b.n	800aee6 <mp_read_unsigned_bin+0x76>
      a->dp[0] |= *b++;
 800aeb4:	9b02      	ldr	r3, [sp, #8]
 800aeb6:	1c5a      	adds	r2, r3, #1
 800aeb8:	9202      	str	r2, [sp, #8]
 800aeba:	7819      	ldrb	r1, [r3, #0]
 800aebc:	9b03      	ldr	r3, [sp, #12]
 800aebe:	68db      	ldr	r3, [r3, #12]
 800aec0:	9a03      	ldr	r2, [sp, #12]
 800aec2:	68d2      	ldr	r2, [r2, #12]
 800aec4:	6812      	ldr	r2, [r2, #0]
 800aec6:	430a      	orrs	r2, r1
 800aec8:	601a      	str	r2, [r3, #0]
      a->used += 1;
 800aeca:	9b03      	ldr	r3, [sp, #12]
 800aecc:	681b      	ldr	r3, [r3, #0]
 800aece:	1c5a      	adds	r2, r3, #1
 800aed0:	9b03      	ldr	r3, [sp, #12]
 800aed2:	601a      	str	r2, [r3, #0]
  while (c-- > 0) {
 800aed4:	9b01      	ldr	r3, [sp, #4]
 800aed6:	1e5a      	subs	r2, r3, #1
 800aed8:	9201      	str	r2, [sp, #4]
 800aeda:	2b00      	cmp	r3, #0
 800aedc:	dcdf      	bgt.n	800ae9e <mp_read_unsigned_bin+0x2e>
  mp_clamp (a);
 800aede:	9803      	ldr	r0, [sp, #12]
 800aee0:	f7ff fe66 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 800aee4:	2300      	movs	r3, #0
}
 800aee6:	4618      	mov	r0, r3
 800aee8:	b007      	add	sp, #28
 800aeea:	f85d fb04 	ldr.w	pc, [sp], #4
 800aeee:	bf00      	nop

0800aef0 <mp_mul_2d>:
{
 800aef0:	b500      	push	{lr}
 800aef2:	b08d      	sub	sp, #52	; 0x34
 800aef4:	9003      	str	r0, [sp, #12]
 800aef6:	9102      	str	r1, [sp, #8]
 800aef8:	9201      	str	r2, [sp, #4]
  if (a != c) {
 800aefa:	9a03      	ldr	r2, [sp, #12]
 800aefc:	9b01      	ldr	r3, [sp, #4]
 800aefe:	429a      	cmp	r2, r3
 800af00:	d009      	beq.n	800af16 <mp_mul_2d+0x26>
     if ((res = mp_copy (a, c)) != MP_OKAY) {
 800af02:	9901      	ldr	r1, [sp, #4]
 800af04:	9803      	ldr	r0, [sp, #12]
 800af06:	f7ff fd0b 	bl	800a920 <mp_copy>
 800af0a:	9008      	str	r0, [sp, #32]
 800af0c:	9b08      	ldr	r3, [sp, #32]
 800af0e:	2b00      	cmp	r3, #0
 800af10:	d001      	beq.n	800af16 <mp_mul_2d+0x26>
       return res;
 800af12:	9b08      	ldr	r3, [sp, #32]
 800af14:	e08d      	b.n	800b032 <mp_mul_2d+0x142>
  if (c->alloc < (int)(c->used + b/DIGIT_BIT + 1)) {
 800af16:	9b01      	ldr	r3, [sp, #4]
 800af18:	685a      	ldr	r2, [r3, #4]
 800af1a:	9b01      	ldr	r3, [sp, #4]
 800af1c:	6819      	ldr	r1, [r3, #0]
 800af1e:	9b02      	ldr	r3, [sp, #8]
 800af20:	4846      	ldr	r0, [pc, #280]	; (800b03c <mp_mul_2d+0x14c>)
 800af22:	fb80 e003 	smull	lr, r0, r0, r3
 800af26:	4418      	add	r0, r3
 800af28:	1100      	asrs	r0, r0, #4
 800af2a:	17db      	asrs	r3, r3, #31
 800af2c:	1ac3      	subs	r3, r0, r3
 800af2e:	440b      	add	r3, r1
 800af30:	3301      	adds	r3, #1
 800af32:	429a      	cmp	r2, r3
 800af34:	da15      	bge.n	800af62 <mp_mul_2d+0x72>
     if ((res = mp_grow (c, c->used + b / DIGIT_BIT + 1)) != MP_OKAY) {
 800af36:	9b01      	ldr	r3, [sp, #4]
 800af38:	681a      	ldr	r2, [r3, #0]
 800af3a:	9b02      	ldr	r3, [sp, #8]
 800af3c:	493f      	ldr	r1, [pc, #252]	; (800b03c <mp_mul_2d+0x14c>)
 800af3e:	fb81 0103 	smull	r0, r1, r1, r3
 800af42:	4419      	add	r1, r3
 800af44:	1109      	asrs	r1, r1, #4
 800af46:	17db      	asrs	r3, r3, #31
 800af48:	1acb      	subs	r3, r1, r3
 800af4a:	4413      	add	r3, r2
 800af4c:	3301      	adds	r3, #1
 800af4e:	4619      	mov	r1, r3
 800af50:	9801      	ldr	r0, [sp, #4]
 800af52:	f7ff fd4d 	bl	800a9f0 <mp_grow>
 800af56:	9008      	str	r0, [sp, #32]
 800af58:	9b08      	ldr	r3, [sp, #32]
 800af5a:	2b00      	cmp	r3, #0
 800af5c:	d001      	beq.n	800af62 <mp_mul_2d+0x72>
       return res;
 800af5e:	9b08      	ldr	r3, [sp, #32]
 800af60:	e067      	b.n	800b032 <mp_mul_2d+0x142>
  if (b >= (int)DIGIT_BIT) {
 800af62:	9b02      	ldr	r3, [sp, #8]
 800af64:	2b1b      	cmp	r3, #27
 800af66:	dd11      	ble.n	800af8c <mp_mul_2d+0x9c>
    if ((res = mp_lshd (c, b / DIGIT_BIT)) != MP_OKAY) {
 800af68:	9b02      	ldr	r3, [sp, #8]
 800af6a:	4a34      	ldr	r2, [pc, #208]	; (800b03c <mp_mul_2d+0x14c>)
 800af6c:	fb82 1203 	smull	r1, r2, r2, r3
 800af70:	441a      	add	r2, r3
 800af72:	1112      	asrs	r2, r2, #4
 800af74:	17db      	asrs	r3, r3, #31
 800af76:	1ad3      	subs	r3, r2, r3
 800af78:	4619      	mov	r1, r3
 800af7a:	9801      	ldr	r0, [sp, #4]
 800af7c:	f000 f860 	bl	800b040 <mp_lshd>
 800af80:	9008      	str	r0, [sp, #32]
 800af82:	9b08      	ldr	r3, [sp, #32]
 800af84:	2b00      	cmp	r3, #0
 800af86:	d001      	beq.n	800af8c <mp_mul_2d+0x9c>
      return res;
 800af88:	9b08      	ldr	r3, [sp, #32]
 800af8a:	e052      	b.n	800b032 <mp_mul_2d+0x142>
  d = (mp_digit) (b % DIGIT_BIT);
 800af8c:	9a02      	ldr	r2, [sp, #8]
 800af8e:	4b2b      	ldr	r3, [pc, #172]	; (800b03c <mp_mul_2d+0x14c>)
 800af90:	fb83 1302 	smull	r1, r3, r3, r2
 800af94:	4413      	add	r3, r2
 800af96:	1119      	asrs	r1, r3, #4
 800af98:	17d3      	asrs	r3, r2, #31
 800af9a:	1ac9      	subs	r1, r1, r3
 800af9c:	460b      	mov	r3, r1
 800af9e:	00db      	lsls	r3, r3, #3
 800afa0:	1a5b      	subs	r3, r3, r1
 800afa2:	009b      	lsls	r3, r3, #2
 800afa4:	1ad1      	subs	r1, r2, r3
 800afa6:	9107      	str	r1, [sp, #28]
  if (d != 0) {
 800afa8:	9b07      	ldr	r3, [sp, #28]
 800afaa:	2b00      	cmp	r3, #0
 800afac:	d03d      	beq.n	800b02a <mp_mul_2d+0x13a>
    mask = (((mp_digit)1) << d) - 1;
 800afae:	2201      	movs	r2, #1
 800afb0:	9b07      	ldr	r3, [sp, #28]
 800afb2:	fa02 f303 	lsl.w	r3, r2, r3
 800afb6:	3b01      	subs	r3, #1
 800afb8:	9306      	str	r3, [sp, #24]
    shift = DIGIT_BIT - d;
 800afba:	9b07      	ldr	r3, [sp, #28]
 800afbc:	f1c3 031c 	rsb	r3, r3, #28
 800afc0:	9305      	str	r3, [sp, #20]
    tmpc = c->dp;
 800afc2:	9b01      	ldr	r3, [sp, #4]
 800afc4:	68db      	ldr	r3, [r3, #12]
 800afc6:	930b      	str	r3, [sp, #44]	; 0x2c
    r    = 0;
 800afc8:	2300      	movs	r3, #0
 800afca:	930a      	str	r3, [sp, #40]	; 0x28
    for (x = 0; x < c->used; x++) {
 800afcc:	2300      	movs	r3, #0
 800afce:	9309      	str	r3, [sp, #36]	; 0x24
 800afd0:	e018      	b.n	800b004 <mp_mul_2d+0x114>
      rr = (*tmpc >> shift) & mask;
 800afd2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800afd4:	681a      	ldr	r2, [r3, #0]
 800afd6:	9b05      	ldr	r3, [sp, #20]
 800afd8:	40da      	lsrs	r2, r3
 800afda:	9b06      	ldr	r3, [sp, #24]
 800afdc:	4013      	ands	r3, r2
 800afde:	9304      	str	r3, [sp, #16]
      *tmpc = (mp_digit)(((*tmpc << d) | r) & MP_MASK);
 800afe0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800afe2:	681a      	ldr	r2, [r3, #0]
 800afe4:	9b07      	ldr	r3, [sp, #28]
 800afe6:	409a      	lsls	r2, r3
 800afe8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800afea:	4313      	orrs	r3, r2
 800afec:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 800aff0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800aff2:	601a      	str	r2, [r3, #0]
      ++tmpc;
 800aff4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800aff6:	3304      	adds	r3, #4
 800aff8:	930b      	str	r3, [sp, #44]	; 0x2c
      r = rr;
 800affa:	9b04      	ldr	r3, [sp, #16]
 800affc:	930a      	str	r3, [sp, #40]	; 0x28
    for (x = 0; x < c->used; x++) {
 800affe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b000:	3301      	adds	r3, #1
 800b002:	9309      	str	r3, [sp, #36]	; 0x24
 800b004:	9b01      	ldr	r3, [sp, #4]
 800b006:	681a      	ldr	r2, [r3, #0]
 800b008:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b00a:	429a      	cmp	r2, r3
 800b00c:	dce1      	bgt.n	800afd2 <mp_mul_2d+0xe2>
    if (r != 0) {
 800b00e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800b010:	2b00      	cmp	r3, #0
 800b012:	d00a      	beq.n	800b02a <mp_mul_2d+0x13a>
       c->dp[(c->used)++] = r;
 800b014:	9b01      	ldr	r3, [sp, #4]
 800b016:	68da      	ldr	r2, [r3, #12]
 800b018:	9b01      	ldr	r3, [sp, #4]
 800b01a:	681b      	ldr	r3, [r3, #0]
 800b01c:	1c58      	adds	r0, r3, #1
 800b01e:	9901      	ldr	r1, [sp, #4]
 800b020:	6008      	str	r0, [r1, #0]
 800b022:	009b      	lsls	r3, r3, #2
 800b024:	4413      	add	r3, r2
 800b026:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800b028:	601a      	str	r2, [r3, #0]
  mp_clamp (c);
 800b02a:	9801      	ldr	r0, [sp, #4]
 800b02c:	f7ff fdc0 	bl	800abb0 <mp_clamp>
  return MP_OKAY;
 800b030:	2300      	movs	r3, #0
}
 800b032:	4618      	mov	r0, r3
 800b034:	b00d      	add	sp, #52	; 0x34
 800b036:	f85d fb04 	ldr.w	pc, [sp], #4
 800b03a:	bf00      	nop
 800b03c:	92492493 	.word	0x92492493

0800b040 <mp_lshd>:
{
 800b040:	b500      	push	{lr}
 800b042:	b087      	sub	sp, #28
 800b044:	9001      	str	r0, [sp, #4]
 800b046:	9100      	str	r1, [sp, #0]
  if (b <= 0) {
 800b048:	9b00      	ldr	r3, [sp, #0]
 800b04a:	2b00      	cmp	r3, #0
 800b04c:	dc01      	bgt.n	800b052 <mp_lshd+0x12>
    return MP_OKAY;
 800b04e:	2300      	movs	r3, #0
 800b050:	e059      	b.n	800b106 <mp_lshd+0xc6>
  if (a->alloc < a->used + b) {
 800b052:	9b01      	ldr	r3, [sp, #4]
 800b054:	685a      	ldr	r2, [r3, #4]
 800b056:	9b01      	ldr	r3, [sp, #4]
 800b058:	6819      	ldr	r1, [r3, #0]
 800b05a:	9b00      	ldr	r3, [sp, #0]
 800b05c:	440b      	add	r3, r1
 800b05e:	429a      	cmp	r2, r3
 800b060:	da0d      	bge.n	800b07e <mp_lshd+0x3e>
     if ((res = mp_grow (a, a->used + b)) != MP_OKAY) {
 800b062:	9b01      	ldr	r3, [sp, #4]
 800b064:	681a      	ldr	r2, [r3, #0]
 800b066:	9b00      	ldr	r3, [sp, #0]
 800b068:	4413      	add	r3, r2
 800b06a:	4619      	mov	r1, r3
 800b06c:	9801      	ldr	r0, [sp, #4]
 800b06e:	f7ff fcbf 	bl	800a9f0 <mp_grow>
 800b072:	9002      	str	r0, [sp, #8]
 800b074:	9b02      	ldr	r3, [sp, #8]
 800b076:	2b00      	cmp	r3, #0
 800b078:	d001      	beq.n	800b07e <mp_lshd+0x3e>
       return res;
 800b07a:	9b02      	ldr	r3, [sp, #8]
 800b07c:	e043      	b.n	800b106 <mp_lshd+0xc6>
    a->used += b;
 800b07e:	9b01      	ldr	r3, [sp, #4]
 800b080:	681a      	ldr	r2, [r3, #0]
 800b082:	9b00      	ldr	r3, [sp, #0]
 800b084:	441a      	add	r2, r3
 800b086:	9b01      	ldr	r3, [sp, #4]
 800b088:	601a      	str	r2, [r3, #0]
    top = a->dp + a->used - 1;
 800b08a:	9b01      	ldr	r3, [sp, #4]
 800b08c:	68da      	ldr	r2, [r3, #12]
 800b08e:	9b01      	ldr	r3, [sp, #4]
 800b090:	681b      	ldr	r3, [r3, #0]
 800b092:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800b096:	3b01      	subs	r3, #1
 800b098:	009b      	lsls	r3, r3, #2
 800b09a:	4413      	add	r3, r2
 800b09c:	9304      	str	r3, [sp, #16]
    bottom = a->dp + a->used - 1 - b;
 800b09e:	9b01      	ldr	r3, [sp, #4]
 800b0a0:	68da      	ldr	r2, [r3, #12]
 800b0a2:	9b01      	ldr	r3, [sp, #4]
 800b0a4:	681b      	ldr	r3, [r3, #0]
 800b0a6:	4619      	mov	r1, r3
 800b0a8:	9b00      	ldr	r3, [sp, #0]
 800b0aa:	1acb      	subs	r3, r1, r3
 800b0ac:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800b0b0:	3b01      	subs	r3, #1
 800b0b2:	009b      	lsls	r3, r3, #2
 800b0b4:	4413      	add	r3, r2
 800b0b6:	9303      	str	r3, [sp, #12]
    for (x = a->used - 1; x >= b; x--) {
 800b0b8:	9b01      	ldr	r3, [sp, #4]
 800b0ba:	681b      	ldr	r3, [r3, #0]
 800b0bc:	3b01      	subs	r3, #1
 800b0be:	9305      	str	r3, [sp, #20]
 800b0c0:	e00a      	b.n	800b0d8 <mp_lshd+0x98>
      *top-- = *bottom--;
 800b0c2:	9b04      	ldr	r3, [sp, #16]
 800b0c4:	1f1a      	subs	r2, r3, #4
 800b0c6:	9204      	str	r2, [sp, #16]
 800b0c8:	9a03      	ldr	r2, [sp, #12]
 800b0ca:	1f11      	subs	r1, r2, #4
 800b0cc:	9103      	str	r1, [sp, #12]
 800b0ce:	6812      	ldr	r2, [r2, #0]
 800b0d0:	601a      	str	r2, [r3, #0]
    for (x = a->used - 1; x >= b; x--) {
 800b0d2:	9b05      	ldr	r3, [sp, #20]
 800b0d4:	3b01      	subs	r3, #1
 800b0d6:	9305      	str	r3, [sp, #20]
 800b0d8:	9a05      	ldr	r2, [sp, #20]
 800b0da:	9b00      	ldr	r3, [sp, #0]
 800b0dc:	429a      	cmp	r2, r3
 800b0de:	daf0      	bge.n	800b0c2 <mp_lshd+0x82>
    top = a->dp;
 800b0e0:	9b01      	ldr	r3, [sp, #4]
 800b0e2:	68db      	ldr	r3, [r3, #12]
 800b0e4:	9304      	str	r3, [sp, #16]
    for (x = 0; x < b; x++) {
 800b0e6:	2300      	movs	r3, #0
 800b0e8:	9305      	str	r3, [sp, #20]
 800b0ea:	e007      	b.n	800b0fc <mp_lshd+0xbc>
      *top++ = 0;
 800b0ec:	9b04      	ldr	r3, [sp, #16]
 800b0ee:	1d1a      	adds	r2, r3, #4
 800b0f0:	9204      	str	r2, [sp, #16]
 800b0f2:	2200      	movs	r2, #0
 800b0f4:	601a      	str	r2, [r3, #0]
    for (x = 0; x < b; x++) {
 800b0f6:	9b05      	ldr	r3, [sp, #20]
 800b0f8:	3301      	adds	r3, #1
 800b0fa:	9305      	str	r3, [sp, #20]
 800b0fc:	9a05      	ldr	r2, [sp, #20]
 800b0fe:	9b00      	ldr	r3, [sp, #0]
 800b100:	429a      	cmp	r2, r3
 800b102:	dbf3      	blt.n	800b0ec <mp_lshd+0xac>
  return MP_OKAY;
 800b104:	2300      	movs	r3, #0
}
 800b106:	4618      	mov	r0, r3
 800b108:	b007      	add	sp, #28
 800b10a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b10e:	bf00      	nop

0800b110 <mp_exptmod>:
{
 800b110:	b500      	push	{lr}
 800b112:	b091      	sub	sp, #68	; 0x44
 800b114:	9005      	str	r0, [sp, #20]
 800b116:	9104      	str	r1, [sp, #16]
 800b118:	9203      	str	r2, [sp, #12]
 800b11a:	9302      	str	r3, [sp, #8]
  if (P->sign == MP_NEG) {
 800b11c:	9b03      	ldr	r3, [sp, #12]
 800b11e:	689b      	ldr	r3, [r3, #8]
 800b120:	2b01      	cmp	r3, #1
 800b122:	d102      	bne.n	800b12a <mp_exptmod+0x1a>
     return MP_VAL;
 800b124:	f06f 0302 	mvn.w	r3, #2
 800b128:	e092      	b.n	800b250 <mp_exptmod+0x140>
  if (X->sign == MP_NEG) {
 800b12a:	9b04      	ldr	r3, [sp, #16]
 800b12c:	689b      	ldr	r3, [r3, #8]
 800b12e:	2b01      	cmp	r3, #1
 800b130:	d14b      	bne.n	800b1ca <mp_exptmod+0xba>
     if ((err = mp_init(&tmpG)) != MP_OKAY) {
 800b132:	ab0a      	add	r3, sp, #40	; 0x28
 800b134:	4618      	mov	r0, r3
 800b136:	f7ff fa63 	bl	800a600 <mp_init>
 800b13a:	900e      	str	r0, [sp, #56]	; 0x38
 800b13c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b13e:	2b00      	cmp	r3, #0
 800b140:	d001      	beq.n	800b146 <mp_exptmod+0x36>
        return err;
 800b142:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b144:	e084      	b.n	800b250 <mp_exptmod+0x140>
     if ((err = mp_invmod(G, P, &tmpG)) != MP_OKAY) {
 800b146:	ab0a      	add	r3, sp, #40	; 0x28
 800b148:	461a      	mov	r2, r3
 800b14a:	9903      	ldr	r1, [sp, #12]
 800b14c:	9805      	ldr	r0, [sp, #20]
 800b14e:	f000 f8a7 	bl	800b2a0 <mp_invmod>
 800b152:	900e      	str	r0, [sp, #56]	; 0x38
 800b154:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b156:	2b00      	cmp	r3, #0
 800b158:	d005      	beq.n	800b166 <mp_exptmod+0x56>
        mp_clear(&tmpG);
 800b15a:	ab0a      	add	r3, sp, #40	; 0x28
 800b15c:	4618      	mov	r0, r3
 800b15e:	f7ff fa67 	bl	800a630 <mp_clear>
        return err;
 800b162:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b164:	e074      	b.n	800b250 <mp_exptmod+0x140>
     if ((err = mp_init(&tmpX)) != MP_OKAY) {
 800b166:	ab06      	add	r3, sp, #24
 800b168:	4618      	mov	r0, r3
 800b16a:	f7ff fa49 	bl	800a600 <mp_init>
 800b16e:	900e      	str	r0, [sp, #56]	; 0x38
 800b170:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b172:	2b00      	cmp	r3, #0
 800b174:	d005      	beq.n	800b182 <mp_exptmod+0x72>
        mp_clear(&tmpG);
 800b176:	ab0a      	add	r3, sp, #40	; 0x28
 800b178:	4618      	mov	r0, r3
 800b17a:	f7ff fa59 	bl	800a630 <mp_clear>
        return err;
 800b17e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b180:	e066      	b.n	800b250 <mp_exptmod+0x140>
     if ((err = mp_abs(X, &tmpX)) != MP_OKAY) {
 800b182:	ab06      	add	r3, sp, #24
 800b184:	4619      	mov	r1, r3
 800b186:	9804      	ldr	r0, [sp, #16]
 800b188:	f000 f86a 	bl	800b260 <mp_abs>
 800b18c:	900e      	str	r0, [sp, #56]	; 0x38
 800b18e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b190:	2b00      	cmp	r3, #0
 800b192:	d009      	beq.n	800b1a8 <mp_exptmod+0x98>
        mp_clear(&tmpG);
 800b194:	ab0a      	add	r3, sp, #40	; 0x28
 800b196:	4618      	mov	r0, r3
 800b198:	f7ff fa4a 	bl	800a630 <mp_clear>
        mp_clear(&tmpX);
 800b19c:	ab06      	add	r3, sp, #24
 800b19e:	4618      	mov	r0, r3
 800b1a0:	f7ff fa46 	bl	800a630 <mp_clear>
        return err;
 800b1a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b1a6:	e053      	b.n	800b250 <mp_exptmod+0x140>
     err = mp_exptmod(&tmpG, &tmpX, P, Y);
 800b1a8:	a906      	add	r1, sp, #24
 800b1aa:	a80a      	add	r0, sp, #40	; 0x28
 800b1ac:	9b02      	ldr	r3, [sp, #8]
 800b1ae:	9a03      	ldr	r2, [sp, #12]
 800b1b0:	f7ff ffae 	bl	800b110 <mp_exptmod>
 800b1b4:	900e      	str	r0, [sp, #56]	; 0x38
     mp_clear(&tmpG);
 800b1b6:	ab0a      	add	r3, sp, #40	; 0x28
 800b1b8:	4618      	mov	r0, r3
 800b1ba:	f7ff fa39 	bl	800a630 <mp_clear>
     mp_clear(&tmpX);
 800b1be:	ab06      	add	r3, sp, #24
 800b1c0:	4618      	mov	r0, r3
 800b1c2:	f7ff fa35 	bl	800a630 <mp_clear>
     return err;
 800b1c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b1c8:	e042      	b.n	800b250 <mp_exptmod+0x140>
  if (mp_reduce_is_2k_l(P) == MP_YES) {
 800b1ca:	9803      	ldr	r0, [sp, #12]
 800b1cc:	f7fc ff58 	bl	8008080 <mp_reduce_is_2k_l>
 800b1d0:	4603      	mov	r3, r0
 800b1d2:	2b01      	cmp	r3, #1
 800b1d4:	d109      	bne.n	800b1ea <mp_exptmod+0xda>
     return s_mp_exptmod(G, X, P, Y, 1);
 800b1d6:	2301      	movs	r3, #1
 800b1d8:	9300      	str	r3, [sp, #0]
 800b1da:	9b02      	ldr	r3, [sp, #8]
 800b1dc:	9a03      	ldr	r2, [sp, #12]
 800b1de:	9904      	ldr	r1, [sp, #16]
 800b1e0:	9805      	ldr	r0, [sp, #20]
 800b1e2:	f7fe fcd5 	bl	8009b90 <s_mp_exptmod>
 800b1e6:	4603      	mov	r3, r0
 800b1e8:	e032      	b.n	800b250 <mp_exptmod+0x140>
  dr = mp_dr_is_modulus(P);
 800b1ea:	9803      	ldr	r0, [sp, #12]
 800b1ec:	f7fc ffd0 	bl	8008190 <mp_dr_is_modulus>
 800b1f0:	900f      	str	r0, [sp, #60]	; 0x3c
  if (dr == 0) {
 800b1f2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b1f4:	2b00      	cmp	r3, #0
 800b1f6:	d105      	bne.n	800b204 <mp_exptmod+0xf4>
     dr = mp_reduce_is_2k(P) << 1;
 800b1f8:	9803      	ldr	r0, [sp, #12]
 800b1fa:	f7fc ff81 	bl	8008100 <mp_reduce_is_2k>
 800b1fe:	4603      	mov	r3, r0
 800b200:	005b      	lsls	r3, r3, #1
 800b202:	930f      	str	r3, [sp, #60]	; 0x3c
  if (mp_isodd (P) == MP_YES || dr !=  0) {
 800b204:	9b03      	ldr	r3, [sp, #12]
 800b206:	681b      	ldr	r3, [r3, #0]
 800b208:	2b00      	cmp	r3, #0
 800b20a:	dd08      	ble.n	800b21e <mp_exptmod+0x10e>
 800b20c:	9b03      	ldr	r3, [sp, #12]
 800b20e:	68db      	ldr	r3, [r3, #12]
 800b210:	681b      	ldr	r3, [r3, #0]
 800b212:	f003 0301 	and.w	r3, r3, #1
 800b216:	2b00      	cmp	r3, #0
 800b218:	d001      	beq.n	800b21e <mp_exptmod+0x10e>
 800b21a:	2301      	movs	r3, #1
 800b21c:	e000      	b.n	800b220 <mp_exptmod+0x110>
 800b21e:	2300      	movs	r3, #0
 800b220:	2b01      	cmp	r3, #1
 800b222:	d002      	beq.n	800b22a <mp_exptmod+0x11a>
 800b224:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b226:	2b00      	cmp	r3, #0
 800b228:	d009      	beq.n	800b23e <mp_exptmod+0x12e>
    return mp_exptmod_fast (G, X, P, Y, dr);
 800b22a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b22c:	9300      	str	r3, [sp, #0]
 800b22e:	9b02      	ldr	r3, [sp, #8]
 800b230:	9a03      	ldr	r2, [sp, #12]
 800b232:	9904      	ldr	r1, [sp, #16]
 800b234:	9805      	ldr	r0, [sp, #20]
 800b236:	f7fc ffd3 	bl	80081e0 <mp_exptmod_fast>
 800b23a:	4603      	mov	r3, r0
 800b23c:	e008      	b.n	800b250 <mp_exptmod+0x140>
    return s_mp_exptmod (G, X, P, Y, 0);
 800b23e:	2300      	movs	r3, #0
 800b240:	9300      	str	r3, [sp, #0]
 800b242:	9b02      	ldr	r3, [sp, #8]
 800b244:	9a03      	ldr	r2, [sp, #12]
 800b246:	9904      	ldr	r1, [sp, #16]
 800b248:	9805      	ldr	r0, [sp, #20]
 800b24a:	f7fe fca1 	bl	8009b90 <s_mp_exptmod>
 800b24e:	4603      	mov	r3, r0
}
 800b250:	4618      	mov	r0, r3
 800b252:	b011      	add	sp, #68	; 0x44
 800b254:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800b260 <mp_abs>:
{
 800b260:	b500      	push	{lr}
 800b262:	b085      	sub	sp, #20
 800b264:	9001      	str	r0, [sp, #4]
 800b266:	9100      	str	r1, [sp, #0]
  if (a != b) {
 800b268:	9a01      	ldr	r2, [sp, #4]
 800b26a:	9b00      	ldr	r3, [sp, #0]
 800b26c:	429a      	cmp	r2, r3
 800b26e:	d009      	beq.n	800b284 <mp_abs+0x24>
     if ((res = mp_copy (a, b)) != MP_OKAY) {
 800b270:	9900      	ldr	r1, [sp, #0]
 800b272:	9801      	ldr	r0, [sp, #4]
 800b274:	f7ff fb54 	bl	800a920 <mp_copy>
 800b278:	9003      	str	r0, [sp, #12]
 800b27a:	9b03      	ldr	r3, [sp, #12]
 800b27c:	2b00      	cmp	r3, #0
 800b27e:	d001      	beq.n	800b284 <mp_abs+0x24>
       return res;
 800b280:	9b03      	ldr	r3, [sp, #12]
 800b282:	e003      	b.n	800b28c <mp_abs+0x2c>
  b->sign = MP_ZPOS;
 800b284:	9b00      	ldr	r3, [sp, #0]
 800b286:	2200      	movs	r2, #0
 800b288:	609a      	str	r2, [r3, #8]
  return MP_OKAY;
 800b28a:	2300      	movs	r3, #0
}
 800b28c:	4618      	mov	r0, r3
 800b28e:	b005      	add	sp, #20
 800b290:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800b2a0 <mp_invmod>:
{
 800b2a0:	b500      	push	{lr}
 800b2a2:	b085      	sub	sp, #20
 800b2a4:	9003      	str	r0, [sp, #12]
 800b2a6:	9102      	str	r1, [sp, #8]
 800b2a8:	9201      	str	r2, [sp, #4]
  if (b->sign == MP_NEG || mp_iszero(b) == MP_YES) {
 800b2aa:	9b02      	ldr	r3, [sp, #8]
 800b2ac:	689b      	ldr	r3, [r3, #8]
 800b2ae:	2b01      	cmp	r3, #1
 800b2b0:	d003      	beq.n	800b2ba <mp_invmod+0x1a>
 800b2b2:	9b02      	ldr	r3, [sp, #8]
 800b2b4:	681b      	ldr	r3, [r3, #0]
 800b2b6:	2b00      	cmp	r3, #0
 800b2b8:	d102      	bne.n	800b2c0 <mp_invmod+0x20>
    return MP_VAL;
 800b2ba:	f06f 0302 	mvn.w	r3, #2
 800b2be:	e023      	b.n	800b308 <mp_invmod+0x68>
  if ((mp_isodd(b) == MP_YES) && (mp_cmp_d(b, 1) != MP_EQ)) {
 800b2c0:	9b02      	ldr	r3, [sp, #8]
 800b2c2:	681b      	ldr	r3, [r3, #0]
 800b2c4:	2b00      	cmp	r3, #0
 800b2c6:	dd08      	ble.n	800b2da <mp_invmod+0x3a>
 800b2c8:	9b02      	ldr	r3, [sp, #8]
 800b2ca:	68db      	ldr	r3, [r3, #12]
 800b2cc:	681b      	ldr	r3, [r3, #0]
 800b2ce:	f003 0301 	and.w	r3, r3, #1
 800b2d2:	2b00      	cmp	r3, #0
 800b2d4:	d001      	beq.n	800b2da <mp_invmod+0x3a>
 800b2d6:	2301      	movs	r3, #1
 800b2d8:	e000      	b.n	800b2dc <mp_invmod+0x3c>
 800b2da:	2300      	movs	r3, #0
 800b2dc:	2b01      	cmp	r3, #1
 800b2de:	d10d      	bne.n	800b2fc <mp_invmod+0x5c>
 800b2e0:	2101      	movs	r1, #1
 800b2e2:	9802      	ldr	r0, [sp, #8]
 800b2e4:	f000 fc1c 	bl	800bb20 <mp_cmp_d>
 800b2e8:	4603      	mov	r3, r0
 800b2ea:	2b00      	cmp	r3, #0
 800b2ec:	d006      	beq.n	800b2fc <mp_invmod+0x5c>
    return fast_mp_invmod (a, b, c);
 800b2ee:	9a01      	ldr	r2, [sp, #4]
 800b2f0:	9902      	ldr	r1, [sp, #8]
 800b2f2:	9803      	ldr	r0, [sp, #12]
 800b2f4:	f000 f80c 	bl	800b310 <fast_mp_invmod>
 800b2f8:	4603      	mov	r3, r0
 800b2fa:	e005      	b.n	800b308 <mp_invmod+0x68>
  return mp_invmod_slow(a, b, c);
 800b2fc:	9a01      	ldr	r2, [sp, #4]
 800b2fe:	9902      	ldr	r1, [sp, #8]
 800b300:	9803      	ldr	r0, [sp, #12]
 800b302:	f000 f97d 	bl	800b600 <mp_invmod_slow>
 800b306:	4603      	mov	r3, r0
}
 800b308:	4618      	mov	r0, r3
 800b30a:	b005      	add	sp, #20
 800b30c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b310 <fast_mp_invmod>:
{
 800b310:	b510      	push	{r4, lr}
 800b312:	b0a2      	sub	sp, #136	; 0x88
 800b314:	9005      	str	r0, [sp, #20]
 800b316:	9104      	str	r1, [sp, #16]
 800b318:	9203      	str	r2, [sp, #12]
  int     res, neg, loop_check = 0;
 800b31a:	2300      	movs	r3, #0
 800b31c:	9320      	str	r3, [sp, #128]	; 0x80
  if (mp_iseven (b) == MP_YES) {
 800b31e:	9b04      	ldr	r3, [sp, #16]
 800b320:	681b      	ldr	r3, [r3, #0]
 800b322:	2b00      	cmp	r3, #0
 800b324:	dd08      	ble.n	800b338 <fast_mp_invmod+0x28>
 800b326:	9b04      	ldr	r3, [sp, #16]
 800b328:	68db      	ldr	r3, [r3, #12]
 800b32a:	681b      	ldr	r3, [r3, #0]
 800b32c:	f003 0301 	and.w	r3, r3, #1
 800b330:	2b00      	cmp	r3, #0
 800b332:	d101      	bne.n	800b338 <fast_mp_invmod+0x28>
 800b334:	2301      	movs	r3, #1
 800b336:	e000      	b.n	800b33a <fast_mp_invmod+0x2a>
 800b338:	2300      	movs	r3, #0
 800b33a:	2b01      	cmp	r3, #1
 800b33c:	d102      	bne.n	800b344 <fast_mp_invmod+0x34>
    return MP_VAL;
 800b33e:	f06f 0302 	mvn.w	r3, #2
 800b342:	e157      	b.n	800b5f4 <fast_mp_invmod+0x2e4>
  if ((res = mp_init_multi(&x, &y, &u, &v, &B, &D)) != MP_OKAY) {
 800b344:	ac0f      	add	r4, sp, #60	; 0x3c
 800b346:	aa13      	add	r2, sp, #76	; 0x4c
 800b348:	a917      	add	r1, sp, #92	; 0x5c
 800b34a:	a81b      	add	r0, sp, #108	; 0x6c
 800b34c:	ab07      	add	r3, sp, #28
 800b34e:	9301      	str	r3, [sp, #4]
 800b350:	ab0b      	add	r3, sp, #44	; 0x2c
 800b352:	9300      	str	r3, [sp, #0]
 800b354:	4623      	mov	r3, r4
 800b356:	f001 fb9b 	bl	800ca90 <mp_init_multi>
 800b35a:	9021      	str	r0, [sp, #132]	; 0x84
 800b35c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b35e:	2b00      	cmp	r3, #0
 800b360:	d001      	beq.n	800b366 <fast_mp_invmod+0x56>
     return res;
 800b362:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b364:	e146      	b.n	800b5f4 <fast_mp_invmod+0x2e4>
  if ((res = mp_copy (b, &x)) != MP_OKAY) {
 800b366:	ab1b      	add	r3, sp, #108	; 0x6c
 800b368:	4619      	mov	r1, r3
 800b36a:	9804      	ldr	r0, [sp, #16]
 800b36c:	f7ff fad8 	bl	800a920 <mp_copy>
 800b370:	9021      	str	r0, [sp, #132]	; 0x84
 800b372:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b374:	2b00      	cmp	r3, #0
 800b376:	f040 8124 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  if ((res = mp_mod (a, b, &y)) != MP_OKAY) {
 800b37a:	ab17      	add	r3, sp, #92	; 0x5c
 800b37c:	461a      	mov	r2, r3
 800b37e:	9904      	ldr	r1, [sp, #16]
 800b380:	9805      	ldr	r0, [sp, #20]
 800b382:	f000 fc2d 	bl	800bbe0 <mp_mod>
 800b386:	9021      	str	r0, [sp, #132]	; 0x84
 800b388:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b38a:	2b00      	cmp	r3, #0
 800b38c:	f040 8119 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  if ((res = mp_copy (&x, &u)) != MP_OKAY) {
 800b390:	aa13      	add	r2, sp, #76	; 0x4c
 800b392:	ab1b      	add	r3, sp, #108	; 0x6c
 800b394:	4611      	mov	r1, r2
 800b396:	4618      	mov	r0, r3
 800b398:	f7ff fac2 	bl	800a920 <mp_copy>
 800b39c:	9021      	str	r0, [sp, #132]	; 0x84
 800b39e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b3a0:	2b00      	cmp	r3, #0
 800b3a2:	f040 810e 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  if ((res = mp_copy (&y, &v)) != MP_OKAY) {
 800b3a6:	aa0f      	add	r2, sp, #60	; 0x3c
 800b3a8:	ab17      	add	r3, sp, #92	; 0x5c
 800b3aa:	4611      	mov	r1, r2
 800b3ac:	4618      	mov	r0, r3
 800b3ae:	f7ff fab7 	bl	800a920 <mp_copy>
 800b3b2:	9021      	str	r0, [sp, #132]	; 0x84
 800b3b4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b3b6:	2b00      	cmp	r3, #0
 800b3b8:	f040 8103 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  if ((res = mp_set (&D, 1)) != MP_OKAY) {
 800b3bc:	ab07      	add	r3, sp, #28
 800b3be:	2101      	movs	r1, #1
 800b3c0:	4618      	mov	r0, r3
 800b3c2:	f000 fbe5 	bl	800bb90 <mp_set>
 800b3c6:	9021      	str	r0, [sp, #132]	; 0x84
 800b3c8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b3ca:	2b00      	cmp	r3, #0
 800b3cc:	f040 80f9 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
 800b3d0:	e02e      	b.n	800b430 <fast_mp_invmod+0x120>
    if ((res = mp_div_2 (&u, &u)) != MP_OKAY) {
 800b3d2:	aa13      	add	r2, sp, #76	; 0x4c
 800b3d4:	ab13      	add	r3, sp, #76	; 0x4c
 800b3d6:	4611      	mov	r1, r2
 800b3d8:	4618      	mov	r0, r3
 800b3da:	f7fc fc31 	bl	8007c40 <mp_div_2>
 800b3de:	9021      	str	r0, [sp, #132]	; 0x84
 800b3e0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b3e2:	2b00      	cmp	r3, #0
 800b3e4:	f040 80ed 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
    if (mp_isodd (&B) == MP_YES) {
 800b3e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b3ea:	2b00      	cmp	r3, #0
 800b3ec:	dd07      	ble.n	800b3fe <fast_mp_invmod+0xee>
 800b3ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b3f0:	681b      	ldr	r3, [r3, #0]
 800b3f2:	f003 0301 	and.w	r3, r3, #1
 800b3f6:	2b00      	cmp	r3, #0
 800b3f8:	d001      	beq.n	800b3fe <fast_mp_invmod+0xee>
 800b3fa:	2301      	movs	r3, #1
 800b3fc:	e000      	b.n	800b400 <fast_mp_invmod+0xf0>
 800b3fe:	2300      	movs	r3, #0
 800b400:	2b01      	cmp	r3, #1
 800b402:	d10a      	bne.n	800b41a <fast_mp_invmod+0x10a>
      if ((res = mp_sub (&B, &x, &B)) != MP_OKAY) {
 800b404:	aa0b      	add	r2, sp, #44	; 0x2c
 800b406:	a91b      	add	r1, sp, #108	; 0x6c
 800b408:	ab0b      	add	r3, sp, #44	; 0x2c
 800b40a:	4618      	mov	r0, r3
 800b40c:	f7fc fdf8 	bl	8008000 <mp_sub>
 800b410:	9021      	str	r0, [sp, #132]	; 0x84
 800b412:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b414:	2b00      	cmp	r3, #0
 800b416:	f040 80d4 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
    if ((res = mp_div_2 (&B, &B)) != MP_OKAY) {
 800b41a:	aa0b      	add	r2, sp, #44	; 0x2c
 800b41c:	ab0b      	add	r3, sp, #44	; 0x2c
 800b41e:	4611      	mov	r1, r2
 800b420:	4618      	mov	r0, r3
 800b422:	f7fc fc0d 	bl	8007c40 <mp_div_2>
 800b426:	9021      	str	r0, [sp, #132]	; 0x84
 800b428:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b42a:	2b00      	cmp	r3, #0
 800b42c:	f040 80c9 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  while (mp_iseven (&u) == MP_YES) {
 800b430:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800b432:	2b00      	cmp	r3, #0
 800b434:	dd07      	ble.n	800b446 <fast_mp_invmod+0x136>
 800b436:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800b438:	681b      	ldr	r3, [r3, #0]
 800b43a:	f003 0301 	and.w	r3, r3, #1
 800b43e:	2b00      	cmp	r3, #0
 800b440:	d101      	bne.n	800b446 <fast_mp_invmod+0x136>
 800b442:	2301      	movs	r3, #1
 800b444:	e000      	b.n	800b448 <fast_mp_invmod+0x138>
 800b446:	2300      	movs	r3, #0
 800b448:	2b01      	cmp	r3, #1
 800b44a:	d0c2      	beq.n	800b3d2 <fast_mp_invmod+0xc2>
 800b44c:	e02e      	b.n	800b4ac <fast_mp_invmod+0x19c>
    if ((res = mp_div_2 (&v, &v)) != MP_OKAY) {
 800b44e:	aa0f      	add	r2, sp, #60	; 0x3c
 800b450:	ab0f      	add	r3, sp, #60	; 0x3c
 800b452:	4611      	mov	r1, r2
 800b454:	4618      	mov	r0, r3
 800b456:	f7fc fbf3 	bl	8007c40 <mp_div_2>
 800b45a:	9021      	str	r0, [sp, #132]	; 0x84
 800b45c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b45e:	2b00      	cmp	r3, #0
 800b460:	f040 80af 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
    if (mp_isodd (&D) == MP_YES) {
 800b464:	9b07      	ldr	r3, [sp, #28]
 800b466:	2b00      	cmp	r3, #0
 800b468:	dd07      	ble.n	800b47a <fast_mp_invmod+0x16a>
 800b46a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800b46c:	681b      	ldr	r3, [r3, #0]
 800b46e:	f003 0301 	and.w	r3, r3, #1
 800b472:	2b00      	cmp	r3, #0
 800b474:	d001      	beq.n	800b47a <fast_mp_invmod+0x16a>
 800b476:	2301      	movs	r3, #1
 800b478:	e000      	b.n	800b47c <fast_mp_invmod+0x16c>
 800b47a:	2300      	movs	r3, #0
 800b47c:	2b01      	cmp	r3, #1
 800b47e:	d10a      	bne.n	800b496 <fast_mp_invmod+0x186>
      if ((res = mp_sub (&D, &x, &D)) != MP_OKAY) {
 800b480:	aa07      	add	r2, sp, #28
 800b482:	a91b      	add	r1, sp, #108	; 0x6c
 800b484:	ab07      	add	r3, sp, #28
 800b486:	4618      	mov	r0, r3
 800b488:	f7fc fdba 	bl	8008000 <mp_sub>
 800b48c:	9021      	str	r0, [sp, #132]	; 0x84
 800b48e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b490:	2b00      	cmp	r3, #0
 800b492:	f040 8096 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
    if ((res = mp_div_2 (&D, &D)) != MP_OKAY) {
 800b496:	aa07      	add	r2, sp, #28
 800b498:	ab07      	add	r3, sp, #28
 800b49a:	4611      	mov	r1, r2
 800b49c:	4618      	mov	r0, r3
 800b49e:	f7fc fbcf 	bl	8007c40 <mp_div_2>
 800b4a2:	9021      	str	r0, [sp, #132]	; 0x84
 800b4a4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b4a6:	2b00      	cmp	r3, #0
 800b4a8:	f040 808b 	bne.w	800b5c2 <fast_mp_invmod+0x2b2>
  while (mp_iseven (&v) == MP_YES) {
 800b4ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b4ae:	2b00      	cmp	r3, #0
 800b4b0:	dd07      	ble.n	800b4c2 <fast_mp_invmod+0x1b2>
 800b4b2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800b4b4:	681b      	ldr	r3, [r3, #0]
 800b4b6:	f003 0301 	and.w	r3, r3, #1
 800b4ba:	2b00      	cmp	r3, #0
 800b4bc:	d101      	bne.n	800b4c2 <fast_mp_invmod+0x1b2>
 800b4be:	2301      	movs	r3, #1
 800b4c0:	e000      	b.n	800b4c4 <fast_mp_invmod+0x1b4>
 800b4c2:	2300      	movs	r3, #0
 800b4c4:	2b01      	cmp	r3, #1
 800b4c6:	d0c2      	beq.n	800b44e <fast_mp_invmod+0x13e>
  if (mp_cmp (&u, &v) != MP_LT) {
 800b4c8:	aa0f      	add	r2, sp, #60	; 0x3c
 800b4ca:	ab13      	add	r3, sp, #76	; 0x4c
 800b4cc:	4611      	mov	r1, r2
 800b4ce:	4618      	mov	r0, r3
 800b4d0:	f000 fafe 	bl	800bad0 <mp_cmp>
 800b4d4:	4603      	mov	r3, r0
 800b4d6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b4da:	d014      	beq.n	800b506 <fast_mp_invmod+0x1f6>
    if ((res = mp_sub (&u, &v, &u)) != MP_OKAY) {
 800b4dc:	aa13      	add	r2, sp, #76	; 0x4c
 800b4de:	a90f      	add	r1, sp, #60	; 0x3c
 800b4e0:	ab13      	add	r3, sp, #76	; 0x4c
 800b4e2:	4618      	mov	r0, r3
 800b4e4:	f7fc fd8c 	bl	8008000 <mp_sub>
 800b4e8:	9021      	str	r0, [sp, #132]	; 0x84
 800b4ea:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b4ec:	2b00      	cmp	r3, #0
 800b4ee:	d168      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
    if ((res = mp_sub (&B, &D, &B)) != MP_OKAY) {
 800b4f0:	aa0b      	add	r2, sp, #44	; 0x2c
 800b4f2:	a907      	add	r1, sp, #28
 800b4f4:	ab0b      	add	r3, sp, #44	; 0x2c
 800b4f6:	4618      	mov	r0, r3
 800b4f8:	f7fc fd82 	bl	8008000 <mp_sub>
 800b4fc:	9021      	str	r0, [sp, #132]	; 0x84
 800b4fe:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b500:	2b00      	cmp	r3, #0
 800b502:	d15e      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
 800b504:	e013      	b.n	800b52e <fast_mp_invmod+0x21e>
    if ((res = mp_sub (&v, &u, &v)) != MP_OKAY) {
 800b506:	aa0f      	add	r2, sp, #60	; 0x3c
 800b508:	a913      	add	r1, sp, #76	; 0x4c
 800b50a:	ab0f      	add	r3, sp, #60	; 0x3c
 800b50c:	4618      	mov	r0, r3
 800b50e:	f7fc fd77 	bl	8008000 <mp_sub>
 800b512:	9021      	str	r0, [sp, #132]	; 0x84
 800b514:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b516:	2b00      	cmp	r3, #0
 800b518:	d153      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
    if ((res = mp_sub (&D, &B, &D)) != MP_OKAY) {
 800b51a:	aa07      	add	r2, sp, #28
 800b51c:	a90b      	add	r1, sp, #44	; 0x2c
 800b51e:	ab07      	add	r3, sp, #28
 800b520:	4618      	mov	r0, r3
 800b522:	f7fc fd6d 	bl	8008000 <mp_sub>
 800b526:	9021      	str	r0, [sp, #132]	; 0x84
 800b528:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d149      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
  if (mp_iszero (&u) == MP_NO) {
 800b52e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800b530:	2b00      	cmp	r3, #0
 800b532:	d00b      	beq.n	800b54c <fast_mp_invmod+0x23c>
    if (++loop_check > MAX_INVMOD_SZ) {
 800b534:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800b536:	3301      	adds	r3, #1
 800b538:	9320      	str	r3, [sp, #128]	; 0x80
 800b53a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800b53c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800b540:	f77f af76 	ble.w	800b430 <fast_mp_invmod+0x120>
        res = MP_VAL;
 800b544:	f06f 0302 	mvn.w	r3, #2
 800b548:	9321      	str	r3, [sp, #132]	; 0x84
 800b54a:	e03a      	b.n	800b5c2 <fast_mp_invmod+0x2b2>
  if (mp_cmp_d (&v, 1) != MP_EQ) {
 800b54c:	ab0f      	add	r3, sp, #60	; 0x3c
 800b54e:	2101      	movs	r1, #1
 800b550:	4618      	mov	r0, r3
 800b552:	f000 fae5 	bl	800bb20 <mp_cmp_d>
 800b556:	4603      	mov	r3, r0
 800b558:	2b00      	cmp	r3, #0
 800b55a:	d003      	beq.n	800b564 <fast_mp_invmod+0x254>
    res = MP_VAL;
 800b55c:	f06f 0302 	mvn.w	r3, #2
 800b560:	9321      	str	r3, [sp, #132]	; 0x84
 800b562:	e02e      	b.n	800b5c2 <fast_mp_invmod+0x2b2>
  neg = a->sign;
 800b564:	9b05      	ldr	r3, [sp, #20]
 800b566:	689b      	ldr	r3, [r3, #8]
 800b568:	931f      	str	r3, [sp, #124]	; 0x7c
 800b56a:	e009      	b.n	800b580 <fast_mp_invmod+0x270>
    if ((res = mp_add (&D, b, &D)) != MP_OKAY) {
 800b56c:	aa07      	add	r2, sp, #28
 800b56e:	ab07      	add	r3, sp, #28
 800b570:	9904      	ldr	r1, [sp, #16]
 800b572:	4618      	mov	r0, r3
 800b574:	f7fc fbdc 	bl	8007d30 <mp_add>
 800b578:	9021      	str	r0, [sp, #132]	; 0x84
 800b57a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b57c:	2b00      	cmp	r3, #0
 800b57e:	d120      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
  while (D.sign == MP_NEG) {
 800b580:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b582:	2b01      	cmp	r3, #1
 800b584:	d0f2      	beq.n	800b56c <fast_mp_invmod+0x25c>
 800b586:	e009      	b.n	800b59c <fast_mp_invmod+0x28c>
      if ((res = mp_sub(&D, b, &D)) != MP_OKAY) {
 800b588:	aa07      	add	r2, sp, #28
 800b58a:	ab07      	add	r3, sp, #28
 800b58c:	9904      	ldr	r1, [sp, #16]
 800b58e:	4618      	mov	r0, r3
 800b590:	f7fc fd36 	bl	8008000 <mp_sub>
 800b594:	9021      	str	r0, [sp, #132]	; 0x84
 800b596:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800b598:	2b00      	cmp	r3, #0
 800b59a:	d112      	bne.n	800b5c2 <fast_mp_invmod+0x2b2>
  while (mp_cmp_mag(&D, b) != MP_LT) {
 800b59c:	ab07      	add	r3, sp, #28
 800b59e:	9904      	ldr	r1, [sp, #16]
 800b5a0:	4618      	mov	r0, r3
 800b5a2:	f000 fa45 	bl	800ba30 <mp_cmp_mag>
 800b5a6:	4603      	mov	r3, r0
 800b5a8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b5ac:	d1ec      	bne.n	800b588 <fast_mp_invmod+0x278>
  mp_exch (&D, c);
 800b5ae:	ab07      	add	r3, sp, #28
 800b5b0:	9903      	ldr	r1, [sp, #12]
 800b5b2:	4618      	mov	r0, r3
 800b5b4:	f7ff fb24 	bl	800ac00 <mp_exch>
  c->sign = neg;
 800b5b8:	9b03      	ldr	r3, [sp, #12]
 800b5ba:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 800b5bc:	609a      	str	r2, [r3, #8]
  res = MP_OKAY;
 800b5be:	2300      	movs	r3, #0
 800b5c0:	9321      	str	r3, [sp, #132]	; 0x84
LBL_ERR:mp_clear(&x);
 800b5c2:	ab1b      	add	r3, sp, #108	; 0x6c
 800b5c4:	4618      	mov	r0, r3
 800b5c6:	f7ff f833 	bl	800a630 <mp_clear>
        mp_clear(&y);
 800b5ca:	ab17      	add	r3, sp, #92	; 0x5c
 800b5cc:	4618      	mov	r0, r3
 800b5ce:	f7ff f82f 	bl	800a630 <mp_clear>
        mp_clear(&u);
 800b5d2:	ab13      	add	r3, sp, #76	; 0x4c
 800b5d4:	4618      	mov	r0, r3
 800b5d6:	f7ff f82b 	bl	800a630 <mp_clear>
        mp_clear(&v);
 800b5da:	ab0f      	add	r3, sp, #60	; 0x3c
 800b5dc:	4618      	mov	r0, r3
 800b5de:	f7ff f827 	bl	800a630 <mp_clear>
        mp_clear(&B);
 800b5e2:	ab0b      	add	r3, sp, #44	; 0x2c
 800b5e4:	4618      	mov	r0, r3
 800b5e6:	f7ff f823 	bl	800a630 <mp_clear>
        mp_clear(&D);
 800b5ea:	ab07      	add	r3, sp, #28
 800b5ec:	4618      	mov	r0, r3
 800b5ee:	f7ff f81f 	bl	800a630 <mp_clear>
  return res;
 800b5f2:	9b21      	ldr	r3, [sp, #132]	; 0x84
}
 800b5f4:	4618      	mov	r0, r3
 800b5f6:	b022      	add	sp, #136	; 0x88
 800b5f8:	bd10      	pop	{r4, pc}
 800b5fa:	bf00      	nop
 800b5fc:	0000      	movs	r0, r0
	...

0800b600 <mp_invmod_slow>:
{
 800b600:	b510      	push	{r4, lr}
 800b602:	b0a8      	sub	sp, #160	; 0xa0
 800b604:	9005      	str	r0, [sp, #20]
 800b606:	9104      	str	r1, [sp, #16]
 800b608:	9203      	str	r2, [sp, #12]
  if (b->sign == MP_NEG || mp_iszero(b) == MP_YES) {
 800b60a:	9b04      	ldr	r3, [sp, #16]
 800b60c:	689b      	ldr	r3, [r3, #8]
 800b60e:	2b01      	cmp	r3, #1
 800b610:	d003      	beq.n	800b61a <mp_invmod_slow+0x1a>
 800b612:	9b04      	ldr	r3, [sp, #16]
 800b614:	681b      	ldr	r3, [r3, #0]
 800b616:	2b00      	cmp	r3, #0
 800b618:	d102      	bne.n	800b620 <mp_invmod_slow+0x20>
    return MP_VAL;
 800b61a:	f06f 0302 	mvn.w	r3, #2
 800b61e:	e201      	b.n	800ba24 <mp_invmod_slow+0x424>
  if ((res = mp_init_multi(&x, &y, &u, &v,
 800b620:	ac17      	add	r4, sp, #92	; 0x5c
 800b622:	aa1b      	add	r2, sp, #108	; 0x6c
 800b624:	a91f      	add	r1, sp, #124	; 0x7c
 800b626:	a823      	add	r0, sp, #140	; 0x8c
 800b628:	ab0f      	add	r3, sp, #60	; 0x3c
 800b62a:	9301      	str	r3, [sp, #4]
 800b62c:	ab13      	add	r3, sp, #76	; 0x4c
 800b62e:	9300      	str	r3, [sp, #0]
 800b630:	4623      	mov	r3, r4
 800b632:	f001 fa2d 	bl	800ca90 <mp_init_multi>
 800b636:	9027      	str	r0, [sp, #156]	; 0x9c
 800b638:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b63a:	2b00      	cmp	r3, #0
 800b63c:	d001      	beq.n	800b642 <mp_invmod_slow+0x42>
     return res;
 800b63e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b640:	e1f0      	b.n	800ba24 <mp_invmod_slow+0x424>
  if ((res = mp_init_multi(&C, &D, 0, 0, 0, 0)) != MP_OKAY) {
 800b642:	a907      	add	r1, sp, #28
 800b644:	a80b      	add	r0, sp, #44	; 0x2c
 800b646:	2300      	movs	r3, #0
 800b648:	9301      	str	r3, [sp, #4]
 800b64a:	2300      	movs	r3, #0
 800b64c:	9300      	str	r3, [sp, #0]
 800b64e:	2300      	movs	r3, #0
 800b650:	2200      	movs	r2, #0
 800b652:	f001 fa1d 	bl	800ca90 <mp_init_multi>
 800b656:	9027      	str	r0, [sp, #156]	; 0x9c
 800b658:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b65a:	2b00      	cmp	r3, #0
 800b65c:	d019      	beq.n	800b692 <mp_invmod_slow+0x92>
     mp_clear(&x);
 800b65e:	ab23      	add	r3, sp, #140	; 0x8c
 800b660:	4618      	mov	r0, r3
 800b662:	f7fe ffe5 	bl	800a630 <mp_clear>
     mp_clear(&y);
 800b666:	ab1f      	add	r3, sp, #124	; 0x7c
 800b668:	4618      	mov	r0, r3
 800b66a:	f7fe ffe1 	bl	800a630 <mp_clear>
     mp_clear(&u);
 800b66e:	ab1b      	add	r3, sp, #108	; 0x6c
 800b670:	4618      	mov	r0, r3
 800b672:	f7fe ffdd 	bl	800a630 <mp_clear>
     mp_clear(&v);
 800b676:	ab17      	add	r3, sp, #92	; 0x5c
 800b678:	4618      	mov	r0, r3
 800b67a:	f7fe ffd9 	bl	800a630 <mp_clear>
     mp_clear(&A);
 800b67e:	ab13      	add	r3, sp, #76	; 0x4c
 800b680:	4618      	mov	r0, r3
 800b682:	f7fe ffd5 	bl	800a630 <mp_clear>
     mp_clear(&B);
 800b686:	ab0f      	add	r3, sp, #60	; 0x3c
 800b688:	4618      	mov	r0, r3
 800b68a:	f7fe ffd1 	bl	800a630 <mp_clear>
     return res;
 800b68e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b690:	e1c8      	b.n	800ba24 <mp_invmod_slow+0x424>
  if ((res = mp_mod(a, b, &x)) != MP_OKAY) {
 800b692:	ab23      	add	r3, sp, #140	; 0x8c
 800b694:	461a      	mov	r2, r3
 800b696:	9904      	ldr	r1, [sp, #16]
 800b698:	9805      	ldr	r0, [sp, #20]
 800b69a:	f000 faa1 	bl	800bbe0 <mp_mod>
 800b69e:	9027      	str	r0, [sp, #156]	; 0x9c
 800b6a0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b6a2:	2b00      	cmp	r3, #0
 800b6a4:	f040 819d 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  if ((res = mp_copy (b, &y)) != MP_OKAY) {
 800b6a8:	ab1f      	add	r3, sp, #124	; 0x7c
 800b6aa:	4619      	mov	r1, r3
 800b6ac:	9804      	ldr	r0, [sp, #16]
 800b6ae:	f7ff f937 	bl	800a920 <mp_copy>
 800b6b2:	9027      	str	r0, [sp, #156]	; 0x9c
 800b6b4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b6b6:	2b00      	cmp	r3, #0
 800b6b8:	f040 8193 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  if (mp_iseven (&x) == MP_YES && mp_iseven (&y) == MP_YES) {
 800b6bc:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800b6be:	2b00      	cmp	r3, #0
 800b6c0:	dd07      	ble.n	800b6d2 <mp_invmod_slow+0xd2>
 800b6c2:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800b6c4:	681b      	ldr	r3, [r3, #0]
 800b6c6:	f003 0301 	and.w	r3, r3, #1
 800b6ca:	2b00      	cmp	r3, #0
 800b6cc:	d101      	bne.n	800b6d2 <mp_invmod_slow+0xd2>
 800b6ce:	2301      	movs	r3, #1
 800b6d0:	e000      	b.n	800b6d4 <mp_invmod_slow+0xd4>
 800b6d2:	2300      	movs	r3, #0
 800b6d4:	2b01      	cmp	r3, #1
 800b6d6:	d111      	bne.n	800b6fc <mp_invmod_slow+0xfc>
 800b6d8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800b6da:	2b00      	cmp	r3, #0
 800b6dc:	dd07      	ble.n	800b6ee <mp_invmod_slow+0xee>
 800b6de:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800b6e0:	681b      	ldr	r3, [r3, #0]
 800b6e2:	f003 0301 	and.w	r3, r3, #1
 800b6e6:	2b00      	cmp	r3, #0
 800b6e8:	d101      	bne.n	800b6ee <mp_invmod_slow+0xee>
 800b6ea:	2301      	movs	r3, #1
 800b6ec:	e000      	b.n	800b6f0 <mp_invmod_slow+0xf0>
 800b6ee:	2300      	movs	r3, #0
 800b6f0:	2b01      	cmp	r3, #1
 800b6f2:	d103      	bne.n	800b6fc <mp_invmod_slow+0xfc>
    res = MP_VAL;
 800b6f4:	f06f 0302 	mvn.w	r3, #2
 800b6f8:	9327      	str	r3, [sp, #156]	; 0x9c
 800b6fa:	e172      	b.n	800b9e2 <mp_invmod_slow+0x3e2>
  if ((res = mp_copy (&x, &u)) != MP_OKAY) {
 800b6fc:	aa1b      	add	r2, sp, #108	; 0x6c
 800b6fe:	ab23      	add	r3, sp, #140	; 0x8c
 800b700:	4611      	mov	r1, r2
 800b702:	4618      	mov	r0, r3
 800b704:	f7ff f90c 	bl	800a920 <mp_copy>
 800b708:	9027      	str	r0, [sp, #156]	; 0x9c
 800b70a:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b70c:	2b00      	cmp	r3, #0
 800b70e:	f040 8168 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  if ((res = mp_copy (&y, &v)) != MP_OKAY) {
 800b712:	aa17      	add	r2, sp, #92	; 0x5c
 800b714:	ab1f      	add	r3, sp, #124	; 0x7c
 800b716:	4611      	mov	r1, r2
 800b718:	4618      	mov	r0, r3
 800b71a:	f7ff f901 	bl	800a920 <mp_copy>
 800b71e:	9027      	str	r0, [sp, #156]	; 0x9c
 800b720:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b722:	2b00      	cmp	r3, #0
 800b724:	f040 815d 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  if ((res = mp_set (&A, 1)) != MP_OKAY) {
 800b728:	ab13      	add	r3, sp, #76	; 0x4c
 800b72a:	2101      	movs	r1, #1
 800b72c:	4618      	mov	r0, r3
 800b72e:	f000 fa2f 	bl	800bb90 <mp_set>
 800b732:	9027      	str	r0, [sp, #156]	; 0x9c
 800b734:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b736:	2b00      	cmp	r3, #0
 800b738:	f040 8153 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  if ((res = mp_set (&D, 1)) != MP_OKAY) {
 800b73c:	ab07      	add	r3, sp, #28
 800b73e:	2101      	movs	r1, #1
 800b740:	4618      	mov	r0, r3
 800b742:	f000 fa25 	bl	800bb90 <mp_set>
 800b746:	9027      	str	r0, [sp, #156]	; 0x9c
 800b748:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b74a:	2b00      	cmp	r3, #0
 800b74c:	f040 8149 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
 800b750:	e052      	b.n	800b7f8 <mp_invmod_slow+0x1f8>
    if ((res = mp_div_2 (&u, &u)) != MP_OKAY) {
 800b752:	aa1b      	add	r2, sp, #108	; 0x6c
 800b754:	ab1b      	add	r3, sp, #108	; 0x6c
 800b756:	4611      	mov	r1, r2
 800b758:	4618      	mov	r0, r3
 800b75a:	f7fc fa71 	bl	8007c40 <mp_div_2>
 800b75e:	9027      	str	r0, [sp, #156]	; 0x9c
 800b760:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b762:	2b00      	cmp	r3, #0
 800b764:	f040 813d 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if (mp_isodd (&A) == MP_YES || mp_isodd (&B) == MP_YES) {
 800b768:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800b76a:	2b00      	cmp	r3, #0
 800b76c:	dd07      	ble.n	800b77e <mp_invmod_slow+0x17e>
 800b76e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800b770:	681b      	ldr	r3, [r3, #0]
 800b772:	f003 0301 	and.w	r3, r3, #1
 800b776:	2b00      	cmp	r3, #0
 800b778:	d001      	beq.n	800b77e <mp_invmod_slow+0x17e>
 800b77a:	2301      	movs	r3, #1
 800b77c:	e000      	b.n	800b780 <mp_invmod_slow+0x180>
 800b77e:	2300      	movs	r3, #0
 800b780:	2b01      	cmp	r3, #1
 800b782:	d00d      	beq.n	800b7a0 <mp_invmod_slow+0x1a0>
 800b784:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b786:	2b00      	cmp	r3, #0
 800b788:	dd07      	ble.n	800b79a <mp_invmod_slow+0x19a>
 800b78a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800b78c:	681b      	ldr	r3, [r3, #0]
 800b78e:	f003 0301 	and.w	r3, r3, #1
 800b792:	2b00      	cmp	r3, #0
 800b794:	d001      	beq.n	800b79a <mp_invmod_slow+0x19a>
 800b796:	2301      	movs	r3, #1
 800b798:	e000      	b.n	800b79c <mp_invmod_slow+0x19c>
 800b79a:	2300      	movs	r3, #0
 800b79c:	2b01      	cmp	r3, #1
 800b79e:	d115      	bne.n	800b7cc <mp_invmod_slow+0x1cc>
      if ((res = mp_add (&A, &y, &A)) != MP_OKAY) {
 800b7a0:	aa13      	add	r2, sp, #76	; 0x4c
 800b7a2:	a91f      	add	r1, sp, #124	; 0x7c
 800b7a4:	ab13      	add	r3, sp, #76	; 0x4c
 800b7a6:	4618      	mov	r0, r3
 800b7a8:	f7fc fac2 	bl	8007d30 <mp_add>
 800b7ac:	9027      	str	r0, [sp, #156]	; 0x9c
 800b7ae:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b7b0:	2b00      	cmp	r3, #0
 800b7b2:	f040 8116 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
      if ((res = mp_sub (&B, &x, &B)) != MP_OKAY) {
 800b7b6:	aa0f      	add	r2, sp, #60	; 0x3c
 800b7b8:	a923      	add	r1, sp, #140	; 0x8c
 800b7ba:	ab0f      	add	r3, sp, #60	; 0x3c
 800b7bc:	4618      	mov	r0, r3
 800b7be:	f7fc fc1f 	bl	8008000 <mp_sub>
 800b7c2:	9027      	str	r0, [sp, #156]	; 0x9c
 800b7c4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b7c6:	2b00      	cmp	r3, #0
 800b7c8:	f040 810b 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_div_2 (&A, &A)) != MP_OKAY) {
 800b7cc:	aa13      	add	r2, sp, #76	; 0x4c
 800b7ce:	ab13      	add	r3, sp, #76	; 0x4c
 800b7d0:	4611      	mov	r1, r2
 800b7d2:	4618      	mov	r0, r3
 800b7d4:	f7fc fa34 	bl	8007c40 <mp_div_2>
 800b7d8:	9027      	str	r0, [sp, #156]	; 0x9c
 800b7da:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b7dc:	2b00      	cmp	r3, #0
 800b7de:	f040 8100 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_div_2 (&B, &B)) != MP_OKAY) {
 800b7e2:	aa0f      	add	r2, sp, #60	; 0x3c
 800b7e4:	ab0f      	add	r3, sp, #60	; 0x3c
 800b7e6:	4611      	mov	r1, r2
 800b7e8:	4618      	mov	r0, r3
 800b7ea:	f7fc fa29 	bl	8007c40 <mp_div_2>
 800b7ee:	9027      	str	r0, [sp, #156]	; 0x9c
 800b7f0:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b7f2:	2b00      	cmp	r3, #0
 800b7f4:	f040 80f5 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  while (mp_iseven (&u) == MP_YES) {
 800b7f8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	dd07      	ble.n	800b80e <mp_invmod_slow+0x20e>
 800b7fe:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800b800:	681b      	ldr	r3, [r3, #0]
 800b802:	f003 0301 	and.w	r3, r3, #1
 800b806:	2b00      	cmp	r3, #0
 800b808:	d101      	bne.n	800b80e <mp_invmod_slow+0x20e>
 800b80a:	2301      	movs	r3, #1
 800b80c:	e000      	b.n	800b810 <mp_invmod_slow+0x210>
 800b80e:	2300      	movs	r3, #0
 800b810:	2b01      	cmp	r3, #1
 800b812:	d09e      	beq.n	800b752 <mp_invmod_slow+0x152>
 800b814:	e052      	b.n	800b8bc <mp_invmod_slow+0x2bc>
    if ((res = mp_div_2 (&v, &v)) != MP_OKAY) {
 800b816:	aa17      	add	r2, sp, #92	; 0x5c
 800b818:	ab17      	add	r3, sp, #92	; 0x5c
 800b81a:	4611      	mov	r1, r2
 800b81c:	4618      	mov	r0, r3
 800b81e:	f7fc fa0f 	bl	8007c40 <mp_div_2>
 800b822:	9027      	str	r0, [sp, #156]	; 0x9c
 800b824:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b826:	2b00      	cmp	r3, #0
 800b828:	f040 80db 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if (mp_isodd (&C) == MP_YES || mp_isodd (&D) == MP_YES) {
 800b82c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b82e:	2b00      	cmp	r3, #0
 800b830:	dd07      	ble.n	800b842 <mp_invmod_slow+0x242>
 800b832:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b834:	681b      	ldr	r3, [r3, #0]
 800b836:	f003 0301 	and.w	r3, r3, #1
 800b83a:	2b00      	cmp	r3, #0
 800b83c:	d001      	beq.n	800b842 <mp_invmod_slow+0x242>
 800b83e:	2301      	movs	r3, #1
 800b840:	e000      	b.n	800b844 <mp_invmod_slow+0x244>
 800b842:	2300      	movs	r3, #0
 800b844:	2b01      	cmp	r3, #1
 800b846:	d00d      	beq.n	800b864 <mp_invmod_slow+0x264>
 800b848:	9b07      	ldr	r3, [sp, #28]
 800b84a:	2b00      	cmp	r3, #0
 800b84c:	dd07      	ble.n	800b85e <mp_invmod_slow+0x25e>
 800b84e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800b850:	681b      	ldr	r3, [r3, #0]
 800b852:	f003 0301 	and.w	r3, r3, #1
 800b856:	2b00      	cmp	r3, #0
 800b858:	d001      	beq.n	800b85e <mp_invmod_slow+0x25e>
 800b85a:	2301      	movs	r3, #1
 800b85c:	e000      	b.n	800b860 <mp_invmod_slow+0x260>
 800b85e:	2300      	movs	r3, #0
 800b860:	2b01      	cmp	r3, #1
 800b862:	d115      	bne.n	800b890 <mp_invmod_slow+0x290>
      if ((res = mp_add (&C, &y, &C)) != MP_OKAY) {
 800b864:	aa0b      	add	r2, sp, #44	; 0x2c
 800b866:	a91f      	add	r1, sp, #124	; 0x7c
 800b868:	ab0b      	add	r3, sp, #44	; 0x2c
 800b86a:	4618      	mov	r0, r3
 800b86c:	f7fc fa60 	bl	8007d30 <mp_add>
 800b870:	9027      	str	r0, [sp, #156]	; 0x9c
 800b872:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b874:	2b00      	cmp	r3, #0
 800b876:	f040 80b4 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
      if ((res = mp_sub (&D, &x, &D)) != MP_OKAY) {
 800b87a:	aa07      	add	r2, sp, #28
 800b87c:	a923      	add	r1, sp, #140	; 0x8c
 800b87e:	ab07      	add	r3, sp, #28
 800b880:	4618      	mov	r0, r3
 800b882:	f7fc fbbd 	bl	8008000 <mp_sub>
 800b886:	9027      	str	r0, [sp, #156]	; 0x9c
 800b888:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b88a:	2b00      	cmp	r3, #0
 800b88c:	f040 80a9 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_div_2 (&C, &C)) != MP_OKAY) {
 800b890:	aa0b      	add	r2, sp, #44	; 0x2c
 800b892:	ab0b      	add	r3, sp, #44	; 0x2c
 800b894:	4611      	mov	r1, r2
 800b896:	4618      	mov	r0, r3
 800b898:	f7fc f9d2 	bl	8007c40 <mp_div_2>
 800b89c:	9027      	str	r0, [sp, #156]	; 0x9c
 800b89e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b8a0:	2b00      	cmp	r3, #0
 800b8a2:	f040 809e 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_div_2 (&D, &D)) != MP_OKAY) {
 800b8a6:	aa07      	add	r2, sp, #28
 800b8a8:	ab07      	add	r3, sp, #28
 800b8aa:	4611      	mov	r1, r2
 800b8ac:	4618      	mov	r0, r3
 800b8ae:	f7fc f9c7 	bl	8007c40 <mp_div_2>
 800b8b2:	9027      	str	r0, [sp, #156]	; 0x9c
 800b8b4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b8b6:	2b00      	cmp	r3, #0
 800b8b8:	f040 8093 	bne.w	800b9e2 <mp_invmod_slow+0x3e2>
  while (mp_iseven (&v) == MP_YES) {
 800b8bc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800b8be:	2b00      	cmp	r3, #0
 800b8c0:	dd07      	ble.n	800b8d2 <mp_invmod_slow+0x2d2>
 800b8c2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800b8c4:	681b      	ldr	r3, [r3, #0]
 800b8c6:	f003 0301 	and.w	r3, r3, #1
 800b8ca:	2b00      	cmp	r3, #0
 800b8cc:	d101      	bne.n	800b8d2 <mp_invmod_slow+0x2d2>
 800b8ce:	2301      	movs	r3, #1
 800b8d0:	e000      	b.n	800b8d4 <mp_invmod_slow+0x2d4>
 800b8d2:	2300      	movs	r3, #0
 800b8d4:	2b01      	cmp	r3, #1
 800b8d6:	d09e      	beq.n	800b816 <mp_invmod_slow+0x216>
  if (mp_cmp (&u, &v) != MP_LT) {
 800b8d8:	aa17      	add	r2, sp, #92	; 0x5c
 800b8da:	ab1b      	add	r3, sp, #108	; 0x6c
 800b8dc:	4611      	mov	r1, r2
 800b8de:	4618      	mov	r0, r3
 800b8e0:	f000 f8f6 	bl	800bad0 <mp_cmp>
 800b8e4:	4603      	mov	r3, r0
 800b8e6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b8ea:	d01e      	beq.n	800b92a <mp_invmod_slow+0x32a>
    if ((res = mp_sub (&u, &v, &u)) != MP_OKAY) {
 800b8ec:	aa1b      	add	r2, sp, #108	; 0x6c
 800b8ee:	a917      	add	r1, sp, #92	; 0x5c
 800b8f0:	ab1b      	add	r3, sp, #108	; 0x6c
 800b8f2:	4618      	mov	r0, r3
 800b8f4:	f7fc fb84 	bl	8008000 <mp_sub>
 800b8f8:	9027      	str	r0, [sp, #156]	; 0x9c
 800b8fa:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b8fc:	2b00      	cmp	r3, #0
 800b8fe:	d170      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_sub (&A, &C, &A)) != MP_OKAY) {
 800b900:	aa13      	add	r2, sp, #76	; 0x4c
 800b902:	a90b      	add	r1, sp, #44	; 0x2c
 800b904:	ab13      	add	r3, sp, #76	; 0x4c
 800b906:	4618      	mov	r0, r3
 800b908:	f7fc fb7a 	bl	8008000 <mp_sub>
 800b90c:	9027      	str	r0, [sp, #156]	; 0x9c
 800b90e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b910:	2b00      	cmp	r3, #0
 800b912:	d166      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_sub (&B, &D, &B)) != MP_OKAY) {
 800b914:	aa0f      	add	r2, sp, #60	; 0x3c
 800b916:	a907      	add	r1, sp, #28
 800b918:	ab0f      	add	r3, sp, #60	; 0x3c
 800b91a:	4618      	mov	r0, r3
 800b91c:	f7fc fb70 	bl	8008000 <mp_sub>
 800b920:	9027      	str	r0, [sp, #156]	; 0x9c
 800b922:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b924:	2b00      	cmp	r3, #0
 800b926:	d15c      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
 800b928:	e01d      	b.n	800b966 <mp_invmod_slow+0x366>
    if ((res = mp_sub (&v, &u, &v)) != MP_OKAY) {
 800b92a:	aa17      	add	r2, sp, #92	; 0x5c
 800b92c:	a91b      	add	r1, sp, #108	; 0x6c
 800b92e:	ab17      	add	r3, sp, #92	; 0x5c
 800b930:	4618      	mov	r0, r3
 800b932:	f7fc fb65 	bl	8008000 <mp_sub>
 800b936:	9027      	str	r0, [sp, #156]	; 0x9c
 800b938:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b93a:	2b00      	cmp	r3, #0
 800b93c:	d151      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_sub (&C, &A, &C)) != MP_OKAY) {
 800b93e:	aa0b      	add	r2, sp, #44	; 0x2c
 800b940:	a913      	add	r1, sp, #76	; 0x4c
 800b942:	ab0b      	add	r3, sp, #44	; 0x2c
 800b944:	4618      	mov	r0, r3
 800b946:	f7fc fb5b 	bl	8008000 <mp_sub>
 800b94a:	9027      	str	r0, [sp, #156]	; 0x9c
 800b94c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b94e:	2b00      	cmp	r3, #0
 800b950:	d147      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
    if ((res = mp_sub (&D, &B, &D)) != MP_OKAY) {
 800b952:	aa07      	add	r2, sp, #28
 800b954:	a90f      	add	r1, sp, #60	; 0x3c
 800b956:	ab07      	add	r3, sp, #28
 800b958:	4618      	mov	r0, r3
 800b95a:	f7fc fb51 	bl	8008000 <mp_sub>
 800b95e:	9027      	str	r0, [sp, #156]	; 0x9c
 800b960:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b962:	2b00      	cmp	r3, #0
 800b964:	d13d      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
  if (mp_iszero (&u) == MP_NO)
 800b966:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800b968:	2b00      	cmp	r3, #0
 800b96a:	f47f af45 	bne.w	800b7f8 <mp_invmod_slow+0x1f8>
  if (mp_cmp_d (&v, 1) != MP_EQ) {
 800b96e:	ab17      	add	r3, sp, #92	; 0x5c
 800b970:	2101      	movs	r1, #1
 800b972:	4618      	mov	r0, r3
 800b974:	f000 f8d4 	bl	800bb20 <mp_cmp_d>
 800b978:	4603      	mov	r3, r0
 800b97a:	2b00      	cmp	r3, #0
 800b97c:	d00d      	beq.n	800b99a <mp_invmod_slow+0x39a>
    res = MP_VAL;
 800b97e:	f06f 0302 	mvn.w	r3, #2
 800b982:	9327      	str	r3, [sp, #156]	; 0x9c
 800b984:	e02d      	b.n	800b9e2 <mp_invmod_slow+0x3e2>
      if ((res = mp_add(&C, b, &C)) != MP_OKAY) {
 800b986:	aa0b      	add	r2, sp, #44	; 0x2c
 800b988:	ab0b      	add	r3, sp, #44	; 0x2c
 800b98a:	9904      	ldr	r1, [sp, #16]
 800b98c:	4618      	mov	r0, r3
 800b98e:	f7fc f9cf 	bl	8007d30 <mp_add>
 800b992:	9027      	str	r0, [sp, #156]	; 0x9c
 800b994:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b996:	2b00      	cmp	r3, #0
 800b998:	d123      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
  while (mp_cmp_d(&C, 0) == MP_LT) {
 800b99a:	ab0b      	add	r3, sp, #44	; 0x2c
 800b99c:	2100      	movs	r1, #0
 800b99e:	4618      	mov	r0, r3
 800b9a0:	f000 f8be 	bl	800bb20 <mp_cmp_d>
 800b9a4:	4603      	mov	r3, r0
 800b9a6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b9aa:	d0ec      	beq.n	800b986 <mp_invmod_slow+0x386>
 800b9ac:	e009      	b.n	800b9c2 <mp_invmod_slow+0x3c2>
      if ((res = mp_sub(&C, b, &C)) != MP_OKAY) {
 800b9ae:	aa0b      	add	r2, sp, #44	; 0x2c
 800b9b0:	ab0b      	add	r3, sp, #44	; 0x2c
 800b9b2:	9904      	ldr	r1, [sp, #16]
 800b9b4:	4618      	mov	r0, r3
 800b9b6:	f7fc fb23 	bl	8008000 <mp_sub>
 800b9ba:	9027      	str	r0, [sp, #156]	; 0x9c
 800b9bc:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800b9be:	2b00      	cmp	r3, #0
 800b9c0:	d10f      	bne.n	800b9e2 <mp_invmod_slow+0x3e2>
  while (mp_cmp_mag(&C, b) != MP_LT) {
 800b9c2:	ab0b      	add	r3, sp, #44	; 0x2c
 800b9c4:	9904      	ldr	r1, [sp, #16]
 800b9c6:	4618      	mov	r0, r3
 800b9c8:	f000 f832 	bl	800ba30 <mp_cmp_mag>
 800b9cc:	4603      	mov	r3, r0
 800b9ce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b9d2:	d1ec      	bne.n	800b9ae <mp_invmod_slow+0x3ae>
  mp_exch (&C, c);
 800b9d4:	ab0b      	add	r3, sp, #44	; 0x2c
 800b9d6:	9903      	ldr	r1, [sp, #12]
 800b9d8:	4618      	mov	r0, r3
 800b9da:	f7ff f911 	bl	800ac00 <mp_exch>
  res = MP_OKAY;
 800b9de:	2300      	movs	r3, #0
 800b9e0:	9327      	str	r3, [sp, #156]	; 0x9c
LBL_ERR:mp_clear(&x);
 800b9e2:	ab23      	add	r3, sp, #140	; 0x8c
 800b9e4:	4618      	mov	r0, r3
 800b9e6:	f7fe fe23 	bl	800a630 <mp_clear>
        mp_clear(&y);
 800b9ea:	ab1f      	add	r3, sp, #124	; 0x7c
 800b9ec:	4618      	mov	r0, r3
 800b9ee:	f7fe fe1f 	bl	800a630 <mp_clear>
        mp_clear(&u);
 800b9f2:	ab1b      	add	r3, sp, #108	; 0x6c
 800b9f4:	4618      	mov	r0, r3
 800b9f6:	f7fe fe1b 	bl	800a630 <mp_clear>
        mp_clear(&v);
 800b9fa:	ab17      	add	r3, sp, #92	; 0x5c
 800b9fc:	4618      	mov	r0, r3
 800b9fe:	f7fe fe17 	bl	800a630 <mp_clear>
        mp_clear(&A);
 800ba02:	ab13      	add	r3, sp, #76	; 0x4c
 800ba04:	4618      	mov	r0, r3
 800ba06:	f7fe fe13 	bl	800a630 <mp_clear>
        mp_clear(&B);
 800ba0a:	ab0f      	add	r3, sp, #60	; 0x3c
 800ba0c:	4618      	mov	r0, r3
 800ba0e:	f7fe fe0f 	bl	800a630 <mp_clear>
        mp_clear(&C);
 800ba12:	ab0b      	add	r3, sp, #44	; 0x2c
 800ba14:	4618      	mov	r0, r3
 800ba16:	f7fe fe0b 	bl	800a630 <mp_clear>
        mp_clear(&D);
 800ba1a:	ab07      	add	r3, sp, #28
 800ba1c:	4618      	mov	r0, r3
 800ba1e:	f7fe fe07 	bl	800a630 <mp_clear>
  return res;
 800ba22:	9b27      	ldr	r3, [sp, #156]	; 0x9c
}
 800ba24:	4618      	mov	r0, r3
 800ba26:	b028      	add	sp, #160	; 0xa0
 800ba28:	bd10      	pop	{r4, pc}
 800ba2a:	bf00      	nop
 800ba2c:	0000      	movs	r0, r0
	...

0800ba30 <mp_cmp_mag>:
{
 800ba30:	b086      	sub	sp, #24
 800ba32:	9001      	str	r0, [sp, #4]
 800ba34:	9100      	str	r1, [sp, #0]
  if (a->used > b->used) {
 800ba36:	9b01      	ldr	r3, [sp, #4]
 800ba38:	681a      	ldr	r2, [r3, #0]
 800ba3a:	9b00      	ldr	r3, [sp, #0]
 800ba3c:	681b      	ldr	r3, [r3, #0]
 800ba3e:	429a      	cmp	r2, r3
 800ba40:	dd01      	ble.n	800ba46 <mp_cmp_mag+0x16>
    return MP_GT;
 800ba42:	2301      	movs	r3, #1
 800ba44:	e03f      	b.n	800bac6 <mp_cmp_mag+0x96>
  if (a->used < b->used) {
 800ba46:	9b01      	ldr	r3, [sp, #4]
 800ba48:	681a      	ldr	r2, [r3, #0]
 800ba4a:	9b00      	ldr	r3, [sp, #0]
 800ba4c:	681b      	ldr	r3, [r3, #0]
 800ba4e:	429a      	cmp	r2, r3
 800ba50:	da02      	bge.n	800ba58 <mp_cmp_mag+0x28>
    return MP_LT;
 800ba52:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba56:	e036      	b.n	800bac6 <mp_cmp_mag+0x96>
  tmpa = a->dp + (a->used - 1);
 800ba58:	9b01      	ldr	r3, [sp, #4]
 800ba5a:	68da      	ldr	r2, [r3, #12]
 800ba5c:	9b01      	ldr	r3, [sp, #4]
 800ba5e:	681b      	ldr	r3, [r3, #0]
 800ba60:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800ba64:	3b01      	subs	r3, #1
 800ba66:	009b      	lsls	r3, r3, #2
 800ba68:	4413      	add	r3, r2
 800ba6a:	9304      	str	r3, [sp, #16]
  tmpb = b->dp + (a->used - 1);
 800ba6c:	9b00      	ldr	r3, [sp, #0]
 800ba6e:	68da      	ldr	r2, [r3, #12]
 800ba70:	9b01      	ldr	r3, [sp, #4]
 800ba72:	681b      	ldr	r3, [r3, #0]
 800ba74:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800ba78:	3b01      	subs	r3, #1
 800ba7a:	009b      	lsls	r3, r3, #2
 800ba7c:	4413      	add	r3, r2
 800ba7e:	9303      	str	r3, [sp, #12]
  for (n = 0; n < a->used; ++n, --tmpa, --tmpb) {
 800ba80:	2300      	movs	r3, #0
 800ba82:	9305      	str	r3, [sp, #20]
 800ba84:	e019      	b.n	800baba <mp_cmp_mag+0x8a>
    if (*tmpa > *tmpb) {
 800ba86:	9b04      	ldr	r3, [sp, #16]
 800ba88:	681a      	ldr	r2, [r3, #0]
 800ba8a:	9b03      	ldr	r3, [sp, #12]
 800ba8c:	681b      	ldr	r3, [r3, #0]
 800ba8e:	429a      	cmp	r2, r3
 800ba90:	d901      	bls.n	800ba96 <mp_cmp_mag+0x66>
      return MP_GT;
 800ba92:	2301      	movs	r3, #1
 800ba94:	e017      	b.n	800bac6 <mp_cmp_mag+0x96>
    if (*tmpa < *tmpb) {
 800ba96:	9b04      	ldr	r3, [sp, #16]
 800ba98:	681a      	ldr	r2, [r3, #0]
 800ba9a:	9b03      	ldr	r3, [sp, #12]
 800ba9c:	681b      	ldr	r3, [r3, #0]
 800ba9e:	429a      	cmp	r2, r3
 800baa0:	d202      	bcs.n	800baa8 <mp_cmp_mag+0x78>
      return MP_LT;
 800baa2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800baa6:	e00e      	b.n	800bac6 <mp_cmp_mag+0x96>
  for (n = 0; n < a->used; ++n, --tmpa, --tmpb) {
 800baa8:	9b05      	ldr	r3, [sp, #20]
 800baaa:	3301      	adds	r3, #1
 800baac:	9305      	str	r3, [sp, #20]
 800baae:	9b04      	ldr	r3, [sp, #16]
 800bab0:	3b04      	subs	r3, #4
 800bab2:	9304      	str	r3, [sp, #16]
 800bab4:	9b03      	ldr	r3, [sp, #12]
 800bab6:	3b04      	subs	r3, #4
 800bab8:	9303      	str	r3, [sp, #12]
 800baba:	9b01      	ldr	r3, [sp, #4]
 800babc:	681a      	ldr	r2, [r3, #0]
 800babe:	9b05      	ldr	r3, [sp, #20]
 800bac0:	429a      	cmp	r2, r3
 800bac2:	dce0      	bgt.n	800ba86 <mp_cmp_mag+0x56>
  return MP_EQ;
 800bac4:	2300      	movs	r3, #0
}
 800bac6:	4618      	mov	r0, r3
 800bac8:	b006      	add	sp, #24
 800baca:	4770      	bx	lr
 800bacc:	0000      	movs	r0, r0
	...

0800bad0 <mp_cmp>:
{
 800bad0:	b500      	push	{lr}
 800bad2:	b083      	sub	sp, #12
 800bad4:	9001      	str	r0, [sp, #4]
 800bad6:	9100      	str	r1, [sp, #0]
  if (a->sign != b->sign) {
 800bad8:	9b01      	ldr	r3, [sp, #4]
 800bada:	689a      	ldr	r2, [r3, #8]
 800badc:	9b00      	ldr	r3, [sp, #0]
 800bade:	689b      	ldr	r3, [r3, #8]
 800bae0:	429a      	cmp	r2, r3
 800bae2:	d008      	beq.n	800baf6 <mp_cmp+0x26>
     if (a->sign == MP_NEG) {
 800bae4:	9b01      	ldr	r3, [sp, #4]
 800bae6:	689b      	ldr	r3, [r3, #8]
 800bae8:	2b01      	cmp	r3, #1
 800baea:	d102      	bne.n	800baf2 <mp_cmp+0x22>
        return MP_LT;
 800baec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800baf0:	e010      	b.n	800bb14 <mp_cmp+0x44>
        return MP_GT;
 800baf2:	2301      	movs	r3, #1
 800baf4:	e00e      	b.n	800bb14 <mp_cmp+0x44>
  if (a->sign == MP_NEG) {
 800baf6:	9b01      	ldr	r3, [sp, #4]
 800baf8:	689b      	ldr	r3, [r3, #8]
 800bafa:	2b01      	cmp	r3, #1
 800bafc:	d105      	bne.n	800bb0a <mp_cmp+0x3a>
     return mp_cmp_mag(b, a);
 800bafe:	9901      	ldr	r1, [sp, #4]
 800bb00:	9800      	ldr	r0, [sp, #0]
 800bb02:	f7ff ff95 	bl	800ba30 <mp_cmp_mag>
 800bb06:	4603      	mov	r3, r0
 800bb08:	e004      	b.n	800bb14 <mp_cmp+0x44>
     return mp_cmp_mag(a, b);
 800bb0a:	9900      	ldr	r1, [sp, #0]
 800bb0c:	9801      	ldr	r0, [sp, #4]
 800bb0e:	f7ff ff8f 	bl	800ba30 <mp_cmp_mag>
 800bb12:	4603      	mov	r3, r0
}
 800bb14:	4618      	mov	r0, r3
 800bb16:	b003      	add	sp, #12
 800bb18:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb1c:	0000      	movs	r0, r0
	...

0800bb20 <mp_cmp_d>:
{
 800bb20:	b082      	sub	sp, #8
 800bb22:	9001      	str	r0, [sp, #4]
 800bb24:	9100      	str	r1, [sp, #0]
  if (a->used == 0 && b == 0)
 800bb26:	9b01      	ldr	r3, [sp, #4]
 800bb28:	681b      	ldr	r3, [r3, #0]
 800bb2a:	2b00      	cmp	r3, #0
 800bb2c:	d104      	bne.n	800bb38 <mp_cmp_d+0x18>
 800bb2e:	9b00      	ldr	r3, [sp, #0]
 800bb30:	2b00      	cmp	r3, #0
 800bb32:	d101      	bne.n	800bb38 <mp_cmp_d+0x18>
    return MP_EQ;
 800bb34:	2300      	movs	r3, #0
 800bb36:	e025      	b.n	800bb84 <mp_cmp_d+0x64>
  if ((b && a->used == 0) || a->sign == MP_NEG) {
 800bb38:	9b00      	ldr	r3, [sp, #0]
 800bb3a:	2b00      	cmp	r3, #0
 800bb3c:	d003      	beq.n	800bb46 <mp_cmp_d+0x26>
 800bb3e:	9b01      	ldr	r3, [sp, #4]
 800bb40:	681b      	ldr	r3, [r3, #0]
 800bb42:	2b00      	cmp	r3, #0
 800bb44:	d003      	beq.n	800bb4e <mp_cmp_d+0x2e>
 800bb46:	9b01      	ldr	r3, [sp, #4]
 800bb48:	689b      	ldr	r3, [r3, #8]
 800bb4a:	2b01      	cmp	r3, #1
 800bb4c:	d102      	bne.n	800bb54 <mp_cmp_d+0x34>
    return MP_LT;
 800bb4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb52:	e017      	b.n	800bb84 <mp_cmp_d+0x64>
  if (a->used > 1) {
 800bb54:	9b01      	ldr	r3, [sp, #4]
 800bb56:	681b      	ldr	r3, [r3, #0]
 800bb58:	2b01      	cmp	r3, #1
 800bb5a:	dd01      	ble.n	800bb60 <mp_cmp_d+0x40>
    return MP_GT;
 800bb5c:	2301      	movs	r3, #1
 800bb5e:	e011      	b.n	800bb84 <mp_cmp_d+0x64>
  if (a->dp[0] > b) {
 800bb60:	9b01      	ldr	r3, [sp, #4]
 800bb62:	68db      	ldr	r3, [r3, #12]
 800bb64:	681a      	ldr	r2, [r3, #0]
 800bb66:	9b00      	ldr	r3, [sp, #0]
 800bb68:	429a      	cmp	r2, r3
 800bb6a:	d901      	bls.n	800bb70 <mp_cmp_d+0x50>
    return MP_GT;
 800bb6c:	2301      	movs	r3, #1
 800bb6e:	e009      	b.n	800bb84 <mp_cmp_d+0x64>
  } else if (a->dp[0] < b) {
 800bb70:	9b01      	ldr	r3, [sp, #4]
 800bb72:	68db      	ldr	r3, [r3, #12]
 800bb74:	681a      	ldr	r2, [r3, #0]
 800bb76:	9b00      	ldr	r3, [sp, #0]
 800bb78:	429a      	cmp	r2, r3
 800bb7a:	d202      	bcs.n	800bb82 <mp_cmp_d+0x62>
    return MP_LT;
 800bb7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb80:	e000      	b.n	800bb84 <mp_cmp_d+0x64>
    return MP_EQ;
 800bb82:	2300      	movs	r3, #0
}
 800bb84:	4618      	mov	r0, r3
 800bb86:	b002      	add	sp, #8
 800bb88:	4770      	bx	lr
 800bb8a:	bf00      	nop
 800bb8c:	0000      	movs	r0, r0
	...

0800bb90 <mp_set>:
{
 800bb90:	b500      	push	{lr}
 800bb92:	b085      	sub	sp, #20
 800bb94:	9001      	str	r0, [sp, #4]
 800bb96:	9100      	str	r1, [sp, #0]
  mp_zero (a);
 800bb98:	9801      	ldr	r0, [sp, #4]
 800bb9a:	f7fe ffe9 	bl	800ab70 <mp_zero>
  res = mp_grow (a, 1);
 800bb9e:	2101      	movs	r1, #1
 800bba0:	9801      	ldr	r0, [sp, #4]
 800bba2:	f7fe ff25 	bl	800a9f0 <mp_grow>
 800bba6:	9003      	str	r0, [sp, #12]
  if (res == MP_OKAY) {
 800bba8:	9b03      	ldr	r3, [sp, #12]
 800bbaa:	2b00      	cmp	r3, #0
 800bbac:	d110      	bne.n	800bbd0 <mp_set+0x40>
    a->dp[0] = (mp_digit)(b & MP_MASK);
 800bbae:	9b01      	ldr	r3, [sp, #4]
 800bbb0:	68db      	ldr	r3, [r3, #12]
 800bbb2:	9a00      	ldr	r2, [sp, #0]
 800bbb4:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800bbb8:	601a      	str	r2, [r3, #0]
    a->used  = (a->dp[0] != 0) ? 1 : 0;
 800bbba:	9b01      	ldr	r3, [sp, #4]
 800bbbc:	68db      	ldr	r3, [r3, #12]
 800bbbe:	681b      	ldr	r3, [r3, #0]
 800bbc0:	2b00      	cmp	r3, #0
 800bbc2:	bf14      	ite	ne
 800bbc4:	2301      	movne	r3, #1
 800bbc6:	2300      	moveq	r3, #0
 800bbc8:	b2db      	uxtb	r3, r3
 800bbca:	461a      	mov	r2, r3
 800bbcc:	9b01      	ldr	r3, [sp, #4]
 800bbce:	601a      	str	r2, [r3, #0]
  return res;
 800bbd0:	9b03      	ldr	r3, [sp, #12]
}
 800bbd2:	4618      	mov	r0, r3
 800bbd4:	b005      	add	sp, #20
 800bbd6:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbda:	bf00      	nop
 800bbdc:	0000      	movs	r0, r0
	...

0800bbe0 <mp_mod>:
{
 800bbe0:	b500      	push	{lr}
 800bbe2:	b08b      	sub	sp, #44	; 0x2c
 800bbe4:	9003      	str	r0, [sp, #12]
 800bbe6:	9102      	str	r1, [sp, #8]
 800bbe8:	9201      	str	r2, [sp, #4]
  if ((res = mp_init_size (&t, b->used)) != MP_OKAY) {
 800bbea:	9b02      	ldr	r3, [sp, #8]
 800bbec:	681a      	ldr	r2, [r3, #0]
 800bbee:	ab05      	add	r3, sp, #20
 800bbf0:	4611      	mov	r1, r2
 800bbf2:	4618      	mov	r0, r3
 800bbf4:	f7fd fbac 	bl	8009350 <mp_init_size>
 800bbf8:	9009      	str	r0, [sp, #36]	; 0x24
 800bbfa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bbfc:	2b00      	cmp	r3, #0
 800bbfe:	d001      	beq.n	800bc04 <mp_mod+0x24>
    return res;
 800bc00:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bc02:	e02b      	b.n	800bc5c <mp_mod+0x7c>
  if ((res = mp_div (a, b, NULL, &t)) != MP_OKAY) {
 800bc04:	ab05      	add	r3, sp, #20
 800bc06:	2200      	movs	r2, #0
 800bc08:	9902      	ldr	r1, [sp, #8]
 800bc0a:	9803      	ldr	r0, [sp, #12]
 800bc0c:	f000 f830 	bl	800bc70 <mp_div>
 800bc10:	9009      	str	r0, [sp, #36]	; 0x24
 800bc12:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bc14:	2b00      	cmp	r3, #0
 800bc16:	d005      	beq.n	800bc24 <mp_mod+0x44>
    mp_clear (&t);
 800bc18:	ab05      	add	r3, sp, #20
 800bc1a:	4618      	mov	r0, r3
 800bc1c:	f7fe fd08 	bl	800a630 <mp_clear>
    return res;
 800bc20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bc22:	e01b      	b.n	800bc5c <mp_mod+0x7c>
  if ((mp_iszero(&t) != MP_NO) || (t.sign == b->sign)) {
 800bc24:	9b05      	ldr	r3, [sp, #20]
 800bc26:	2b00      	cmp	r3, #0
 800bc28:	d004      	beq.n	800bc34 <mp_mod+0x54>
 800bc2a:	9a07      	ldr	r2, [sp, #28]
 800bc2c:	9b02      	ldr	r3, [sp, #8]
 800bc2e:	689b      	ldr	r3, [r3, #8]
 800bc30:	429a      	cmp	r2, r3
 800bc32:	d107      	bne.n	800bc44 <mp_mod+0x64>
    res = MP_OKAY;
 800bc34:	2300      	movs	r3, #0
 800bc36:	9309      	str	r3, [sp, #36]	; 0x24
    mp_exch (&t, c);
 800bc38:	ab05      	add	r3, sp, #20
 800bc3a:	9901      	ldr	r1, [sp, #4]
 800bc3c:	4618      	mov	r0, r3
 800bc3e:	f7fe ffdf 	bl	800ac00 <mp_exch>
 800bc42:	e006      	b.n	800bc52 <mp_mod+0x72>
    res = mp_add (b, &t, c);
 800bc44:	ab05      	add	r3, sp, #20
 800bc46:	9a01      	ldr	r2, [sp, #4]
 800bc48:	4619      	mov	r1, r3
 800bc4a:	9802      	ldr	r0, [sp, #8]
 800bc4c:	f7fc f870 	bl	8007d30 <mp_add>
 800bc50:	9009      	str	r0, [sp, #36]	; 0x24
  mp_clear (&t);
 800bc52:	ab05      	add	r3, sp, #20
 800bc54:	4618      	mov	r0, r3
 800bc56:	f7fe fceb 	bl	800a630 <mp_clear>
  return res;
 800bc5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800bc5c:	4618      	mov	r0, r3
 800bc5e:	b00b      	add	sp, #44	; 0x2c
 800bc60:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800bc70 <mp_div>:
{
 800bc70:	b510      	push	{r4, lr}
 800bc72:	b09a      	sub	sp, #104	; 0x68
 800bc74:	9005      	str	r0, [sp, #20]
 800bc76:	9104      	str	r1, [sp, #16]
 800bc78:	9203      	str	r2, [sp, #12]
 800bc7a:	9302      	str	r3, [sp, #8]
  if (mp_iszero (b) == MP_YES) {
 800bc7c:	9b04      	ldr	r3, [sp, #16]
 800bc7e:	681b      	ldr	r3, [r3, #0]
 800bc80:	2b00      	cmp	r3, #0
 800bc82:	d102      	bne.n	800bc8a <mp_div+0x1a>
    return MP_VAL;
 800bc84:	f06f 0302 	mvn.w	r3, #2
 800bc88:	e0de      	b.n	800be48 <mp_div+0x1d8>
  if (mp_cmp_mag (a, b) == MP_LT) {
 800bc8a:	9904      	ldr	r1, [sp, #16]
 800bc8c:	9805      	ldr	r0, [sp, #20]
 800bc8e:	f7ff fecf 	bl	800ba30 <mp_cmp_mag>
 800bc92:	4603      	mov	r3, r0
 800bc94:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800bc98:	d112      	bne.n	800bcc0 <mp_div+0x50>
    if (d != NULL) {
 800bc9a:	9b02      	ldr	r3, [sp, #8]
 800bc9c:	2b00      	cmp	r3, #0
 800bc9e:	d005      	beq.n	800bcac <mp_div+0x3c>
      res = mp_copy (a, d);
 800bca0:	9902      	ldr	r1, [sp, #8]
 800bca2:	9805      	ldr	r0, [sp, #20]
 800bca4:	f7fe fe3c 	bl	800a920 <mp_copy>
 800bca8:	9019      	str	r0, [sp, #100]	; 0x64
 800bcaa:	e001      	b.n	800bcb0 <mp_div+0x40>
      res = MP_OKAY;
 800bcac:	2300      	movs	r3, #0
 800bcae:	9319      	str	r3, [sp, #100]	; 0x64
    if (c != NULL) {
 800bcb0:	9b03      	ldr	r3, [sp, #12]
 800bcb2:	2b00      	cmp	r3, #0
 800bcb4:	d002      	beq.n	800bcbc <mp_div+0x4c>
      mp_zero (c);
 800bcb6:	9803      	ldr	r0, [sp, #12]
 800bcb8:	f7fe ff5a 	bl	800ab70 <mp_zero>
    return res;
 800bcbc:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bcbe:	e0c3      	b.n	800be48 <mp_div+0x1d8>
  if ((res = mp_init_multi(&ta, &tb, &tq, &q, 0, 0)) != MP_OKAY) {
 800bcc0:	ac07      	add	r4, sp, #28
 800bcc2:	aa0b      	add	r2, sp, #44	; 0x2c
 800bcc4:	a90f      	add	r1, sp, #60	; 0x3c
 800bcc6:	a813      	add	r0, sp, #76	; 0x4c
 800bcc8:	2300      	movs	r3, #0
 800bcca:	9301      	str	r3, [sp, #4]
 800bccc:	2300      	movs	r3, #0
 800bcce:	9300      	str	r3, [sp, #0]
 800bcd0:	4623      	mov	r3, r4
 800bcd2:	f000 fedd 	bl	800ca90 <mp_init_multi>
 800bcd6:	9019      	str	r0, [sp, #100]	; 0x64
 800bcd8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bcda:	2b00      	cmp	r3, #0
 800bcdc:	d001      	beq.n	800bce2 <mp_div+0x72>
     return res;
 800bcde:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bce0:	e0b2      	b.n	800be48 <mp_div+0x1d8>
  if ((res = mp_set(&tq, 1)) != MP_OKAY) {
 800bce2:	ab0b      	add	r3, sp, #44	; 0x2c
 800bce4:	2101      	movs	r1, #1
 800bce6:	4618      	mov	r0, r3
 800bce8:	f7ff ff52 	bl	800bb90 <mp_set>
 800bcec:	9019      	str	r0, [sp, #100]	; 0x64
 800bcee:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bcf0:	2b00      	cmp	r3, #0
 800bcf2:	d001      	beq.n	800bcf8 <mp_div+0x88>
     return res;
 800bcf4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bcf6:	e0a7      	b.n	800be48 <mp_div+0x1d8>
  n = mp_count_bits(a) - mp_count_bits(b);
 800bcf8:	9805      	ldr	r0, [sp, #20]
 800bcfa:	f7fe fd31 	bl	800a760 <mp_count_bits>
 800bcfe:	4604      	mov	r4, r0
 800bd00:	9804      	ldr	r0, [sp, #16]
 800bd02:	f7fe fd2d 	bl	800a760 <mp_count_bits>
 800bd06:	4603      	mov	r3, r0
 800bd08:	1ae3      	subs	r3, r4, r3
 800bd0a:	9318      	str	r3, [sp, #96]	; 0x60
  if (((res = mp_abs(a, &ta)) != MP_OKAY) ||
 800bd0c:	ab13      	add	r3, sp, #76	; 0x4c
 800bd0e:	4619      	mov	r1, r3
 800bd10:	9805      	ldr	r0, [sp, #20]
 800bd12:	f7ff faa5 	bl	800b260 <mp_abs>
 800bd16:	9019      	str	r0, [sp, #100]	; 0x64
 800bd18:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd1a:	2b00      	cmp	r3, #0
 800bd1c:	f040 8083 	bne.w	800be26 <mp_div+0x1b6>
 800bd20:	ab0f      	add	r3, sp, #60	; 0x3c
 800bd22:	4619      	mov	r1, r3
 800bd24:	9804      	ldr	r0, [sp, #16]
 800bd26:	f7ff fa9b 	bl	800b260 <mp_abs>
 800bd2a:	9019      	str	r0, [sp, #100]	; 0x64
 800bd2c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd2e:	2b00      	cmp	r3, #0
 800bd30:	d179      	bne.n	800be26 <mp_div+0x1b6>
      ((res = mp_abs(b, &tb)) != MP_OKAY) ||
 800bd32:	aa0f      	add	r2, sp, #60	; 0x3c
 800bd34:	ab0f      	add	r3, sp, #60	; 0x3c
 800bd36:	9918      	ldr	r1, [sp, #96]	; 0x60
 800bd38:	4618      	mov	r0, r3
 800bd3a:	f7ff f8d9 	bl	800aef0 <mp_mul_2d>
 800bd3e:	9019      	str	r0, [sp, #100]	; 0x64
 800bd40:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd42:	2b00      	cmp	r3, #0
 800bd44:	d16f      	bne.n	800be26 <mp_div+0x1b6>
      ((res = mp_mul_2d(&tb, n, &tb)) != MP_OKAY) ||
 800bd46:	aa0b      	add	r2, sp, #44	; 0x2c
 800bd48:	ab0b      	add	r3, sp, #44	; 0x2c
 800bd4a:	9918      	ldr	r1, [sp, #96]	; 0x60
 800bd4c:	4618      	mov	r0, r3
 800bd4e:	f7ff f8cf 	bl	800aef0 <mp_mul_2d>
 800bd52:	9019      	str	r0, [sp, #100]	; 0x64
 800bd54:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d165      	bne.n	800be26 <mp_div+0x1b6>
 800bd5a:	e030      	b.n	800bdbe <mp_div+0x14e>
     if (mp_cmp(&tb, &ta) != MP_GT) {
 800bd5c:	aa13      	add	r2, sp, #76	; 0x4c
 800bd5e:	ab0f      	add	r3, sp, #60	; 0x3c
 800bd60:	4611      	mov	r1, r2
 800bd62:	4618      	mov	r0, r3
 800bd64:	f7ff feb4 	bl	800bad0 <mp_cmp>
 800bd68:	4603      	mov	r3, r0
 800bd6a:	2b01      	cmp	r3, #1
 800bd6c:	d013      	beq.n	800bd96 <mp_div+0x126>
        if (((res = mp_sub(&ta, &tb, &ta)) != MP_OKAY) ||
 800bd6e:	aa13      	add	r2, sp, #76	; 0x4c
 800bd70:	a90f      	add	r1, sp, #60	; 0x3c
 800bd72:	ab13      	add	r3, sp, #76	; 0x4c
 800bd74:	4618      	mov	r0, r3
 800bd76:	f7fc f943 	bl	8008000 <mp_sub>
 800bd7a:	9019      	str	r0, [sp, #100]	; 0x64
 800bd7c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd7e:	2b00      	cmp	r3, #0
 800bd80:	d151      	bne.n	800be26 <mp_div+0x1b6>
 800bd82:	aa07      	add	r2, sp, #28
 800bd84:	a90b      	add	r1, sp, #44	; 0x2c
 800bd86:	ab07      	add	r3, sp, #28
 800bd88:	4618      	mov	r0, r3
 800bd8a:	f7fb ffd1 	bl	8007d30 <mp_add>
 800bd8e:	9019      	str	r0, [sp, #100]	; 0x64
 800bd90:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bd92:	2b00      	cmp	r3, #0
 800bd94:	d147      	bne.n	800be26 <mp_div+0x1b6>
     if (((res = mp_div_2d(&tb, 1, &tb, NULL)) != MP_OKAY) ||
 800bd96:	aa0f      	add	r2, sp, #60	; 0x3c
 800bd98:	a80f      	add	r0, sp, #60	; 0x3c
 800bd9a:	2300      	movs	r3, #0
 800bd9c:	2101      	movs	r1, #1
 800bd9e:	f7fe fe67 	bl	800aa70 <mp_div_2d>
 800bda2:	9019      	str	r0, [sp, #100]	; 0x64
 800bda4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bda6:	2b00      	cmp	r3, #0
 800bda8:	d13d      	bne.n	800be26 <mp_div+0x1b6>
 800bdaa:	aa0b      	add	r2, sp, #44	; 0x2c
 800bdac:	a80b      	add	r0, sp, #44	; 0x2c
 800bdae:	2300      	movs	r3, #0
 800bdb0:	2101      	movs	r1, #1
 800bdb2:	f7fe fe5d 	bl	800aa70 <mp_div_2d>
 800bdb6:	9019      	str	r0, [sp, #100]	; 0x64
 800bdb8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800bdba:	2b00      	cmp	r3, #0
 800bdbc:	d133      	bne.n	800be26 <mp_div+0x1b6>
  while (n-- >= 0) {
 800bdbe:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800bdc0:	1e5a      	subs	r2, r3, #1
 800bdc2:	9218      	str	r2, [sp, #96]	; 0x60
 800bdc4:	2b00      	cmp	r3, #0
 800bdc6:	dac9      	bge.n	800bd5c <mp_div+0xec>
  n  = a->sign;
 800bdc8:	9b05      	ldr	r3, [sp, #20]
 800bdca:	689b      	ldr	r3, [r3, #8]
 800bdcc:	9318      	str	r3, [sp, #96]	; 0x60
  n2 = (a->sign == b->sign ? MP_ZPOS : MP_NEG);
 800bdce:	9b05      	ldr	r3, [sp, #20]
 800bdd0:	689a      	ldr	r2, [r3, #8]
 800bdd2:	9b04      	ldr	r3, [sp, #16]
 800bdd4:	689b      	ldr	r3, [r3, #8]
 800bdd6:	429a      	cmp	r2, r3
 800bdd8:	bf14      	ite	ne
 800bdda:	2301      	movne	r3, #1
 800bddc:	2300      	moveq	r3, #0
 800bdde:	b2db      	uxtb	r3, r3
 800bde0:	9317      	str	r3, [sp, #92]	; 0x5c
  if (c != NULL) {
 800bde2:	9b03      	ldr	r3, [sp, #12]
 800bde4:	2b00      	cmp	r3, #0
 800bde6:	d00d      	beq.n	800be04 <mp_div+0x194>
     mp_exch(c, &q);
 800bde8:	ab07      	add	r3, sp, #28
 800bdea:	4619      	mov	r1, r3
 800bdec:	9803      	ldr	r0, [sp, #12]
 800bdee:	f7fe ff07 	bl	800ac00 <mp_exch>
     c->sign  = (mp_iszero(c) == MP_YES) ? MP_ZPOS : n2;
 800bdf2:	9b03      	ldr	r3, [sp, #12]
 800bdf4:	681b      	ldr	r3, [r3, #0]
 800bdf6:	2b00      	cmp	r3, #0
 800bdf8:	d001      	beq.n	800bdfe <mp_div+0x18e>
 800bdfa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800bdfc:	e000      	b.n	800be00 <mp_div+0x190>
 800bdfe:	2300      	movs	r3, #0
 800be00:	9a03      	ldr	r2, [sp, #12]
 800be02:	6093      	str	r3, [r2, #8]
  if (d != NULL) {
 800be04:	9b02      	ldr	r3, [sp, #8]
 800be06:	2b00      	cmp	r3, #0
 800be08:	d00d      	beq.n	800be26 <mp_div+0x1b6>
     mp_exch(d, &ta);
 800be0a:	ab13      	add	r3, sp, #76	; 0x4c
 800be0c:	4619      	mov	r1, r3
 800be0e:	9802      	ldr	r0, [sp, #8]
 800be10:	f7fe fef6 	bl	800ac00 <mp_exch>
     d->sign = (mp_iszero(d) == MP_YES) ? MP_ZPOS : n;
 800be14:	9b02      	ldr	r3, [sp, #8]
 800be16:	681b      	ldr	r3, [r3, #0]
 800be18:	2b00      	cmp	r3, #0
 800be1a:	d001      	beq.n	800be20 <mp_div+0x1b0>
 800be1c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800be1e:	e000      	b.n	800be22 <mp_div+0x1b2>
 800be20:	2300      	movs	r3, #0
 800be22:	9a02      	ldr	r2, [sp, #8]
 800be24:	6093      	str	r3, [r2, #8]
   mp_clear(&ta);
 800be26:	ab13      	add	r3, sp, #76	; 0x4c
 800be28:	4618      	mov	r0, r3
 800be2a:	f7fe fc01 	bl	800a630 <mp_clear>
   mp_clear(&tb);
 800be2e:	ab0f      	add	r3, sp, #60	; 0x3c
 800be30:	4618      	mov	r0, r3
 800be32:	f7fe fbfd 	bl	800a630 <mp_clear>
   mp_clear(&tq);
 800be36:	ab0b      	add	r3, sp, #44	; 0x2c
 800be38:	4618      	mov	r0, r3
 800be3a:	f7fe fbf9 	bl	800a630 <mp_clear>
   mp_clear(&q);
 800be3e:	ab07      	add	r3, sp, #28
 800be40:	4618      	mov	r0, r3
 800be42:	f7fe fbf5 	bl	800a630 <mp_clear>
   return res;
 800be46:	9b19      	ldr	r3, [sp, #100]	; 0x64
}
 800be48:	4618      	mov	r0, r3
 800be4a:	b01a      	add	sp, #104	; 0x68
 800be4c:	bd10      	pop	{r4, pc}
 800be4e:	bf00      	nop

0800be50 <get_digit_count>:
    };
#endif


int get_digit_count(mp_int* a)
{
 800be50:	b082      	sub	sp, #8
 800be52:	9001      	str	r0, [sp, #4]
    if (a == NULL)
 800be54:	9b01      	ldr	r3, [sp, #4]
 800be56:	2b00      	cmp	r3, #0
 800be58:	d101      	bne.n	800be5e <get_digit_count+0xe>
        return 0;
 800be5a:	2300      	movs	r3, #0
 800be5c:	e001      	b.n	800be62 <get_digit_count+0x12>

    return a->used;
 800be5e:	9b01      	ldr	r3, [sp, #4]
 800be60:	681b      	ldr	r3, [r3, #0]
}
 800be62:	4618      	mov	r0, r3
 800be64:	b002      	add	sp, #8
 800be66:	4770      	bx	lr
	...

0800be70 <get_rand_digit>:

    return (n >= a->used || n < 0) ? 0 : a->dp[n];
}

int get_rand_digit(WC_RNG* rng, mp_digit* d)
{
 800be70:	b500      	push	{lr}
 800be72:	b083      	sub	sp, #12
 800be74:	9001      	str	r0, [sp, #4]
 800be76:	9100      	str	r1, [sp, #0]
    return wc_RNG_GenerateBlock(rng, (byte*)d, sizeof(mp_digit));
 800be78:	2204      	movs	r2, #4
 800be7a:	9900      	ldr	r1, [sp, #0]
 800be7c:	9801      	ldr	r0, [sp, #4]
 800be7e:	f002 fd5f 	bl	800e940 <wc_RNG_GenerateBlock>
 800be82:	4603      	mov	r3, r0
}
 800be84:	4618      	mov	r0, r3
 800be86:	b003      	add	sp, #12
 800be88:	f85d fb04 	ldr.w	pc, [sp], #4
 800be8c:	0000      	movs	r0, r0
	...

0800be90 <mp_rand>:

#ifdef WC_RSA_BLINDING
int mp_rand(mp_int* a, int digits, WC_RNG* rng)
{
 800be90:	b500      	push	{lr}
 800be92:	b087      	sub	sp, #28
 800be94:	9003      	str	r0, [sp, #12]
 800be96:	9102      	str	r1, [sp, #8]
 800be98:	9201      	str	r2, [sp, #4]
    int ret;
    mp_digit d;

    if (rng == NULL)
 800be9a:	9b01      	ldr	r3, [sp, #4]
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d102      	bne.n	800bea6 <mp_rand+0x16>
        return MISSING_RNG_E;
 800bea0:	f06f 03eb 	mvn.w	r3, #235	; 0xeb
 800bea4:	e04f      	b.n	800bf46 <mp_rand+0xb6>

    if (a == NULL)
 800bea6:	9b03      	ldr	r3, [sp, #12]
 800bea8:	2b00      	cmp	r3, #0
 800beaa:	d102      	bne.n	800beb2 <mp_rand+0x22>
        return BAD_FUNC_ARG;
 800beac:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800beb0:	e049      	b.n	800bf46 <mp_rand+0xb6>

    mp_zero(a);
 800beb2:	9803      	ldr	r0, [sp, #12]
 800beb4:	f7fe fe5c 	bl	800ab70 <mp_zero>
    if (digits <= 0) {
 800beb8:	9b02      	ldr	r3, [sp, #8]
 800beba:	2b00      	cmp	r3, #0
 800bebc:	dc01      	bgt.n	800bec2 <mp_rand+0x32>
        return MP_OKAY;
 800bebe:	2300      	movs	r3, #0
 800bec0:	e041      	b.n	800bf46 <mp_rand+0xb6>
    }

    /* first place a random non-zero digit */
    do {
        ret = get_rand_digit(rng, &d);
 800bec2:	ab04      	add	r3, sp, #16
 800bec4:	4619      	mov	r1, r3
 800bec6:	9801      	ldr	r0, [sp, #4]
 800bec8:	f7ff ffd2 	bl	800be70 <get_rand_digit>
 800becc:	9005      	str	r0, [sp, #20]
        if (ret != 0) {
 800bece:	9b05      	ldr	r3, [sp, #20]
 800bed0:	2b00      	cmp	r3, #0
 800bed2:	d001      	beq.n	800bed8 <mp_rand+0x48>
            return ret;
 800bed4:	9b05      	ldr	r3, [sp, #20]
 800bed6:	e036      	b.n	800bf46 <mp_rand+0xb6>
        }
    } while (d == 0);
 800bed8:	9b04      	ldr	r3, [sp, #16]
 800beda:	2b00      	cmp	r3, #0
 800bedc:	d0f1      	beq.n	800bec2 <mp_rand+0x32>

    if ((ret = mp_add_d(a, d, a)) != MP_OKAY) {
 800bede:	9b04      	ldr	r3, [sp, #16]
 800bee0:	9a03      	ldr	r2, [sp, #12]
 800bee2:	4619      	mov	r1, r3
 800bee4:	9803      	ldr	r0, [sp, #12]
 800bee6:	f7fa fc63 	bl	80067b0 <mp_add_d>
 800beea:	9005      	str	r0, [sp, #20]
 800beec:	9b05      	ldr	r3, [sp, #20]
 800beee:	2b00      	cmp	r3, #0
 800bef0:	d022      	beq.n	800bf38 <mp_rand+0xa8>
        return ret;
 800bef2:	9b05      	ldr	r3, [sp, #20]
 800bef4:	e027      	b.n	800bf46 <mp_rand+0xb6>
    }

    while (--digits > 0) {
        if ((ret = mp_lshd(a, 1)) != MP_OKAY) {
 800bef6:	2101      	movs	r1, #1
 800bef8:	9803      	ldr	r0, [sp, #12]
 800befa:	f7ff f8a1 	bl	800b040 <mp_lshd>
 800befe:	9005      	str	r0, [sp, #20]
 800bf00:	9b05      	ldr	r3, [sp, #20]
 800bf02:	2b00      	cmp	r3, #0
 800bf04:	d001      	beq.n	800bf0a <mp_rand+0x7a>
            return ret;
 800bf06:	9b05      	ldr	r3, [sp, #20]
 800bf08:	e01d      	b.n	800bf46 <mp_rand+0xb6>
        }
        if ((ret = get_rand_digit(rng, &d)) != 0) {
 800bf0a:	ab04      	add	r3, sp, #16
 800bf0c:	4619      	mov	r1, r3
 800bf0e:	9801      	ldr	r0, [sp, #4]
 800bf10:	f7ff ffae 	bl	800be70 <get_rand_digit>
 800bf14:	9005      	str	r0, [sp, #20]
 800bf16:	9b05      	ldr	r3, [sp, #20]
 800bf18:	2b00      	cmp	r3, #0
 800bf1a:	d001      	beq.n	800bf20 <mp_rand+0x90>
            return ret;
 800bf1c:	9b05      	ldr	r3, [sp, #20]
 800bf1e:	e012      	b.n	800bf46 <mp_rand+0xb6>
        }
        if ((ret = mp_add_d(a, d, a)) != MP_OKAY) {
 800bf20:	9b04      	ldr	r3, [sp, #16]
 800bf22:	9a03      	ldr	r2, [sp, #12]
 800bf24:	4619      	mov	r1, r3
 800bf26:	9803      	ldr	r0, [sp, #12]
 800bf28:	f7fa fc42 	bl	80067b0 <mp_add_d>
 800bf2c:	9005      	str	r0, [sp, #20]
 800bf2e:	9b05      	ldr	r3, [sp, #20]
 800bf30:	2b00      	cmp	r3, #0
 800bf32:	d001      	beq.n	800bf38 <mp_rand+0xa8>
            return ret;
 800bf34:	9b05      	ldr	r3, [sp, #20]
 800bf36:	e006      	b.n	800bf46 <mp_rand+0xb6>
    while (--digits > 0) {
 800bf38:	9b02      	ldr	r3, [sp, #8]
 800bf3a:	3b01      	subs	r3, #1
 800bf3c:	9302      	str	r3, [sp, #8]
 800bf3e:	9b02      	ldr	r3, [sp, #8]
 800bf40:	2b00      	cmp	r3, #0
 800bf42:	dcd8      	bgt.n	800bef6 <mp_rand+0x66>
        }
    }

    return ret;
 800bf44:	9b05      	ldr	r3, [sp, #20]
}
 800bf46:	4618      	mov	r0, r3
 800bf48:	b007      	add	sp, #28
 800bf4a:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf4e:	bf00      	nop

0800bf50 <Base64_Decode>:
                              46, 47, 48, 49, 50, 51
                            };


int Base64_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 800bf50:	b08c      	sub	sp, #48	; 0x30
 800bf52:	9003      	str	r0, [sp, #12]
 800bf54:	9102      	str	r1, [sp, #8]
 800bf56:	9201      	str	r2, [sp, #4]
 800bf58:	9300      	str	r3, [sp, #0]
    word32 i = 0;
 800bf5a:	2300      	movs	r3, #0
 800bf5c:	930b      	str	r3, [sp, #44]	; 0x2c
    word32 j = 0;
 800bf5e:	2300      	movs	r3, #0
 800bf60:	930a      	str	r3, [sp, #40]	; 0x28
    word32 plainSz = inLen - ((inLen + (PEM_LINE_SZ - 1)) / PEM_LINE_SZ );
 800bf62:	9b02      	ldr	r3, [sp, #8]
 800bf64:	333f      	adds	r3, #63	; 0x3f
 800bf66:	099b      	lsrs	r3, r3, #6
 800bf68:	9a02      	ldr	r2, [sp, #8]
 800bf6a:	1ad3      	subs	r3, r2, r3
 800bf6c:	9306      	str	r3, [sp, #24]
    const byte maxIdx = (byte)sizeof(base64Decode) + 0x2B - 1;
 800bf6e:	237a      	movs	r3, #122	; 0x7a
 800bf70:	f88d 3017 	strb.w	r3, [sp, #23]

    plainSz = (plainSz * 3 + 3) / 4;
 800bf74:	9b06      	ldr	r3, [sp, #24]
 800bf76:	1c5a      	adds	r2, r3, #1
 800bf78:	4613      	mov	r3, r2
 800bf7a:	005b      	lsls	r3, r3, #1
 800bf7c:	4413      	add	r3, r2
 800bf7e:	089b      	lsrs	r3, r3, #2
 800bf80:	9306      	str	r3, [sp, #24]
    if (plainSz > *outLen) return BAD_FUNC_ARG;
 800bf82:	9b00      	ldr	r3, [sp, #0]
 800bf84:	681a      	ldr	r2, [r3, #0]
 800bf86:	9b06      	ldr	r3, [sp, #24]
 800bf88:	429a      	cmp	r2, r3
 800bf8a:	f080 811f 	bcs.w	800c1cc <Base64_Decode+0x27c>
 800bf8e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800bf92:	e123      	b.n	800c1dc <Base64_Decode+0x28c>

    while (inLen > 3) {
        byte b1, b2, b3;
        byte e1 = in[j++];
 800bf94:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bf96:	1c5a      	adds	r2, r3, #1
 800bf98:	920a      	str	r2, [sp, #40]	; 0x28
 800bf9a:	9a03      	ldr	r2, [sp, #12]
 800bf9c:	4413      	add	r3, r2
 800bf9e:	781b      	ldrb	r3, [r3, #0]
 800bfa0:	f88d 3016 	strb.w	r3, [sp, #22]
        byte e2 = in[j++];
 800bfa4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bfa6:	1c5a      	adds	r2, r3, #1
 800bfa8:	920a      	str	r2, [sp, #40]	; 0x28
 800bfaa:	9a03      	ldr	r2, [sp, #12]
 800bfac:	4413      	add	r3, r2
 800bfae:	781b      	ldrb	r3, [r3, #0]
 800bfb0:	f88d 3015 	strb.w	r3, [sp, #21]
        byte e3 = in[j++];
 800bfb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bfb6:	1c5a      	adds	r2, r3, #1
 800bfb8:	920a      	str	r2, [sp, #40]	; 0x28
 800bfba:	9a03      	ldr	r2, [sp, #12]
 800bfbc:	4413      	add	r3, r2
 800bfbe:	781b      	ldrb	r3, [r3, #0]
 800bfc0:	f88d 3014 	strb.w	r3, [sp, #20]
        byte e4 = in[j++];
 800bfc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bfc6:	1c5a      	adds	r2, r3, #1
 800bfc8:	920a      	str	r2, [sp, #40]	; 0x28
 800bfca:	9a03      	ldr	r2, [sp, #12]
 800bfcc:	4413      	add	r3, r2
 800bfce:	781b      	ldrb	r3, [r3, #0]
 800bfd0:	f88d 3013 	strb.w	r3, [sp, #19]

        int pad3 = 0;
 800bfd4:	2300      	movs	r3, #0
 800bfd6:	9309      	str	r3, [sp, #36]	; 0x24
        int pad4 = 0;
 800bfd8:	2300      	movs	r3, #0
 800bfda:	9308      	str	r3, [sp, #32]

        if (e1 == 0)            /* end file 0's */
 800bfdc:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800bfe0:	2b00      	cmp	r3, #0
 800bfe2:	f000 80f7 	beq.w	800c1d4 <Base64_Decode+0x284>
            break;
        if (e3 == PAD)
 800bfe6:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800bfea:	2b3d      	cmp	r3, #61	; 0x3d
 800bfec:	d101      	bne.n	800bff2 <Base64_Decode+0xa2>
            pad3 = 1;
 800bfee:	2301      	movs	r3, #1
 800bff0:	9309      	str	r3, [sp, #36]	; 0x24
        if (e4 == PAD)
 800bff2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800bff6:	2b3d      	cmp	r3, #61	; 0x3d
 800bff8:	d101      	bne.n	800bffe <Base64_Decode+0xae>
            pad4 = 1;
 800bffa:	2301      	movs	r3, #1
 800bffc:	9308      	str	r3, [sp, #32]

        if (e1 < 0x2B || e2 < 0x2B || e3 < 0x2B || e4 < 0x2B) {
 800bffe:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800c002:	2b2a      	cmp	r3, #42	; 0x2a
 800c004:	d90b      	bls.n	800c01e <Base64_Decode+0xce>
 800c006:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800c00a:	2b2a      	cmp	r3, #42	; 0x2a
 800c00c:	d907      	bls.n	800c01e <Base64_Decode+0xce>
 800c00e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800c012:	2b2a      	cmp	r3, #42	; 0x2a
 800c014:	d903      	bls.n	800c01e <Base64_Decode+0xce>
 800c016:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800c01a:	2b2a      	cmp	r3, #42	; 0x2a
 800c01c:	d802      	bhi.n	800c024 <Base64_Decode+0xd4>
            WOLFSSL_MSG("Bad Base64 Decode data, too small");
            return ASN_INPUT_E;
 800c01e:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800c022:	e0db      	b.n	800c1dc <Base64_Decode+0x28c>
        }

        if (e1 > maxIdx || e2 > maxIdx || e3 > maxIdx || e4 > maxIdx) {
 800c024:	f89d 2016 	ldrb.w	r2, [sp, #22]
 800c028:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c02c:	429a      	cmp	r2, r3
 800c02e:	d811      	bhi.n	800c054 <Base64_Decode+0x104>
 800c030:	f89d 2015 	ldrb.w	r2, [sp, #21]
 800c034:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c038:	429a      	cmp	r2, r3
 800c03a:	d80b      	bhi.n	800c054 <Base64_Decode+0x104>
 800c03c:	f89d 2014 	ldrb.w	r2, [sp, #20]
 800c040:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c044:	429a      	cmp	r2, r3
 800c046:	d805      	bhi.n	800c054 <Base64_Decode+0x104>
 800c048:	f89d 2013 	ldrb.w	r2, [sp, #19]
 800c04c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c050:	429a      	cmp	r2, r3
 800c052:	d902      	bls.n	800c05a <Base64_Decode+0x10a>
            WOLFSSL_MSG("Bad Base64 Decode data, too big");
            return ASN_INPUT_E;
 800c054:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800c058:	e0c0      	b.n	800c1dc <Base64_Decode+0x28c>
        }

        e1 = base64Decode[e1 - 0x2B];
 800c05a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800c05e:	3b2b      	subs	r3, #43	; 0x2b
 800c060:	4a60      	ldr	r2, [pc, #384]	; (800c1e4 <Base64_Decode+0x294>)
 800c062:	5cd3      	ldrb	r3, [r2, r3]
 800c064:	f88d 3016 	strb.w	r3, [sp, #22]
        e2 = base64Decode[e2 - 0x2B];
 800c068:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800c06c:	3b2b      	subs	r3, #43	; 0x2b
 800c06e:	4a5d      	ldr	r2, [pc, #372]	; (800c1e4 <Base64_Decode+0x294>)
 800c070:	5cd3      	ldrb	r3, [r2, r3]
 800c072:	f88d 3015 	strb.w	r3, [sp, #21]
        e3 = (e3 == PAD) ? 0 : base64Decode[e3 - 0x2B];
 800c076:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800c07a:	2b3d      	cmp	r3, #61	; 0x3d
 800c07c:	d005      	beq.n	800c08a <Base64_Decode+0x13a>
 800c07e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800c082:	3b2b      	subs	r3, #43	; 0x2b
 800c084:	4a57      	ldr	r2, [pc, #348]	; (800c1e4 <Base64_Decode+0x294>)
 800c086:	5cd3      	ldrb	r3, [r2, r3]
 800c088:	e000      	b.n	800c08c <Base64_Decode+0x13c>
 800c08a:	2300      	movs	r3, #0
 800c08c:	f88d 3014 	strb.w	r3, [sp, #20]
        e4 = (e4 == PAD) ? 0 : base64Decode[e4 - 0x2B];
 800c090:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800c094:	2b3d      	cmp	r3, #61	; 0x3d
 800c096:	d005      	beq.n	800c0a4 <Base64_Decode+0x154>
 800c098:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800c09c:	3b2b      	subs	r3, #43	; 0x2b
 800c09e:	4a51      	ldr	r2, [pc, #324]	; (800c1e4 <Base64_Decode+0x294>)
 800c0a0:	5cd3      	ldrb	r3, [r2, r3]
 800c0a2:	e000      	b.n	800c0a6 <Base64_Decode+0x156>
 800c0a4:	2300      	movs	r3, #0
 800c0a6:	f88d 3013 	strb.w	r3, [sp, #19]

        b1 = (byte)((e1 << 2) | (e2 >> 4));
 800c0aa:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800c0ae:	009b      	lsls	r3, r3, #2
 800c0b0:	b25a      	sxtb	r2, r3
 800c0b2:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800c0b6:	091b      	lsrs	r3, r3, #4
 800c0b8:	b2db      	uxtb	r3, r3
 800c0ba:	b25b      	sxtb	r3, r3
 800c0bc:	4313      	orrs	r3, r2
 800c0be:	b25b      	sxtb	r3, r3
 800c0c0:	f88d 3012 	strb.w	r3, [sp, #18]
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 800c0c4:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800c0c8:	011b      	lsls	r3, r3, #4
 800c0ca:	b25a      	sxtb	r2, r3
 800c0cc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800c0d0:	089b      	lsrs	r3, r3, #2
 800c0d2:	b2db      	uxtb	r3, r3
 800c0d4:	b25b      	sxtb	r3, r3
 800c0d6:	4313      	orrs	r3, r2
 800c0d8:	b25b      	sxtb	r3, r3
 800c0da:	f88d 3011 	strb.w	r3, [sp, #17]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 800c0de:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800c0e2:	019b      	lsls	r3, r3, #6
 800c0e4:	b25a      	sxtb	r2, r3
 800c0e6:	f99d 3013 	ldrsb.w	r3, [sp, #19]
 800c0ea:	4313      	orrs	r3, r2
 800c0ec:	b25b      	sxtb	r3, r3
 800c0ee:	f88d 3010 	strb.w	r3, [sp, #16]

        out[i++] = b1;
 800c0f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c0f4:	1c5a      	adds	r2, r3, #1
 800c0f6:	920b      	str	r2, [sp, #44]	; 0x2c
 800c0f8:	9a01      	ldr	r2, [sp, #4]
 800c0fa:	4413      	add	r3, r2
 800c0fc:	f89d 2012 	ldrb.w	r2, [sp, #18]
 800c100:	701a      	strb	r2, [r3, #0]
        if (!pad3)
 800c102:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c104:	2b00      	cmp	r3, #0
 800c106:	d107      	bne.n	800c118 <Base64_Decode+0x1c8>
            out[i++] = b2;
 800c108:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c10a:	1c5a      	adds	r2, r3, #1
 800c10c:	920b      	str	r2, [sp, #44]	; 0x2c
 800c10e:	9a01      	ldr	r2, [sp, #4]
 800c110:	4413      	add	r3, r2
 800c112:	f89d 2011 	ldrb.w	r2, [sp, #17]
 800c116:	701a      	strb	r2, [r3, #0]
        if (!pad4)
 800c118:	9b08      	ldr	r3, [sp, #32]
 800c11a:	2b00      	cmp	r3, #0
 800c11c:	d15a      	bne.n	800c1d4 <Base64_Decode+0x284>
            out[i++] = b3;
 800c11e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c120:	1c5a      	adds	r2, r3, #1
 800c122:	920b      	str	r2, [sp, #44]	; 0x2c
 800c124:	9a01      	ldr	r2, [sp, #4]
 800c126:	4413      	add	r3, r2
 800c128:	f89d 2010 	ldrb.w	r2, [sp, #16]
 800c12c:	701a      	strb	r2, [r3, #0]
        else
            break;

        inLen -= 4;
 800c12e:	9b02      	ldr	r3, [sp, #8]
 800c130:	3b04      	subs	r3, #4
 800c132:	9302      	str	r3, [sp, #8]
        if (inLen && (in[j] == ' ' || in[j] == '\r' || in[j] == '\n')) {
 800c134:	9b02      	ldr	r3, [sp, #8]
 800c136:	2b00      	cmp	r3, #0
 800c138:	d048      	beq.n	800c1cc <Base64_Decode+0x27c>
 800c13a:	9a03      	ldr	r2, [sp, #12]
 800c13c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c13e:	4413      	add	r3, r2
 800c140:	781b      	ldrb	r3, [r3, #0]
 800c142:	2b20      	cmp	r3, #32
 800c144:	d00b      	beq.n	800c15e <Base64_Decode+0x20e>
 800c146:	9a03      	ldr	r2, [sp, #12]
 800c148:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c14a:	4413      	add	r3, r2
 800c14c:	781b      	ldrb	r3, [r3, #0]
 800c14e:	2b0d      	cmp	r3, #13
 800c150:	d005      	beq.n	800c15e <Base64_Decode+0x20e>
 800c152:	9a03      	ldr	r2, [sp, #12]
 800c154:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c156:	4413      	add	r3, r2
 800c158:	781b      	ldrb	r3, [r3, #0]
 800c15a:	2b0a      	cmp	r3, #10
 800c15c:	d136      	bne.n	800c1cc <Base64_Decode+0x27c>
            byte endLine = in[j++];
 800c15e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c160:	1c5a      	adds	r2, r3, #1
 800c162:	920a      	str	r2, [sp, #40]	; 0x28
 800c164:	9a03      	ldr	r2, [sp, #12]
 800c166:	4413      	add	r3, r2
 800c168:	781b      	ldrb	r3, [r3, #0]
 800c16a:	f88d 301f 	strb.w	r3, [sp, #31]
            inLen--;
 800c16e:	9b02      	ldr	r3, [sp, #8]
 800c170:	3b01      	subs	r3, #1
 800c172:	9302      	str	r3, [sp, #8]
 800c174:	e00a      	b.n	800c18c <Base64_Decode+0x23c>
            while (inLen && endLine == ' ') {   /* allow trailing whitespace */
                endLine = in[j++];
 800c176:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c178:	1c5a      	adds	r2, r3, #1
 800c17a:	920a      	str	r2, [sp, #40]	; 0x28
 800c17c:	9a03      	ldr	r2, [sp, #12]
 800c17e:	4413      	add	r3, r2
 800c180:	781b      	ldrb	r3, [r3, #0]
 800c182:	f88d 301f 	strb.w	r3, [sp, #31]
                inLen--;
 800c186:	9b02      	ldr	r3, [sp, #8]
 800c188:	3b01      	subs	r3, #1
 800c18a:	9302      	str	r3, [sp, #8]
            while (inLen && endLine == ' ') {   /* allow trailing whitespace */
 800c18c:	9b02      	ldr	r3, [sp, #8]
 800c18e:	2b00      	cmp	r3, #0
 800c190:	d003      	beq.n	800c19a <Base64_Decode+0x24a>
 800c192:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800c196:	2b20      	cmp	r3, #32
 800c198:	d0ed      	beq.n	800c176 <Base64_Decode+0x226>
            }
            if (endLine == '\r') {
 800c19a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800c19e:	2b0d      	cmp	r3, #13
 800c1a0:	d10d      	bne.n	800c1be <Base64_Decode+0x26e>
                if (inLen) {
 800c1a2:	9b02      	ldr	r3, [sp, #8]
 800c1a4:	2b00      	cmp	r3, #0
 800c1a6:	d00a      	beq.n	800c1be <Base64_Decode+0x26e>
                    endLine = in[j++];
 800c1a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c1aa:	1c5a      	adds	r2, r3, #1
 800c1ac:	920a      	str	r2, [sp, #40]	; 0x28
 800c1ae:	9a03      	ldr	r2, [sp, #12]
 800c1b0:	4413      	add	r3, r2
 800c1b2:	781b      	ldrb	r3, [r3, #0]
 800c1b4:	f88d 301f 	strb.w	r3, [sp, #31]
                    inLen--;
 800c1b8:	9b02      	ldr	r3, [sp, #8]
 800c1ba:	3b01      	subs	r3, #1
 800c1bc:	9302      	str	r3, [sp, #8]
                }
            }
            if (endLine != '\n') {
 800c1be:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800c1c2:	2b0a      	cmp	r3, #10
 800c1c4:	d002      	beq.n	800c1cc <Base64_Decode+0x27c>
                WOLFSSL_MSG("Bad end of line in Base64 Decode");
                return ASN_INPUT_E;
 800c1c6:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800c1ca:	e007      	b.n	800c1dc <Base64_Decode+0x28c>
    while (inLen > 3) {
 800c1cc:	9b02      	ldr	r3, [sp, #8]
 800c1ce:	2b03      	cmp	r3, #3
 800c1d0:	f63f aee0 	bhi.w	800bf94 <Base64_Decode+0x44>
            }
        }
    }
    *outLen = i;
 800c1d4:	9b00      	ldr	r3, [sp, #0]
 800c1d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800c1d8:	601a      	str	r2, [r3, #0]

    return 0;
 800c1da:	2300      	movs	r3, #0
}
 800c1dc:	4618      	mov	r0, r3
 800c1de:	b00c      	add	sp, #48	; 0x30
 800c1e0:	4770      	bx	lr
 800c1e2:	bf00      	nop
 800c1e4:	080245c0 	.word	0x080245c0
	...

0800c1f0 <CEscape>:

/* make sure *i (idx) won't exceed max, store and possibly escape to out,
 * raw means use e w/o decode,  0 on success */
static int CEscape(int escaped, byte e, byte* out, word32* i, word32 max,
                  int raw, int getSzOnly)
{
 800c1f0:	b088      	sub	sp, #32
 800c1f2:	9003      	str	r0, [sp, #12]
 800c1f4:	9201      	str	r2, [sp, #4]
 800c1f6:	9300      	str	r3, [sp, #0]
 800c1f8:	460b      	mov	r3, r1
 800c1fa:	f88d 300b 	strb.w	r3, [sp, #11]
    int    doEscape = 0;
 800c1fe:	2300      	movs	r3, #0
 800c200:	9307      	str	r3, [sp, #28]
    word32 needed = 1;
 800c202:	2301      	movs	r3, #1
 800c204:	9306      	str	r3, [sp, #24]
    word32 idx = *i;
 800c206:	9b00      	ldr	r3, [sp, #0]
 800c208:	681b      	ldr	r3, [r3, #0]
 800c20a:	9305      	str	r3, [sp, #20]

    byte basic;
    byte plus    = 0;
 800c20c:	2300      	movs	r3, #0
 800c20e:	f88d 3012 	strb.w	r3, [sp, #18]
    byte equals  = 0;
 800c212:	2300      	movs	r3, #0
 800c214:	f88d 3011 	strb.w	r3, [sp, #17]
    byte newline = 0;
 800c218:	2300      	movs	r3, #0
 800c21a:	f88d 3010 	strb.w	r3, [sp, #16]

    if (raw)
 800c21e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c220:	2b00      	cmp	r3, #0
 800c222:	d004      	beq.n	800c22e <CEscape+0x3e>
        basic = e;
 800c224:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800c228:	f88d 3013 	strb.w	r3, [sp, #19]
 800c22c:	e005      	b.n	800c23a <CEscape+0x4a>
    else
        basic = base64Encode[e];
 800c22e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800c232:	4a4b      	ldr	r2, [pc, #300]	; (800c360 <CEscape+0x170>)
 800c234:	5cd3      	ldrb	r3, [r2, r3]
 800c236:	f88d 3013 	strb.w	r3, [sp, #19]

    /* check whether to escape. Only escape for EncodeEsc */
    if (escaped == WC_ESC_NL_ENC) {
 800c23a:	9b03      	ldr	r3, [sp, #12]
 800c23c:	2b01      	cmp	r3, #1
 800c23e:	d122      	bne.n	800c286 <CEscape+0x96>
        switch ((char)basic) {
 800c240:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800c244:	2b2b      	cmp	r3, #43	; 0x2b
 800c246:	d004      	beq.n	800c252 <CEscape+0x62>
 800c248:	2b3d      	cmp	r3, #61	; 0x3d
 800c24a:	d00b      	beq.n	800c264 <CEscape+0x74>
 800c24c:	2b0a      	cmp	r3, #10
 800c24e:	d012      	beq.n	800c276 <CEscape+0x86>
 800c250:	e019      	b.n	800c286 <CEscape+0x96>
            case '+' :
                plus     = 1;
 800c252:	2301      	movs	r3, #1
 800c254:	f88d 3012 	strb.w	r3, [sp, #18]
                doEscape = 1;
 800c258:	2301      	movs	r3, #1
 800c25a:	9307      	str	r3, [sp, #28]
                needed  += 2;
 800c25c:	9b06      	ldr	r3, [sp, #24]
 800c25e:	3302      	adds	r3, #2
 800c260:	9306      	str	r3, [sp, #24]
 800c262:	e010      	b.n	800c286 <CEscape+0x96>
                break;
            case '=' :
                equals   = 1;
 800c264:	2301      	movs	r3, #1
 800c266:	f88d 3011 	strb.w	r3, [sp, #17]
                doEscape = 1;
 800c26a:	2301      	movs	r3, #1
 800c26c:	9307      	str	r3, [sp, #28]
                needed  += 2;
 800c26e:	9b06      	ldr	r3, [sp, #24]
 800c270:	3302      	adds	r3, #2
 800c272:	9306      	str	r3, [sp, #24]
 800c274:	e007      	b.n	800c286 <CEscape+0x96>
                break;
            case '\n' :
                newline  = 1;
 800c276:	2301      	movs	r3, #1
 800c278:	f88d 3010 	strb.w	r3, [sp, #16]
                doEscape = 1;
 800c27c:	2301      	movs	r3, #1
 800c27e:	9307      	str	r3, [sp, #28]
                needed  += 2;
 800c280:	9b06      	ldr	r3, [sp, #24]
 800c282:	3302      	adds	r3, #2
 800c284:	9306      	str	r3, [sp, #24]
                break;
        }
    }

    /* check size */
    if ( (idx+needed) > max && !getSzOnly) {
 800c286:	9a05      	ldr	r2, [sp, #20]
 800c288:	9b06      	ldr	r3, [sp, #24]
 800c28a:	441a      	add	r2, r3
 800c28c:	9b08      	ldr	r3, [sp, #32]
 800c28e:	429a      	cmp	r2, r3
 800c290:	d905      	bls.n	800c29e <CEscape+0xae>
 800c292:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c294:	2b00      	cmp	r3, #0
 800c296:	d102      	bne.n	800c29e <CEscape+0xae>
        WOLFSSL_MSG("Escape buffer max too small");
        return BUFFER_E;
 800c298:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800c29c:	e05c      	b.n	800c358 <CEscape+0x168>
    }

    /* store it */
    if (doEscape == 0) {
 800c29e:	9b07      	ldr	r3, [sp, #28]
 800c2a0:	2b00      	cmp	r3, #0
 800c2a2:	d10f      	bne.n	800c2c4 <CEscape+0xd4>
        if(getSzOnly)
 800c2a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c2a6:	2b00      	cmp	r3, #0
 800c2a8:	d003      	beq.n	800c2b2 <CEscape+0xc2>
            idx++;
 800c2aa:	9b05      	ldr	r3, [sp, #20]
 800c2ac:	3301      	adds	r3, #1
 800c2ae:	9305      	str	r3, [sp, #20]
        else
            out[idx++] = basic;
 800c2b0:	e04e      	b.n	800c350 <CEscape+0x160>
 800c2b2:	9b05      	ldr	r3, [sp, #20]
 800c2b4:	1c5a      	adds	r2, r3, #1
 800c2b6:	9205      	str	r2, [sp, #20]
 800c2b8:	9a01      	ldr	r2, [sp, #4]
 800c2ba:	4413      	add	r3, r2
 800c2bc:	f89d 2013 	ldrb.w	r2, [sp, #19]
 800c2c0:	701a      	strb	r2, [r3, #0]
 800c2c2:	e045      	b.n	800c350 <CEscape+0x160>
    }
    else {
        if(getSzOnly)
 800c2c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c2c6:	2b00      	cmp	r3, #0
 800c2c8:	d003      	beq.n	800c2d2 <CEscape+0xe2>
            idx+=3;
 800c2ca:	9b05      	ldr	r3, [sp, #20]
 800c2cc:	3303      	adds	r3, #3
 800c2ce:	9305      	str	r3, [sp, #20]
 800c2d0:	e03e      	b.n	800c350 <CEscape+0x160>
        else {
            out[idx++] = '%';  /* start escape */
 800c2d2:	9b05      	ldr	r3, [sp, #20]
 800c2d4:	1c5a      	adds	r2, r3, #1
 800c2d6:	9205      	str	r2, [sp, #20]
 800c2d8:	9a01      	ldr	r2, [sp, #4]
 800c2da:	4413      	add	r3, r2
 800c2dc:	2225      	movs	r2, #37	; 0x25
 800c2de:	701a      	strb	r2, [r3, #0]

            if (plus) {
 800c2e0:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800c2e4:	2b00      	cmp	r3, #0
 800c2e6:	d00e      	beq.n	800c306 <CEscape+0x116>
                out[idx++] = '2';
 800c2e8:	9b05      	ldr	r3, [sp, #20]
 800c2ea:	1c5a      	adds	r2, r3, #1
 800c2ec:	9205      	str	r2, [sp, #20]
 800c2ee:	9a01      	ldr	r2, [sp, #4]
 800c2f0:	4413      	add	r3, r2
 800c2f2:	2232      	movs	r2, #50	; 0x32
 800c2f4:	701a      	strb	r2, [r3, #0]
                out[idx++] = 'B';
 800c2f6:	9b05      	ldr	r3, [sp, #20]
 800c2f8:	1c5a      	adds	r2, r3, #1
 800c2fa:	9205      	str	r2, [sp, #20]
 800c2fc:	9a01      	ldr	r2, [sp, #4]
 800c2fe:	4413      	add	r3, r2
 800c300:	2242      	movs	r2, #66	; 0x42
 800c302:	701a      	strb	r2, [r3, #0]
 800c304:	e024      	b.n	800c350 <CEscape+0x160>
            }
            else if (equals) {
 800c306:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800c30a:	2b00      	cmp	r3, #0
 800c30c:	d00e      	beq.n	800c32c <CEscape+0x13c>
                out[idx++] = '3';
 800c30e:	9b05      	ldr	r3, [sp, #20]
 800c310:	1c5a      	adds	r2, r3, #1
 800c312:	9205      	str	r2, [sp, #20]
 800c314:	9a01      	ldr	r2, [sp, #4]
 800c316:	4413      	add	r3, r2
 800c318:	2233      	movs	r2, #51	; 0x33
 800c31a:	701a      	strb	r2, [r3, #0]
                out[idx++] = 'D';
 800c31c:	9b05      	ldr	r3, [sp, #20]
 800c31e:	1c5a      	adds	r2, r3, #1
 800c320:	9205      	str	r2, [sp, #20]
 800c322:	9a01      	ldr	r2, [sp, #4]
 800c324:	4413      	add	r3, r2
 800c326:	2244      	movs	r2, #68	; 0x44
 800c328:	701a      	strb	r2, [r3, #0]
 800c32a:	e011      	b.n	800c350 <CEscape+0x160>
            }
            else if (newline) {
 800c32c:	f89d 3010 	ldrb.w	r3, [sp, #16]
 800c330:	2b00      	cmp	r3, #0
 800c332:	d00d      	beq.n	800c350 <CEscape+0x160>
                out[idx++] = '0';
 800c334:	9b05      	ldr	r3, [sp, #20]
 800c336:	1c5a      	adds	r2, r3, #1
 800c338:	9205      	str	r2, [sp, #20]
 800c33a:	9a01      	ldr	r2, [sp, #4]
 800c33c:	4413      	add	r3, r2
 800c33e:	2230      	movs	r2, #48	; 0x30
 800c340:	701a      	strb	r2, [r3, #0]
                out[idx++] = 'A';
 800c342:	9b05      	ldr	r3, [sp, #20]
 800c344:	1c5a      	adds	r2, r3, #1
 800c346:	9205      	str	r2, [sp, #20]
 800c348:	9a01      	ldr	r2, [sp, #4]
 800c34a:	4413      	add	r3, r2
 800c34c:	2241      	movs	r2, #65	; 0x41
 800c34e:	701a      	strb	r2, [r3, #0]
            }
        }
    }
    *i = idx;
 800c350:	9b00      	ldr	r3, [sp, #0]
 800c352:	9a05      	ldr	r2, [sp, #20]
 800c354:	601a      	str	r2, [r3, #0]

    return 0;
 800c356:	2300      	movs	r3, #0
}
 800c358:	4618      	mov	r0, r3
 800c35a:	b008      	add	sp, #32
 800c35c:	4770      	bx	lr
 800c35e:	bf00      	nop
 800c360:	08024610 	.word	0x08024610
	...

0800c370 <DoBase64_Encode>:

/* internal worker, handles both escaped and normal line endings.
   If out buffer is NULL, will return sz needed in outLen */
static int DoBase64_Encode(const byte* in, word32 inLen, byte* out,
                           word32* outLen, int escaped)
{
 800c370:	b500      	push	{lr}
 800c372:	b095      	sub	sp, #84	; 0x54
 800c374:	9007      	str	r0, [sp, #28]
 800c376:	9106      	str	r1, [sp, #24]
 800c378:	9205      	str	r2, [sp, #20]
 800c37a:	9304      	str	r3, [sp, #16]
    int    ret = 0;
 800c37c:	2300      	movs	r3, #0
 800c37e:	9313      	str	r3, [sp, #76]	; 0x4c
    word32 i = 0,
 800c380:	2300      	movs	r3, #0
 800c382:	9308      	str	r3, [sp, #32]
           j = 0,
 800c384:	2300      	movs	r3, #0
 800c386:	9312      	str	r3, [sp, #72]	; 0x48
           n = 0;   /* new line counter */
 800c388:	2300      	movs	r3, #0
 800c38a:	9311      	str	r3, [sp, #68]	; 0x44

    int    getSzOnly = (out == NULL);
 800c38c:	9b05      	ldr	r3, [sp, #20]
 800c38e:	2b00      	cmp	r3, #0
 800c390:	bf0c      	ite	eq
 800c392:	2301      	moveq	r3, #1
 800c394:	2300      	movne	r3, #0
 800c396:	b2db      	uxtb	r3, r3
 800c398:	930f      	str	r3, [sp, #60]	; 0x3c

    word32 outSz = (inLen + 3 - 1) / 3 * 4;
 800c39a:	9b06      	ldr	r3, [sp, #24]
 800c39c:	3302      	adds	r3, #2
 800c39e:	4a81      	ldr	r2, [pc, #516]	; (800c5a4 <DoBase64_Encode+0x234>)
 800c3a0:	fba2 2303 	umull	r2, r3, r2, r3
 800c3a4:	085b      	lsrs	r3, r3, #1
 800c3a6:	009b      	lsls	r3, r3, #2
 800c3a8:	930e      	str	r3, [sp, #56]	; 0x38
    word32 addSz = (outSz + PEM_LINE_SZ - 1) / PEM_LINE_SZ;  /* new lines */
 800c3aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c3ac:	333f      	adds	r3, #63	; 0x3f
 800c3ae:	099b      	lsrs	r3, r3, #6
 800c3b0:	9310      	str	r3, [sp, #64]	; 0x40

    if (escaped == WC_ESC_NL_ENC)
 800c3b2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c3b4:	2b01      	cmp	r3, #1
 800c3b6:	d105      	bne.n	800c3c4 <DoBase64_Encode+0x54>
        addSz *= 3;   /* instead of just \n, we're doing %0A triplet */
 800c3b8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800c3ba:	4613      	mov	r3, r2
 800c3bc:	005b      	lsls	r3, r3, #1
 800c3be:	4413      	add	r3, r2
 800c3c0:	9310      	str	r3, [sp, #64]	; 0x40
 800c3c2:	e004      	b.n	800c3ce <DoBase64_Encode+0x5e>
    else if (escaped == WC_NO_NL_ENC)
 800c3c4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c3c6:	2b02      	cmp	r3, #2
 800c3c8:	d101      	bne.n	800c3ce <DoBase64_Encode+0x5e>
        addSz = 0;    /* encode without \n */
 800c3ca:	2300      	movs	r3, #0
 800c3cc:	9310      	str	r3, [sp, #64]	; 0x40

    outSz += addSz;
 800c3ce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800c3d0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800c3d2:	4413      	add	r3, r2
 800c3d4:	930e      	str	r3, [sp, #56]	; 0x38

    /* if escaped we can't predetermine size for one pass encoding, but
     * make sure we have enough if no escapes are in input
     * Also need to ensure outLen valid before dereference */
    if (!outLen || (outSz > *outLen && !getSzOnly)) return BAD_FUNC_ARG;
 800c3d6:	9b04      	ldr	r3, [sp, #16]
 800c3d8:	2b00      	cmp	r3, #0
 800c3da:	d009      	beq.n	800c3f0 <DoBase64_Encode+0x80>
 800c3dc:	9b04      	ldr	r3, [sp, #16]
 800c3de:	681a      	ldr	r2, [r3, #0]
 800c3e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c3e2:	429a      	cmp	r2, r3
 800c3e4:	f080 80b9 	bcs.w	800c55a <DoBase64_Encode+0x1ea>
 800c3e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800c3ea:	2b00      	cmp	r3, #0
 800c3ec:	f040 80b5 	bne.w	800c55a <DoBase64_Encode+0x1ea>
 800c3f0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800c3f4:	e184      	b.n	800c700 <DoBase64_Encode+0x390>

    while (inLen > 2) {
        byte b1 = in[j++];
 800c3f6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c3f8:	1c5a      	adds	r2, r3, #1
 800c3fa:	9212      	str	r2, [sp, #72]	; 0x48
 800c3fc:	9a07      	ldr	r2, [sp, #28]
 800c3fe:	4413      	add	r3, r2
 800c400:	781b      	ldrb	r3, [r3, #0]
 800c402:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        byte b2 = in[j++];
 800c406:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c408:	1c5a      	adds	r2, r3, #1
 800c40a:	9212      	str	r2, [sp, #72]	; 0x48
 800c40c:	9a07      	ldr	r2, [sp, #28]
 800c40e:	4413      	add	r3, r2
 800c410:	781b      	ldrb	r3, [r3, #0]
 800c412:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        byte b3 = in[j++];
 800c416:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c418:	1c5a      	adds	r2, r3, #1
 800c41a:	9212      	str	r2, [sp, #72]	; 0x48
 800c41c:	9a07      	ldr	r2, [sp, #28]
 800c41e:	4413      	add	r3, r2
 800c420:	781b      	ldrb	r3, [r3, #0]
 800c422:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35

        /* encoded idx */
        byte e1 = b1 >> 2;
 800c426:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800c42a:	089b      	lsrs	r3, r3, #2
 800c42c:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
 800c430:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800c434:	011b      	lsls	r3, r3, #4
 800c436:	b25b      	sxtb	r3, r3
 800c438:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800c43c:	b25a      	sxtb	r2, r3
 800c43e:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800c442:	091b      	lsrs	r3, r3, #4
 800c444:	b2db      	uxtb	r3, r3
 800c446:	b25b      	sxtb	r3, r3
 800c448:	4313      	orrs	r3, r2
 800c44a:	b25b      	sxtb	r3, r3
 800c44c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
        byte e3 = (byte)(((b2 & 0xF) << 2) | (b3 >> 6));
 800c450:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800c454:	009b      	lsls	r3, r3, #2
 800c456:	b25b      	sxtb	r3, r3
 800c458:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 800c45c:	b25a      	sxtb	r2, r3
 800c45e:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 800c462:	099b      	lsrs	r3, r3, #6
 800c464:	b2db      	uxtb	r3, r3
 800c466:	b25b      	sxtb	r3, r3
 800c468:	4313      	orrs	r3, r2
 800c46a:	b25b      	sxtb	r3, r3
 800c46c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
        byte e4 = b3 & 0x3F;
 800c470:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 800c474:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800c478:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31

        /* store */
        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
 800c47c:	9b04      	ldr	r3, [sp, #16]
 800c47e:	681b      	ldr	r3, [r3, #0]
 800c480:	a808      	add	r0, sp, #32
 800c482:	f89d 1034 	ldrb.w	r1, [sp, #52]	; 0x34
 800c486:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c488:	9202      	str	r2, [sp, #8]
 800c48a:	2200      	movs	r2, #0
 800c48c:	9201      	str	r2, [sp, #4]
 800c48e:	9300      	str	r3, [sp, #0]
 800c490:	4603      	mov	r3, r0
 800c492:	9a05      	ldr	r2, [sp, #20]
 800c494:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c496:	f7ff feab 	bl	800c1f0 <CEscape>
 800c49a:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret != 0) break;
 800c49c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c49e:	2b00      	cmp	r3, #0
 800c4a0:	d15f      	bne.n	800c562 <DoBase64_Encode+0x1f2>
        ret = CEscape(escaped, e2, out, &i, *outLen, 0, getSzOnly);
 800c4a2:	9b04      	ldr	r3, [sp, #16]
 800c4a4:	681b      	ldr	r3, [r3, #0]
 800c4a6:	a808      	add	r0, sp, #32
 800c4a8:	f89d 1033 	ldrb.w	r1, [sp, #51]	; 0x33
 800c4ac:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c4ae:	9202      	str	r2, [sp, #8]
 800c4b0:	2200      	movs	r2, #0
 800c4b2:	9201      	str	r2, [sp, #4]
 800c4b4:	9300      	str	r3, [sp, #0]
 800c4b6:	4603      	mov	r3, r0
 800c4b8:	9a05      	ldr	r2, [sp, #20]
 800c4ba:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c4bc:	f7ff fe98 	bl	800c1f0 <CEscape>
 800c4c0:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret != 0) break;
 800c4c2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c4c4:	2b00      	cmp	r3, #0
 800c4c6:	d14c      	bne.n	800c562 <DoBase64_Encode+0x1f2>
        ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
 800c4c8:	9b04      	ldr	r3, [sp, #16]
 800c4ca:	681b      	ldr	r3, [r3, #0]
 800c4cc:	a808      	add	r0, sp, #32
 800c4ce:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
 800c4d2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c4d4:	9202      	str	r2, [sp, #8]
 800c4d6:	2200      	movs	r2, #0
 800c4d8:	9201      	str	r2, [sp, #4]
 800c4da:	9300      	str	r3, [sp, #0]
 800c4dc:	4603      	mov	r3, r0
 800c4de:	9a05      	ldr	r2, [sp, #20]
 800c4e0:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c4e2:	f7ff fe85 	bl	800c1f0 <CEscape>
 800c4e6:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret != 0) break;
 800c4e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c4ea:	2b00      	cmp	r3, #0
 800c4ec:	d139      	bne.n	800c562 <DoBase64_Encode+0x1f2>
        ret = CEscape(escaped, e4, out, &i, *outLen, 0, getSzOnly);
 800c4ee:	9b04      	ldr	r3, [sp, #16]
 800c4f0:	681b      	ldr	r3, [r3, #0]
 800c4f2:	a808      	add	r0, sp, #32
 800c4f4:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
 800c4f8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c4fa:	9202      	str	r2, [sp, #8]
 800c4fc:	2200      	movs	r2, #0
 800c4fe:	9201      	str	r2, [sp, #4]
 800c500:	9300      	str	r3, [sp, #0]
 800c502:	4603      	mov	r3, r0
 800c504:	9a05      	ldr	r2, [sp, #20]
 800c506:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c508:	f7ff fe72 	bl	800c1f0 <CEscape>
 800c50c:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret != 0) break;
 800c50e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c510:	2b00      	cmp	r3, #0
 800c512:	d126      	bne.n	800c562 <DoBase64_Encode+0x1f2>

        inLen -= 3;
 800c514:	9b06      	ldr	r3, [sp, #24]
 800c516:	3b03      	subs	r3, #3
 800c518:	9306      	str	r3, [sp, #24]

        /* Insert newline after PEM_LINE_SZ, unless no \n requested */
        if (escaped != WC_NO_NL_ENC && (++n % (PEM_LINE_SZ/4)) == 0 && inLen){
 800c51a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c51c:	2b02      	cmp	r3, #2
 800c51e:	d01c      	beq.n	800c55a <DoBase64_Encode+0x1ea>
 800c520:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800c522:	3301      	adds	r3, #1
 800c524:	9311      	str	r3, [sp, #68]	; 0x44
 800c526:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800c528:	f003 030f 	and.w	r3, r3, #15
 800c52c:	2b00      	cmp	r3, #0
 800c52e:	d114      	bne.n	800c55a <DoBase64_Encode+0x1ea>
 800c530:	9b06      	ldr	r3, [sp, #24]
 800c532:	2b00      	cmp	r3, #0
 800c534:	d011      	beq.n	800c55a <DoBase64_Encode+0x1ea>
            ret = CEscape(escaped, '\n', out, &i, *outLen, 1, getSzOnly);
 800c536:	9b04      	ldr	r3, [sp, #16]
 800c538:	681b      	ldr	r3, [r3, #0]
 800c53a:	a908      	add	r1, sp, #32
 800c53c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c53e:	9202      	str	r2, [sp, #8]
 800c540:	2201      	movs	r2, #1
 800c542:	9201      	str	r2, [sp, #4]
 800c544:	9300      	str	r3, [sp, #0]
 800c546:	460b      	mov	r3, r1
 800c548:	9a05      	ldr	r2, [sp, #20]
 800c54a:	210a      	movs	r1, #10
 800c54c:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c54e:	f7ff fe4f 	bl	800c1f0 <CEscape>
 800c552:	9013      	str	r0, [sp, #76]	; 0x4c
            if (ret != 0) break;
 800c554:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c556:	2b00      	cmp	r3, #0
 800c558:	d103      	bne.n	800c562 <DoBase64_Encode+0x1f2>
    while (inLen > 2) {
 800c55a:	9b06      	ldr	r3, [sp, #24]
 800c55c:	2b02      	cmp	r3, #2
 800c55e:	f63f af4a 	bhi.w	800c3f6 <DoBase64_Encode+0x86>
        }
    }

    /* last integral */
    if (inLen && ret == 0) {
 800c562:	9b06      	ldr	r3, [sp, #24]
 800c564:	2b00      	cmp	r3, #0
 800c566:	f000 809a 	beq.w	800c69e <DoBase64_Encode+0x32e>
 800c56a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c56c:	2b00      	cmp	r3, #0
 800c56e:	f040 8096 	bne.w	800c69e <DoBase64_Encode+0x32e>
        int twoBytes = (inLen == 2);
 800c572:	9b06      	ldr	r3, [sp, #24]
 800c574:	2b02      	cmp	r3, #2
 800c576:	bf0c      	ite	eq
 800c578:	2301      	moveq	r3, #1
 800c57a:	2300      	movne	r3, #0
 800c57c:	b2db      	uxtb	r3, r3
 800c57e:	930b      	str	r3, [sp, #44]	; 0x2c

        byte b1 = in[j++];
 800c580:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c582:	1c5a      	adds	r2, r3, #1
 800c584:	9212      	str	r2, [sp, #72]	; 0x48
 800c586:	9a07      	ldr	r2, [sp, #28]
 800c588:	4413      	add	r3, r2
 800c58a:	781b      	ldrb	r3, [r3, #0]
 800c58c:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        byte b2 = (twoBytes) ? in[j++] : 0;
 800c590:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c592:	2b00      	cmp	r3, #0
 800c594:	d008      	beq.n	800c5a8 <DoBase64_Encode+0x238>
 800c596:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c598:	1c5a      	adds	r2, r3, #1
 800c59a:	9212      	str	r2, [sp, #72]	; 0x48
 800c59c:	9a07      	ldr	r2, [sp, #28]
 800c59e:	4413      	add	r3, r2
 800c5a0:	781b      	ldrb	r3, [r3, #0]
 800c5a2:	e002      	b.n	800c5aa <DoBase64_Encode+0x23a>
 800c5a4:	aaaaaaab 	.word	0xaaaaaaab
 800c5a8:	2300      	movs	r3, #0
 800c5aa:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a

        byte e1 = b1 >> 2;
 800c5ae:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 800c5b2:	089b      	lsrs	r3, r3, #2
 800c5b4:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
 800c5b8:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 800c5bc:	011b      	lsls	r3, r3, #4
 800c5be:	b25b      	sxtb	r3, r3
 800c5c0:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800c5c4:	b25a      	sxtb	r2, r3
 800c5c6:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
 800c5ca:	091b      	lsrs	r3, r3, #4
 800c5cc:	b2db      	uxtb	r3, r3
 800c5ce:	b25b      	sxtb	r3, r3
 800c5d0:	4313      	orrs	r3, r2
 800c5d2:	b25b      	sxtb	r3, r3
 800c5d4:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
        byte e3 = (byte)((b2 & 0xF) << 2);
 800c5d8:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
 800c5dc:	009b      	lsls	r3, r3, #2
 800c5de:	b2db      	uxtb	r3, r3
 800c5e0:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 800c5e4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27

        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
 800c5e8:	9b04      	ldr	r3, [sp, #16]
 800c5ea:	681b      	ldr	r3, [r3, #0]
 800c5ec:	a808      	add	r0, sp, #32
 800c5ee:	f89d 1029 	ldrb.w	r1, [sp, #41]	; 0x29
 800c5f2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c5f4:	9202      	str	r2, [sp, #8]
 800c5f6:	2200      	movs	r2, #0
 800c5f8:	9201      	str	r2, [sp, #4]
 800c5fa:	9300      	str	r3, [sp, #0]
 800c5fc:	4603      	mov	r3, r0
 800c5fe:	9a05      	ldr	r2, [sp, #20]
 800c600:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c602:	f7ff fdf5 	bl	800c1f0 <CEscape>
 800c606:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret == 0)
 800c608:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c60a:	2b00      	cmp	r3, #0
 800c60c:	d10f      	bne.n	800c62e <DoBase64_Encode+0x2be>
            ret = CEscape(escaped, e2, out, &i, *outLen, 0, getSzOnly);
 800c60e:	9b04      	ldr	r3, [sp, #16]
 800c610:	681b      	ldr	r3, [r3, #0]
 800c612:	a808      	add	r0, sp, #32
 800c614:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
 800c618:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c61a:	9202      	str	r2, [sp, #8]
 800c61c:	2200      	movs	r2, #0
 800c61e:	9201      	str	r2, [sp, #4]
 800c620:	9300      	str	r3, [sp, #0]
 800c622:	4603      	mov	r3, r0
 800c624:	9a05      	ldr	r2, [sp, #20]
 800c626:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c628:	f7ff fde2 	bl	800c1f0 <CEscape>
 800c62c:	9013      	str	r0, [sp, #76]	; 0x4c
        if (ret == 0) {
 800c62e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c630:	2b00      	cmp	r3, #0
 800c632:	d122      	bne.n	800c67a <DoBase64_Encode+0x30a>
            /* third */
            if (twoBytes)
 800c634:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c636:	2b00      	cmp	r3, #0
 800c638:	d010      	beq.n	800c65c <DoBase64_Encode+0x2ec>
                ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
 800c63a:	9b04      	ldr	r3, [sp, #16]
 800c63c:	681b      	ldr	r3, [r3, #0]
 800c63e:	a808      	add	r0, sp, #32
 800c640:	f89d 1027 	ldrb.w	r1, [sp, #39]	; 0x27
 800c644:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c646:	9202      	str	r2, [sp, #8]
 800c648:	2200      	movs	r2, #0
 800c64a:	9201      	str	r2, [sp, #4]
 800c64c:	9300      	str	r3, [sp, #0]
 800c64e:	4603      	mov	r3, r0
 800c650:	9a05      	ldr	r2, [sp, #20]
 800c652:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c654:	f7ff fdcc 	bl	800c1f0 <CEscape>
 800c658:	9013      	str	r0, [sp, #76]	; 0x4c
 800c65a:	e00e      	b.n	800c67a <DoBase64_Encode+0x30a>
            else
                ret = CEscape(escaped, '=', out, &i, *outLen, 1, getSzOnly);
 800c65c:	9b04      	ldr	r3, [sp, #16]
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	a908      	add	r1, sp, #32
 800c662:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c664:	9202      	str	r2, [sp, #8]
 800c666:	2201      	movs	r2, #1
 800c668:	9201      	str	r2, [sp, #4]
 800c66a:	9300      	str	r3, [sp, #0]
 800c66c:	460b      	mov	r3, r1
 800c66e:	9a05      	ldr	r2, [sp, #20]
 800c670:	213d      	movs	r1, #61	; 0x3d
 800c672:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c674:	f7ff fdbc 	bl	800c1f0 <CEscape>
 800c678:	9013      	str	r0, [sp, #76]	; 0x4c
        }
        /* fourth always pad */
        if (ret == 0)
 800c67a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c67c:	2b00      	cmp	r3, #0
 800c67e:	d10e      	bne.n	800c69e <DoBase64_Encode+0x32e>
            ret = CEscape(escaped, '=', out, &i, *outLen, 1, getSzOnly);
 800c680:	9b04      	ldr	r3, [sp, #16]
 800c682:	681b      	ldr	r3, [r3, #0]
 800c684:	a908      	add	r1, sp, #32
 800c686:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c688:	9202      	str	r2, [sp, #8]
 800c68a:	2201      	movs	r2, #1
 800c68c:	9201      	str	r2, [sp, #4]
 800c68e:	9300      	str	r3, [sp, #0]
 800c690:	460b      	mov	r3, r1
 800c692:	9a05      	ldr	r2, [sp, #20]
 800c694:	213d      	movs	r1, #61	; 0x3d
 800c696:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c698:	f7ff fdaa 	bl	800c1f0 <CEscape>
 800c69c:	9013      	str	r0, [sp, #76]	; 0x4c
    }

    if (ret == 0 && escaped != WC_NO_NL_ENC)
 800c69e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c6a0:	2b00      	cmp	r3, #0
 800c6a2:	d111      	bne.n	800c6c8 <DoBase64_Encode+0x358>
 800c6a4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c6a6:	2b02      	cmp	r3, #2
 800c6a8:	d00e      	beq.n	800c6c8 <DoBase64_Encode+0x358>
        ret = CEscape(escaped, '\n', out, &i, *outLen, 1, getSzOnly);
 800c6aa:	9b04      	ldr	r3, [sp, #16]
 800c6ac:	681b      	ldr	r3, [r3, #0]
 800c6ae:	a908      	add	r1, sp, #32
 800c6b0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800c6b2:	9202      	str	r2, [sp, #8]
 800c6b4:	2201      	movs	r2, #1
 800c6b6:	9201      	str	r2, [sp, #4]
 800c6b8:	9300      	str	r3, [sp, #0]
 800c6ba:	460b      	mov	r3, r1
 800c6bc:	9a05      	ldr	r2, [sp, #20]
 800c6be:	210a      	movs	r1, #10
 800c6c0:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c6c2:	f7ff fd95 	bl	800c1f0 <CEscape>
 800c6c6:	9013      	str	r0, [sp, #76]	; 0x4c

    if (i != outSz && escaped != 1 && ret == 0)
 800c6c8:	9a08      	ldr	r2, [sp, #32]
 800c6ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c6cc:	429a      	cmp	r2, r3
 800c6ce:	d008      	beq.n	800c6e2 <DoBase64_Encode+0x372>
 800c6d0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c6d2:	2b01      	cmp	r3, #1
 800c6d4:	d005      	beq.n	800c6e2 <DoBase64_Encode+0x372>
 800c6d6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c6d8:	2b00      	cmp	r3, #0
 800c6da:	d102      	bne.n	800c6e2 <DoBase64_Encode+0x372>
        return ASN_INPUT_E;
 800c6dc:	f06f 0399 	mvn.w	r3, #153	; 0x99
 800c6e0:	e00e      	b.n	800c700 <DoBase64_Encode+0x390>

    *outLen = i;
 800c6e2:	9a08      	ldr	r2, [sp, #32]
 800c6e4:	9b04      	ldr	r3, [sp, #16]
 800c6e6:	601a      	str	r2, [r3, #0]
    if(ret == 0)
 800c6e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c6ea:	2b00      	cmp	r3, #0
 800c6ec:	d107      	bne.n	800c6fe <DoBase64_Encode+0x38e>
        return getSzOnly ? LENGTH_ONLY_E : 0;
 800c6ee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800c6f0:	2b00      	cmp	r3, #0
 800c6f2:	d002      	beq.n	800c6fa <DoBase64_Encode+0x38a>
 800c6f4:	f06f 03c9 	mvn.w	r3, #201	; 0xc9
 800c6f8:	e002      	b.n	800c700 <DoBase64_Encode+0x390>
 800c6fa:	2300      	movs	r3, #0
 800c6fc:	e000      	b.n	800c700 <DoBase64_Encode+0x390>
    return ret;
 800c6fe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
}
 800c700:	4618      	mov	r0, r3
 800c702:	b015      	add	sp, #84	; 0x54
 800c704:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800c710 <Base64_Encode>:


/* Base64 Encode, PEM style, with \n line endings */
int Base64_Encode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 800c710:	b500      	push	{lr}
 800c712:	b087      	sub	sp, #28
 800c714:	9005      	str	r0, [sp, #20]
 800c716:	9104      	str	r1, [sp, #16]
 800c718:	9203      	str	r2, [sp, #12]
 800c71a:	9302      	str	r3, [sp, #8]
    return DoBase64_Encode(in, inLen, out, outLen, WC_STD_ENC);
 800c71c:	2300      	movs	r3, #0
 800c71e:	9300      	str	r3, [sp, #0]
 800c720:	9b02      	ldr	r3, [sp, #8]
 800c722:	9a03      	ldr	r2, [sp, #12]
 800c724:	9904      	ldr	r1, [sp, #16]
 800c726:	9805      	ldr	r0, [sp, #20]
 800c728:	f7ff fe22 	bl	800c370 <DoBase64_Encode>
 800c72c:	4603      	mov	r3, r0
}
 800c72e:	4618      	mov	r0, r3
 800c730:	b007      	add	sp, #28
 800c732:	f85d fb04 	ldr.w	pc, [sp], #4
 800c736:	bf00      	nop
	...

0800c740 <wc_HashGetDigestSize>:
}
#endif

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
 800c740:	b084      	sub	sp, #16
 800c742:	4603      	mov	r3, r0
 800c744:	f88d 3007 	strb.w	r3, [sp, #7]
    int dig_size = HASH_TYPE_E; /* Default to hash type error */
 800c748:	f06f 03e7 	mvn.w	r3, #231	; 0xe7
 800c74c:	9303      	str	r3, [sp, #12]
    switch(hash_type)
 800c74e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c752:	3b03      	subs	r3, #3
 800c754:	2b06      	cmp	r3, #6
 800c756:	d820      	bhi.n	800c79a <wc_HashGetDigestSize+0x5a>
 800c758:	a201      	add	r2, pc, #4	; (adr r2, 800c760 <wc_HashGetDigestSize+0x20>)
 800c75a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c75e:	bf00      	nop
 800c760:	0800c77d 	.word	0x0800c77d
 800c764:	0800c783 	.word	0x0800c783
 800c768:	0800c78f 	.word	0x0800c78f
 800c76c:	0800c7a1 	.word	0x0800c7a1
 800c770:	0800c7a1 	.word	0x0800c7a1
 800c774:	0800c795 	.word	0x0800c795
 800c778:	0800c789 	.word	0x0800c789
    {
        case WC_HASH_TYPE_MD5:
#ifndef NO_MD5
            dig_size = WC_MD5_DIGEST_SIZE;
 800c77c:	2310      	movs	r3, #16
 800c77e:	9303      	str	r3, [sp, #12]
 800c780:	e00e      	b.n	800c7a0 <wc_HashGetDigestSize+0x60>
#endif
            break;
        case WC_HASH_TYPE_SHA:
#ifndef NO_SHA
            dig_size = WC_SHA_DIGEST_SIZE;
 800c782:	2314      	movs	r3, #20
 800c784:	9303      	str	r3, [sp, #12]
 800c786:	e00b      	b.n	800c7a0 <wc_HashGetDigestSize+0x60>
#endif
            break;
        case WC_HASH_TYPE_SHA224:
#ifdef WOLFSSL_SHA224
            dig_size = WC_SHA224_DIGEST_SIZE;
 800c788:	231c      	movs	r3, #28
 800c78a:	9303      	str	r3, [sp, #12]
 800c78c:	e008      	b.n	800c7a0 <wc_HashGetDigestSize+0x60>
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            dig_size = WC_SHA256_DIGEST_SIZE;
 800c78e:	2320      	movs	r3, #32
 800c790:	9303      	str	r3, [sp, #12]
 800c792:	e005      	b.n	800c7a0 <wc_HashGetDigestSize+0x60>
            dig_size = WC_SHA512_DIGEST_SIZE;
#endif
            break;
        case WC_HASH_TYPE_MD5_SHA:
#if !defined(NO_MD5) && !defined(NO_SHA)
            dig_size = WC_MD5_DIGEST_SIZE + WC_SHA_DIGEST_SIZE;
 800c794:	2324      	movs	r3, #36	; 0x24
 800c796:	9303      	str	r3, [sp, #12]
 800c798:	e002      	b.n	800c7a0 <wc_HashGetDigestSize+0x60>
        /* Not Supported */
        case WC_HASH_TYPE_MD2:
        case WC_HASH_TYPE_MD4:
        case WC_HASH_TYPE_NONE:
        default:
            dig_size = BAD_FUNC_ARG;
 800c79a:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800c79e:	9303      	str	r3, [sp, #12]
            break;
    }
    return dig_size;
 800c7a0:	9b03      	ldr	r3, [sp, #12]
}
 800c7a2:	4618      	mov	r0, r3
 800c7a4:	b004      	add	sp, #16
 800c7a6:	4770      	bx	lr
	...

0800c7b0 <wc_Hash>:

/* Generic Hashing Wrapper */
int wc_Hash(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len)
{
 800c7b0:	b500      	push	{lr}
 800c7b2:	b087      	sub	sp, #28
 800c7b4:	9102      	str	r1, [sp, #8]
 800c7b6:	9201      	str	r2, [sp, #4]
 800c7b8:	9300      	str	r3, [sp, #0]
 800c7ba:	4603      	mov	r3, r0
 800c7bc:	f88d 300f 	strb.w	r3, [sp, #15]
    int ret = HASH_TYPE_E; /* Default to hash type error */
 800c7c0:	f06f 03e7 	mvn.w	r3, #231	; 0xe7
 800c7c4:	9305      	str	r3, [sp, #20]
    word32 dig_size;

    /* Validate hash buffer size */
    dig_size = wc_HashGetDigestSize(hash_type);
 800c7c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800c7ca:	4618      	mov	r0, r3
 800c7cc:	f7ff ffb8 	bl	800c740 <wc_HashGetDigestSize>
 800c7d0:	4603      	mov	r3, r0
 800c7d2:	9304      	str	r3, [sp, #16]
    if (hash_len < dig_size) {
 800c7d4:	9a08      	ldr	r2, [sp, #32]
 800c7d6:	9b04      	ldr	r3, [sp, #16]
 800c7d8:	429a      	cmp	r2, r3
 800c7da:	d202      	bcs.n	800c7e2 <wc_Hash+0x32>
        return BUFFER_E;
 800c7dc:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800c7e0:	e04a      	b.n	800c878 <wc_Hash+0xc8>
    (void)data;
    (void)data_len;
    (void)hash;
    (void)hash_len;

    switch(hash_type)
 800c7e2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800c7e6:	3b03      	subs	r3, #3
 800c7e8:	2b06      	cmp	r3, #6
 800c7ea:	d83f      	bhi.n	800c86c <wc_Hash+0xbc>
 800c7ec:	a201      	add	r2, pc, #4	; (adr r2, 800c7f4 <wc_Hash+0x44>)
 800c7ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c7f2:	bf00      	nop
 800c7f4:	0800c811 	.word	0x0800c811
 800c7f8:	0800c81f 	.word	0x0800c81f
 800c7fc:	0800c83b 	.word	0x0800c83b
 800c800:	0800c877 	.word	0x0800c877
 800c804:	0800c877 	.word	0x0800c877
 800c808:	0800c849 	.word	0x0800c849
 800c80c:	0800c82d 	.word	0x0800c82d
    {
        case WC_HASH_TYPE_MD5:
#ifndef NO_MD5
            ret = wc_Md5Hash(data, data_len, hash);
 800c810:	9a00      	ldr	r2, [sp, #0]
 800c812:	9901      	ldr	r1, [sp, #4]
 800c814:	9802      	ldr	r0, [sp, #8]
 800c816:	f000 f833 	bl	800c880 <wc_Md5Hash>
 800c81a:	9005      	str	r0, [sp, #20]
 800c81c:	e02b      	b.n	800c876 <wc_Hash+0xc6>
#endif
            break;
        case WC_HASH_TYPE_SHA:
#ifndef NO_SHA
            ret = wc_ShaHash(data, data_len, hash);
 800c81e:	9a00      	ldr	r2, [sp, #0]
 800c820:	9901      	ldr	r1, [sp, #4]
 800c822:	9802      	ldr	r0, [sp, #8]
 800c824:	f000 f85c 	bl	800c8e0 <wc_ShaHash>
 800c828:	9005      	str	r0, [sp, #20]
 800c82a:	e024      	b.n	800c876 <wc_Hash+0xc6>
#endif
            break;
        case WC_HASH_TYPE_SHA224:
#ifdef WOLFSSL_SHA224
            ret = wc_Sha224Hash(data, data_len, hash);
 800c82c:	9a00      	ldr	r2, [sp, #0]
 800c82e:	9901      	ldr	r1, [sp, #4]
 800c830:	9802      	ldr	r0, [sp, #8]
 800c832:	f000 f885 	bl	800c940 <wc_Sha224Hash>
 800c836:	9005      	str	r0, [sp, #20]
 800c838:	e01d      	b.n	800c876 <wc_Hash+0xc6>
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Hash(data, data_len, hash);
 800c83a:	9a00      	ldr	r2, [sp, #0]
 800c83c:	9901      	ldr	r1, [sp, #4]
 800c83e:	9802      	ldr	r0, [sp, #8]
 800c840:	f000 f8ae 	bl	800c9a0 <wc_Sha256Hash>
 800c844:	9005      	str	r0, [sp, #20]
 800c846:	e016      	b.n	800c876 <wc_Hash+0xc6>
            ret = wc_Sha512Hash(data, data_len, hash);
#endif
            break;
        case WC_HASH_TYPE_MD5_SHA:
#if !defined(NO_MD5) && !defined(NO_SHA)
            ret = wc_Md5Hash(data, data_len, hash);
 800c848:	9a00      	ldr	r2, [sp, #0]
 800c84a:	9901      	ldr	r1, [sp, #4]
 800c84c:	9802      	ldr	r0, [sp, #8]
 800c84e:	f000 f817 	bl	800c880 <wc_Md5Hash>
 800c852:	9005      	str	r0, [sp, #20]
            if (ret == 0) {
 800c854:	9b05      	ldr	r3, [sp, #20]
 800c856:	2b00      	cmp	r3, #0
 800c858:	d10c      	bne.n	800c874 <wc_Hash+0xc4>
                ret = wc_ShaHash(data, data_len, &hash[WC_MD5_DIGEST_SIZE]);
 800c85a:	9b00      	ldr	r3, [sp, #0]
 800c85c:	3310      	adds	r3, #16
 800c85e:	461a      	mov	r2, r3
 800c860:	9901      	ldr	r1, [sp, #4]
 800c862:	9802      	ldr	r0, [sp, #8]
 800c864:	f000 f83c 	bl	800c8e0 <wc_ShaHash>
 800c868:	9005      	str	r0, [sp, #20]
 800c86a:	e004      	b.n	800c876 <wc_Hash+0xc6>
        /* Not Supported */
        case WC_HASH_TYPE_MD2:
        case WC_HASH_TYPE_MD4:
        case WC_HASH_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 800c86c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800c870:	9305      	str	r3, [sp, #20]
 800c872:	e000      	b.n	800c876 <wc_Hash+0xc6>
                ret = wc_ShaHash(data, data_len, &hash[WC_MD5_DIGEST_SIZE]);
 800c874:	bf00      	nop
            break;
    }
    return ret;
 800c876:	9b05      	ldr	r3, [sp, #20]
}
 800c878:	4618      	mov	r0, r3
 800c87a:	b007      	add	sp, #28
 800c87c:	f85d fb04 	ldr.w	pc, [sp], #4

0800c880 <wc_Md5Hash>:

#if !defined(WOLFSSL_TI_HASH)

#if !defined(NO_MD5)
    int wc_Md5Hash(const byte* data, word32 len, byte* hash)
    {
 800c880:	b500      	push	{lr}
 800c882:	b087      	sub	sp, #28
 800c884:	9003      	str	r0, [sp, #12]
 800c886:	9102      	str	r1, [sp, #8]
 800c888:	9201      	str	r2, [sp, #4]
    #else
        wc_Md5  md5[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        md5 = (wc_Md5*)XMALLOC(sizeof(wc_Md5), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c88a:	2160      	movs	r1, #96	; 0x60
 800c88c:	2000      	movs	r0, #0
 800c88e:	f7f8 ffe7 	bl	8005860 <chibios_alloc>
 800c892:	9004      	str	r0, [sp, #16]
        if (md5 == NULL)
 800c894:	9b04      	ldr	r3, [sp, #16]
 800c896:	2b00      	cmp	r3, #0
 800c898:	d102      	bne.n	800c8a0 <wc_Md5Hash+0x20>
            return MEMORY_E;
 800c89a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c89e:	e018      	b.n	800c8d2 <wc_Md5Hash+0x52>
    #endif

        ret = wc_InitMd5(md5);
 800c8a0:	9804      	ldr	r0, [sp, #16]
 800c8a2:	f001 f8f5 	bl	800da90 <wc_InitMd5>
 800c8a6:	9005      	str	r0, [sp, #20]
        if (ret == 0) {
 800c8a8:	9b05      	ldr	r3, [sp, #20]
 800c8aa:	2b00      	cmp	r3, #0
 800c8ac:	d10d      	bne.n	800c8ca <wc_Md5Hash+0x4a>
            ret = wc_Md5Update(md5, data, len);
 800c8ae:	9a02      	ldr	r2, [sp, #8]
 800c8b0:	9903      	ldr	r1, [sp, #12]
 800c8b2:	9804      	ldr	r0, [sp, #16]
 800c8b4:	f001 f824 	bl	800d900 <wc_Md5Update>
 800c8b8:	9005      	str	r0, [sp, #20]
            if (ret == 0) {
 800c8ba:	9b05      	ldr	r3, [sp, #20]
 800c8bc:	2b00      	cmp	r3, #0
 800c8be:	d104      	bne.n	800c8ca <wc_Md5Hash+0x4a>
                ret = wc_Md5Final(md5, hash);
 800c8c0:	9901      	ldr	r1, [sp, #4]
 800c8c2:	9804      	ldr	r0, [sp, #16]
 800c8c4:	f001 f874 	bl	800d9b0 <wc_Md5Final>
 800c8c8:	9005      	str	r0, [sp, #20]
            }
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(md5, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c8ca:	9804      	ldr	r0, [sp, #16]
 800c8cc:	f7f8 ffd8 	bl	8005880 <chibios_free>
    #endif

        return ret;
 800c8d0:	9b05      	ldr	r3, [sp, #20]
    }
 800c8d2:	4618      	mov	r0, r3
 800c8d4:	b007      	add	sp, #28
 800c8d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c8da:	bf00      	nop
 800c8dc:	0000      	movs	r0, r0
	...

0800c8e0 <wc_ShaHash>:
#endif /* !NO_MD5 */

#if !defined(NO_SHA)
    int wc_ShaHash(const byte* data, word32 len, byte* hash)
    {
 800c8e0:	b500      	push	{lr}
 800c8e2:	b087      	sub	sp, #28
 800c8e4:	9003      	str	r0, [sp, #12]
 800c8e6:	9102      	str	r1, [sp, #8]
 800c8e8:	9201      	str	r2, [sp, #4]
        int ret = 0;
 800c8ea:	2300      	movs	r3, #0
 800c8ec:	9305      	str	r3, [sp, #20]
    #else
        wc_Sha sha[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha = (wc_Sha*)XMALLOC(sizeof(wc_Sha), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c8ee:	2164      	movs	r1, #100	; 0x64
 800c8f0:	2000      	movs	r0, #0
 800c8f2:	f7f8 ffb5 	bl	8005860 <chibios_alloc>
 800c8f6:	9004      	str	r0, [sp, #16]
        if (sha == NULL)
 800c8f8:	9b04      	ldr	r3, [sp, #16]
 800c8fa:	2b00      	cmp	r3, #0
 800c8fc:	d102      	bne.n	800c904 <wc_ShaHash+0x24>
            return MEMORY_E;
 800c8fe:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c902:	e013      	b.n	800c92c <wc_ShaHash+0x4c>
    #endif

        if ((ret = wc_InitSha(sha)) != 0) {
 800c904:	9804      	ldr	r0, [sp, #16]
 800c906:	f004 ff6b 	bl	80117e0 <wc_InitSha>
 800c90a:	9005      	str	r0, [sp, #20]
 800c90c:	9b05      	ldr	r3, [sp, #20]
 800c90e:	2b00      	cmp	r3, #0
 800c910:	d108      	bne.n	800c924 <wc_ShaHash+0x44>
            WOLFSSL_MSG("wc_InitSha failed");
        }
        else {
            wc_ShaUpdate(sha, data, len);
 800c912:	9a02      	ldr	r2, [sp, #8]
 800c914:	9903      	ldr	r1, [sp, #12]
 800c916:	9804      	ldr	r0, [sp, #16]
 800c918:	f004 fe72 	bl	8011600 <wc_ShaUpdate>
            wc_ShaFinal(sha, hash);
 800c91c:	9901      	ldr	r1, [sp, #4]
 800c91e:	9804      	ldr	r0, [sp, #16]
 800c920:	f004 fece 	bl	80116c0 <wc_ShaFinal>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c924:	9804      	ldr	r0, [sp, #16]
 800c926:	f7f8 ffab 	bl	8005880 <chibios_free>
    #endif

        return ret;
 800c92a:	9b05      	ldr	r3, [sp, #20]
    }
 800c92c:	4618      	mov	r0, r3
 800c92e:	b007      	add	sp, #28
 800c930:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800c940 <wc_Sha224Hash>:
#endif /* !NO_SHA */

#if defined(WOLFSSL_SHA224)
int wc_Sha224Hash(const byte* data, word32 len, byte* hash)
{
 800c940:	b500      	push	{lr}
 800c942:	b087      	sub	sp, #28
 800c944:	9003      	str	r0, [sp, #12]
 800c946:	9102      	str	r1, [sp, #8]
 800c948:	9201      	str	r2, [sp, #4]
    int ret = 0;
 800c94a:	2300      	movs	r3, #0
 800c94c:	9305      	str	r3, [sp, #20]
#else
    wc_Sha224 sha224[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    sha224 = (wc_Sha224*)XMALLOC(sizeof(wc_Sha224), NULL,
 800c94e:	2170      	movs	r1, #112	; 0x70
 800c950:	2000      	movs	r0, #0
 800c952:	f7f8 ff85 	bl	8005860 <chibios_alloc>
 800c956:	9004      	str	r0, [sp, #16]
        DYNAMIC_TYPE_TMP_BUFFER);
    if (sha224 == NULL)
 800c958:	9b04      	ldr	r3, [sp, #16]
 800c95a:	2b00      	cmp	r3, #0
 800c95c:	d102      	bne.n	800c964 <wc_Sha224Hash+0x24>
        return MEMORY_E;
 800c95e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c962:	e018      	b.n	800c996 <wc_Sha224Hash+0x56>
#endif

    if ((ret = wc_InitSha224(sha224)) != 0) {
 800c964:	9804      	ldr	r0, [sp, #16]
 800c966:	f7f9 fe3b 	bl	80065e0 <wc_InitSha224>
 800c96a:	9005      	str	r0, [sp, #20]
 800c96c:	9b05      	ldr	r3, [sp, #20]
 800c96e:	2b00      	cmp	r3, #0
 800c970:	d10d      	bne.n	800c98e <wc_Sha224Hash+0x4e>
        WOLFSSL_MSG("InitSha224 failed");
    }
    else if ((ret = wc_Sha224Update(sha224, data, len)) != 0) {
 800c972:	9a02      	ldr	r2, [sp, #8]
 800c974:	9903      	ldr	r1, [sp, #12]
 800c976:	9804      	ldr	r0, [sp, #16]
 800c978:	f7f9 fe42 	bl	8006600 <wc_Sha224Update>
 800c97c:	9005      	str	r0, [sp, #20]
 800c97e:	9b05      	ldr	r3, [sp, #20]
 800c980:	2b00      	cmp	r3, #0
 800c982:	d104      	bne.n	800c98e <wc_Sha224Hash+0x4e>
        WOLFSSL_MSG("Sha224Update failed");
    }
    else if ((ret = wc_Sha224Final(sha224, hash)) != 0) {
 800c984:	9901      	ldr	r1, [sp, #4]
 800c986:	9804      	ldr	r0, [sp, #16]
 800c988:	f7f9 fe5a 	bl	8006640 <wc_Sha224Final>
 800c98c:	9005      	str	r0, [sp, #20]
        WOLFSSL_MSG("Sha224Final failed");
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(sha224, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c98e:	9804      	ldr	r0, [sp, #16]
 800c990:	f7f8 ff76 	bl	8005880 <chibios_free>
#endif

    return ret;
 800c994:	9b05      	ldr	r3, [sp, #20]
}
 800c996:	4618      	mov	r0, r3
 800c998:	b007      	add	sp, #28
 800c99a:	f85d fb04 	ldr.w	pc, [sp], #4
 800c99e:	bf00      	nop

0800c9a0 <wc_Sha256Hash>:
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
 800c9a0:	b500      	push	{lr}
 800c9a2:	b087      	sub	sp, #28
 800c9a4:	9003      	str	r0, [sp, #12]
 800c9a6:	9102      	str	r1, [sp, #8]
 800c9a8:	9201      	str	r2, [sp, #4]
        int ret = 0;
 800c9aa:	2300      	movs	r3, #0
 800c9ac:	9305      	str	r3, [sp, #20]
    #else
        wc_Sha256 sha256[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
 800c9ae:	2170      	movs	r1, #112	; 0x70
 800c9b0:	2000      	movs	r0, #0
 800c9b2:	f7f8 ff55 	bl	8005860 <chibios_alloc>
 800c9b6:	9004      	str	r0, [sp, #16]
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
 800c9b8:	9b04      	ldr	r3, [sp, #16]
 800c9ba:	2b00      	cmp	r3, #0
 800c9bc:	d102      	bne.n	800c9c4 <wc_Sha256Hash+0x24>
            return MEMORY_E;
 800c9be:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800c9c2:	e018      	b.n	800c9f6 <wc_Sha256Hash+0x56>
    #endif

        if ((ret = wc_InitSha256(sha256)) != 0) {
 800c9c4:	9804      	ldr	r0, [sp, #16]
 800c9c6:	f7f9 fe6b 	bl	80066a0 <wc_InitSha256>
 800c9ca:	9005      	str	r0, [sp, #20]
 800c9cc:	9b05      	ldr	r3, [sp, #20]
 800c9ce:	2b00      	cmp	r3, #0
 800c9d0:	d10d      	bne.n	800c9ee <wc_Sha256Hash+0x4e>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
 800c9d2:	9a02      	ldr	r2, [sp, #8]
 800c9d4:	9903      	ldr	r1, [sp, #12]
 800c9d6:	9804      	ldr	r0, [sp, #16]
 800c9d8:	f7f9 fce2 	bl	80063a0 <wc_Sha256Update>
 800c9dc:	9005      	str	r0, [sp, #20]
 800c9de:	9b05      	ldr	r3, [sp, #20]
 800c9e0:	2b00      	cmp	r3, #0
 800c9e2:	d104      	bne.n	800c9ee <wc_Sha256Hash+0x4e>
            WOLFSSL_MSG("Sha256Update failed");
        }
        else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
 800c9e4:	9901      	ldr	r1, [sp, #4]
 800c9e6:	9804      	ldr	r0, [sp, #16]
 800c9e8:	f7f9 fd6a 	bl	80064c0 <wc_Sha256Final>
 800c9ec:	9005      	str	r0, [sp, #20]
            WOLFSSL_MSG("Sha256Final failed");
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800c9ee:	9804      	ldr	r0, [sp, #16]
 800c9f0:	f7f8 ff46 	bl	8005880 <chibios_free>
    #endif

        return ret;
 800c9f4:	9b05      	ldr	r3, [sp, #20]
    }
 800c9f6:	4618      	mov	r0, r3
 800c9f8:	b007      	add	sp, #28
 800c9fa:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9fe:	bf00      	nop

0800ca00 <ForceZero.lto_priv.365>:
{
 800ca00:	b084      	sub	sp, #16
 800ca02:	9001      	str	r0, [sp, #4]
 800ca04:	9100      	str	r1, [sp, #0]
    volatile byte* z = (volatile byte*)mem;
 800ca06:	9b01      	ldr	r3, [sp, #4]
 800ca08:	9303      	str	r3, [sp, #12]
 800ca0a:	e004      	b.n	800ca16 <ForceZero.lto_priv.365+0x16>
    while (len--) *z++ = 0;
 800ca0c:	9b03      	ldr	r3, [sp, #12]
 800ca0e:	1c5a      	adds	r2, r3, #1
 800ca10:	9203      	str	r2, [sp, #12]
 800ca12:	2200      	movs	r2, #0
 800ca14:	701a      	strb	r2, [r3, #0]
 800ca16:	9b00      	ldr	r3, [sp, #0]
 800ca18:	1e5a      	subs	r2, r3, #1
 800ca1a:	9200      	str	r2, [sp, #0]
 800ca1c:	2b00      	cmp	r3, #0
 800ca1e:	d1f5      	bne.n	800ca0c <ForceZero.lto_priv.365+0xc>
}
 800ca20:	b004      	add	sp, #16
 800ca22:	4770      	bx	lr
	...

0800ca30 <bn_reverse.lto_priv.364>:
{
 800ca30:	b086      	sub	sp, #24
 800ca32:	9001      	str	r0, [sp, #4]
 800ca34:	9100      	str	r1, [sp, #0]
    ix = 0;
 800ca36:	2300      	movs	r3, #0
 800ca38:	9305      	str	r3, [sp, #20]
    iy = len - 1;
 800ca3a:	9b00      	ldr	r3, [sp, #0]
 800ca3c:	3b01      	subs	r3, #1
 800ca3e:	9304      	str	r3, [sp, #16]
 800ca40:	e019      	b.n	800ca76 <bn_reverse.lto_priv.364+0x46>
        t     = s[ix];
 800ca42:	9b05      	ldr	r3, [sp, #20]
 800ca44:	9a01      	ldr	r2, [sp, #4]
 800ca46:	4413      	add	r3, r2
 800ca48:	781b      	ldrb	r3, [r3, #0]
 800ca4a:	f88d 300f 	strb.w	r3, [sp, #15]
        s[ix] = s[iy];
 800ca4e:	9b05      	ldr	r3, [sp, #20]
 800ca50:	9a01      	ldr	r2, [sp, #4]
 800ca52:	4413      	add	r3, r2
 800ca54:	9a04      	ldr	r2, [sp, #16]
 800ca56:	9901      	ldr	r1, [sp, #4]
 800ca58:	440a      	add	r2, r1
 800ca5a:	7812      	ldrb	r2, [r2, #0]
 800ca5c:	701a      	strb	r2, [r3, #0]
        s[iy] = t;
 800ca5e:	9b04      	ldr	r3, [sp, #16]
 800ca60:	9a01      	ldr	r2, [sp, #4]
 800ca62:	4413      	add	r3, r2
 800ca64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800ca68:	701a      	strb	r2, [r3, #0]
        ++ix;
 800ca6a:	9b05      	ldr	r3, [sp, #20]
 800ca6c:	3301      	adds	r3, #1
 800ca6e:	9305      	str	r3, [sp, #20]
        --iy;
 800ca70:	9b04      	ldr	r3, [sp, #16]
 800ca72:	3b01      	subs	r3, #1
 800ca74:	9304      	str	r3, [sp, #16]
    while (ix < iy) {
 800ca76:	9a05      	ldr	r2, [sp, #20]
 800ca78:	9b04      	ldr	r3, [sp, #16]
 800ca7a:	429a      	cmp	r2, r3
 800ca7c:	dbe1      	blt.n	800ca42 <bn_reverse.lto_priv.364+0x12>
}
 800ca7e:	b006      	add	sp, #24
 800ca80:	4770      	bx	lr
 800ca82:	bf00      	nop
	...

0800ca90 <mp_init_multi>:
{
 800ca90:	b500      	push	{lr}
 800ca92:	b087      	sub	sp, #28
 800ca94:	9003      	str	r0, [sp, #12]
 800ca96:	9102      	str	r1, [sp, #8]
 800ca98:	9201      	str	r2, [sp, #4]
 800ca9a:	9300      	str	r3, [sp, #0]
    int res = MP_OKAY;
 800ca9c:	2300      	movs	r3, #0
 800ca9e:	9305      	str	r3, [sp, #20]
    if (a) XMEMSET(a, 0, sizeof(mp_int));
 800caa0:	9b03      	ldr	r3, [sp, #12]
 800caa2:	2b00      	cmp	r3, #0
 800caa4:	d004      	beq.n	800cab0 <mp_init_multi+0x20>
 800caa6:	2210      	movs	r2, #16
 800caa8:	2100      	movs	r1, #0
 800caaa:	9803      	ldr	r0, [sp, #12]
 800caac:	f010 fe92 	bl	801d7d4 <memset>
    if (b) XMEMSET(b, 0, sizeof(mp_int));
 800cab0:	9b02      	ldr	r3, [sp, #8]
 800cab2:	2b00      	cmp	r3, #0
 800cab4:	d004      	beq.n	800cac0 <mp_init_multi+0x30>
 800cab6:	2210      	movs	r2, #16
 800cab8:	2100      	movs	r1, #0
 800caba:	9802      	ldr	r0, [sp, #8]
 800cabc:	f010 fe8a 	bl	801d7d4 <memset>
    if (c) XMEMSET(c, 0, sizeof(mp_int));
 800cac0:	9b01      	ldr	r3, [sp, #4]
 800cac2:	2b00      	cmp	r3, #0
 800cac4:	d004      	beq.n	800cad0 <mp_init_multi+0x40>
 800cac6:	2210      	movs	r2, #16
 800cac8:	2100      	movs	r1, #0
 800caca:	9801      	ldr	r0, [sp, #4]
 800cacc:	f010 fe82 	bl	801d7d4 <memset>
    if (d) XMEMSET(d, 0, sizeof(mp_int));
 800cad0:	9b00      	ldr	r3, [sp, #0]
 800cad2:	2b00      	cmp	r3, #0
 800cad4:	d004      	beq.n	800cae0 <mp_init_multi+0x50>
 800cad6:	2210      	movs	r2, #16
 800cad8:	2100      	movs	r1, #0
 800cada:	9800      	ldr	r0, [sp, #0]
 800cadc:	f010 fe7a 	bl	801d7d4 <memset>
    if (e) XMEMSET(e, 0, sizeof(mp_int));
 800cae0:	9b08      	ldr	r3, [sp, #32]
 800cae2:	2b00      	cmp	r3, #0
 800cae4:	d004      	beq.n	800caf0 <mp_init_multi+0x60>
 800cae6:	2210      	movs	r2, #16
 800cae8:	2100      	movs	r1, #0
 800caea:	9808      	ldr	r0, [sp, #32]
 800caec:	f010 fe72 	bl	801d7d4 <memset>
    if (f) XMEMSET(f, 0, sizeof(mp_int));
 800caf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800caf2:	2b00      	cmp	r3, #0
 800caf4:	d004      	beq.n	800cb00 <mp_init_multi+0x70>
 800caf6:	2210      	movs	r2, #16
 800caf8:	2100      	movs	r1, #0
 800cafa:	9809      	ldr	r0, [sp, #36]	; 0x24
 800cafc:	f010 fe6a 	bl	801d7d4 <memset>
    if (a && ((res = mp_init(a)) != MP_OKAY))
 800cb00:	9b03      	ldr	r3, [sp, #12]
 800cb02:	2b00      	cmp	r3, #0
 800cb04:	d008      	beq.n	800cb18 <mp_init_multi+0x88>
 800cb06:	9803      	ldr	r0, [sp, #12]
 800cb08:	f7fd fd7a 	bl	800a600 <mp_init>
 800cb0c:	9005      	str	r0, [sp, #20]
 800cb0e:	9b05      	ldr	r3, [sp, #20]
 800cb10:	2b00      	cmp	r3, #0
 800cb12:	d001      	beq.n	800cb18 <mp_init_multi+0x88>
        return res;
 800cb14:	9b05      	ldr	r3, [sp, #20]
 800cb16:	e069      	b.n	800cbec <mp_init_multi+0x15c>
    if (b && ((res = mp_init(b)) != MP_OKAY)) {
 800cb18:	9b02      	ldr	r3, [sp, #8]
 800cb1a:	2b00      	cmp	r3, #0
 800cb1c:	d00b      	beq.n	800cb36 <mp_init_multi+0xa6>
 800cb1e:	9802      	ldr	r0, [sp, #8]
 800cb20:	f7fd fd6e 	bl	800a600 <mp_init>
 800cb24:	9005      	str	r0, [sp, #20]
 800cb26:	9b05      	ldr	r3, [sp, #20]
 800cb28:	2b00      	cmp	r3, #0
 800cb2a:	d004      	beq.n	800cb36 <mp_init_multi+0xa6>
        mp_clear(a);
 800cb2c:	9803      	ldr	r0, [sp, #12]
 800cb2e:	f7fd fd7f 	bl	800a630 <mp_clear>
        return res;
 800cb32:	9b05      	ldr	r3, [sp, #20]
 800cb34:	e05a      	b.n	800cbec <mp_init_multi+0x15c>
    if (c && ((res = mp_init(c)) != MP_OKAY)) {
 800cb36:	9b01      	ldr	r3, [sp, #4]
 800cb38:	2b00      	cmp	r3, #0
 800cb3a:	d00e      	beq.n	800cb5a <mp_init_multi+0xca>
 800cb3c:	9801      	ldr	r0, [sp, #4]
 800cb3e:	f7fd fd5f 	bl	800a600 <mp_init>
 800cb42:	9005      	str	r0, [sp, #20]
 800cb44:	9b05      	ldr	r3, [sp, #20]
 800cb46:	2b00      	cmp	r3, #0
 800cb48:	d007      	beq.n	800cb5a <mp_init_multi+0xca>
        mp_clear(a); mp_clear(b);
 800cb4a:	9803      	ldr	r0, [sp, #12]
 800cb4c:	f7fd fd70 	bl	800a630 <mp_clear>
 800cb50:	9802      	ldr	r0, [sp, #8]
 800cb52:	f7fd fd6d 	bl	800a630 <mp_clear>
        return res;
 800cb56:	9b05      	ldr	r3, [sp, #20]
 800cb58:	e048      	b.n	800cbec <mp_init_multi+0x15c>
    if (d && ((res = mp_init(d)) != MP_OKAY)) {
 800cb5a:	9b00      	ldr	r3, [sp, #0]
 800cb5c:	2b00      	cmp	r3, #0
 800cb5e:	d011      	beq.n	800cb84 <mp_init_multi+0xf4>
 800cb60:	9800      	ldr	r0, [sp, #0]
 800cb62:	f7fd fd4d 	bl	800a600 <mp_init>
 800cb66:	9005      	str	r0, [sp, #20]
 800cb68:	9b05      	ldr	r3, [sp, #20]
 800cb6a:	2b00      	cmp	r3, #0
 800cb6c:	d00a      	beq.n	800cb84 <mp_init_multi+0xf4>
        mp_clear(a); mp_clear(b); mp_clear(c);
 800cb6e:	9803      	ldr	r0, [sp, #12]
 800cb70:	f7fd fd5e 	bl	800a630 <mp_clear>
 800cb74:	9802      	ldr	r0, [sp, #8]
 800cb76:	f7fd fd5b 	bl	800a630 <mp_clear>
 800cb7a:	9801      	ldr	r0, [sp, #4]
 800cb7c:	f7fd fd58 	bl	800a630 <mp_clear>
        return res;
 800cb80:	9b05      	ldr	r3, [sp, #20]
 800cb82:	e033      	b.n	800cbec <mp_init_multi+0x15c>
    if (e && ((res = mp_init(e)) != MP_OKAY)) {
 800cb84:	9b08      	ldr	r3, [sp, #32]
 800cb86:	2b00      	cmp	r3, #0
 800cb88:	d014      	beq.n	800cbb4 <mp_init_multi+0x124>
 800cb8a:	9808      	ldr	r0, [sp, #32]
 800cb8c:	f7fd fd38 	bl	800a600 <mp_init>
 800cb90:	9005      	str	r0, [sp, #20]
 800cb92:	9b05      	ldr	r3, [sp, #20]
 800cb94:	2b00      	cmp	r3, #0
 800cb96:	d00d      	beq.n	800cbb4 <mp_init_multi+0x124>
        mp_clear(a); mp_clear(b); mp_clear(c); mp_clear(d);
 800cb98:	9803      	ldr	r0, [sp, #12]
 800cb9a:	f7fd fd49 	bl	800a630 <mp_clear>
 800cb9e:	9802      	ldr	r0, [sp, #8]
 800cba0:	f7fd fd46 	bl	800a630 <mp_clear>
 800cba4:	9801      	ldr	r0, [sp, #4]
 800cba6:	f7fd fd43 	bl	800a630 <mp_clear>
 800cbaa:	9800      	ldr	r0, [sp, #0]
 800cbac:	f7fd fd40 	bl	800a630 <mp_clear>
        return res;
 800cbb0:	9b05      	ldr	r3, [sp, #20]
 800cbb2:	e01b      	b.n	800cbec <mp_init_multi+0x15c>
    if (f && ((res = mp_init(f)) != MP_OKAY)) {
 800cbb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cbb6:	2b00      	cmp	r3, #0
 800cbb8:	d017      	beq.n	800cbea <mp_init_multi+0x15a>
 800cbba:	9809      	ldr	r0, [sp, #36]	; 0x24
 800cbbc:	f7fd fd20 	bl	800a600 <mp_init>
 800cbc0:	9005      	str	r0, [sp, #20]
 800cbc2:	9b05      	ldr	r3, [sp, #20]
 800cbc4:	2b00      	cmp	r3, #0
 800cbc6:	d010      	beq.n	800cbea <mp_init_multi+0x15a>
        mp_clear(a); mp_clear(b); mp_clear(c); mp_clear(d); mp_clear(e);
 800cbc8:	9803      	ldr	r0, [sp, #12]
 800cbca:	f7fd fd31 	bl	800a630 <mp_clear>
 800cbce:	9802      	ldr	r0, [sp, #8]
 800cbd0:	f7fd fd2e 	bl	800a630 <mp_clear>
 800cbd4:	9801      	ldr	r0, [sp, #4]
 800cbd6:	f7fd fd2b 	bl	800a630 <mp_clear>
 800cbda:	9800      	ldr	r0, [sp, #0]
 800cbdc:	f7fd fd28 	bl	800a630 <mp_clear>
 800cbe0:	9808      	ldr	r0, [sp, #32]
 800cbe2:	f7fd fd25 	bl	800a630 <mp_clear>
        return res;
 800cbe6:	9b05      	ldr	r3, [sp, #20]
 800cbe8:	e000      	b.n	800cbec <mp_init_multi+0x15c>
    return res;
 800cbea:	9b05      	ldr	r3, [sp, #20]
}
 800cbec:	4618      	mov	r0, r3
 800cbee:	b007      	add	sp, #28
 800cbf0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800cc00 <rotlFixed.lto_priv.376>:
    {
 800cc00:	b082      	sub	sp, #8
 800cc02:	9001      	str	r0, [sp, #4]
 800cc04:	9100      	str	r1, [sp, #0]
        return (x << y) | (x >> (sizeof(y) * 8 - y));
 800cc06:	9a01      	ldr	r2, [sp, #4]
 800cc08:	9b00      	ldr	r3, [sp, #0]
 800cc0a:	f1c3 0320 	rsb	r3, r3, #32
 800cc0e:	fa62 f303 	ror.w	r3, r2, r3
    }
 800cc12:	4618      	mov	r0, r3
 800cc14:	b002      	add	sp, #8
 800cc16:	4770      	bx	lr
	...

0800cc20 <min>:
    {
 800cc20:	b082      	sub	sp, #8
 800cc22:	9001      	str	r0, [sp, #4]
 800cc24:	9100      	str	r1, [sp, #0]
        return a > b ? b : a;
 800cc26:	9a01      	ldr	r2, [sp, #4]
 800cc28:	9b00      	ldr	r3, [sp, #0]
 800cc2a:	4293      	cmp	r3, r2
 800cc2c:	bf28      	it	cs
 800cc2e:	4613      	movcs	r3, r2
    }
 800cc30:	4618      	mov	r0, r3
 800cc32:	b002      	add	sp, #8
 800cc34:	4770      	bx	lr
 800cc36:	bf00      	nop
	...

0800cc40 <Transform>:

    #define MD5STEP(f, w, x, y, z, data, s) \
        w = rotlFixed(w + f(x, y, z) + data, s) + x

    static int Transform(wc_Md5* md5)
    {
 800cc40:	b500      	push	{lr}
 800cc42:	b087      	sub	sp, #28
 800cc44:	9001      	str	r0, [sp, #4]
        /* Copy context->state[] to working vars  */
        word32 a = md5->digest[0];
 800cc46:	9b01      	ldr	r3, [sp, #4]
 800cc48:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800cc4a:	9305      	str	r3, [sp, #20]
        word32 b = md5->digest[1];
 800cc4c:	9b01      	ldr	r3, [sp, #4]
 800cc4e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800cc50:	9304      	str	r3, [sp, #16]
        word32 c = md5->digest[2];
 800cc52:	9b01      	ldr	r3, [sp, #4]
 800cc54:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800cc56:	9303      	str	r3, [sp, #12]
        word32 d = md5->digest[3];
 800cc58:	9b01      	ldr	r3, [sp, #4]
 800cc5a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800cc5c:	9302      	str	r3, [sp, #8]

        MD5STEP(F1, a, b, c, d, md5->buffer[0]  + 0xd76aa478,  7);
 800cc5e:	9a03      	ldr	r2, [sp, #12]
 800cc60:	9b02      	ldr	r3, [sp, #8]
 800cc62:	405a      	eors	r2, r3
 800cc64:	9b04      	ldr	r3, [sp, #16]
 800cc66:	401a      	ands	r2, r3
 800cc68:	9b02      	ldr	r3, [sp, #8]
 800cc6a:	405a      	eors	r2, r3
 800cc6c:	9b05      	ldr	r3, [sp, #20]
 800cc6e:	441a      	add	r2, r3
 800cc70:	9b01      	ldr	r3, [sp, #4]
 800cc72:	68db      	ldr	r3, [r3, #12]
 800cc74:	441a      	add	r2, r3
 800cc76:	4baf      	ldr	r3, [pc, #700]	; (800cf34 <Transform+0x2f4>)
 800cc78:	4413      	add	r3, r2
 800cc7a:	2107      	movs	r1, #7
 800cc7c:	4618      	mov	r0, r3
 800cc7e:	f7ff ffbf 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cc82:	4602      	mov	r2, r0
 800cc84:	9b04      	ldr	r3, [sp, #16]
 800cc86:	4413      	add	r3, r2
 800cc88:	9305      	str	r3, [sp, #20]
        MD5STEP(F1, d, a, b, c, md5->buffer[1]  + 0xe8c7b756, 12);
 800cc8a:	9a04      	ldr	r2, [sp, #16]
 800cc8c:	9b03      	ldr	r3, [sp, #12]
 800cc8e:	405a      	eors	r2, r3
 800cc90:	9b05      	ldr	r3, [sp, #20]
 800cc92:	401a      	ands	r2, r3
 800cc94:	9b03      	ldr	r3, [sp, #12]
 800cc96:	405a      	eors	r2, r3
 800cc98:	9b02      	ldr	r3, [sp, #8]
 800cc9a:	441a      	add	r2, r3
 800cc9c:	9b01      	ldr	r3, [sp, #4]
 800cc9e:	691b      	ldr	r3, [r3, #16]
 800cca0:	441a      	add	r2, r3
 800cca2:	4ba5      	ldr	r3, [pc, #660]	; (800cf38 <Transform+0x2f8>)
 800cca4:	4413      	add	r3, r2
 800cca6:	210c      	movs	r1, #12
 800cca8:	4618      	mov	r0, r3
 800ccaa:	f7ff ffa9 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ccae:	4602      	mov	r2, r0
 800ccb0:	9b05      	ldr	r3, [sp, #20]
 800ccb2:	4413      	add	r3, r2
 800ccb4:	9302      	str	r3, [sp, #8]
        MD5STEP(F1, c, d, a, b, md5->buffer[2]  + 0x242070db, 17);
 800ccb6:	9a05      	ldr	r2, [sp, #20]
 800ccb8:	9b04      	ldr	r3, [sp, #16]
 800ccba:	405a      	eors	r2, r3
 800ccbc:	9b02      	ldr	r3, [sp, #8]
 800ccbe:	401a      	ands	r2, r3
 800ccc0:	9b04      	ldr	r3, [sp, #16]
 800ccc2:	405a      	eors	r2, r3
 800ccc4:	9b03      	ldr	r3, [sp, #12]
 800ccc6:	441a      	add	r2, r3
 800ccc8:	9b01      	ldr	r3, [sp, #4]
 800ccca:	695b      	ldr	r3, [r3, #20]
 800cccc:	441a      	add	r2, r3
 800ccce:	4b9b      	ldr	r3, [pc, #620]	; (800cf3c <Transform+0x2fc>)
 800ccd0:	4413      	add	r3, r2
 800ccd2:	2111      	movs	r1, #17
 800ccd4:	4618      	mov	r0, r3
 800ccd6:	f7ff ff93 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ccda:	4602      	mov	r2, r0
 800ccdc:	9b02      	ldr	r3, [sp, #8]
 800ccde:	4413      	add	r3, r2
 800cce0:	9303      	str	r3, [sp, #12]
        MD5STEP(F1, b, c, d, a, md5->buffer[3]  + 0xc1bdceee, 22);
 800cce2:	9a02      	ldr	r2, [sp, #8]
 800cce4:	9b05      	ldr	r3, [sp, #20]
 800cce6:	405a      	eors	r2, r3
 800cce8:	9b03      	ldr	r3, [sp, #12]
 800ccea:	401a      	ands	r2, r3
 800ccec:	9b05      	ldr	r3, [sp, #20]
 800ccee:	405a      	eors	r2, r3
 800ccf0:	9b04      	ldr	r3, [sp, #16]
 800ccf2:	441a      	add	r2, r3
 800ccf4:	9b01      	ldr	r3, [sp, #4]
 800ccf6:	699b      	ldr	r3, [r3, #24]
 800ccf8:	441a      	add	r2, r3
 800ccfa:	4b91      	ldr	r3, [pc, #580]	; (800cf40 <Transform+0x300>)
 800ccfc:	4413      	add	r3, r2
 800ccfe:	2116      	movs	r1, #22
 800cd00:	4618      	mov	r0, r3
 800cd02:	f7ff ff7d 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cd06:	4602      	mov	r2, r0
 800cd08:	9b03      	ldr	r3, [sp, #12]
 800cd0a:	4413      	add	r3, r2
 800cd0c:	9304      	str	r3, [sp, #16]
        MD5STEP(F1, a, b, c, d, md5->buffer[4]  + 0xf57c0faf,  7);
 800cd0e:	9a03      	ldr	r2, [sp, #12]
 800cd10:	9b02      	ldr	r3, [sp, #8]
 800cd12:	405a      	eors	r2, r3
 800cd14:	9b04      	ldr	r3, [sp, #16]
 800cd16:	401a      	ands	r2, r3
 800cd18:	9b02      	ldr	r3, [sp, #8]
 800cd1a:	405a      	eors	r2, r3
 800cd1c:	9b05      	ldr	r3, [sp, #20]
 800cd1e:	441a      	add	r2, r3
 800cd20:	9b01      	ldr	r3, [sp, #4]
 800cd22:	69db      	ldr	r3, [r3, #28]
 800cd24:	441a      	add	r2, r3
 800cd26:	4b87      	ldr	r3, [pc, #540]	; (800cf44 <Transform+0x304>)
 800cd28:	4413      	add	r3, r2
 800cd2a:	2107      	movs	r1, #7
 800cd2c:	4618      	mov	r0, r3
 800cd2e:	f7ff ff67 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cd32:	4602      	mov	r2, r0
 800cd34:	9b04      	ldr	r3, [sp, #16]
 800cd36:	4413      	add	r3, r2
 800cd38:	9305      	str	r3, [sp, #20]
        MD5STEP(F1, d, a, b, c, md5->buffer[5]  + 0x4787c62a, 12);
 800cd3a:	9a04      	ldr	r2, [sp, #16]
 800cd3c:	9b03      	ldr	r3, [sp, #12]
 800cd3e:	405a      	eors	r2, r3
 800cd40:	9b05      	ldr	r3, [sp, #20]
 800cd42:	401a      	ands	r2, r3
 800cd44:	9b03      	ldr	r3, [sp, #12]
 800cd46:	405a      	eors	r2, r3
 800cd48:	9b02      	ldr	r3, [sp, #8]
 800cd4a:	441a      	add	r2, r3
 800cd4c:	9b01      	ldr	r3, [sp, #4]
 800cd4e:	6a1b      	ldr	r3, [r3, #32]
 800cd50:	441a      	add	r2, r3
 800cd52:	4b7d      	ldr	r3, [pc, #500]	; (800cf48 <Transform+0x308>)
 800cd54:	4413      	add	r3, r2
 800cd56:	210c      	movs	r1, #12
 800cd58:	4618      	mov	r0, r3
 800cd5a:	f7ff ff51 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cd5e:	4602      	mov	r2, r0
 800cd60:	9b05      	ldr	r3, [sp, #20]
 800cd62:	4413      	add	r3, r2
 800cd64:	9302      	str	r3, [sp, #8]
        MD5STEP(F1, c, d, a, b, md5->buffer[6]  + 0xa8304613, 17);
 800cd66:	9a05      	ldr	r2, [sp, #20]
 800cd68:	9b04      	ldr	r3, [sp, #16]
 800cd6a:	405a      	eors	r2, r3
 800cd6c:	9b02      	ldr	r3, [sp, #8]
 800cd6e:	401a      	ands	r2, r3
 800cd70:	9b04      	ldr	r3, [sp, #16]
 800cd72:	405a      	eors	r2, r3
 800cd74:	9b03      	ldr	r3, [sp, #12]
 800cd76:	441a      	add	r2, r3
 800cd78:	9b01      	ldr	r3, [sp, #4]
 800cd7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cd7c:	441a      	add	r2, r3
 800cd7e:	4b73      	ldr	r3, [pc, #460]	; (800cf4c <Transform+0x30c>)
 800cd80:	4413      	add	r3, r2
 800cd82:	2111      	movs	r1, #17
 800cd84:	4618      	mov	r0, r3
 800cd86:	f7ff ff3b 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cd8a:	4602      	mov	r2, r0
 800cd8c:	9b02      	ldr	r3, [sp, #8]
 800cd8e:	4413      	add	r3, r2
 800cd90:	9303      	str	r3, [sp, #12]
        MD5STEP(F1, b, c, d, a, md5->buffer[7]  + 0xfd469501, 22);
 800cd92:	9a02      	ldr	r2, [sp, #8]
 800cd94:	9b05      	ldr	r3, [sp, #20]
 800cd96:	405a      	eors	r2, r3
 800cd98:	9b03      	ldr	r3, [sp, #12]
 800cd9a:	401a      	ands	r2, r3
 800cd9c:	9b05      	ldr	r3, [sp, #20]
 800cd9e:	405a      	eors	r2, r3
 800cda0:	9b04      	ldr	r3, [sp, #16]
 800cda2:	441a      	add	r2, r3
 800cda4:	9b01      	ldr	r3, [sp, #4]
 800cda6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cda8:	441a      	add	r2, r3
 800cdaa:	4b69      	ldr	r3, [pc, #420]	; (800cf50 <Transform+0x310>)
 800cdac:	4413      	add	r3, r2
 800cdae:	2116      	movs	r1, #22
 800cdb0:	4618      	mov	r0, r3
 800cdb2:	f7ff ff25 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cdb6:	4602      	mov	r2, r0
 800cdb8:	9b03      	ldr	r3, [sp, #12]
 800cdba:	4413      	add	r3, r2
 800cdbc:	9304      	str	r3, [sp, #16]
        MD5STEP(F1, a, b, c, d, md5->buffer[8]  + 0x698098d8,  7);
 800cdbe:	9a03      	ldr	r2, [sp, #12]
 800cdc0:	9b02      	ldr	r3, [sp, #8]
 800cdc2:	405a      	eors	r2, r3
 800cdc4:	9b04      	ldr	r3, [sp, #16]
 800cdc6:	401a      	ands	r2, r3
 800cdc8:	9b02      	ldr	r3, [sp, #8]
 800cdca:	405a      	eors	r2, r3
 800cdcc:	9b05      	ldr	r3, [sp, #20]
 800cdce:	441a      	add	r2, r3
 800cdd0:	9b01      	ldr	r3, [sp, #4]
 800cdd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cdd4:	441a      	add	r2, r3
 800cdd6:	4b5f      	ldr	r3, [pc, #380]	; (800cf54 <Transform+0x314>)
 800cdd8:	4413      	add	r3, r2
 800cdda:	2107      	movs	r1, #7
 800cddc:	4618      	mov	r0, r3
 800cdde:	f7ff ff0f 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cde2:	4602      	mov	r2, r0
 800cde4:	9b04      	ldr	r3, [sp, #16]
 800cde6:	4413      	add	r3, r2
 800cde8:	9305      	str	r3, [sp, #20]
        MD5STEP(F1, d, a, b, c, md5->buffer[9]  + 0x8b44f7af, 12);
 800cdea:	9a04      	ldr	r2, [sp, #16]
 800cdec:	9b03      	ldr	r3, [sp, #12]
 800cdee:	405a      	eors	r2, r3
 800cdf0:	9b05      	ldr	r3, [sp, #20]
 800cdf2:	401a      	ands	r2, r3
 800cdf4:	9b03      	ldr	r3, [sp, #12]
 800cdf6:	405a      	eors	r2, r3
 800cdf8:	9b02      	ldr	r3, [sp, #8]
 800cdfa:	441a      	add	r2, r3
 800cdfc:	9b01      	ldr	r3, [sp, #4]
 800cdfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ce00:	441a      	add	r2, r3
 800ce02:	4b55      	ldr	r3, [pc, #340]	; (800cf58 <Transform+0x318>)
 800ce04:	4413      	add	r3, r2
 800ce06:	210c      	movs	r1, #12
 800ce08:	4618      	mov	r0, r3
 800ce0a:	f7ff fef9 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ce0e:	4602      	mov	r2, r0
 800ce10:	9b05      	ldr	r3, [sp, #20]
 800ce12:	4413      	add	r3, r2
 800ce14:	9302      	str	r3, [sp, #8]
        MD5STEP(F1, c, d, a, b, md5->buffer[10] + 0xffff5bb1, 17);
 800ce16:	9a05      	ldr	r2, [sp, #20]
 800ce18:	9b04      	ldr	r3, [sp, #16]
 800ce1a:	405a      	eors	r2, r3
 800ce1c:	9b02      	ldr	r3, [sp, #8]
 800ce1e:	401a      	ands	r2, r3
 800ce20:	9b04      	ldr	r3, [sp, #16]
 800ce22:	405a      	eors	r2, r3
 800ce24:	9b03      	ldr	r3, [sp, #12]
 800ce26:	441a      	add	r2, r3
 800ce28:	9b01      	ldr	r3, [sp, #4]
 800ce2a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ce2c:	4413      	add	r3, r2
 800ce2e:	f5a3 4324 	sub.w	r3, r3, #41984	; 0xa400
 800ce32:	3b4f      	subs	r3, #79	; 0x4f
 800ce34:	2111      	movs	r1, #17
 800ce36:	4618      	mov	r0, r3
 800ce38:	f7ff fee2 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ce3c:	4602      	mov	r2, r0
 800ce3e:	9b02      	ldr	r3, [sp, #8]
 800ce40:	4413      	add	r3, r2
 800ce42:	9303      	str	r3, [sp, #12]
        MD5STEP(F1, b, c, d, a, md5->buffer[11] + 0x895cd7be, 22);
 800ce44:	9a02      	ldr	r2, [sp, #8]
 800ce46:	9b05      	ldr	r3, [sp, #20]
 800ce48:	405a      	eors	r2, r3
 800ce4a:	9b03      	ldr	r3, [sp, #12]
 800ce4c:	401a      	ands	r2, r3
 800ce4e:	9b05      	ldr	r3, [sp, #20]
 800ce50:	405a      	eors	r2, r3
 800ce52:	9b04      	ldr	r3, [sp, #16]
 800ce54:	441a      	add	r2, r3
 800ce56:	9b01      	ldr	r3, [sp, #4]
 800ce58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ce5a:	441a      	add	r2, r3
 800ce5c:	4b3f      	ldr	r3, [pc, #252]	; (800cf5c <Transform+0x31c>)
 800ce5e:	4413      	add	r3, r2
 800ce60:	2116      	movs	r1, #22
 800ce62:	4618      	mov	r0, r3
 800ce64:	f7ff fecc 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ce68:	4602      	mov	r2, r0
 800ce6a:	9b03      	ldr	r3, [sp, #12]
 800ce6c:	4413      	add	r3, r2
 800ce6e:	9304      	str	r3, [sp, #16]
        MD5STEP(F1, a, b, c, d, md5->buffer[12] + 0x6b901122,  7);
 800ce70:	9a03      	ldr	r2, [sp, #12]
 800ce72:	9b02      	ldr	r3, [sp, #8]
 800ce74:	405a      	eors	r2, r3
 800ce76:	9b04      	ldr	r3, [sp, #16]
 800ce78:	401a      	ands	r2, r3
 800ce7a:	9b02      	ldr	r3, [sp, #8]
 800ce7c:	405a      	eors	r2, r3
 800ce7e:	9b05      	ldr	r3, [sp, #20]
 800ce80:	441a      	add	r2, r3
 800ce82:	9b01      	ldr	r3, [sp, #4]
 800ce84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce86:	441a      	add	r2, r3
 800ce88:	4b35      	ldr	r3, [pc, #212]	; (800cf60 <Transform+0x320>)
 800ce8a:	4413      	add	r3, r2
 800ce8c:	2107      	movs	r1, #7
 800ce8e:	4618      	mov	r0, r3
 800ce90:	f7ff feb6 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ce94:	4602      	mov	r2, r0
 800ce96:	9b04      	ldr	r3, [sp, #16]
 800ce98:	4413      	add	r3, r2
 800ce9a:	9305      	str	r3, [sp, #20]
        MD5STEP(F1, d, a, b, c, md5->buffer[13] + 0xfd987193, 12);
 800ce9c:	9a04      	ldr	r2, [sp, #16]
 800ce9e:	9b03      	ldr	r3, [sp, #12]
 800cea0:	405a      	eors	r2, r3
 800cea2:	9b05      	ldr	r3, [sp, #20]
 800cea4:	401a      	ands	r2, r3
 800cea6:	9b03      	ldr	r3, [sp, #12]
 800cea8:	405a      	eors	r2, r3
 800ceaa:	9b02      	ldr	r3, [sp, #8]
 800ceac:	441a      	add	r2, r3
 800ceae:	9b01      	ldr	r3, [sp, #4]
 800ceb0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ceb2:	441a      	add	r2, r3
 800ceb4:	4b2b      	ldr	r3, [pc, #172]	; (800cf64 <Transform+0x324>)
 800ceb6:	4413      	add	r3, r2
 800ceb8:	210c      	movs	r1, #12
 800ceba:	4618      	mov	r0, r3
 800cebc:	f7ff fea0 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cec0:	4602      	mov	r2, r0
 800cec2:	9b05      	ldr	r3, [sp, #20]
 800cec4:	4413      	add	r3, r2
 800cec6:	9302      	str	r3, [sp, #8]
        MD5STEP(F1, c, d, a, b, md5->buffer[14] + 0xa679438e, 17);
 800cec8:	9a05      	ldr	r2, [sp, #20]
 800ceca:	9b04      	ldr	r3, [sp, #16]
 800cecc:	405a      	eors	r2, r3
 800cece:	9b02      	ldr	r3, [sp, #8]
 800ced0:	401a      	ands	r2, r3
 800ced2:	9b04      	ldr	r3, [sp, #16]
 800ced4:	405a      	eors	r2, r3
 800ced6:	9b03      	ldr	r3, [sp, #12]
 800ced8:	441a      	add	r2, r3
 800ceda:	9b01      	ldr	r3, [sp, #4]
 800cedc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cede:	441a      	add	r2, r3
 800cee0:	4b21      	ldr	r3, [pc, #132]	; (800cf68 <Transform+0x328>)
 800cee2:	4413      	add	r3, r2
 800cee4:	2111      	movs	r1, #17
 800cee6:	4618      	mov	r0, r3
 800cee8:	f7ff fe8a 	bl	800cc00 <rotlFixed.lto_priv.376>
 800ceec:	4602      	mov	r2, r0
 800ceee:	9b02      	ldr	r3, [sp, #8]
 800cef0:	4413      	add	r3, r2
 800cef2:	9303      	str	r3, [sp, #12]
        MD5STEP(F1, b, c, d, a, md5->buffer[15] + 0x49b40821, 22);
 800cef4:	9a02      	ldr	r2, [sp, #8]
 800cef6:	9b05      	ldr	r3, [sp, #20]
 800cef8:	405a      	eors	r2, r3
 800cefa:	9b03      	ldr	r3, [sp, #12]
 800cefc:	401a      	ands	r2, r3
 800cefe:	9b05      	ldr	r3, [sp, #20]
 800cf00:	405a      	eors	r2, r3
 800cf02:	9b04      	ldr	r3, [sp, #16]
 800cf04:	441a      	add	r2, r3
 800cf06:	9b01      	ldr	r3, [sp, #4]
 800cf08:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800cf0a:	441a      	add	r2, r3
 800cf0c:	4b17      	ldr	r3, [pc, #92]	; (800cf6c <Transform+0x32c>)
 800cf0e:	4413      	add	r3, r2
 800cf10:	2116      	movs	r1, #22
 800cf12:	4618      	mov	r0, r3
 800cf14:	f7ff fe74 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cf18:	4602      	mov	r2, r0
 800cf1a:	9b03      	ldr	r3, [sp, #12]
 800cf1c:	4413      	add	r3, r2
 800cf1e:	9304      	str	r3, [sp, #16]

        MD5STEP(F2, a, b, c, d, md5->buffer[1]  + 0xf61e2562,  5);
 800cf20:	9a04      	ldr	r2, [sp, #16]
 800cf22:	9b03      	ldr	r3, [sp, #12]
 800cf24:	405a      	eors	r2, r3
 800cf26:	9b02      	ldr	r3, [sp, #8]
 800cf28:	401a      	ands	r2, r3
 800cf2a:	9b03      	ldr	r3, [sp, #12]
 800cf2c:	405a      	eors	r2, r3
 800cf2e:	9b05      	ldr	r3, [sp, #20]
 800cf30:	441a      	add	r2, r3
 800cf32:	e01d      	b.n	800cf70 <Transform+0x330>
 800cf34:	d76aa478 	.word	0xd76aa478
 800cf38:	e8c7b756 	.word	0xe8c7b756
 800cf3c:	242070db 	.word	0x242070db
 800cf40:	c1bdceee 	.word	0xc1bdceee
 800cf44:	f57c0faf 	.word	0xf57c0faf
 800cf48:	4787c62a 	.word	0x4787c62a
 800cf4c:	a8304613 	.word	0xa8304613
 800cf50:	fd469501 	.word	0xfd469501
 800cf54:	698098d8 	.word	0x698098d8
 800cf58:	8b44f7af 	.word	0x8b44f7af
 800cf5c:	895cd7be 	.word	0x895cd7be
 800cf60:	6b901122 	.word	0x6b901122
 800cf64:	fd987193 	.word	0xfd987193
 800cf68:	a679438e 	.word	0xa679438e
 800cf6c:	49b40821 	.word	0x49b40821
 800cf70:	9b01      	ldr	r3, [sp, #4]
 800cf72:	691b      	ldr	r3, [r3, #16]
 800cf74:	441a      	add	r2, r3
 800cf76:	4baf      	ldr	r3, [pc, #700]	; (800d234 <Transform+0x5f4>)
 800cf78:	4413      	add	r3, r2
 800cf7a:	2105      	movs	r1, #5
 800cf7c:	4618      	mov	r0, r3
 800cf7e:	f7ff fe3f 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cf82:	4602      	mov	r2, r0
 800cf84:	9b04      	ldr	r3, [sp, #16]
 800cf86:	4413      	add	r3, r2
 800cf88:	9305      	str	r3, [sp, #20]
        MD5STEP(F2, d, a, b, c, md5->buffer[6]  + 0xc040b340,  9);
 800cf8a:	9a05      	ldr	r2, [sp, #20]
 800cf8c:	9b04      	ldr	r3, [sp, #16]
 800cf8e:	405a      	eors	r2, r3
 800cf90:	9b03      	ldr	r3, [sp, #12]
 800cf92:	401a      	ands	r2, r3
 800cf94:	9b04      	ldr	r3, [sp, #16]
 800cf96:	405a      	eors	r2, r3
 800cf98:	9b02      	ldr	r3, [sp, #8]
 800cf9a:	441a      	add	r2, r3
 800cf9c:	9b01      	ldr	r3, [sp, #4]
 800cf9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cfa0:	441a      	add	r2, r3
 800cfa2:	4ba5      	ldr	r3, [pc, #660]	; (800d238 <Transform+0x5f8>)
 800cfa4:	4413      	add	r3, r2
 800cfa6:	2109      	movs	r1, #9
 800cfa8:	4618      	mov	r0, r3
 800cfaa:	f7ff fe29 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cfae:	4602      	mov	r2, r0
 800cfb0:	9b05      	ldr	r3, [sp, #20]
 800cfb2:	4413      	add	r3, r2
 800cfb4:	9302      	str	r3, [sp, #8]
        MD5STEP(F2, c, d, a, b, md5->buffer[11] + 0x265e5a51, 14);
 800cfb6:	9a02      	ldr	r2, [sp, #8]
 800cfb8:	9b05      	ldr	r3, [sp, #20]
 800cfba:	405a      	eors	r2, r3
 800cfbc:	9b04      	ldr	r3, [sp, #16]
 800cfbe:	401a      	ands	r2, r3
 800cfc0:	9b05      	ldr	r3, [sp, #20]
 800cfc2:	405a      	eors	r2, r3
 800cfc4:	9b03      	ldr	r3, [sp, #12]
 800cfc6:	441a      	add	r2, r3
 800cfc8:	9b01      	ldr	r3, [sp, #4]
 800cfca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cfcc:	441a      	add	r2, r3
 800cfce:	4b9b      	ldr	r3, [pc, #620]	; (800d23c <Transform+0x5fc>)
 800cfd0:	4413      	add	r3, r2
 800cfd2:	210e      	movs	r1, #14
 800cfd4:	4618      	mov	r0, r3
 800cfd6:	f7ff fe13 	bl	800cc00 <rotlFixed.lto_priv.376>
 800cfda:	4602      	mov	r2, r0
 800cfdc:	9b02      	ldr	r3, [sp, #8]
 800cfde:	4413      	add	r3, r2
 800cfe0:	9303      	str	r3, [sp, #12]
        MD5STEP(F2, b, c, d, a, md5->buffer[0]  + 0xe9b6c7aa, 20);
 800cfe2:	9a03      	ldr	r2, [sp, #12]
 800cfe4:	9b02      	ldr	r3, [sp, #8]
 800cfe6:	405a      	eors	r2, r3
 800cfe8:	9b05      	ldr	r3, [sp, #20]
 800cfea:	401a      	ands	r2, r3
 800cfec:	9b02      	ldr	r3, [sp, #8]
 800cfee:	405a      	eors	r2, r3
 800cff0:	9b04      	ldr	r3, [sp, #16]
 800cff2:	441a      	add	r2, r3
 800cff4:	9b01      	ldr	r3, [sp, #4]
 800cff6:	68db      	ldr	r3, [r3, #12]
 800cff8:	441a      	add	r2, r3
 800cffa:	4b91      	ldr	r3, [pc, #580]	; (800d240 <Transform+0x600>)
 800cffc:	4413      	add	r3, r2
 800cffe:	2114      	movs	r1, #20
 800d000:	4618      	mov	r0, r3
 800d002:	f7ff fdfd 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d006:	4602      	mov	r2, r0
 800d008:	9b03      	ldr	r3, [sp, #12]
 800d00a:	4413      	add	r3, r2
 800d00c:	9304      	str	r3, [sp, #16]
        MD5STEP(F2, a, b, c, d, md5->buffer[5]  + 0xd62f105d,  5);
 800d00e:	9a04      	ldr	r2, [sp, #16]
 800d010:	9b03      	ldr	r3, [sp, #12]
 800d012:	405a      	eors	r2, r3
 800d014:	9b02      	ldr	r3, [sp, #8]
 800d016:	401a      	ands	r2, r3
 800d018:	9b03      	ldr	r3, [sp, #12]
 800d01a:	405a      	eors	r2, r3
 800d01c:	9b05      	ldr	r3, [sp, #20]
 800d01e:	441a      	add	r2, r3
 800d020:	9b01      	ldr	r3, [sp, #4]
 800d022:	6a1b      	ldr	r3, [r3, #32]
 800d024:	441a      	add	r2, r3
 800d026:	4b87      	ldr	r3, [pc, #540]	; (800d244 <Transform+0x604>)
 800d028:	4413      	add	r3, r2
 800d02a:	2105      	movs	r1, #5
 800d02c:	4618      	mov	r0, r3
 800d02e:	f7ff fde7 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d032:	4602      	mov	r2, r0
 800d034:	9b04      	ldr	r3, [sp, #16]
 800d036:	4413      	add	r3, r2
 800d038:	9305      	str	r3, [sp, #20]
        MD5STEP(F2, d, a, b, c, md5->buffer[10] + 0x02441453,  9);
 800d03a:	9a05      	ldr	r2, [sp, #20]
 800d03c:	9b04      	ldr	r3, [sp, #16]
 800d03e:	405a      	eors	r2, r3
 800d040:	9b03      	ldr	r3, [sp, #12]
 800d042:	401a      	ands	r2, r3
 800d044:	9b04      	ldr	r3, [sp, #16]
 800d046:	405a      	eors	r2, r3
 800d048:	9b02      	ldr	r3, [sp, #8]
 800d04a:	441a      	add	r2, r3
 800d04c:	9b01      	ldr	r3, [sp, #4]
 800d04e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d050:	441a      	add	r2, r3
 800d052:	4b7d      	ldr	r3, [pc, #500]	; (800d248 <Transform+0x608>)
 800d054:	4413      	add	r3, r2
 800d056:	2109      	movs	r1, #9
 800d058:	4618      	mov	r0, r3
 800d05a:	f7ff fdd1 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d05e:	4602      	mov	r2, r0
 800d060:	9b05      	ldr	r3, [sp, #20]
 800d062:	4413      	add	r3, r2
 800d064:	9302      	str	r3, [sp, #8]
        MD5STEP(F2, c, d, a, b, md5->buffer[15] + 0xd8a1e681, 14);
 800d066:	9a02      	ldr	r2, [sp, #8]
 800d068:	9b05      	ldr	r3, [sp, #20]
 800d06a:	405a      	eors	r2, r3
 800d06c:	9b04      	ldr	r3, [sp, #16]
 800d06e:	401a      	ands	r2, r3
 800d070:	9b05      	ldr	r3, [sp, #20]
 800d072:	405a      	eors	r2, r3
 800d074:	9b03      	ldr	r3, [sp, #12]
 800d076:	441a      	add	r2, r3
 800d078:	9b01      	ldr	r3, [sp, #4]
 800d07a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d07c:	441a      	add	r2, r3
 800d07e:	4b73      	ldr	r3, [pc, #460]	; (800d24c <Transform+0x60c>)
 800d080:	4413      	add	r3, r2
 800d082:	210e      	movs	r1, #14
 800d084:	4618      	mov	r0, r3
 800d086:	f7ff fdbb 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d08a:	4602      	mov	r2, r0
 800d08c:	9b02      	ldr	r3, [sp, #8]
 800d08e:	4413      	add	r3, r2
 800d090:	9303      	str	r3, [sp, #12]
        MD5STEP(F2, b, c, d, a, md5->buffer[4]  + 0xe7d3fbc8, 20);
 800d092:	9a03      	ldr	r2, [sp, #12]
 800d094:	9b02      	ldr	r3, [sp, #8]
 800d096:	405a      	eors	r2, r3
 800d098:	9b05      	ldr	r3, [sp, #20]
 800d09a:	401a      	ands	r2, r3
 800d09c:	9b02      	ldr	r3, [sp, #8]
 800d09e:	405a      	eors	r2, r3
 800d0a0:	9b04      	ldr	r3, [sp, #16]
 800d0a2:	441a      	add	r2, r3
 800d0a4:	9b01      	ldr	r3, [sp, #4]
 800d0a6:	69db      	ldr	r3, [r3, #28]
 800d0a8:	441a      	add	r2, r3
 800d0aa:	4b69      	ldr	r3, [pc, #420]	; (800d250 <Transform+0x610>)
 800d0ac:	4413      	add	r3, r2
 800d0ae:	2114      	movs	r1, #20
 800d0b0:	4618      	mov	r0, r3
 800d0b2:	f7ff fda5 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d0b6:	4602      	mov	r2, r0
 800d0b8:	9b03      	ldr	r3, [sp, #12]
 800d0ba:	4413      	add	r3, r2
 800d0bc:	9304      	str	r3, [sp, #16]
        MD5STEP(F2, a, b, c, d, md5->buffer[9]  + 0x21e1cde6,  5);
 800d0be:	9a04      	ldr	r2, [sp, #16]
 800d0c0:	9b03      	ldr	r3, [sp, #12]
 800d0c2:	405a      	eors	r2, r3
 800d0c4:	9b02      	ldr	r3, [sp, #8]
 800d0c6:	401a      	ands	r2, r3
 800d0c8:	9b03      	ldr	r3, [sp, #12]
 800d0ca:	405a      	eors	r2, r3
 800d0cc:	9b05      	ldr	r3, [sp, #20]
 800d0ce:	441a      	add	r2, r3
 800d0d0:	9b01      	ldr	r3, [sp, #4]
 800d0d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d0d4:	441a      	add	r2, r3
 800d0d6:	4b5f      	ldr	r3, [pc, #380]	; (800d254 <Transform+0x614>)
 800d0d8:	4413      	add	r3, r2
 800d0da:	2105      	movs	r1, #5
 800d0dc:	4618      	mov	r0, r3
 800d0de:	f7ff fd8f 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d0e2:	4602      	mov	r2, r0
 800d0e4:	9b04      	ldr	r3, [sp, #16]
 800d0e6:	4413      	add	r3, r2
 800d0e8:	9305      	str	r3, [sp, #20]
        MD5STEP(F2, d, a, b, c, md5->buffer[14] + 0xc33707d6,  9);
 800d0ea:	9a05      	ldr	r2, [sp, #20]
 800d0ec:	9b04      	ldr	r3, [sp, #16]
 800d0ee:	405a      	eors	r2, r3
 800d0f0:	9b03      	ldr	r3, [sp, #12]
 800d0f2:	401a      	ands	r2, r3
 800d0f4:	9b04      	ldr	r3, [sp, #16]
 800d0f6:	405a      	eors	r2, r3
 800d0f8:	9b02      	ldr	r3, [sp, #8]
 800d0fa:	441a      	add	r2, r3
 800d0fc:	9b01      	ldr	r3, [sp, #4]
 800d0fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d100:	441a      	add	r2, r3
 800d102:	4b55      	ldr	r3, [pc, #340]	; (800d258 <Transform+0x618>)
 800d104:	4413      	add	r3, r2
 800d106:	2109      	movs	r1, #9
 800d108:	4618      	mov	r0, r3
 800d10a:	f7ff fd79 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d10e:	4602      	mov	r2, r0
 800d110:	9b05      	ldr	r3, [sp, #20]
 800d112:	4413      	add	r3, r2
 800d114:	9302      	str	r3, [sp, #8]
        MD5STEP(F2, c, d, a, b, md5->buffer[3]  + 0xf4d50d87, 14);
 800d116:	9a02      	ldr	r2, [sp, #8]
 800d118:	9b05      	ldr	r3, [sp, #20]
 800d11a:	405a      	eors	r2, r3
 800d11c:	9b04      	ldr	r3, [sp, #16]
 800d11e:	401a      	ands	r2, r3
 800d120:	9b05      	ldr	r3, [sp, #20]
 800d122:	405a      	eors	r2, r3
 800d124:	9b03      	ldr	r3, [sp, #12]
 800d126:	441a      	add	r2, r3
 800d128:	9b01      	ldr	r3, [sp, #4]
 800d12a:	699b      	ldr	r3, [r3, #24]
 800d12c:	441a      	add	r2, r3
 800d12e:	4b4b      	ldr	r3, [pc, #300]	; (800d25c <Transform+0x61c>)
 800d130:	4413      	add	r3, r2
 800d132:	210e      	movs	r1, #14
 800d134:	4618      	mov	r0, r3
 800d136:	f7ff fd63 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d13a:	4602      	mov	r2, r0
 800d13c:	9b02      	ldr	r3, [sp, #8]
 800d13e:	4413      	add	r3, r2
 800d140:	9303      	str	r3, [sp, #12]
        MD5STEP(F2, b, c, d, a, md5->buffer[8]  + 0x455a14ed, 20);
 800d142:	9a03      	ldr	r2, [sp, #12]
 800d144:	9b02      	ldr	r3, [sp, #8]
 800d146:	405a      	eors	r2, r3
 800d148:	9b05      	ldr	r3, [sp, #20]
 800d14a:	401a      	ands	r2, r3
 800d14c:	9b02      	ldr	r3, [sp, #8]
 800d14e:	405a      	eors	r2, r3
 800d150:	9b04      	ldr	r3, [sp, #16]
 800d152:	441a      	add	r2, r3
 800d154:	9b01      	ldr	r3, [sp, #4]
 800d156:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d158:	441a      	add	r2, r3
 800d15a:	4b41      	ldr	r3, [pc, #260]	; (800d260 <Transform+0x620>)
 800d15c:	4413      	add	r3, r2
 800d15e:	2114      	movs	r1, #20
 800d160:	4618      	mov	r0, r3
 800d162:	f7ff fd4d 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d166:	4602      	mov	r2, r0
 800d168:	9b03      	ldr	r3, [sp, #12]
 800d16a:	4413      	add	r3, r2
 800d16c:	9304      	str	r3, [sp, #16]
        MD5STEP(F2, a, b, c, d, md5->buffer[13] + 0xa9e3e905,  5);
 800d16e:	9a04      	ldr	r2, [sp, #16]
 800d170:	9b03      	ldr	r3, [sp, #12]
 800d172:	405a      	eors	r2, r3
 800d174:	9b02      	ldr	r3, [sp, #8]
 800d176:	401a      	ands	r2, r3
 800d178:	9b03      	ldr	r3, [sp, #12]
 800d17a:	405a      	eors	r2, r3
 800d17c:	9b05      	ldr	r3, [sp, #20]
 800d17e:	441a      	add	r2, r3
 800d180:	9b01      	ldr	r3, [sp, #4]
 800d182:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d184:	441a      	add	r2, r3
 800d186:	4b37      	ldr	r3, [pc, #220]	; (800d264 <Transform+0x624>)
 800d188:	4413      	add	r3, r2
 800d18a:	2105      	movs	r1, #5
 800d18c:	4618      	mov	r0, r3
 800d18e:	f7ff fd37 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d192:	4602      	mov	r2, r0
 800d194:	9b04      	ldr	r3, [sp, #16]
 800d196:	4413      	add	r3, r2
 800d198:	9305      	str	r3, [sp, #20]
        MD5STEP(F2, d, a, b, c, md5->buffer[2]  + 0xfcefa3f8,  9);
 800d19a:	9a05      	ldr	r2, [sp, #20]
 800d19c:	9b04      	ldr	r3, [sp, #16]
 800d19e:	405a      	eors	r2, r3
 800d1a0:	9b03      	ldr	r3, [sp, #12]
 800d1a2:	401a      	ands	r2, r3
 800d1a4:	9b04      	ldr	r3, [sp, #16]
 800d1a6:	405a      	eors	r2, r3
 800d1a8:	9b02      	ldr	r3, [sp, #8]
 800d1aa:	441a      	add	r2, r3
 800d1ac:	9b01      	ldr	r3, [sp, #4]
 800d1ae:	695b      	ldr	r3, [r3, #20]
 800d1b0:	441a      	add	r2, r3
 800d1b2:	4b2d      	ldr	r3, [pc, #180]	; (800d268 <Transform+0x628>)
 800d1b4:	4413      	add	r3, r2
 800d1b6:	2109      	movs	r1, #9
 800d1b8:	4618      	mov	r0, r3
 800d1ba:	f7ff fd21 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d1be:	4602      	mov	r2, r0
 800d1c0:	9b05      	ldr	r3, [sp, #20]
 800d1c2:	4413      	add	r3, r2
 800d1c4:	9302      	str	r3, [sp, #8]
        MD5STEP(F2, c, d, a, b, md5->buffer[7]  + 0x676f02d9, 14);
 800d1c6:	9a02      	ldr	r2, [sp, #8]
 800d1c8:	9b05      	ldr	r3, [sp, #20]
 800d1ca:	405a      	eors	r2, r3
 800d1cc:	9b04      	ldr	r3, [sp, #16]
 800d1ce:	401a      	ands	r2, r3
 800d1d0:	9b05      	ldr	r3, [sp, #20]
 800d1d2:	405a      	eors	r2, r3
 800d1d4:	9b03      	ldr	r3, [sp, #12]
 800d1d6:	441a      	add	r2, r3
 800d1d8:	9b01      	ldr	r3, [sp, #4]
 800d1da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d1dc:	441a      	add	r2, r3
 800d1de:	4b23      	ldr	r3, [pc, #140]	; (800d26c <Transform+0x62c>)
 800d1e0:	4413      	add	r3, r2
 800d1e2:	210e      	movs	r1, #14
 800d1e4:	4618      	mov	r0, r3
 800d1e6:	f7ff fd0b 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d1ea:	4602      	mov	r2, r0
 800d1ec:	9b02      	ldr	r3, [sp, #8]
 800d1ee:	4413      	add	r3, r2
 800d1f0:	9303      	str	r3, [sp, #12]
        MD5STEP(F2, b, c, d, a, md5->buffer[12] + 0x8d2a4c8a, 20);
 800d1f2:	9a03      	ldr	r2, [sp, #12]
 800d1f4:	9b02      	ldr	r3, [sp, #8]
 800d1f6:	405a      	eors	r2, r3
 800d1f8:	9b05      	ldr	r3, [sp, #20]
 800d1fa:	401a      	ands	r2, r3
 800d1fc:	9b02      	ldr	r3, [sp, #8]
 800d1fe:	405a      	eors	r2, r3
 800d200:	9b04      	ldr	r3, [sp, #16]
 800d202:	441a      	add	r2, r3
 800d204:	9b01      	ldr	r3, [sp, #4]
 800d206:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d208:	441a      	add	r2, r3
 800d20a:	4b19      	ldr	r3, [pc, #100]	; (800d270 <Transform+0x630>)
 800d20c:	4413      	add	r3, r2
 800d20e:	2114      	movs	r1, #20
 800d210:	4618      	mov	r0, r3
 800d212:	f7ff fcf5 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d216:	4602      	mov	r2, r0
 800d218:	9b03      	ldr	r3, [sp, #12]
 800d21a:	4413      	add	r3, r2
 800d21c:	9304      	str	r3, [sp, #16]

        MD5STEP(F3, a, b, c, d, md5->buffer[5]  + 0xfffa3942,  4);
 800d21e:	9a04      	ldr	r2, [sp, #16]
 800d220:	9b03      	ldr	r3, [sp, #12]
 800d222:	405a      	eors	r2, r3
 800d224:	9b02      	ldr	r3, [sp, #8]
 800d226:	405a      	eors	r2, r3
 800d228:	9b05      	ldr	r3, [sp, #20]
 800d22a:	441a      	add	r2, r3
 800d22c:	9b01      	ldr	r3, [sp, #4]
 800d22e:	6a1b      	ldr	r3, [r3, #32]
 800d230:	e020      	b.n	800d274 <Transform+0x634>
 800d232:	bf00      	nop
 800d234:	f61e2562 	.word	0xf61e2562
 800d238:	c040b340 	.word	0xc040b340
 800d23c:	265e5a51 	.word	0x265e5a51
 800d240:	e9b6c7aa 	.word	0xe9b6c7aa
 800d244:	d62f105d 	.word	0xd62f105d
 800d248:	02441453 	.word	0x02441453
 800d24c:	d8a1e681 	.word	0xd8a1e681
 800d250:	e7d3fbc8 	.word	0xe7d3fbc8
 800d254:	21e1cde6 	.word	0x21e1cde6
 800d258:	c33707d6 	.word	0xc33707d6
 800d25c:	f4d50d87 	.word	0xf4d50d87
 800d260:	455a14ed 	.word	0x455a14ed
 800d264:	a9e3e905 	.word	0xa9e3e905
 800d268:	fcefa3f8 	.word	0xfcefa3f8
 800d26c:	676f02d9 	.word	0x676f02d9
 800d270:	8d2a4c8a 	.word	0x8d2a4c8a
 800d274:	4413      	add	r3, r2
 800d276:	f5a3 23b8 	sub.w	r3, r3, #376832	; 0x5c000
 800d27a:	f2a3 63be 	subw	r3, r3, #1726	; 0x6be
 800d27e:	2104      	movs	r1, #4
 800d280:	4618      	mov	r0, r3
 800d282:	f7ff fcbd 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d286:	4602      	mov	r2, r0
 800d288:	9b04      	ldr	r3, [sp, #16]
 800d28a:	4413      	add	r3, r2
 800d28c:	9305      	str	r3, [sp, #20]
        MD5STEP(F3, d, a, b, c, md5->buffer[8]  + 0x8771f681, 11);
 800d28e:	9a05      	ldr	r2, [sp, #20]
 800d290:	9b04      	ldr	r3, [sp, #16]
 800d292:	405a      	eors	r2, r3
 800d294:	9b03      	ldr	r3, [sp, #12]
 800d296:	405a      	eors	r2, r3
 800d298:	9b02      	ldr	r3, [sp, #8]
 800d29a:	441a      	add	r2, r3
 800d29c:	9b01      	ldr	r3, [sp, #4]
 800d29e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d2a0:	441a      	add	r2, r3
 800d2a2:	4bb0      	ldr	r3, [pc, #704]	; (800d564 <Transform+0x924>)
 800d2a4:	4413      	add	r3, r2
 800d2a6:	210b      	movs	r1, #11
 800d2a8:	4618      	mov	r0, r3
 800d2aa:	f7ff fca9 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d2ae:	4602      	mov	r2, r0
 800d2b0:	9b05      	ldr	r3, [sp, #20]
 800d2b2:	4413      	add	r3, r2
 800d2b4:	9302      	str	r3, [sp, #8]
        MD5STEP(F3, c, d, a, b, md5->buffer[11] + 0x6d9d6122, 16);
 800d2b6:	9a02      	ldr	r2, [sp, #8]
 800d2b8:	9b05      	ldr	r3, [sp, #20]
 800d2ba:	405a      	eors	r2, r3
 800d2bc:	9b04      	ldr	r3, [sp, #16]
 800d2be:	405a      	eors	r2, r3
 800d2c0:	9b03      	ldr	r3, [sp, #12]
 800d2c2:	441a      	add	r2, r3
 800d2c4:	9b01      	ldr	r3, [sp, #4]
 800d2c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d2c8:	441a      	add	r2, r3
 800d2ca:	4ba7      	ldr	r3, [pc, #668]	; (800d568 <Transform+0x928>)
 800d2cc:	4413      	add	r3, r2
 800d2ce:	2110      	movs	r1, #16
 800d2d0:	4618      	mov	r0, r3
 800d2d2:	f7ff fc95 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d2d6:	4602      	mov	r2, r0
 800d2d8:	9b02      	ldr	r3, [sp, #8]
 800d2da:	4413      	add	r3, r2
 800d2dc:	9303      	str	r3, [sp, #12]
        MD5STEP(F3, b, c, d, a, md5->buffer[14] + 0xfde5380c, 23);
 800d2de:	9a03      	ldr	r2, [sp, #12]
 800d2e0:	9b02      	ldr	r3, [sp, #8]
 800d2e2:	405a      	eors	r2, r3
 800d2e4:	9b05      	ldr	r3, [sp, #20]
 800d2e6:	405a      	eors	r2, r3
 800d2e8:	9b04      	ldr	r3, [sp, #16]
 800d2ea:	441a      	add	r2, r3
 800d2ec:	9b01      	ldr	r3, [sp, #4]
 800d2ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d2f0:	441a      	add	r2, r3
 800d2f2:	4b9e      	ldr	r3, [pc, #632]	; (800d56c <Transform+0x92c>)
 800d2f4:	4413      	add	r3, r2
 800d2f6:	2117      	movs	r1, #23
 800d2f8:	4618      	mov	r0, r3
 800d2fa:	f7ff fc81 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d2fe:	4602      	mov	r2, r0
 800d300:	9b03      	ldr	r3, [sp, #12]
 800d302:	4413      	add	r3, r2
 800d304:	9304      	str	r3, [sp, #16]
        MD5STEP(F3, a, b, c, d, md5->buffer[1]  + 0xa4beea44,  4);
 800d306:	9a04      	ldr	r2, [sp, #16]
 800d308:	9b03      	ldr	r3, [sp, #12]
 800d30a:	405a      	eors	r2, r3
 800d30c:	9b02      	ldr	r3, [sp, #8]
 800d30e:	405a      	eors	r2, r3
 800d310:	9b05      	ldr	r3, [sp, #20]
 800d312:	441a      	add	r2, r3
 800d314:	9b01      	ldr	r3, [sp, #4]
 800d316:	691b      	ldr	r3, [r3, #16]
 800d318:	441a      	add	r2, r3
 800d31a:	4b95      	ldr	r3, [pc, #596]	; (800d570 <Transform+0x930>)
 800d31c:	4413      	add	r3, r2
 800d31e:	2104      	movs	r1, #4
 800d320:	4618      	mov	r0, r3
 800d322:	f7ff fc6d 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d326:	4602      	mov	r2, r0
 800d328:	9b04      	ldr	r3, [sp, #16]
 800d32a:	4413      	add	r3, r2
 800d32c:	9305      	str	r3, [sp, #20]
        MD5STEP(F3, d, a, b, c, md5->buffer[4]  + 0x4bdecfa9, 11);
 800d32e:	9a05      	ldr	r2, [sp, #20]
 800d330:	9b04      	ldr	r3, [sp, #16]
 800d332:	405a      	eors	r2, r3
 800d334:	9b03      	ldr	r3, [sp, #12]
 800d336:	405a      	eors	r2, r3
 800d338:	9b02      	ldr	r3, [sp, #8]
 800d33a:	441a      	add	r2, r3
 800d33c:	9b01      	ldr	r3, [sp, #4]
 800d33e:	69db      	ldr	r3, [r3, #28]
 800d340:	441a      	add	r2, r3
 800d342:	4b8c      	ldr	r3, [pc, #560]	; (800d574 <Transform+0x934>)
 800d344:	4413      	add	r3, r2
 800d346:	210b      	movs	r1, #11
 800d348:	4618      	mov	r0, r3
 800d34a:	f7ff fc59 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d34e:	4602      	mov	r2, r0
 800d350:	9b05      	ldr	r3, [sp, #20]
 800d352:	4413      	add	r3, r2
 800d354:	9302      	str	r3, [sp, #8]
        MD5STEP(F3, c, d, a, b, md5->buffer[7]  + 0xf6bb4b60, 16);
 800d356:	9a02      	ldr	r2, [sp, #8]
 800d358:	9b05      	ldr	r3, [sp, #20]
 800d35a:	405a      	eors	r2, r3
 800d35c:	9b04      	ldr	r3, [sp, #16]
 800d35e:	405a      	eors	r2, r3
 800d360:	9b03      	ldr	r3, [sp, #12]
 800d362:	441a      	add	r2, r3
 800d364:	9b01      	ldr	r3, [sp, #4]
 800d366:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d368:	441a      	add	r2, r3
 800d36a:	4b83      	ldr	r3, [pc, #524]	; (800d578 <Transform+0x938>)
 800d36c:	4413      	add	r3, r2
 800d36e:	2110      	movs	r1, #16
 800d370:	4618      	mov	r0, r3
 800d372:	f7ff fc45 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d376:	4602      	mov	r2, r0
 800d378:	9b02      	ldr	r3, [sp, #8]
 800d37a:	4413      	add	r3, r2
 800d37c:	9303      	str	r3, [sp, #12]
        MD5STEP(F3, b, c, d, a, md5->buffer[10] + 0xbebfbc70, 23);
 800d37e:	9a03      	ldr	r2, [sp, #12]
 800d380:	9b02      	ldr	r3, [sp, #8]
 800d382:	405a      	eors	r2, r3
 800d384:	9b05      	ldr	r3, [sp, #20]
 800d386:	405a      	eors	r2, r3
 800d388:	9b04      	ldr	r3, [sp, #16]
 800d38a:	441a      	add	r2, r3
 800d38c:	9b01      	ldr	r3, [sp, #4]
 800d38e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d390:	441a      	add	r2, r3
 800d392:	4b7a      	ldr	r3, [pc, #488]	; (800d57c <Transform+0x93c>)
 800d394:	4413      	add	r3, r2
 800d396:	2117      	movs	r1, #23
 800d398:	4618      	mov	r0, r3
 800d39a:	f7ff fc31 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d39e:	4602      	mov	r2, r0
 800d3a0:	9b03      	ldr	r3, [sp, #12]
 800d3a2:	4413      	add	r3, r2
 800d3a4:	9304      	str	r3, [sp, #16]
        MD5STEP(F3, a, b, c, d, md5->buffer[13] + 0x289b7ec6,  4);
 800d3a6:	9a04      	ldr	r2, [sp, #16]
 800d3a8:	9b03      	ldr	r3, [sp, #12]
 800d3aa:	405a      	eors	r2, r3
 800d3ac:	9b02      	ldr	r3, [sp, #8]
 800d3ae:	405a      	eors	r2, r3
 800d3b0:	9b05      	ldr	r3, [sp, #20]
 800d3b2:	441a      	add	r2, r3
 800d3b4:	9b01      	ldr	r3, [sp, #4]
 800d3b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d3b8:	441a      	add	r2, r3
 800d3ba:	4b71      	ldr	r3, [pc, #452]	; (800d580 <Transform+0x940>)
 800d3bc:	4413      	add	r3, r2
 800d3be:	2104      	movs	r1, #4
 800d3c0:	4618      	mov	r0, r3
 800d3c2:	f7ff fc1d 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d3c6:	4602      	mov	r2, r0
 800d3c8:	9b04      	ldr	r3, [sp, #16]
 800d3ca:	4413      	add	r3, r2
 800d3cc:	9305      	str	r3, [sp, #20]
        MD5STEP(F3, d, a, b, c, md5->buffer[0]  + 0xeaa127fa, 11);
 800d3ce:	9a05      	ldr	r2, [sp, #20]
 800d3d0:	9b04      	ldr	r3, [sp, #16]
 800d3d2:	405a      	eors	r2, r3
 800d3d4:	9b03      	ldr	r3, [sp, #12]
 800d3d6:	405a      	eors	r2, r3
 800d3d8:	9b02      	ldr	r3, [sp, #8]
 800d3da:	441a      	add	r2, r3
 800d3dc:	9b01      	ldr	r3, [sp, #4]
 800d3de:	68db      	ldr	r3, [r3, #12]
 800d3e0:	441a      	add	r2, r3
 800d3e2:	4b68      	ldr	r3, [pc, #416]	; (800d584 <Transform+0x944>)
 800d3e4:	4413      	add	r3, r2
 800d3e6:	210b      	movs	r1, #11
 800d3e8:	4618      	mov	r0, r3
 800d3ea:	f7ff fc09 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d3ee:	4602      	mov	r2, r0
 800d3f0:	9b05      	ldr	r3, [sp, #20]
 800d3f2:	4413      	add	r3, r2
 800d3f4:	9302      	str	r3, [sp, #8]
        MD5STEP(F3, c, d, a, b, md5->buffer[3]  + 0xd4ef3085, 16);
 800d3f6:	9a02      	ldr	r2, [sp, #8]
 800d3f8:	9b05      	ldr	r3, [sp, #20]
 800d3fa:	405a      	eors	r2, r3
 800d3fc:	9b04      	ldr	r3, [sp, #16]
 800d3fe:	405a      	eors	r2, r3
 800d400:	9b03      	ldr	r3, [sp, #12]
 800d402:	441a      	add	r2, r3
 800d404:	9b01      	ldr	r3, [sp, #4]
 800d406:	699b      	ldr	r3, [r3, #24]
 800d408:	441a      	add	r2, r3
 800d40a:	4b5f      	ldr	r3, [pc, #380]	; (800d588 <Transform+0x948>)
 800d40c:	4413      	add	r3, r2
 800d40e:	2110      	movs	r1, #16
 800d410:	4618      	mov	r0, r3
 800d412:	f7ff fbf5 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d416:	4602      	mov	r2, r0
 800d418:	9b02      	ldr	r3, [sp, #8]
 800d41a:	4413      	add	r3, r2
 800d41c:	9303      	str	r3, [sp, #12]
        MD5STEP(F3, b, c, d, a, md5->buffer[6]  + 0x04881d05, 23);
 800d41e:	9a03      	ldr	r2, [sp, #12]
 800d420:	9b02      	ldr	r3, [sp, #8]
 800d422:	405a      	eors	r2, r3
 800d424:	9b05      	ldr	r3, [sp, #20]
 800d426:	405a      	eors	r2, r3
 800d428:	9b04      	ldr	r3, [sp, #16]
 800d42a:	441a      	add	r2, r3
 800d42c:	9b01      	ldr	r3, [sp, #4]
 800d42e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d430:	441a      	add	r2, r3
 800d432:	4b56      	ldr	r3, [pc, #344]	; (800d58c <Transform+0x94c>)
 800d434:	4413      	add	r3, r2
 800d436:	2117      	movs	r1, #23
 800d438:	4618      	mov	r0, r3
 800d43a:	f7ff fbe1 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d43e:	4602      	mov	r2, r0
 800d440:	9b03      	ldr	r3, [sp, #12]
 800d442:	4413      	add	r3, r2
 800d444:	9304      	str	r3, [sp, #16]
        MD5STEP(F3, a, b, c, d, md5->buffer[9]  + 0xd9d4d039,  4);
 800d446:	9a04      	ldr	r2, [sp, #16]
 800d448:	9b03      	ldr	r3, [sp, #12]
 800d44a:	405a      	eors	r2, r3
 800d44c:	9b02      	ldr	r3, [sp, #8]
 800d44e:	405a      	eors	r2, r3
 800d450:	9b05      	ldr	r3, [sp, #20]
 800d452:	441a      	add	r2, r3
 800d454:	9b01      	ldr	r3, [sp, #4]
 800d456:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d458:	441a      	add	r2, r3
 800d45a:	4b4d      	ldr	r3, [pc, #308]	; (800d590 <Transform+0x950>)
 800d45c:	4413      	add	r3, r2
 800d45e:	2104      	movs	r1, #4
 800d460:	4618      	mov	r0, r3
 800d462:	f7ff fbcd 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d466:	4602      	mov	r2, r0
 800d468:	9b04      	ldr	r3, [sp, #16]
 800d46a:	4413      	add	r3, r2
 800d46c:	9305      	str	r3, [sp, #20]
        MD5STEP(F3, d, a, b, c, md5->buffer[12] + 0xe6db99e5, 11);
 800d46e:	9a05      	ldr	r2, [sp, #20]
 800d470:	9b04      	ldr	r3, [sp, #16]
 800d472:	405a      	eors	r2, r3
 800d474:	9b03      	ldr	r3, [sp, #12]
 800d476:	405a      	eors	r2, r3
 800d478:	9b02      	ldr	r3, [sp, #8]
 800d47a:	441a      	add	r2, r3
 800d47c:	9b01      	ldr	r3, [sp, #4]
 800d47e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d480:	441a      	add	r2, r3
 800d482:	4b44      	ldr	r3, [pc, #272]	; (800d594 <Transform+0x954>)
 800d484:	4413      	add	r3, r2
 800d486:	210b      	movs	r1, #11
 800d488:	4618      	mov	r0, r3
 800d48a:	f7ff fbb9 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d48e:	4602      	mov	r2, r0
 800d490:	9b05      	ldr	r3, [sp, #20]
 800d492:	4413      	add	r3, r2
 800d494:	9302      	str	r3, [sp, #8]
        MD5STEP(F3, c, d, a, b, md5->buffer[15] + 0x1fa27cf8, 16);
 800d496:	9a02      	ldr	r2, [sp, #8]
 800d498:	9b05      	ldr	r3, [sp, #20]
 800d49a:	405a      	eors	r2, r3
 800d49c:	9b04      	ldr	r3, [sp, #16]
 800d49e:	405a      	eors	r2, r3
 800d4a0:	9b03      	ldr	r3, [sp, #12]
 800d4a2:	441a      	add	r2, r3
 800d4a4:	9b01      	ldr	r3, [sp, #4]
 800d4a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d4a8:	441a      	add	r2, r3
 800d4aa:	4b3b      	ldr	r3, [pc, #236]	; (800d598 <Transform+0x958>)
 800d4ac:	4413      	add	r3, r2
 800d4ae:	2110      	movs	r1, #16
 800d4b0:	4618      	mov	r0, r3
 800d4b2:	f7ff fba5 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d4b6:	4602      	mov	r2, r0
 800d4b8:	9b02      	ldr	r3, [sp, #8]
 800d4ba:	4413      	add	r3, r2
 800d4bc:	9303      	str	r3, [sp, #12]
        MD5STEP(F3, b, c, d, a, md5->buffer[2]  + 0xc4ac5665, 23);
 800d4be:	9a03      	ldr	r2, [sp, #12]
 800d4c0:	9b02      	ldr	r3, [sp, #8]
 800d4c2:	405a      	eors	r2, r3
 800d4c4:	9b05      	ldr	r3, [sp, #20]
 800d4c6:	405a      	eors	r2, r3
 800d4c8:	9b04      	ldr	r3, [sp, #16]
 800d4ca:	441a      	add	r2, r3
 800d4cc:	9b01      	ldr	r3, [sp, #4]
 800d4ce:	695b      	ldr	r3, [r3, #20]
 800d4d0:	441a      	add	r2, r3
 800d4d2:	4b32      	ldr	r3, [pc, #200]	; (800d59c <Transform+0x95c>)
 800d4d4:	4413      	add	r3, r2
 800d4d6:	2117      	movs	r1, #23
 800d4d8:	4618      	mov	r0, r3
 800d4da:	f7ff fb91 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d4de:	4602      	mov	r2, r0
 800d4e0:	9b03      	ldr	r3, [sp, #12]
 800d4e2:	4413      	add	r3, r2
 800d4e4:	9304      	str	r3, [sp, #16]

        MD5STEP(F4, a, b, c, d, md5->buffer[0]  + 0xf4292244,  6);
 800d4e6:	9b02      	ldr	r3, [sp, #8]
 800d4e8:	43da      	mvns	r2, r3
 800d4ea:	9b04      	ldr	r3, [sp, #16]
 800d4ec:	431a      	orrs	r2, r3
 800d4ee:	9b03      	ldr	r3, [sp, #12]
 800d4f0:	405a      	eors	r2, r3
 800d4f2:	9b05      	ldr	r3, [sp, #20]
 800d4f4:	441a      	add	r2, r3
 800d4f6:	9b01      	ldr	r3, [sp, #4]
 800d4f8:	68db      	ldr	r3, [r3, #12]
 800d4fa:	441a      	add	r2, r3
 800d4fc:	4b28      	ldr	r3, [pc, #160]	; (800d5a0 <Transform+0x960>)
 800d4fe:	4413      	add	r3, r2
 800d500:	2106      	movs	r1, #6
 800d502:	4618      	mov	r0, r3
 800d504:	f7ff fb7c 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d508:	4602      	mov	r2, r0
 800d50a:	9b04      	ldr	r3, [sp, #16]
 800d50c:	4413      	add	r3, r2
 800d50e:	9305      	str	r3, [sp, #20]
        MD5STEP(F4, d, a, b, c, md5->buffer[7]  + 0x432aff97, 10);
 800d510:	9b03      	ldr	r3, [sp, #12]
 800d512:	43da      	mvns	r2, r3
 800d514:	9b05      	ldr	r3, [sp, #20]
 800d516:	431a      	orrs	r2, r3
 800d518:	9b04      	ldr	r3, [sp, #16]
 800d51a:	405a      	eors	r2, r3
 800d51c:	9b02      	ldr	r3, [sp, #8]
 800d51e:	441a      	add	r2, r3
 800d520:	9b01      	ldr	r3, [sp, #4]
 800d522:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d524:	441a      	add	r2, r3
 800d526:	4b1f      	ldr	r3, [pc, #124]	; (800d5a4 <Transform+0x964>)
 800d528:	4413      	add	r3, r2
 800d52a:	210a      	movs	r1, #10
 800d52c:	4618      	mov	r0, r3
 800d52e:	f7ff fb67 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d532:	4602      	mov	r2, r0
 800d534:	9b05      	ldr	r3, [sp, #20]
 800d536:	4413      	add	r3, r2
 800d538:	9302      	str	r3, [sp, #8]
        MD5STEP(F4, c, d, a, b, md5->buffer[14] + 0xab9423a7, 15);
 800d53a:	9b04      	ldr	r3, [sp, #16]
 800d53c:	43da      	mvns	r2, r3
 800d53e:	9b02      	ldr	r3, [sp, #8]
 800d540:	431a      	orrs	r2, r3
 800d542:	9b05      	ldr	r3, [sp, #20]
 800d544:	405a      	eors	r2, r3
 800d546:	9b03      	ldr	r3, [sp, #12]
 800d548:	441a      	add	r2, r3
 800d54a:	9b01      	ldr	r3, [sp, #4]
 800d54c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d54e:	441a      	add	r2, r3
 800d550:	4b15      	ldr	r3, [pc, #84]	; (800d5a8 <Transform+0x968>)
 800d552:	4413      	add	r3, r2
 800d554:	210f      	movs	r1, #15
 800d556:	4618      	mov	r0, r3
 800d558:	f7ff fb52 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d55c:	4602      	mov	r2, r0
 800d55e:	9b02      	ldr	r3, [sp, #8]
 800d560:	4413      	add	r3, r2
 800d562:	e023      	b.n	800d5ac <Transform+0x96c>
 800d564:	8771f681 	.word	0x8771f681
 800d568:	6d9d6122 	.word	0x6d9d6122
 800d56c:	fde5380c 	.word	0xfde5380c
 800d570:	a4beea44 	.word	0xa4beea44
 800d574:	4bdecfa9 	.word	0x4bdecfa9
 800d578:	f6bb4b60 	.word	0xf6bb4b60
 800d57c:	bebfbc70 	.word	0xbebfbc70
 800d580:	289b7ec6 	.word	0x289b7ec6
 800d584:	eaa127fa 	.word	0xeaa127fa
 800d588:	d4ef3085 	.word	0xd4ef3085
 800d58c:	04881d05 	.word	0x04881d05
 800d590:	d9d4d039 	.word	0xd9d4d039
 800d594:	e6db99e5 	.word	0xe6db99e5
 800d598:	1fa27cf8 	.word	0x1fa27cf8
 800d59c:	c4ac5665 	.word	0xc4ac5665
 800d5a0:	f4292244 	.word	0xf4292244
 800d5a4:	432aff97 	.word	0x432aff97
 800d5a8:	ab9423a7 	.word	0xab9423a7
 800d5ac:	9303      	str	r3, [sp, #12]
        MD5STEP(F4, b, c, d, a, md5->buffer[5]  + 0xfc93a039, 21);
 800d5ae:	9b05      	ldr	r3, [sp, #20]
 800d5b0:	43da      	mvns	r2, r3
 800d5b2:	9b03      	ldr	r3, [sp, #12]
 800d5b4:	431a      	orrs	r2, r3
 800d5b6:	9b02      	ldr	r3, [sp, #8]
 800d5b8:	405a      	eors	r2, r3
 800d5ba:	9b04      	ldr	r3, [sp, #16]
 800d5bc:	441a      	add	r2, r3
 800d5be:	9b01      	ldr	r3, [sp, #4]
 800d5c0:	6a1b      	ldr	r3, [r3, #32]
 800d5c2:	441a      	add	r2, r3
 800d5c4:	4b92      	ldr	r3, [pc, #584]	; (800d810 <Transform+0xbd0>)
 800d5c6:	4413      	add	r3, r2
 800d5c8:	2115      	movs	r1, #21
 800d5ca:	4618      	mov	r0, r3
 800d5cc:	f7ff fb18 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d5d0:	4602      	mov	r2, r0
 800d5d2:	9b03      	ldr	r3, [sp, #12]
 800d5d4:	4413      	add	r3, r2
 800d5d6:	9304      	str	r3, [sp, #16]
        MD5STEP(F4, a, b, c, d, md5->buffer[12] + 0x655b59c3,  6);
 800d5d8:	9b02      	ldr	r3, [sp, #8]
 800d5da:	43da      	mvns	r2, r3
 800d5dc:	9b04      	ldr	r3, [sp, #16]
 800d5de:	431a      	orrs	r2, r3
 800d5e0:	9b03      	ldr	r3, [sp, #12]
 800d5e2:	405a      	eors	r2, r3
 800d5e4:	9b05      	ldr	r3, [sp, #20]
 800d5e6:	441a      	add	r2, r3
 800d5e8:	9b01      	ldr	r3, [sp, #4]
 800d5ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d5ec:	441a      	add	r2, r3
 800d5ee:	4b89      	ldr	r3, [pc, #548]	; (800d814 <Transform+0xbd4>)
 800d5f0:	4413      	add	r3, r2
 800d5f2:	2106      	movs	r1, #6
 800d5f4:	4618      	mov	r0, r3
 800d5f6:	f7ff fb03 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d5fa:	4602      	mov	r2, r0
 800d5fc:	9b04      	ldr	r3, [sp, #16]
 800d5fe:	4413      	add	r3, r2
 800d600:	9305      	str	r3, [sp, #20]
        MD5STEP(F4, d, a, b, c, md5->buffer[3]  + 0x8f0ccc92, 10);
 800d602:	9b03      	ldr	r3, [sp, #12]
 800d604:	43da      	mvns	r2, r3
 800d606:	9b05      	ldr	r3, [sp, #20]
 800d608:	431a      	orrs	r2, r3
 800d60a:	9b04      	ldr	r3, [sp, #16]
 800d60c:	405a      	eors	r2, r3
 800d60e:	9b02      	ldr	r3, [sp, #8]
 800d610:	441a      	add	r2, r3
 800d612:	9b01      	ldr	r3, [sp, #4]
 800d614:	699b      	ldr	r3, [r3, #24]
 800d616:	441a      	add	r2, r3
 800d618:	4b7f      	ldr	r3, [pc, #508]	; (800d818 <Transform+0xbd8>)
 800d61a:	4413      	add	r3, r2
 800d61c:	210a      	movs	r1, #10
 800d61e:	4618      	mov	r0, r3
 800d620:	f7ff faee 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d624:	4602      	mov	r2, r0
 800d626:	9b05      	ldr	r3, [sp, #20]
 800d628:	4413      	add	r3, r2
 800d62a:	9302      	str	r3, [sp, #8]
        MD5STEP(F4, c, d, a, b, md5->buffer[10] + 0xffeff47d, 15);
 800d62c:	9b04      	ldr	r3, [sp, #16]
 800d62e:	43da      	mvns	r2, r3
 800d630:	9b02      	ldr	r3, [sp, #8]
 800d632:	431a      	orrs	r2, r3
 800d634:	9b05      	ldr	r3, [sp, #20]
 800d636:	405a      	eors	r2, r3
 800d638:	9b03      	ldr	r3, [sp, #12]
 800d63a:	441a      	add	r2, r3
 800d63c:	9b01      	ldr	r3, [sp, #4]
 800d63e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d640:	4413      	add	r3, r2
 800d642:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 800d646:	f6a3 3383 	subw	r3, r3, #2947	; 0xb83
 800d64a:	210f      	movs	r1, #15
 800d64c:	4618      	mov	r0, r3
 800d64e:	f7ff fad7 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d652:	4602      	mov	r2, r0
 800d654:	9b02      	ldr	r3, [sp, #8]
 800d656:	4413      	add	r3, r2
 800d658:	9303      	str	r3, [sp, #12]
        MD5STEP(F4, b, c, d, a, md5->buffer[1]  + 0x85845dd1, 21);
 800d65a:	9b05      	ldr	r3, [sp, #20]
 800d65c:	43da      	mvns	r2, r3
 800d65e:	9b03      	ldr	r3, [sp, #12]
 800d660:	431a      	orrs	r2, r3
 800d662:	9b02      	ldr	r3, [sp, #8]
 800d664:	405a      	eors	r2, r3
 800d666:	9b04      	ldr	r3, [sp, #16]
 800d668:	441a      	add	r2, r3
 800d66a:	9b01      	ldr	r3, [sp, #4]
 800d66c:	691b      	ldr	r3, [r3, #16]
 800d66e:	441a      	add	r2, r3
 800d670:	4b6a      	ldr	r3, [pc, #424]	; (800d81c <Transform+0xbdc>)
 800d672:	4413      	add	r3, r2
 800d674:	2115      	movs	r1, #21
 800d676:	4618      	mov	r0, r3
 800d678:	f7ff fac2 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d67c:	4602      	mov	r2, r0
 800d67e:	9b03      	ldr	r3, [sp, #12]
 800d680:	4413      	add	r3, r2
 800d682:	9304      	str	r3, [sp, #16]
        MD5STEP(F4, a, b, c, d, md5->buffer[8]  + 0x6fa87e4f,  6);
 800d684:	9b02      	ldr	r3, [sp, #8]
 800d686:	43da      	mvns	r2, r3
 800d688:	9b04      	ldr	r3, [sp, #16]
 800d68a:	431a      	orrs	r2, r3
 800d68c:	9b03      	ldr	r3, [sp, #12]
 800d68e:	405a      	eors	r2, r3
 800d690:	9b05      	ldr	r3, [sp, #20]
 800d692:	441a      	add	r2, r3
 800d694:	9b01      	ldr	r3, [sp, #4]
 800d696:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d698:	441a      	add	r2, r3
 800d69a:	4b61      	ldr	r3, [pc, #388]	; (800d820 <Transform+0xbe0>)
 800d69c:	4413      	add	r3, r2
 800d69e:	2106      	movs	r1, #6
 800d6a0:	4618      	mov	r0, r3
 800d6a2:	f7ff faad 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d6a6:	4602      	mov	r2, r0
 800d6a8:	9b04      	ldr	r3, [sp, #16]
 800d6aa:	4413      	add	r3, r2
 800d6ac:	9305      	str	r3, [sp, #20]
        MD5STEP(F4, d, a, b, c, md5->buffer[15] + 0xfe2ce6e0, 10);
 800d6ae:	9b03      	ldr	r3, [sp, #12]
 800d6b0:	43da      	mvns	r2, r3
 800d6b2:	9b05      	ldr	r3, [sp, #20]
 800d6b4:	431a      	orrs	r2, r3
 800d6b6:	9b04      	ldr	r3, [sp, #16]
 800d6b8:	405a      	eors	r2, r3
 800d6ba:	9b02      	ldr	r3, [sp, #8]
 800d6bc:	441a      	add	r2, r3
 800d6be:	9b01      	ldr	r3, [sp, #4]
 800d6c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d6c2:	441a      	add	r2, r3
 800d6c4:	4b57      	ldr	r3, [pc, #348]	; (800d824 <Transform+0xbe4>)
 800d6c6:	4413      	add	r3, r2
 800d6c8:	210a      	movs	r1, #10
 800d6ca:	4618      	mov	r0, r3
 800d6cc:	f7ff fa98 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d6d0:	4602      	mov	r2, r0
 800d6d2:	9b05      	ldr	r3, [sp, #20]
 800d6d4:	4413      	add	r3, r2
 800d6d6:	9302      	str	r3, [sp, #8]
        MD5STEP(F4, c, d, a, b, md5->buffer[6]  + 0xa3014314, 15);
 800d6d8:	9b04      	ldr	r3, [sp, #16]
 800d6da:	43da      	mvns	r2, r3
 800d6dc:	9b02      	ldr	r3, [sp, #8]
 800d6de:	431a      	orrs	r2, r3
 800d6e0:	9b05      	ldr	r3, [sp, #20]
 800d6e2:	405a      	eors	r2, r3
 800d6e4:	9b03      	ldr	r3, [sp, #12]
 800d6e6:	441a      	add	r2, r3
 800d6e8:	9b01      	ldr	r3, [sp, #4]
 800d6ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d6ec:	441a      	add	r2, r3
 800d6ee:	4b4e      	ldr	r3, [pc, #312]	; (800d828 <Transform+0xbe8>)
 800d6f0:	4413      	add	r3, r2
 800d6f2:	210f      	movs	r1, #15
 800d6f4:	4618      	mov	r0, r3
 800d6f6:	f7ff fa83 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d6fa:	4602      	mov	r2, r0
 800d6fc:	9b02      	ldr	r3, [sp, #8]
 800d6fe:	4413      	add	r3, r2
 800d700:	9303      	str	r3, [sp, #12]
        MD5STEP(F4, b, c, d, a, md5->buffer[13] + 0x4e0811a1, 21);
 800d702:	9b05      	ldr	r3, [sp, #20]
 800d704:	43da      	mvns	r2, r3
 800d706:	9b03      	ldr	r3, [sp, #12]
 800d708:	431a      	orrs	r2, r3
 800d70a:	9b02      	ldr	r3, [sp, #8]
 800d70c:	405a      	eors	r2, r3
 800d70e:	9b04      	ldr	r3, [sp, #16]
 800d710:	441a      	add	r2, r3
 800d712:	9b01      	ldr	r3, [sp, #4]
 800d714:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d716:	441a      	add	r2, r3
 800d718:	4b44      	ldr	r3, [pc, #272]	; (800d82c <Transform+0xbec>)
 800d71a:	4413      	add	r3, r2
 800d71c:	2115      	movs	r1, #21
 800d71e:	4618      	mov	r0, r3
 800d720:	f7ff fa6e 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d724:	4602      	mov	r2, r0
 800d726:	9b03      	ldr	r3, [sp, #12]
 800d728:	4413      	add	r3, r2
 800d72a:	9304      	str	r3, [sp, #16]
        MD5STEP(F4, a, b, c, d, md5->buffer[4]  + 0xf7537e82,  6);
 800d72c:	9b02      	ldr	r3, [sp, #8]
 800d72e:	43da      	mvns	r2, r3
 800d730:	9b04      	ldr	r3, [sp, #16]
 800d732:	431a      	orrs	r2, r3
 800d734:	9b03      	ldr	r3, [sp, #12]
 800d736:	405a      	eors	r2, r3
 800d738:	9b05      	ldr	r3, [sp, #20]
 800d73a:	441a      	add	r2, r3
 800d73c:	9b01      	ldr	r3, [sp, #4]
 800d73e:	69db      	ldr	r3, [r3, #28]
 800d740:	441a      	add	r2, r3
 800d742:	4b3b      	ldr	r3, [pc, #236]	; (800d830 <Transform+0xbf0>)
 800d744:	4413      	add	r3, r2
 800d746:	2106      	movs	r1, #6
 800d748:	4618      	mov	r0, r3
 800d74a:	f7ff fa59 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d74e:	4602      	mov	r2, r0
 800d750:	9b04      	ldr	r3, [sp, #16]
 800d752:	4413      	add	r3, r2
 800d754:	9305      	str	r3, [sp, #20]
        MD5STEP(F4, d, a, b, c, md5->buffer[11] + 0xbd3af235, 10);
 800d756:	9b03      	ldr	r3, [sp, #12]
 800d758:	43da      	mvns	r2, r3
 800d75a:	9b05      	ldr	r3, [sp, #20]
 800d75c:	431a      	orrs	r2, r3
 800d75e:	9b04      	ldr	r3, [sp, #16]
 800d760:	405a      	eors	r2, r3
 800d762:	9b02      	ldr	r3, [sp, #8]
 800d764:	441a      	add	r2, r3
 800d766:	9b01      	ldr	r3, [sp, #4]
 800d768:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d76a:	441a      	add	r2, r3
 800d76c:	4b31      	ldr	r3, [pc, #196]	; (800d834 <Transform+0xbf4>)
 800d76e:	4413      	add	r3, r2
 800d770:	210a      	movs	r1, #10
 800d772:	4618      	mov	r0, r3
 800d774:	f7ff fa44 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d778:	4602      	mov	r2, r0
 800d77a:	9b05      	ldr	r3, [sp, #20]
 800d77c:	4413      	add	r3, r2
 800d77e:	9302      	str	r3, [sp, #8]
        MD5STEP(F4, c, d, a, b, md5->buffer[2]  + 0x2ad7d2bb, 15);
 800d780:	9b04      	ldr	r3, [sp, #16]
 800d782:	43da      	mvns	r2, r3
 800d784:	9b02      	ldr	r3, [sp, #8]
 800d786:	431a      	orrs	r2, r3
 800d788:	9b05      	ldr	r3, [sp, #20]
 800d78a:	405a      	eors	r2, r3
 800d78c:	9b03      	ldr	r3, [sp, #12]
 800d78e:	441a      	add	r2, r3
 800d790:	9b01      	ldr	r3, [sp, #4]
 800d792:	695b      	ldr	r3, [r3, #20]
 800d794:	441a      	add	r2, r3
 800d796:	4b28      	ldr	r3, [pc, #160]	; (800d838 <Transform+0xbf8>)
 800d798:	4413      	add	r3, r2
 800d79a:	210f      	movs	r1, #15
 800d79c:	4618      	mov	r0, r3
 800d79e:	f7ff fa2f 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d7a2:	4602      	mov	r2, r0
 800d7a4:	9b02      	ldr	r3, [sp, #8]
 800d7a6:	4413      	add	r3, r2
 800d7a8:	9303      	str	r3, [sp, #12]
        MD5STEP(F4, b, c, d, a, md5->buffer[9]  + 0xeb86d391, 21);
 800d7aa:	9b05      	ldr	r3, [sp, #20]
 800d7ac:	43da      	mvns	r2, r3
 800d7ae:	9b03      	ldr	r3, [sp, #12]
 800d7b0:	431a      	orrs	r2, r3
 800d7b2:	9b02      	ldr	r3, [sp, #8]
 800d7b4:	405a      	eors	r2, r3
 800d7b6:	9b04      	ldr	r3, [sp, #16]
 800d7b8:	441a      	add	r2, r3
 800d7ba:	9b01      	ldr	r3, [sp, #4]
 800d7bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d7be:	441a      	add	r2, r3
 800d7c0:	4b1e      	ldr	r3, [pc, #120]	; (800d83c <Transform+0xbfc>)
 800d7c2:	4413      	add	r3, r2
 800d7c4:	2115      	movs	r1, #21
 800d7c6:	4618      	mov	r0, r3
 800d7c8:	f7ff fa1a 	bl	800cc00 <rotlFixed.lto_priv.376>
 800d7cc:	4602      	mov	r2, r0
 800d7ce:	9b03      	ldr	r3, [sp, #12]
 800d7d0:	4413      	add	r3, r2
 800d7d2:	9304      	str	r3, [sp, #16]

        /* Add the working vars back into digest state[]  */
        md5->digest[0] += a;
 800d7d4:	9b01      	ldr	r3, [sp, #4]
 800d7d6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d7d8:	9b05      	ldr	r3, [sp, #20]
 800d7da:	441a      	add	r2, r3
 800d7dc:	9b01      	ldr	r3, [sp, #4]
 800d7de:	64da      	str	r2, [r3, #76]	; 0x4c
        md5->digest[1] += b;
 800d7e0:	9b01      	ldr	r3, [sp, #4]
 800d7e2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800d7e4:	9b04      	ldr	r3, [sp, #16]
 800d7e6:	441a      	add	r2, r3
 800d7e8:	9b01      	ldr	r3, [sp, #4]
 800d7ea:	651a      	str	r2, [r3, #80]	; 0x50
        md5->digest[2] += c;
 800d7ec:	9b01      	ldr	r3, [sp, #4]
 800d7ee:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d7f0:	9b03      	ldr	r3, [sp, #12]
 800d7f2:	441a      	add	r2, r3
 800d7f4:	9b01      	ldr	r3, [sp, #4]
 800d7f6:	655a      	str	r2, [r3, #84]	; 0x54
        md5->digest[3] += d;
 800d7f8:	9b01      	ldr	r3, [sp, #4]
 800d7fa:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800d7fc:	9b02      	ldr	r3, [sp, #8]
 800d7fe:	441a      	add	r2, r3
 800d800:	9b01      	ldr	r3, [sp, #4]
 800d802:	659a      	str	r2, [r3, #88]	; 0x58

        return 0;
 800d804:	2300      	movs	r3, #0
    }
 800d806:	4618      	mov	r0, r3
 800d808:	b007      	add	sp, #28
 800d80a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d80e:	bf00      	nop
 800d810:	fc93a039 	.word	0xfc93a039
 800d814:	655b59c3 	.word	0x655b59c3
 800d818:	8f0ccc92 	.word	0x8f0ccc92
 800d81c:	85845dd1 	.word	0x85845dd1
 800d820:	6fa87e4f 	.word	0x6fa87e4f
 800d824:	fe2ce6e0 	.word	0xfe2ce6e0
 800d828:	a3014314 	.word	0xa3014314
 800d82c:	4e0811a1 	.word	0x4e0811a1
 800d830:	f7537e82 	.word	0xf7537e82
 800d834:	bd3af235 	.word	0xbd3af235
 800d838:	2ad7d2bb 	.word	0x2ad7d2bb
 800d83c:	eb86d391 	.word	0xeb86d391

0800d840 <AddLength>:
#endif /* NEED_SOFT_MD5 */

#if !defined(HAVE_MD5_CUST_API) || defined(STM32_HASH)
static INLINE void AddLength(wc_Md5* md5, word32 len)
{
 800d840:	b084      	sub	sp, #16
 800d842:	9001      	str	r0, [sp, #4]
 800d844:	9100      	str	r1, [sp, #0]
    word32 tmp = md5->loLen;
 800d846:	9b01      	ldr	r3, [sp, #4]
 800d848:	685b      	ldr	r3, [r3, #4]
 800d84a:	9303      	str	r3, [sp, #12]
    if ((md5->loLen += len) < tmp) {
 800d84c:	9b01      	ldr	r3, [sp, #4]
 800d84e:	685a      	ldr	r2, [r3, #4]
 800d850:	9b00      	ldr	r3, [sp, #0]
 800d852:	441a      	add	r2, r3
 800d854:	9b01      	ldr	r3, [sp, #4]
 800d856:	605a      	str	r2, [r3, #4]
 800d858:	9b01      	ldr	r3, [sp, #4]
 800d85a:	685a      	ldr	r2, [r3, #4]
 800d85c:	9b03      	ldr	r3, [sp, #12]
 800d85e:	429a      	cmp	r2, r3
 800d860:	d204      	bcs.n	800d86c <AddLength+0x2c>
        md5->hiLen++;                       /* carry low to high */
 800d862:	9b01      	ldr	r3, [sp, #4]
 800d864:	689b      	ldr	r3, [r3, #8]
 800d866:	1c5a      	adds	r2, r3, #1
 800d868:	9b01      	ldr	r3, [sp, #4]
 800d86a:	609a      	str	r2, [r3, #8]
    }
}
 800d86c:	b004      	add	sp, #16
 800d86e:	4770      	bx	lr

0800d870 <_InitMd5>:
#endif

#ifndef HAVE_MD5_CUST_API
static int _InitMd5(wc_Md5* md5)
{
 800d870:	b084      	sub	sp, #16
 800d872:	9001      	str	r0, [sp, #4]
    int ret = 0;
 800d874:	2300      	movs	r3, #0
 800d876:	9303      	str	r3, [sp, #12]

    md5->digest[0] = 0x67452301L;
 800d878:	9b01      	ldr	r3, [sp, #4]
 800d87a:	4a0c      	ldr	r2, [pc, #48]	; (800d8ac <_InitMd5+0x3c>)
 800d87c:	64da      	str	r2, [r3, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
 800d87e:	9b01      	ldr	r3, [sp, #4]
 800d880:	4a0b      	ldr	r2, [pc, #44]	; (800d8b0 <_InitMd5+0x40>)
 800d882:	651a      	str	r2, [r3, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
 800d884:	9b01      	ldr	r3, [sp, #4]
 800d886:	4a0b      	ldr	r2, [pc, #44]	; (800d8b4 <_InitMd5+0x44>)
 800d888:	655a      	str	r2, [r3, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
 800d88a:	9b01      	ldr	r3, [sp, #4]
 800d88c:	4a0a      	ldr	r2, [pc, #40]	; (800d8b8 <_InitMd5+0x48>)
 800d88e:	659a      	str	r2, [r3, #88]	; 0x58

    md5->buffLen = 0;
 800d890:	9b01      	ldr	r3, [sp, #4]
 800d892:	2200      	movs	r2, #0
 800d894:	601a      	str	r2, [r3, #0]
    md5->loLen   = 0;
 800d896:	9b01      	ldr	r3, [sp, #4]
 800d898:	2200      	movs	r2, #0
 800d89a:	605a      	str	r2, [r3, #4]
    md5->hiLen   = 0;
 800d89c:	9b01      	ldr	r3, [sp, #4]
 800d89e:	2200      	movs	r2, #0
 800d8a0:	609a      	str	r2, [r3, #8]

    return ret;
 800d8a2:	9b03      	ldr	r3, [sp, #12]
}
 800d8a4:	4618      	mov	r0, r3
 800d8a6:	b004      	add	sp, #16
 800d8a8:	4770      	bx	lr
 800d8aa:	bf00      	nop
 800d8ac:	67452301 	.word	0x67452301
 800d8b0:	efcdab89 	.word	0xefcdab89
 800d8b4:	98badcfe 	.word	0x98badcfe
 800d8b8:	10325476 	.word	0x10325476
 800d8bc:	00000000 	.word	0x00000000

0800d8c0 <wc_InitMd5_ex>:

int wc_InitMd5_ex(wc_Md5* md5, void* heap, int devId)
{
 800d8c0:	b500      	push	{lr}
 800d8c2:	b087      	sub	sp, #28
 800d8c4:	9003      	str	r0, [sp, #12]
 800d8c6:	9102      	str	r1, [sp, #8]
 800d8c8:	9201      	str	r2, [sp, #4]
    int ret = 0;
 800d8ca:	2300      	movs	r3, #0
 800d8cc:	9305      	str	r3, [sp, #20]

    if (md5 == NULL)
 800d8ce:	9b03      	ldr	r3, [sp, #12]
 800d8d0:	2b00      	cmp	r3, #0
 800d8d2:	d102      	bne.n	800d8da <wc_InitMd5_ex+0x1a>
        return BAD_FUNC_ARG;
 800d8d4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d8d8:	e00c      	b.n	800d8f4 <wc_InitMd5_ex+0x34>

    md5->heap = heap;
 800d8da:	9b03      	ldr	r3, [sp, #12]
 800d8dc:	9a02      	ldr	r2, [sp, #8]
 800d8de:	65da      	str	r2, [r3, #92]	; 0x5c

    ret = _InitMd5(md5);
 800d8e0:	9803      	ldr	r0, [sp, #12]
 800d8e2:	f7ff ffc5 	bl	800d870 <_InitMd5>
 800d8e6:	9005      	str	r0, [sp, #20]
    if (ret != 0)
 800d8e8:	9b05      	ldr	r3, [sp, #20]
 800d8ea:	2b00      	cmp	r3, #0
 800d8ec:	d001      	beq.n	800d8f2 <wc_InitMd5_ex+0x32>
        return ret;
 800d8ee:	9b05      	ldr	r3, [sp, #20]
 800d8f0:	e000      	b.n	800d8f4 <wc_InitMd5_ex+0x34>
    ret = wolfAsync_DevCtxInit(&md5->asyncDev, WOLFSSL_ASYNC_MARKER_MD5,
                                                            md5->heap, devId);
#else
    (void)devId;
#endif
    return ret;
 800d8f2:	9b05      	ldr	r3, [sp, #20]
}
 800d8f4:	4618      	mov	r0, r3
 800d8f6:	b007      	add	sp, #28
 800d8f8:	f85d fb04 	ldr.w	pc, [sp], #4
 800d8fc:	0000      	movs	r0, r0
	...

0800d900 <wc_Md5Update>:

int wc_Md5Update(wc_Md5* md5, const byte* data, word32 len)
{
 800d900:	b500      	push	{lr}
 800d902:	b089      	sub	sp, #36	; 0x24
 800d904:	9003      	str	r0, [sp, #12]
 800d906:	9102      	str	r1, [sp, #8]
 800d908:	9201      	str	r2, [sp, #4]
    int ret = 0;
 800d90a:	2300      	movs	r3, #0
 800d90c:	9307      	str	r3, [sp, #28]
    byte* local;

    if (md5 == NULL || (data == NULL && len > 0)) {
 800d90e:	9b03      	ldr	r3, [sp, #12]
 800d910:	2b00      	cmp	r3, #0
 800d912:	d005      	beq.n	800d920 <wc_Md5Update+0x20>
 800d914:	9b02      	ldr	r3, [sp, #8]
 800d916:	2b00      	cmp	r3, #0
 800d918:	d105      	bne.n	800d926 <wc_Md5Update+0x26>
 800d91a:	9b01      	ldr	r3, [sp, #4]
 800d91c:	2b00      	cmp	r3, #0
 800d91e:	d002      	beq.n	800d926 <wc_Md5Update+0x26>
        return BAD_FUNC_ARG;
 800d920:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d924:	e03b      	b.n	800d99e <wc_Md5Update+0x9e>
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* do block size increments */
    local = (byte*)md5->buffer;
 800d926:	9b03      	ldr	r3, [sp, #12]
 800d928:	330c      	adds	r3, #12
 800d92a:	9306      	str	r3, [sp, #24]

    /* check that internal buffLen is valid */
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
 800d92c:	9b03      	ldr	r3, [sp, #12]
 800d92e:	681b      	ldr	r3, [r3, #0]
 800d930:	2b3f      	cmp	r3, #63	; 0x3f
 800d932:	d930      	bls.n	800d996 <wc_Md5Update+0x96>
        return BUFFER_E;
 800d934:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800d938:	e031      	b.n	800d99e <wc_Md5Update+0x9e>

    while (len) {
        word32 add = min(len, WC_MD5_BLOCK_SIZE - md5->buffLen);
 800d93a:	9b03      	ldr	r3, [sp, #12]
 800d93c:	681b      	ldr	r3, [r3, #0]
 800d93e:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800d942:	4619      	mov	r1, r3
 800d944:	9801      	ldr	r0, [sp, #4]
 800d946:	f7ff f96b 	bl	800cc20 <min>
 800d94a:	9005      	str	r0, [sp, #20]
        XMEMCPY(&local[md5->buffLen], data, add);
 800d94c:	9b03      	ldr	r3, [sp, #12]
 800d94e:	681b      	ldr	r3, [r3, #0]
 800d950:	9a06      	ldr	r2, [sp, #24]
 800d952:	4413      	add	r3, r2
 800d954:	9a05      	ldr	r2, [sp, #20]
 800d956:	9902      	ldr	r1, [sp, #8]
 800d958:	4618      	mov	r0, r3
 800d95a:	f7f6 fedf 	bl	800471c <memcpy>

        md5->buffLen += add;
 800d95e:	9b03      	ldr	r3, [sp, #12]
 800d960:	681a      	ldr	r2, [r3, #0]
 800d962:	9b05      	ldr	r3, [sp, #20]
 800d964:	441a      	add	r2, r3
 800d966:	9b03      	ldr	r3, [sp, #12]
 800d968:	601a      	str	r2, [r3, #0]
        data         += add;
 800d96a:	9a02      	ldr	r2, [sp, #8]
 800d96c:	9b05      	ldr	r3, [sp, #20]
 800d96e:	4413      	add	r3, r2
 800d970:	9302      	str	r3, [sp, #8]
        len          -= add;
 800d972:	9a01      	ldr	r2, [sp, #4]
 800d974:	9b05      	ldr	r3, [sp, #20]
 800d976:	1ad3      	subs	r3, r2, r3
 800d978:	9301      	str	r3, [sp, #4]

        if (md5->buffLen == WC_MD5_BLOCK_SIZE) {
 800d97a:	9b03      	ldr	r3, [sp, #12]
 800d97c:	681b      	ldr	r3, [r3, #0]
 800d97e:	2b40      	cmp	r3, #64	; 0x40
 800d980:	d109      	bne.n	800d996 <wc_Md5Update+0x96>
        #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
            ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
        #endif
            XTRANSFORM(md5, local);
 800d982:	9803      	ldr	r0, [sp, #12]
 800d984:	f7ff f95c 	bl	800cc40 <Transform>
            AddLength(md5, WC_MD5_BLOCK_SIZE);
 800d988:	2140      	movs	r1, #64	; 0x40
 800d98a:	9803      	ldr	r0, [sp, #12]
 800d98c:	f7ff ff58 	bl	800d840 <AddLength>
            md5->buffLen = 0;
 800d990:	9b03      	ldr	r3, [sp, #12]
 800d992:	2200      	movs	r2, #0
 800d994:	601a      	str	r2, [r3, #0]
    while (len) {
 800d996:	9b01      	ldr	r3, [sp, #4]
 800d998:	2b00      	cmp	r3, #0
 800d99a:	d1ce      	bne.n	800d93a <wc_Md5Update+0x3a>
        }
    }
    return ret;
 800d99c:	9b07      	ldr	r3, [sp, #28]
}
 800d99e:	4618      	mov	r0, r3
 800d9a0:	b009      	add	sp, #36	; 0x24
 800d9a2:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9a6:	bf00      	nop
	...

0800d9b0 <wc_Md5Final>:

int wc_Md5Final(wc_Md5* md5, byte* hash)
{
 800d9b0:	b500      	push	{lr}
 800d9b2:	b085      	sub	sp, #20
 800d9b4:	9001      	str	r0, [sp, #4]
 800d9b6:	9100      	str	r1, [sp, #0]
    byte* local;

    if (md5 == NULL || hash == NULL) {
 800d9b8:	9b01      	ldr	r3, [sp, #4]
 800d9ba:	2b00      	cmp	r3, #0
 800d9bc:	d002      	beq.n	800d9c4 <wc_Md5Final+0x14>
 800d9be:	9b00      	ldr	r3, [sp, #0]
 800d9c0:	2b00      	cmp	r3, #0
 800d9c2:	d102      	bne.n	800d9ca <wc_Md5Final+0x1a>
        return BAD_FUNC_ARG;
 800d9c4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800d9c8:	e05e      	b.n	800da88 <wc_Md5Final+0xd8>
        return IntelQaSymMd5(&md5->asyncDev, hash, NULL, WC_MD5_DIGEST_SIZE);
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    local = (byte*)md5->buffer;
 800d9ca:	9b01      	ldr	r3, [sp, #4]
 800d9cc:	330c      	adds	r3, #12
 800d9ce:	9303      	str	r3, [sp, #12]

    AddLength(md5, md5->buffLen);  /* before adding pads */
 800d9d0:	9b01      	ldr	r3, [sp, #4]
 800d9d2:	681b      	ldr	r3, [r3, #0]
 800d9d4:	4619      	mov	r1, r3
 800d9d6:	9801      	ldr	r0, [sp, #4]
 800d9d8:	f7ff ff32 	bl	800d840 <AddLength>
    local[md5->buffLen++] = 0x80;  /* add 1 */
 800d9dc:	9b01      	ldr	r3, [sp, #4]
 800d9de:	681b      	ldr	r3, [r3, #0]
 800d9e0:	1c59      	adds	r1, r3, #1
 800d9e2:	9a01      	ldr	r2, [sp, #4]
 800d9e4:	6011      	str	r1, [r2, #0]
 800d9e6:	9a03      	ldr	r2, [sp, #12]
 800d9e8:	4413      	add	r3, r2
 800d9ea:	2280      	movs	r2, #128	; 0x80
 800d9ec:	701a      	strb	r2, [r3, #0]

    /* pad with zeros */
    if (md5->buffLen > WC_MD5_PAD_SIZE) {
 800d9ee:	9b01      	ldr	r3, [sp, #4]
 800d9f0:	681b      	ldr	r3, [r3, #0]
 800d9f2:	2b38      	cmp	r3, #56	; 0x38
 800d9f4:	d914      	bls.n	800da20 <wc_Md5Final+0x70>
        XMEMSET(&local[md5->buffLen], 0, WC_MD5_BLOCK_SIZE - md5->buffLen);
 800d9f6:	9b01      	ldr	r3, [sp, #4]
 800d9f8:	681b      	ldr	r3, [r3, #0]
 800d9fa:	9a03      	ldr	r2, [sp, #12]
 800d9fc:	18d0      	adds	r0, r2, r3
 800d9fe:	9b01      	ldr	r3, [sp, #4]
 800da00:	681b      	ldr	r3, [r3, #0]
 800da02:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800da06:	461a      	mov	r2, r3
 800da08:	2100      	movs	r1, #0
 800da0a:	f00f fee3 	bl	801d7d4 <memset>
        md5->buffLen += WC_MD5_BLOCK_SIZE - md5->buffLen;
 800da0e:	9b01      	ldr	r3, [sp, #4]
 800da10:	2240      	movs	r2, #64	; 0x40
 800da12:	601a      	str	r2, [r3, #0]

    #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
    #endif
        XTRANSFORM(md5, local);
 800da14:	9801      	ldr	r0, [sp, #4]
 800da16:	f7ff f913 	bl	800cc40 <Transform>
        md5->buffLen = 0;
 800da1a:	9b01      	ldr	r3, [sp, #4]
 800da1c:	2200      	movs	r2, #0
 800da1e:	601a      	str	r2, [r3, #0]
    }
    XMEMSET(&local[md5->buffLen], 0, WC_MD5_PAD_SIZE - md5->buffLen);
 800da20:	9b01      	ldr	r3, [sp, #4]
 800da22:	681b      	ldr	r3, [r3, #0]
 800da24:	9a03      	ldr	r2, [sp, #12]
 800da26:	18d0      	adds	r0, r2, r3
 800da28:	9b01      	ldr	r3, [sp, #4]
 800da2a:	681b      	ldr	r3, [r3, #0]
 800da2c:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 800da30:	461a      	mov	r2, r3
 800da32:	2100      	movs	r1, #0
 800da34:	f00f fece 	bl	801d7d4 <memset>
#if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif

    /* put lengths in bits */
    md5->hiLen = (md5->loLen >> (8*sizeof(md5->loLen) - 3)) +
 800da38:	9b01      	ldr	r3, [sp, #4]
 800da3a:	685b      	ldr	r3, [r3, #4]
 800da3c:	0f5a      	lsrs	r2, r3, #29
                 (md5->hiLen << 3);
 800da3e:	9b01      	ldr	r3, [sp, #4]
 800da40:	689b      	ldr	r3, [r3, #8]
 800da42:	00db      	lsls	r3, r3, #3
    md5->hiLen = (md5->loLen >> (8*sizeof(md5->loLen) - 3)) +
 800da44:	441a      	add	r2, r3
 800da46:	9b01      	ldr	r3, [sp, #4]
 800da48:	609a      	str	r2, [r3, #8]
    md5->loLen = md5->loLen << 3;
 800da4a:	9b01      	ldr	r3, [sp, #4]
 800da4c:	685b      	ldr	r3, [r3, #4]
 800da4e:	00da      	lsls	r2, r3, #3
 800da50:	9b01      	ldr	r3, [sp, #4]
 800da52:	605a      	str	r2, [r3, #4]

    /* store lengths */
    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_MD5_PAD_SIZE], &md5->loLen, sizeof(word32));
 800da54:	9b03      	ldr	r3, [sp, #12]
 800da56:	3338      	adds	r3, #56	; 0x38
 800da58:	9a01      	ldr	r2, [sp, #4]
 800da5a:	3204      	adds	r2, #4
 800da5c:	6812      	ldr	r2, [r2, #0]
 800da5e:	601a      	str	r2, [r3, #0]
    XMEMCPY(&local[WC_MD5_PAD_SIZE + sizeof(word32)], &md5->hiLen, sizeof(word32));
 800da60:	9b03      	ldr	r3, [sp, #12]
 800da62:	333c      	adds	r3, #60	; 0x3c
 800da64:	9a01      	ldr	r2, [sp, #4]
 800da66:	3208      	adds	r2, #8
 800da68:	6812      	ldr	r2, [r2, #0]
 800da6a:	601a      	str	r2, [r3, #0]

    /* final transform and result to hash */
    XTRANSFORM(md5, local);
 800da6c:	9801      	ldr	r0, [sp, #4]
 800da6e:	f7ff f8e7 	bl	800cc40 <Transform>
#ifdef BIG_ENDIAN_ORDER
    ByteReverseWords(md5->digest, md5->digest, WC_MD5_DIGEST_SIZE);
#endif
    XMEMCPY(hash, md5->digest, WC_MD5_DIGEST_SIZE);
 800da72:	9b01      	ldr	r3, [sp, #4]
 800da74:	334c      	adds	r3, #76	; 0x4c
 800da76:	2210      	movs	r2, #16
 800da78:	4619      	mov	r1, r3
 800da7a:	9800      	ldr	r0, [sp, #0]
 800da7c:	f7f6 fe4e 	bl	800471c <memcpy>

    return _InitMd5(md5); /* reset state */
 800da80:	9801      	ldr	r0, [sp, #4]
 800da82:	f7ff fef5 	bl	800d870 <_InitMd5>
 800da86:	4603      	mov	r3, r0
}
 800da88:	4618      	mov	r0, r3
 800da8a:	b005      	add	sp, #20
 800da8c:	f85d fb04 	ldr.w	pc, [sp], #4

0800da90 <wc_InitMd5>:
#endif /* !HAVE_MD5_CUST_API */


int wc_InitMd5(wc_Md5* md5)
{
 800da90:	b500      	push	{lr}
 800da92:	b083      	sub	sp, #12
 800da94:	9001      	str	r0, [sp, #4]
    if (md5 == NULL) {
 800da96:	9b01      	ldr	r3, [sp, #4]
 800da98:	2b00      	cmp	r3, #0
 800da9a:	d102      	bne.n	800daa2 <wc_InitMd5+0x12>
        return BAD_FUNC_ARG;
 800da9c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800daa0:	e006      	b.n	800dab0 <wc_InitMd5+0x20>
    }
    return wc_InitMd5_ex(md5, NULL, INVALID_DEVID);
 800daa2:	f06f 0201 	mvn.w	r2, #1
 800daa6:	2100      	movs	r1, #0
 800daa8:	9801      	ldr	r0, [sp, #4]
 800daaa:	f7ff ff09 	bl	800d8c0 <wc_InitMd5_ex>
 800daae:	4603      	mov	r3, r0
}
 800dab0:	4618      	mov	r0, r3
 800dab2:	b003      	add	sp, #12
 800dab4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800dac0 <SetMyVersion>:
    }
}
#endif /* WOLFSSL_TRUST_PEER_CERT */

WOLFSSL_LOCAL int SetMyVersion(word32 version, byte* output, int header)
{
 800dac0:	b086      	sub	sp, #24
 800dac2:	9003      	str	r0, [sp, #12]
 800dac4:	9102      	str	r1, [sp, #8]
 800dac6:	9201      	str	r2, [sp, #4]
    int i = 0;
 800dac8:	2300      	movs	r3, #0
 800daca:	9305      	str	r3, [sp, #20]

    if (output == NULL)
 800dacc:	9b02      	ldr	r3, [sp, #8]
 800dace:	2b00      	cmp	r3, #0
 800dad0:	d102      	bne.n	800dad8 <SetMyVersion+0x18>
        return BAD_FUNC_ARG;
 800dad2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800dad6:	e02c      	b.n	800db32 <SetMyVersion+0x72>

    if (header) {
 800dad8:	9b01      	ldr	r3, [sp, #4]
 800dada:	2b00      	cmp	r3, #0
 800dadc:	d00f      	beq.n	800dafe <SetMyVersion+0x3e>
        output[i++] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;
 800dade:	9b05      	ldr	r3, [sp, #20]
 800dae0:	1c5a      	adds	r2, r3, #1
 800dae2:	9205      	str	r2, [sp, #20]
 800dae4:	461a      	mov	r2, r3
 800dae6:	9b02      	ldr	r3, [sp, #8]
 800dae8:	4413      	add	r3, r2
 800daea:	22a0      	movs	r2, #160	; 0xa0
 800daec:	701a      	strb	r2, [r3, #0]
        output[i++] = 3;
 800daee:	9b05      	ldr	r3, [sp, #20]
 800daf0:	1c5a      	adds	r2, r3, #1
 800daf2:	9205      	str	r2, [sp, #20]
 800daf4:	461a      	mov	r2, r3
 800daf6:	9b02      	ldr	r3, [sp, #8]
 800daf8:	4413      	add	r3, r2
 800dafa:	2203      	movs	r2, #3
 800dafc:	701a      	strb	r2, [r3, #0]
    }
    output[i++] = ASN_INTEGER;
 800dafe:	9b05      	ldr	r3, [sp, #20]
 800db00:	1c5a      	adds	r2, r3, #1
 800db02:	9205      	str	r2, [sp, #20]
 800db04:	461a      	mov	r2, r3
 800db06:	9b02      	ldr	r3, [sp, #8]
 800db08:	4413      	add	r3, r2
 800db0a:	2202      	movs	r2, #2
 800db0c:	701a      	strb	r2, [r3, #0]
    output[i++] = 0x01;
 800db0e:	9b05      	ldr	r3, [sp, #20]
 800db10:	1c5a      	adds	r2, r3, #1
 800db12:	9205      	str	r2, [sp, #20]
 800db14:	461a      	mov	r2, r3
 800db16:	9b02      	ldr	r3, [sp, #8]
 800db18:	4413      	add	r3, r2
 800db1a:	2201      	movs	r2, #1
 800db1c:	701a      	strb	r2, [r3, #0]
    output[i++] = (byte)version;
 800db1e:	9b05      	ldr	r3, [sp, #20]
 800db20:	1c5a      	adds	r2, r3, #1
 800db22:	9205      	str	r2, [sp, #20]
 800db24:	461a      	mov	r2, r3
 800db26:	9b02      	ldr	r3, [sp, #8]
 800db28:	4413      	add	r3, r2
 800db2a:	9a03      	ldr	r2, [sp, #12]
 800db2c:	b2d2      	uxtb	r2, r2
 800db2e:	701a      	strb	r2, [r3, #0]

    return i;
 800db30:	9b05      	ldr	r3, [sp, #20]
}
 800db32:	4618      	mov	r0, r3
 800db34:	b006      	add	sp, #24
 800db36:	4770      	bx	lr
	...

0800db40 <wc_DerToPem>:
#if defined(WOLFSSL_KEY_GEN) || defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA)

/* Used for compatibility API */
int wc_DerToPem(const byte* der, word32 derSz,
                byte* output, word32 outSz, int type)
{
 800db40:	b500      	push	{lr}
 800db42:	b087      	sub	sp, #28
 800db44:	9005      	str	r0, [sp, #20]
 800db46:	9104      	str	r1, [sp, #16]
 800db48:	9203      	str	r2, [sp, #12]
 800db4a:	9302      	str	r3, [sp, #8]
    return wc_DerToPemEx(der, derSz, output, outSz, NULL, type);
 800db4c:	9b08      	ldr	r3, [sp, #32]
 800db4e:	9301      	str	r3, [sp, #4]
 800db50:	2300      	movs	r3, #0
 800db52:	9300      	str	r3, [sp, #0]
 800db54:	9b02      	ldr	r3, [sp, #8]
 800db56:	9a03      	ldr	r2, [sp, #12]
 800db58:	9904      	ldr	r1, [sp, #16]
 800db5a:	9805      	ldr	r0, [sp, #20]
 800db5c:	f000 f808 	bl	800db70 <wc_DerToPemEx>
 800db60:	4603      	mov	r3, r0
}
 800db62:	4618      	mov	r0, r3
 800db64:	b007      	add	sp, #28
 800db66:	f85d fb04 	ldr.w	pc, [sp], #4
 800db6a:	bf00      	nop
 800db6c:	0000      	movs	r0, r0
	...

0800db70 <wc_DerToPemEx>:

/* convert der buffer to pem into output, can't do inplace, der and output
   need to be different */
int wc_DerToPemEx(const byte* der, word32 derSz, byte* output, word32 outSz,
             byte *cipher_info, int type)
{
 800db70:	b500      	push	{lr}
 800db72:	b08d      	sub	sp, #52	; 0x34
 800db74:	9003      	str	r0, [sp, #12]
 800db76:	9102      	str	r1, [sp, #8]
 800db78:	9201      	str	r2, [sp, #4]
 800db7a:	9300      	str	r3, [sp, #0]
#ifdef WOLFSSL_SMALL_STACK
    char* header = NULL;
 800db7c:	2300      	movs	r3, #0
 800db7e:	930a      	str	r3, [sp, #40]	; 0x28
    char* footer = NULL;
 800db80:	2300      	movs	r3, #0
 800db82:	9309      	str	r3, [sp, #36]	; 0x24
#else
    char header[40 + HEADER_ENCRYPTED_KEY_SIZE];
    char footer[40];
#endif

    int headerLen = 40 + HEADER_ENCRYPTED_KEY_SIZE;
 800db84:	2380      	movs	r3, #128	; 0x80
 800db86:	9308      	str	r3, [sp, #32]
    int footerLen = 40;
 800db88:	2328      	movs	r3, #40	; 0x28
 800db8a:	9307      	str	r3, [sp, #28]
    int i;
    int err;
    int outLen;   /* return length or error */

    if (der == output)      /* no in place conversion */
 800db8c:	9a03      	ldr	r2, [sp, #12]
 800db8e:	9b01      	ldr	r3, [sp, #4]
 800db90:	429a      	cmp	r2, r3
 800db92:	d102      	bne.n	800db9a <wc_DerToPemEx+0x2a>
        return BAD_FUNC_ARG;
 800db94:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800db98:	e1c7      	b.n	800df2a <wc_DerToPemEx+0x3ba>

#ifdef WOLFSSL_SMALL_STACK
    header = (char*)XMALLOC(headerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800db9a:	9908      	ldr	r1, [sp, #32]
 800db9c:	2000      	movs	r0, #0
 800db9e:	f7f7 fe5f 	bl	8005860 <chibios_alloc>
 800dba2:	900a      	str	r0, [sp, #40]	; 0x28
    if (header == NULL)
 800dba4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dba6:	2b00      	cmp	r3, #0
 800dba8:	d102      	bne.n	800dbb0 <wc_DerToPemEx+0x40>
        return MEMORY_E;
 800dbaa:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800dbae:	e1bc      	b.n	800df2a <wc_DerToPemEx+0x3ba>

    footer = (char*)XMALLOC(footerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dbb0:	9907      	ldr	r1, [sp, #28]
 800dbb2:	2000      	movs	r0, #0
 800dbb4:	f7f7 fe54 	bl	8005860 <chibios_alloc>
 800dbb8:	9009      	str	r0, [sp, #36]	; 0x24
    if (footer == NULL) {
 800dbba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dbbc:	2b00      	cmp	r3, #0
 800dbbe:	d105      	bne.n	800dbcc <wc_DerToPemEx+0x5c>
        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dbc0:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dbc2:	f7f7 fe5d 	bl	8005880 <chibios_free>
        return MEMORY_E;
 800dbc6:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800dbca:	e1ae      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }
#endif
    if (type == CERT_TYPE) {
 800dbcc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dbce:	2b00      	cmp	r3, #0
 800dbd0:	d124      	bne.n	800dc1c <wc_DerToPemEx+0xac>
        XSTRNCPY(header, BEGIN_CERT, headerLen);
 800dbd2:	4ba6      	ldr	r3, [pc, #664]	; (800de6c <wc_DerToPemEx+0x2fc>)
 800dbd4:	681b      	ldr	r3, [r3, #0]
 800dbd6:	9a08      	ldr	r2, [sp, #32]
 800dbd8:	4619      	mov	r1, r3
 800dbda:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dbdc:	f011 f9da 	bl	801ef94 <strncpy>
        XSTRNCAT(header, "\n", 1);
 800dbe0:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dbe2:	f7f6 fd2d 	bl	8004640 <strlen>
 800dbe6:	4602      	mov	r2, r0
 800dbe8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dbea:	4413      	add	r3, r2
 800dbec:	2202      	movs	r2, #2
 800dbee:	49a0      	ldr	r1, [pc, #640]	; (800de70 <wc_DerToPemEx+0x300>)
 800dbf0:	4618      	mov	r0, r3
 800dbf2:	f7f6 fd93 	bl	800471c <memcpy>

        XSTRNCPY(footer, END_CERT, footerLen);
 800dbf6:	4b9f      	ldr	r3, [pc, #636]	; (800de74 <wc_DerToPemEx+0x304>)
 800dbf8:	681b      	ldr	r3, [r3, #0]
 800dbfa:	9a07      	ldr	r2, [sp, #28]
 800dbfc:	4619      	mov	r1, r3
 800dbfe:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dc00:	f011 f9c8 	bl	801ef94 <strncpy>
        XSTRNCAT(footer, "\n", 1);
 800dc04:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dc06:	f7f6 fd1b 	bl	8004640 <strlen>
 800dc0a:	4602      	mov	r2, r0
 800dc0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dc0e:	4413      	add	r3, r2
 800dc10:	2202      	movs	r2, #2
 800dc12:	4997      	ldr	r1, [pc, #604]	; (800de70 <wc_DerToPemEx+0x300>)
 800dc14:	4618      	mov	r0, r3
 800dc16:	f7f6 fd81 	bl	800471c <memcpy>
 800dc1a:	e0a8      	b.n	800dd6e <wc_DerToPemEx+0x1fe>
    }
    else if (type == PRIVATEKEY_TYPE) {
 800dc1c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dc1e:	2b01      	cmp	r3, #1
 800dc20:	d124      	bne.n	800dc6c <wc_DerToPemEx+0xfc>
        XSTRNCPY(header, BEGIN_RSA_PRIV, headerLen);
 800dc22:	4b95      	ldr	r3, [pc, #596]	; (800de78 <wc_DerToPemEx+0x308>)
 800dc24:	681b      	ldr	r3, [r3, #0]
 800dc26:	9a08      	ldr	r2, [sp, #32]
 800dc28:	4619      	mov	r1, r3
 800dc2a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dc2c:	f011 f9b2 	bl	801ef94 <strncpy>
        XSTRNCAT(header, "\n", 1);
 800dc30:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dc32:	f7f6 fd05 	bl	8004640 <strlen>
 800dc36:	4602      	mov	r2, r0
 800dc38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dc3a:	4413      	add	r3, r2
 800dc3c:	2202      	movs	r2, #2
 800dc3e:	498c      	ldr	r1, [pc, #560]	; (800de70 <wc_DerToPemEx+0x300>)
 800dc40:	4618      	mov	r0, r3
 800dc42:	f7f6 fd6b 	bl	800471c <memcpy>

        XSTRNCPY(footer, END_RSA_PRIV, footerLen);
 800dc46:	4b8d      	ldr	r3, [pc, #564]	; (800de7c <wc_DerToPemEx+0x30c>)
 800dc48:	681b      	ldr	r3, [r3, #0]
 800dc4a:	9a07      	ldr	r2, [sp, #28]
 800dc4c:	4619      	mov	r1, r3
 800dc4e:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dc50:	f011 f9a0 	bl	801ef94 <strncpy>
        XSTRNCAT(footer, "\n", 1);
 800dc54:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dc56:	f7f6 fcf3 	bl	8004640 <strlen>
 800dc5a:	4602      	mov	r2, r0
 800dc5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dc5e:	4413      	add	r3, r2
 800dc60:	2202      	movs	r2, #2
 800dc62:	4983      	ldr	r1, [pc, #524]	; (800de70 <wc_DerToPemEx+0x300>)
 800dc64:	4618      	mov	r0, r3
 800dc66:	f7f6 fd59 	bl	800471c <memcpy>
 800dc6a:	e080      	b.n	800dd6e <wc_DerToPemEx+0x1fe>
    }
    else if(type == RSA_PUBLICKEY_TYPE){
 800dc6c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dc6e:	2b0d      	cmp	r3, #13
 800dc70:	d124      	bne.n	800dcbc <wc_DerToPemEx+0x14c>
        XSTRNCPY(header, BEGIN_RSA_PUB, headerLen);
 800dc72:	4b83      	ldr	r3, [pc, #524]	; (800de80 <wc_DerToPemEx+0x310>)
 800dc74:	681b      	ldr	r3, [r3, #0]
 800dc76:	9a08      	ldr	r2, [sp, #32]
 800dc78:	4619      	mov	r1, r3
 800dc7a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dc7c:	f011 f98a 	bl	801ef94 <strncpy>
        XSTRNCAT(header, "\n", 1);
 800dc80:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dc82:	f7f6 fcdd 	bl	8004640 <strlen>
 800dc86:	4602      	mov	r2, r0
 800dc88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dc8a:	4413      	add	r3, r2
 800dc8c:	2202      	movs	r2, #2
 800dc8e:	4978      	ldr	r1, [pc, #480]	; (800de70 <wc_DerToPemEx+0x300>)
 800dc90:	4618      	mov	r0, r3
 800dc92:	f7f6 fd43 	bl	800471c <memcpy>

        XSTRNCPY(footer, END_RSA_PUB, footerLen);
 800dc96:	4b7b      	ldr	r3, [pc, #492]	; (800de84 <wc_DerToPemEx+0x314>)
 800dc98:	681b      	ldr	r3, [r3, #0]
 800dc9a:	9a07      	ldr	r2, [sp, #28]
 800dc9c:	4619      	mov	r1, r3
 800dc9e:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dca0:	f011 f978 	bl	801ef94 <strncpy>
        XSTRNCAT(footer, "\n", 1);
 800dca4:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dca6:	f7f6 fccb 	bl	8004640 <strlen>
 800dcaa:	4602      	mov	r2, r0
 800dcac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dcae:	4413      	add	r3, r2
 800dcb0:	2202      	movs	r2, #2
 800dcb2:	496f      	ldr	r1, [pc, #444]	; (800de70 <wc_DerToPemEx+0x300>)
 800dcb4:	4618      	mov	r0, r3
 800dcb6:	f7f6 fd31 	bl	800471c <memcpy>
 800dcba:	e058      	b.n	800dd6e <wc_DerToPemEx+0x1fe>
    }
#ifndef NO_DSA
    else if (type == DSA_PRIVATEKEY_TYPE) {
 800dcbc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dcbe:	2b07      	cmp	r3, #7
 800dcc0:	d124      	bne.n	800dd0c <wc_DerToPemEx+0x19c>
        XSTRNCPY(header, BEGIN_DSA_PRIV, headerLen);
 800dcc2:	4b71      	ldr	r3, [pc, #452]	; (800de88 <wc_DerToPemEx+0x318>)
 800dcc4:	681b      	ldr	r3, [r3, #0]
 800dcc6:	9a08      	ldr	r2, [sp, #32]
 800dcc8:	4619      	mov	r1, r3
 800dcca:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dccc:	f011 f962 	bl	801ef94 <strncpy>
        XSTRNCAT(header, "\n", 1);
 800dcd0:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dcd2:	f7f6 fcb5 	bl	8004640 <strlen>
 800dcd6:	4602      	mov	r2, r0
 800dcd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dcda:	4413      	add	r3, r2
 800dcdc:	2202      	movs	r2, #2
 800dcde:	4964      	ldr	r1, [pc, #400]	; (800de70 <wc_DerToPemEx+0x300>)
 800dce0:	4618      	mov	r0, r3
 800dce2:	f7f6 fd1b 	bl	800471c <memcpy>

        XSTRNCPY(footer, END_DSA_PRIV, footerLen);
 800dce6:	4b69      	ldr	r3, [pc, #420]	; (800de8c <wc_DerToPemEx+0x31c>)
 800dce8:	681b      	ldr	r3, [r3, #0]
 800dcea:	9a07      	ldr	r2, [sp, #28]
 800dcec:	4619      	mov	r1, r3
 800dcee:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dcf0:	f011 f950 	bl	801ef94 <strncpy>
        XSTRNCAT(footer, "\n", 1);
 800dcf4:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dcf6:	f7f6 fca3 	bl	8004640 <strlen>
 800dcfa:	4602      	mov	r2, r0
 800dcfc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dcfe:	4413      	add	r3, r2
 800dd00:	2202      	movs	r2, #2
 800dd02:	495b      	ldr	r1, [pc, #364]	; (800de70 <wc_DerToPemEx+0x300>)
 800dd04:	4618      	mov	r0, r3
 800dd06:	f7f6 fd09 	bl	800471c <memcpy>
 800dd0a:	e030      	b.n	800dd6e <wc_DerToPemEx+0x1fe>
    }
#endif
#ifdef HAVE_ECC
    else if (type == ECC_PRIVATEKEY_TYPE) {
 800dd0c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dd0e:	2b06      	cmp	r3, #6
 800dd10:	d124      	bne.n	800dd5c <wc_DerToPemEx+0x1ec>
        XSTRNCPY(header, BEGIN_EC_PRIV, headerLen);
 800dd12:	4b5f      	ldr	r3, [pc, #380]	; (800de90 <wc_DerToPemEx+0x320>)
 800dd14:	681b      	ldr	r3, [r3, #0]
 800dd16:	9a08      	ldr	r2, [sp, #32]
 800dd18:	4619      	mov	r1, r3
 800dd1a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dd1c:	f011 f93a 	bl	801ef94 <strncpy>
        XSTRNCAT(header, "\n", 1);
 800dd20:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dd22:	f7f6 fc8d 	bl	8004640 <strlen>
 800dd26:	4602      	mov	r2, r0
 800dd28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dd2a:	4413      	add	r3, r2
 800dd2c:	2202      	movs	r2, #2
 800dd2e:	4950      	ldr	r1, [pc, #320]	; (800de70 <wc_DerToPemEx+0x300>)
 800dd30:	4618      	mov	r0, r3
 800dd32:	f7f6 fcf3 	bl	800471c <memcpy>

        XSTRNCPY(footer, END_EC_PRIV, footerLen);
 800dd36:	4b57      	ldr	r3, [pc, #348]	; (800de94 <wc_DerToPemEx+0x324>)
 800dd38:	681b      	ldr	r3, [r3, #0]
 800dd3a:	9a07      	ldr	r2, [sp, #28]
 800dd3c:	4619      	mov	r1, r3
 800dd3e:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dd40:	f011 f928 	bl	801ef94 <strncpy>
        XSTRNCAT(footer, "\n", 1);
 800dd44:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dd46:	f7f6 fc7b 	bl	8004640 <strlen>
 800dd4a:	4602      	mov	r2, r0
 800dd4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dd4e:	4413      	add	r3, r2
 800dd50:	2202      	movs	r2, #2
 800dd52:	4947      	ldr	r1, [pc, #284]	; (800de70 <wc_DerToPemEx+0x300>)
 800dd54:	4618      	mov	r0, r3
 800dd56:	f7f6 fce1 	bl	800471c <memcpy>
 800dd5a:	e008      	b.n	800dd6e <wc_DerToPemEx+0x1fe>
        XSTRNCAT(footer, "\n", 1);
    }
#endif
    else {
#ifdef WOLFSSL_SMALL_STACK
        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dd5c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dd5e:	f7f7 fd8f 	bl	8005880 <chibios_free>
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dd62:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dd64:	f7f7 fd8c 	bl	8005880 <chibios_free>
#endif
        return BAD_FUNC_ARG;
 800dd68:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800dd6c:	e0dd      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }

    /* extra header information for encrypted key */
    if (cipher_info != NULL) {
 800dd6e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800dd70:	2b00      	cmp	r3, #0
 800dd72:	d02e      	beq.n	800ddd2 <wc_DerToPemEx+0x262>
        size_t cipherInfoStrLen = XSTRLEN((char*)cipher_info);
 800dd74:	980e      	ldr	r0, [sp, #56]	; 0x38
 800dd76:	f7f6 fc63 	bl	8004640 <strlen>
 800dd7a:	900b      	str	r0, [sp, #44]	; 0x2c
        if (cipherInfoStrLen > HEADER_ENCRYPTED_KEY_SIZE - (23+10+2))
 800dd7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800dd7e:	2b35      	cmp	r3, #53	; 0x35
 800dd80:	d901      	bls.n	800dd86 <wc_DerToPemEx+0x216>
            cipherInfoStrLen = HEADER_ENCRYPTED_KEY_SIZE - (23+10+2);
 800dd82:	2335      	movs	r3, #53	; 0x35
 800dd84:	930b      	str	r3, [sp, #44]	; 0x2c

        XSTRNCAT(header, "Proc-Type: 4,ENCRYPTED\n", 23);
 800dd86:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dd88:	f7f6 fc5a 	bl	8004640 <strlen>
 800dd8c:	4602      	mov	r2, r0
 800dd8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dd90:	4413      	add	r3, r2
 800dd92:	2218      	movs	r2, #24
 800dd94:	4940      	ldr	r1, [pc, #256]	; (800de98 <wc_DerToPemEx+0x328>)
 800dd96:	4618      	mov	r0, r3
 800dd98:	f7f6 fcc0 	bl	800471c <memcpy>
        XSTRNCAT(header, "DEK-Info: ", 10);
 800dd9c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800dd9e:	f7f6 fc4f 	bl	8004640 <strlen>
 800dda2:	4602      	mov	r2, r0
 800dda4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dda6:	4413      	add	r3, r2
 800dda8:	220b      	movs	r2, #11
 800ddaa:	493c      	ldr	r1, [pc, #240]	; (800de9c <wc_DerToPemEx+0x32c>)
 800ddac:	4618      	mov	r0, r3
 800ddae:	f7f6 fcb5 	bl	800471c <memcpy>
        XSTRNCAT(header, (char*)cipher_info, cipherInfoStrLen);
 800ddb2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ddb4:	990e      	ldr	r1, [sp, #56]	; 0x38
 800ddb6:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ddb8:	f011 f8be 	bl	801ef38 <strncat>
        XSTRNCAT(header, "\n\n", 2);
 800ddbc:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ddbe:	f7f6 fc3f 	bl	8004640 <strlen>
 800ddc2:	4602      	mov	r2, r0
 800ddc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ddc6:	4413      	add	r3, r2
 800ddc8:	2203      	movs	r2, #3
 800ddca:	4935      	ldr	r1, [pc, #212]	; (800dea0 <wc_DerToPemEx+0x330>)
 800ddcc:	4618      	mov	r0, r3
 800ddce:	f7f6 fca5 	bl	800471c <memcpy>
    }

    headerLen = (int)XSTRLEN(header);
 800ddd2:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ddd4:	f7f6 fc34 	bl	8004640 <strlen>
 800ddd8:	4603      	mov	r3, r0
 800ddda:	9308      	str	r3, [sp, #32]
    footerLen = (int)XSTRLEN(footer);
 800dddc:	9809      	ldr	r0, [sp, #36]	; 0x24
 800ddde:	f7f6 fc2f 	bl	8004640 <strlen>
 800dde2:	4603      	mov	r3, r0
 800dde4:	9307      	str	r3, [sp, #28]

    /* if null output and 0 size passed in then return size needed */
    if (!output && outSz == 0) {
 800dde6:	9b01      	ldr	r3, [sp, #4]
 800dde8:	2b00      	cmp	r3, #0
 800ddea:	d11d      	bne.n	800de28 <wc_DerToPemEx+0x2b8>
 800ddec:	9b00      	ldr	r3, [sp, #0]
 800ddee:	2b00      	cmp	r3, #0
 800ddf0:	d11a      	bne.n	800de28 <wc_DerToPemEx+0x2b8>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800ddf2:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ddf4:	f7f7 fd44 	bl	8005880 <chibios_free>
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800ddf8:	9809      	ldr	r0, [sp, #36]	; 0x24
 800ddfa:	f7f7 fd41 	bl	8005880 <chibios_free>
#endif
        outLen = 0;
 800ddfe:	2300      	movs	r3, #0
 800de00:	9304      	str	r3, [sp, #16]
        if ((err = Base64_Encode(der, derSz, NULL, (word32*)&outLen))
 800de02:	ab04      	add	r3, sp, #16
 800de04:	2200      	movs	r2, #0
 800de06:	9902      	ldr	r1, [sp, #8]
 800de08:	9803      	ldr	r0, [sp, #12]
 800de0a:	f7fe fc81 	bl	800c710 <Base64_Encode>
 800de0e:	9006      	str	r0, [sp, #24]
 800de10:	9b06      	ldr	r3, [sp, #24]
 800de12:	f113 0fca 	cmn.w	r3, #202	; 0xca
 800de16:	d001      	beq.n	800de1c <wc_DerToPemEx+0x2ac>
                != LENGTH_ONLY_E) {
            return err;
 800de18:	9b06      	ldr	r3, [sp, #24]
 800de1a:	e086      	b.n	800df2a <wc_DerToPemEx+0x3ba>
        }
        return headerLen + footerLen + outLen;
 800de1c:	9a08      	ldr	r2, [sp, #32]
 800de1e:	9b07      	ldr	r3, [sp, #28]
 800de20:	441a      	add	r2, r3
 800de22:	9b04      	ldr	r3, [sp, #16]
 800de24:	4413      	add	r3, r2
 800de26:	e080      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }

    if (!der || !output) {
 800de28:	9b03      	ldr	r3, [sp, #12]
 800de2a:	2b00      	cmp	r3, #0
 800de2c:	d002      	beq.n	800de34 <wc_DerToPemEx+0x2c4>
 800de2e:	9b01      	ldr	r3, [sp, #4]
 800de30:	2b00      	cmp	r3, #0
 800de32:	d108      	bne.n	800de46 <wc_DerToPemEx+0x2d6>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800de34:	980a      	ldr	r0, [sp, #40]	; 0x28
 800de36:	f7f7 fd23 	bl	8005880 <chibios_free>
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800de3a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800de3c:	f7f7 fd20 	bl	8005880 <chibios_free>
#endif
        return BAD_FUNC_ARG;
 800de40:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800de44:	e071      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }

    /* don't even try if outSz too short */
    if (outSz < headerLen + footerLen + derSz) {
 800de46:	9a08      	ldr	r2, [sp, #32]
 800de48:	9b07      	ldr	r3, [sp, #28]
 800de4a:	4413      	add	r3, r2
 800de4c:	461a      	mov	r2, r3
 800de4e:	9b02      	ldr	r3, [sp, #8]
 800de50:	441a      	add	r2, r3
 800de52:	9b00      	ldr	r3, [sp, #0]
 800de54:	429a      	cmp	r2, r3
 800de56:	d925      	bls.n	800dea4 <wc_DerToPemEx+0x334>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800de58:	980a      	ldr	r0, [sp, #40]	; 0x28
 800de5a:	f7f7 fd11 	bl	8005880 <chibios_free>
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800de5e:	9809      	ldr	r0, [sp, #36]	; 0x24
 800de60:	f7f7 fd0e 	bl	8005880 <chibios_free>
#endif
        return BAD_FUNC_ARG;
 800de64:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800de68:	e05f      	b.n	800df2a <wc_DerToPemEx+0x3ba>
 800de6a:	bf00      	nop
 800de6c:	20004400 	.word	0x20004400
 800de70:	08024c5c 	.word	0x08024c5c
 800de74:	20004404 	.word	0x20004404
 800de78:	20004428 	.word	0x20004428
 800de7c:	2000442c 	.word	0x2000442c
 800de80:	20004430 	.word	0x20004430
 800de84:	20004434 	.word	0x20004434
 800de88:	20004450 	.word	0x20004450
 800de8c:	20004454 	.word	0x20004454
 800de90:	20004448 	.word	0x20004448
 800de94:	2000444c 	.word	0x2000444c
 800de98:	08024c60 	.word	0x08024c60
 800de9c:	08024c78 	.word	0x08024c78
 800dea0:	08024c84 	.word	0x08024c84
    }

    /* header */
    XMEMCPY(output, header, headerLen);
 800dea4:	9b08      	ldr	r3, [sp, #32]
 800dea6:	461a      	mov	r2, r3
 800dea8:	990a      	ldr	r1, [sp, #40]	; 0x28
 800deaa:	9801      	ldr	r0, [sp, #4]
 800deac:	f7f6 fc36 	bl	800471c <memcpy>
    i = headerLen;
 800deb0:	9b08      	ldr	r3, [sp, #32]
 800deb2:	9305      	str	r3, [sp, #20]

#ifdef WOLFSSL_SMALL_STACK
    XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800deb4:	980a      	ldr	r0, [sp, #40]	; 0x28
 800deb6:	f7f7 fce3 	bl	8005880 <chibios_free>
#endif

    /* body */
    outLen = outSz - (headerLen + footerLen);  /* input to Base64_Encode */
 800deba:	9a08      	ldr	r2, [sp, #32]
 800debc:	9b07      	ldr	r3, [sp, #28]
 800debe:	4413      	add	r3, r2
 800dec0:	461a      	mov	r2, r3
 800dec2:	9b00      	ldr	r3, [sp, #0]
 800dec4:	1a9b      	subs	r3, r3, r2
 800dec6:	9304      	str	r3, [sp, #16]
    if ( (err = Base64_Encode(der, derSz, output + i, (word32*)&outLen)) < 0) {
 800dec8:	9b05      	ldr	r3, [sp, #20]
 800deca:	9a01      	ldr	r2, [sp, #4]
 800decc:	441a      	add	r2, r3
 800dece:	ab04      	add	r3, sp, #16
 800ded0:	9902      	ldr	r1, [sp, #8]
 800ded2:	9803      	ldr	r0, [sp, #12]
 800ded4:	f7fe fc1c 	bl	800c710 <Base64_Encode>
 800ded8:	9006      	str	r0, [sp, #24]
 800deda:	9b06      	ldr	r3, [sp, #24]
 800dedc:	2b00      	cmp	r3, #0
 800dede:	da04      	bge.n	800deea <wc_DerToPemEx+0x37a>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dee0:	9809      	ldr	r0, [sp, #36]	; 0x24
 800dee2:	f7f7 fccd 	bl	8005880 <chibios_free>
#endif
        return err;
 800dee6:	9b06      	ldr	r3, [sp, #24]
 800dee8:	e01f      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }
    i += outLen;
 800deea:	9b04      	ldr	r3, [sp, #16]
 800deec:	9a05      	ldr	r2, [sp, #20]
 800deee:	4413      	add	r3, r2
 800def0:	9305      	str	r3, [sp, #20]

    /* footer */
    if ( (i + footerLen) > (int)outSz) {
 800def2:	9a05      	ldr	r2, [sp, #20]
 800def4:	9b07      	ldr	r3, [sp, #28]
 800def6:	441a      	add	r2, r3
 800def8:	9b00      	ldr	r3, [sp, #0]
 800defa:	429a      	cmp	r2, r3
 800defc:	dd05      	ble.n	800df0a <wc_DerToPemEx+0x39a>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800defe:	9809      	ldr	r0, [sp, #36]	; 0x24
 800df00:	f7f7 fcbe 	bl	8005880 <chibios_free>
#endif
        return BAD_FUNC_ARG;
 800df04:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800df08:	e00f      	b.n	800df2a <wc_DerToPemEx+0x3ba>
    }
    XMEMCPY(output + i, footer, footerLen);
 800df0a:	9b05      	ldr	r3, [sp, #20]
 800df0c:	9a01      	ldr	r2, [sp, #4]
 800df0e:	4413      	add	r3, r2
 800df10:	9a07      	ldr	r2, [sp, #28]
 800df12:	9909      	ldr	r1, [sp, #36]	; 0x24
 800df14:	4618      	mov	r0, r3
 800df16:	f7f6 fc01 	bl	800471c <memcpy>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800df1a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800df1c:	f7f7 fcb0 	bl	8005880 <chibios_free>
#endif

    return outLen + headerLen + footerLen;
 800df20:	9a04      	ldr	r2, [sp, #16]
 800df22:	9b08      	ldr	r3, [sp, #32]
 800df24:	441a      	add	r2, r3
 800df26:	9b07      	ldr	r3, [sp, #28]
 800df28:	4413      	add	r3, r2
}
 800df2a:	4618      	mov	r0, r3
 800df2c:	b00d      	add	sp, #52	; 0x34
 800df2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800df32:	bf00      	nop
	...

0800df40 <SetRsaPublicKey>:
/* USER RSA ifdef portions used instead of refactor in consideration for
   possible fips build */
/* Write a public RSA key to output */
static int SetRsaPublicKey(byte* output, RsaKey* key,
                           int outLen, int with_header)
{
 800df40:	b500      	push	{lr}
 800df42:	b093      	sub	sp, #76	; 0x4c
 800df44:	9003      	str	r0, [sp, #12]
 800df46:	9102      	str	r1, [sp, #8]
 800df48:	9201      	str	r2, [sp, #4]
 800df4a:	9300      	str	r3, [sp, #0]
#ifdef WOLFSSL_SMALL_STACK
    byte* n = NULL;
 800df4c:	2300      	movs	r3, #0
 800df4e:	9310      	str	r3, [sp, #64]	; 0x40
    byte* e = NULL;
 800df50:	2300      	movs	r3, #0
 800df52:	930f      	str	r3, [sp, #60]	; 0x3c
    int  eSz;
    int  seqSz;
    int  bitStringSz;
    int  idx;

    if (output == NULL || key == NULL || outLen < MAX_SEQ_SZ)
 800df54:	9b03      	ldr	r3, [sp, #12]
 800df56:	2b00      	cmp	r3, #0
 800df58:	d005      	beq.n	800df66 <SetRsaPublicKey+0x26>
 800df5a:	9b02      	ldr	r3, [sp, #8]
 800df5c:	2b00      	cmp	r3, #0
 800df5e:	d002      	beq.n	800df66 <SetRsaPublicKey+0x26>
 800df60:	9b01      	ldr	r3, [sp, #4]
 800df62:	2b04      	cmp	r3, #4
 800df64:	dc02      	bgt.n	800df6c <SetRsaPublicKey+0x2c>
        return BAD_FUNC_ARG;
 800df66:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800df6a:	e0f7      	b.n	800e15c <SetRsaPublicKey+0x21c>

    /* n */
#ifdef WOLFSSL_SMALL_STACK
    n = (byte*)XMALLOC(MAX_RSA_INT_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800df6c:	f240 2105 	movw	r1, #517	; 0x205
 800df70:	2000      	movs	r0, #0
 800df72:	f7f7 fc75 	bl	8005860 <chibios_alloc>
 800df76:	9010      	str	r0, [sp, #64]	; 0x40
    if (n == NULL)
 800df78:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800df7a:	2b00      	cmp	r3, #0
 800df7c:	d102      	bne.n	800df84 <SetRsaPublicKey+0x44>
        return MEMORY_E;
 800df7e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800df82:	e0eb      	b.n	800e15c <SetRsaPublicKey+0x21c>
#endif

#ifdef HAVE_USER_RSA
    nSz = SetASNIntRSA(key->n, n);
#else
    nSz = SetASNIntMP(&key->n, MAX_RSA_INT_SZ, n);
 800df84:	9b02      	ldr	r3, [sp, #8]
 800df86:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800df88:	f240 2105 	movw	r1, #517	; 0x205
 800df8c:	4618      	mov	r0, r3
 800df8e:	f001 f807 	bl	800efa0 <SetASNIntMP.lto_priv.384>
 800df92:	900e      	str	r0, [sp, #56]	; 0x38
#endif
    if (nSz < 0) {
 800df94:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800df96:	2b00      	cmp	r3, #0
 800df98:	da04      	bge.n	800dfa4 <SetRsaPublicKey+0x64>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(n, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800df9a:	9810      	ldr	r0, [sp, #64]	; 0x40
 800df9c:	f7f7 fc70 	bl	8005880 <chibios_free>
#endif
        return nSz;
 800dfa0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800dfa2:	e0db      	b.n	800e15c <SetRsaPublicKey+0x21c>
    }

    /* e */
#ifdef WOLFSSL_SMALL_STACK
    e = (byte*)XMALLOC(MAX_RSA_E_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dfa4:	2110      	movs	r1, #16
 800dfa6:	2000      	movs	r0, #0
 800dfa8:	f7f7 fc5a 	bl	8005860 <chibios_alloc>
 800dfac:	900f      	str	r0, [sp, #60]	; 0x3c
    if (e == NULL) {
 800dfae:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dfb0:	2b00      	cmp	r3, #0
 800dfb2:	d105      	bne.n	800dfc0 <SetRsaPublicKey+0x80>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(n, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dfb4:	9810      	ldr	r0, [sp, #64]	; 0x40
 800dfb6:	f7f7 fc63 	bl	8005880 <chibios_free>
#endif
        return MEMORY_E;
 800dfba:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800dfbe:	e0cd      	b.n	800e15c <SetRsaPublicKey+0x21c>
#endif

#ifdef HAVE_USER_RSA
    eSz = SetASNIntRSA(key->e, e);
#else
    eSz = SetASNIntMP(&key->e, MAX_RSA_INT_SZ, e);
 800dfc0:	9b02      	ldr	r3, [sp, #8]
 800dfc2:	3310      	adds	r3, #16
 800dfc4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800dfc6:	f240 2105 	movw	r1, #517	; 0x205
 800dfca:	4618      	mov	r0, r3
 800dfcc:	f000 ffe8 	bl	800efa0 <SetASNIntMP.lto_priv.384>
 800dfd0:	900d      	str	r0, [sp, #52]	; 0x34
#endif
    if (eSz < 0) {
 800dfd2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dfd4:	2b00      	cmp	r3, #0
 800dfd6:	da07      	bge.n	800dfe8 <SetRsaPublicKey+0xa8>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(n, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dfd8:	9810      	ldr	r0, [sp, #64]	; 0x40
 800dfda:	f7f7 fc51 	bl	8005880 <chibios_free>
        XFREE(e, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800dfde:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800dfe0:	f7f7 fc4e 	bl	8005880 <chibios_free>
#endif
        return eSz;
 800dfe4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dfe6:	e0b9      	b.n	800e15c <SetRsaPublicKey+0x21c>
    }

    seqSz  = SetSequence(nSz + eSz, seq);
 800dfe8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800dfea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dfec:	4413      	add	r3, r2
 800dfee:	461a      	mov	r2, r3
 800dff0:	ab07      	add	r3, sp, #28
 800dff2:	4619      	mov	r1, r3
 800dff4:	4610      	mov	r0, r2
 800dff6:	f000 fa6b 	bl	800e4d0 <SetSequence>
 800dffa:	4603      	mov	r3, r0
 800dffc:	930c      	str	r3, [sp, #48]	; 0x30

    /* check output size */
    if ( (seqSz + nSz + eSz) > outLen) {
 800dffe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e000:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e002:	441a      	add	r2, r3
 800e004:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e006:	441a      	add	r2, r3
 800e008:	9b01      	ldr	r3, [sp, #4]
 800e00a:	429a      	cmp	r2, r3
 800e00c:	dd08      	ble.n	800e020 <SetRsaPublicKey+0xe0>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(n,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e00e:	9810      	ldr	r0, [sp, #64]	; 0x40
 800e010:	f7f7 fc36 	bl	8005880 <chibios_free>
        XFREE(e,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e014:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800e016:	f7f7 fc33 	bl	8005880 <chibios_free>
#endif
        return BUFFER_E;
 800e01a:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800e01e:	e09d      	b.n	800e15c <SetRsaPublicKey+0x21c>
    }

    /* headers */
    if (with_header) {
 800e020:	9b00      	ldr	r3, [sp, #0]
 800e022:	2b00      	cmp	r3, #0
 800e024:	d06d      	beq.n	800e102 <SetRsaPublicKey+0x1c2>
        int  algoSz;
#ifdef WOLFSSL_SMALL_STACK
        byte* algo = NULL;
 800e026:	2300      	movs	r3, #0
 800e028:	930b      	str	r3, [sp, #44]	; 0x2c

        algo = (byte*)XMALLOC(MAX_ALGO_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e02a:	2114      	movs	r1, #20
 800e02c:	2000      	movs	r0, #0
 800e02e:	f7f7 fc17 	bl	8005860 <chibios_alloc>
 800e032:	900b      	str	r0, [sp, #44]	; 0x2c
        if (algo == NULL) {
 800e034:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e036:	2b00      	cmp	r3, #0
 800e038:	d108      	bne.n	800e04c <SetRsaPublicKey+0x10c>
            XFREE(n, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e03a:	9810      	ldr	r0, [sp, #64]	; 0x40
 800e03c:	f7f7 fc20 	bl	8005880 <chibios_free>
            XFREE(e, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e040:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800e042:	f7f7 fc1d 	bl	8005880 <chibios_free>
            return MEMORY_E;
 800e046:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e04a:	e087      	b.n	800e15c <SetRsaPublicKey+0x21c>
        }
#else
        byte algo[MAX_ALGO_SZ];
#endif
        algoSz = SetAlgoID(RSAk, algo, oidKeyType, 0);
 800e04c:	2300      	movs	r3, #0
 800e04e:	2202      	movs	r2, #2
 800e050:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800e052:	f240 2085 	movw	r0, #645	; 0x285
 800e056:	f000 fa73 	bl	800e540 <SetAlgoID>
 800e05a:	4603      	mov	r3, r0
 800e05c:	930a      	str	r3, [sp, #40]	; 0x28
        bitStringSz  = SetBitString(seqSz + nSz + eSz, 0, bitString);
 800e05e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e060:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e062:	441a      	add	r2, r3
 800e064:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e066:	4413      	add	r3, r2
 800e068:	4618      	mov	r0, r3
 800e06a:	ab05      	add	r3, sp, #20
 800e06c:	461a      	mov	r2, r3
 800e06e:	2100      	movs	r1, #0
 800e070:	f001 f8ce 	bl	800f210 <SetBitString.lto_priv.378>
 800e074:	4603      	mov	r3, r0
 800e076:	9309      	str	r3, [sp, #36]	; 0x24

        idx = SetSequence(nSz + eSz + seqSz + bitStringSz + algoSz, output);
 800e078:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e07a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e07c:	441a      	add	r2, r3
 800e07e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e080:	441a      	add	r2, r3
 800e082:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e084:	441a      	add	r2, r3
 800e086:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e088:	4413      	add	r3, r2
 800e08a:	9903      	ldr	r1, [sp, #12]
 800e08c:	4618      	mov	r0, r3
 800e08e:	f000 fa1f 	bl	800e4d0 <SetSequence>
 800e092:	4603      	mov	r3, r0
 800e094:	9311      	str	r3, [sp, #68]	; 0x44

        /* check output size */
        if ( (idx + algoSz + bitStringSz + seqSz + nSz + eSz) > outLen) {
 800e096:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e098:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e09a:	441a      	add	r2, r3
 800e09c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e09e:	441a      	add	r2, r3
 800e0a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e0a2:	441a      	add	r2, r3
 800e0a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e0a6:	441a      	add	r2, r3
 800e0a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e0aa:	441a      	add	r2, r3
 800e0ac:	9b01      	ldr	r3, [sp, #4]
 800e0ae:	429a      	cmp	r2, r3
 800e0b0:	dd0b      	ble.n	800e0ca <SetRsaPublicKey+0x18a>
            #ifdef WOLFSSL_SMALL_STACK
                XFREE(n,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e0b2:	9810      	ldr	r0, [sp, #64]	; 0x40
 800e0b4:	f7f7 fbe4 	bl	8005880 <chibios_free>
                XFREE(e,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e0b8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800e0ba:	f7f7 fbe1 	bl	8005880 <chibios_free>
                XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e0be:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800e0c0:	f7f7 fbde 	bl	8005880 <chibios_free>
            #endif

            return BUFFER_E;
 800e0c4:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800e0c8:	e048      	b.n	800e15c <SetRsaPublicKey+0x21c>
        }

        /* algo */
        XMEMCPY(output + idx, algo, algoSz);
 800e0ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e0cc:	9a03      	ldr	r2, [sp, #12]
 800e0ce:	4413      	add	r3, r2
 800e0d0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e0d2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800e0d4:	4618      	mov	r0, r3
 800e0d6:	f7f6 fb21 	bl	800471c <memcpy>
        idx += algoSz;
 800e0da:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e0dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e0de:	4413      	add	r3, r2
 800e0e0:	9311      	str	r3, [sp, #68]	; 0x44
        /* bit string */
        XMEMCPY(output + idx, bitString, bitStringSz);
 800e0e2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e0e4:	9a03      	ldr	r2, [sp, #12]
 800e0e6:	4413      	add	r3, r2
 800e0e8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e0ea:	a905      	add	r1, sp, #20
 800e0ec:	4618      	mov	r0, r3
 800e0ee:	f7f6 fb15 	bl	800471c <memcpy>
        idx += bitStringSz;
 800e0f2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e0f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e0f6:	4413      	add	r3, r2
 800e0f8:	9311      	str	r3, [sp, #68]	; 0x44
#ifdef WOLFSSL_SMALL_STACK
        XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e0fa:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800e0fc:	f7f7 fbc0 	bl	8005880 <chibios_free>
 800e100:	e001      	b.n	800e106 <SetRsaPublicKey+0x1c6>
#endif
    }
    else
        idx = 0;
 800e102:	2300      	movs	r3, #0
 800e104:	9311      	str	r3, [sp, #68]	; 0x44

    /* seq */
    XMEMCPY(output + idx, seq, seqSz);
 800e106:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e108:	9a03      	ldr	r2, [sp, #12]
 800e10a:	4413      	add	r3, r2
 800e10c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e10e:	a907      	add	r1, sp, #28
 800e110:	4618      	mov	r0, r3
 800e112:	f7f6 fb03 	bl	800471c <memcpy>
    idx += seqSz;
 800e116:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e118:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e11a:	4413      	add	r3, r2
 800e11c:	9311      	str	r3, [sp, #68]	; 0x44
    /* n */
    XMEMCPY(output + idx, n, nSz);
 800e11e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e120:	9a03      	ldr	r2, [sp, #12]
 800e122:	4413      	add	r3, r2
 800e124:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e126:	9910      	ldr	r1, [sp, #64]	; 0x40
 800e128:	4618      	mov	r0, r3
 800e12a:	f7f6 faf7 	bl	800471c <memcpy>
    idx += nSz;
 800e12e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e130:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e132:	4413      	add	r3, r2
 800e134:	9311      	str	r3, [sp, #68]	; 0x44
    /* e */
    XMEMCPY(output + idx, e, eSz);
 800e136:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e138:	9a03      	ldr	r2, [sp, #12]
 800e13a:	4413      	add	r3, r2
 800e13c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800e13e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800e140:	4618      	mov	r0, r3
 800e142:	f7f6 faeb 	bl	800471c <memcpy>
    idx += eSz;
 800e146:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e148:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e14a:	4413      	add	r3, r2
 800e14c:	9311      	str	r3, [sp, #68]	; 0x44

#ifdef WOLFSSL_SMALL_STACK
    XFREE(n,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e14e:	9810      	ldr	r0, [sp, #64]	; 0x40
 800e150:	f7f7 fb96 	bl	8005880 <chibios_free>
    XFREE(e,    NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800e154:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800e156:	f7f7 fb93 	bl	8005880 <chibios_free>
#endif

    return idx;
 800e15a:	9b11      	ldr	r3, [sp, #68]	; 0x44
}
 800e15c:	4618      	mov	r0, r3
 800e15e:	b013      	add	sp, #76	; 0x4c
 800e160:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800e170 <GetRsaInt>:

#if defined(WOLFSSL_KEY_GEN) && !defined(NO_RSA) && !defined(HAVE_USER_RSA)


static mp_int* GetRsaInt(RsaKey* key, int idx)
{
 800e170:	b082      	sub	sp, #8
 800e172:	9001      	str	r0, [sp, #4]
 800e174:	9100      	str	r1, [sp, #0]
    if (idx == 0)
 800e176:	9b00      	ldr	r3, [sp, #0]
 800e178:	2b00      	cmp	r3, #0
 800e17a:	d101      	bne.n	800e180 <GetRsaInt+0x10>
        return &key->n;
 800e17c:	9b01      	ldr	r3, [sp, #4]
 800e17e:	e02a      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 1)
 800e180:	9b00      	ldr	r3, [sp, #0]
 800e182:	2b01      	cmp	r3, #1
 800e184:	d102      	bne.n	800e18c <GetRsaInt+0x1c>
        return &key->e;
 800e186:	9b01      	ldr	r3, [sp, #4]
 800e188:	3310      	adds	r3, #16
 800e18a:	e024      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 2)
 800e18c:	9b00      	ldr	r3, [sp, #0]
 800e18e:	2b02      	cmp	r3, #2
 800e190:	d102      	bne.n	800e198 <GetRsaInt+0x28>
        return &key->d;
 800e192:	9b01      	ldr	r3, [sp, #4]
 800e194:	3320      	adds	r3, #32
 800e196:	e01e      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 3)
 800e198:	9b00      	ldr	r3, [sp, #0]
 800e19a:	2b03      	cmp	r3, #3
 800e19c:	d102      	bne.n	800e1a4 <GetRsaInt+0x34>
        return &key->p;
 800e19e:	9b01      	ldr	r3, [sp, #4]
 800e1a0:	3330      	adds	r3, #48	; 0x30
 800e1a2:	e018      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 4)
 800e1a4:	9b00      	ldr	r3, [sp, #0]
 800e1a6:	2b04      	cmp	r3, #4
 800e1a8:	d102      	bne.n	800e1b0 <GetRsaInt+0x40>
        return &key->q;
 800e1aa:	9b01      	ldr	r3, [sp, #4]
 800e1ac:	3340      	adds	r3, #64	; 0x40
 800e1ae:	e012      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 5)
 800e1b0:	9b00      	ldr	r3, [sp, #0]
 800e1b2:	2b05      	cmp	r3, #5
 800e1b4:	d102      	bne.n	800e1bc <GetRsaInt+0x4c>
        return &key->dP;
 800e1b6:	9b01      	ldr	r3, [sp, #4]
 800e1b8:	3350      	adds	r3, #80	; 0x50
 800e1ba:	e00c      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 6)
 800e1bc:	9b00      	ldr	r3, [sp, #0]
 800e1be:	2b06      	cmp	r3, #6
 800e1c0:	d102      	bne.n	800e1c8 <GetRsaInt+0x58>
        return &key->dQ;
 800e1c2:	9b01      	ldr	r3, [sp, #4]
 800e1c4:	3360      	adds	r3, #96	; 0x60
 800e1c6:	e006      	b.n	800e1d6 <GetRsaInt+0x66>
    if (idx == 7)
 800e1c8:	9b00      	ldr	r3, [sp, #0]
 800e1ca:	2b07      	cmp	r3, #7
 800e1cc:	d102      	bne.n	800e1d4 <GetRsaInt+0x64>
        return &key->u;
 800e1ce:	9b01      	ldr	r3, [sp, #4]
 800e1d0:	3370      	adds	r3, #112	; 0x70
 800e1d2:	e000      	b.n	800e1d6 <GetRsaInt+0x66>

    return NULL;
 800e1d4:	2300      	movs	r3, #0
}
 800e1d6:	4618      	mov	r0, r3
 800e1d8:	b002      	add	sp, #8
 800e1da:	4770      	bx	lr
 800e1dc:	0000      	movs	r0, r0
	...

0800e1e0 <FreeTmpRsas>:


/* Release Tmp RSA resources */
static INLINE void FreeTmpRsas(byte** tmps, void* heap)
{
 800e1e0:	b500      	push	{lr}
 800e1e2:	b085      	sub	sp, #20
 800e1e4:	9001      	str	r0, [sp, #4]
 800e1e6:	9100      	str	r1, [sp, #0]
    int i;

    (void)heap;

    for (i = 0; i < RSA_INTS; i++)
 800e1e8:	2300      	movs	r3, #0
 800e1ea:	9303      	str	r3, [sp, #12]
 800e1ec:	e00a      	b.n	800e204 <FreeTmpRsas+0x24>
        XFREE(tmps[i], heap, DYNAMIC_TYPE_RSA);
 800e1ee:	9b03      	ldr	r3, [sp, #12]
 800e1f0:	009b      	lsls	r3, r3, #2
 800e1f2:	9a01      	ldr	r2, [sp, #4]
 800e1f4:	4413      	add	r3, r2
 800e1f6:	681b      	ldr	r3, [r3, #0]
 800e1f8:	4618      	mov	r0, r3
 800e1fa:	f7f7 fb41 	bl	8005880 <chibios_free>
    for (i = 0; i < RSA_INTS; i++)
 800e1fe:	9b03      	ldr	r3, [sp, #12]
 800e200:	3301      	adds	r3, #1
 800e202:	9303      	str	r3, [sp, #12]
 800e204:	9b03      	ldr	r3, [sp, #12]
 800e206:	2b07      	cmp	r3, #7
 800e208:	ddf1      	ble.n	800e1ee <FreeTmpRsas+0xe>
}
 800e20a:	b005      	add	sp, #20
 800e20c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e210 <wc_RsaKeyToDer>:


/* Convert RsaKey key to DER format, write to output (inLen), return bytes
   written */
int wc_RsaKeyToDer(RsaKey* key, byte* output, word32 inLen)
{
 800e210:	b500      	push	{lr}
 800e212:	b0a3      	sub	sp, #140	; 0x8c
 800e214:	9003      	str	r0, [sp, #12]
 800e216:	9102      	str	r1, [sp, #8]
 800e218:	9201      	str	r2, [sp, #4]
    word32 seqSz, verSz, rawLen, intTotalLen = 0;
 800e21a:	2300      	movs	r3, #0
 800e21c:	9321      	str	r3, [sp, #132]	; 0x84
    word32 sizes[RSA_INTS];
    int    i, j, outLen, ret = 0, mpSz;
 800e21e:	2300      	movs	r3, #0
 800e220:	931e      	str	r3, [sp, #120]	; 0x78

    byte  seq[MAX_SEQ_SZ];
    byte  ver[MAX_VERSION_SZ];
    byte* tmps[RSA_INTS];

    if (!key || !output)
 800e222:	9b03      	ldr	r3, [sp, #12]
 800e224:	2b00      	cmp	r3, #0
 800e226:	d002      	beq.n	800e22e <wc_RsaKeyToDer+0x1e>
 800e228:	9b02      	ldr	r3, [sp, #8]
 800e22a:	2b00      	cmp	r3, #0
 800e22c:	d102      	bne.n	800e234 <wc_RsaKeyToDer+0x24>
        return BAD_FUNC_ARG;
 800e22e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e232:	e0d6      	b.n	800e3e2 <wc_RsaKeyToDer+0x1d2>

    if (key->type != RSA_PRIVATE)
 800e234:	9b03      	ldr	r3, [sp, #12]
 800e236:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800e23a:	2b01      	cmp	r3, #1
 800e23c:	d002      	beq.n	800e244 <wc_RsaKeyToDer+0x34>
        return BAD_FUNC_ARG;
 800e23e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e242:	e0ce      	b.n	800e3e2 <wc_RsaKeyToDer+0x1d2>

    for (i = 0; i < RSA_INTS; i++)
 800e244:	2300      	movs	r3, #0
 800e246:	9320      	str	r3, [sp, #128]	; 0x80
 800e248:	e009      	b.n	800e25e <wc_RsaKeyToDer+0x4e>
        tmps[i] = NULL;
 800e24a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e24c:	009b      	lsls	r3, r3, #2
 800e24e:	aa22      	add	r2, sp, #136	; 0x88
 800e250:	4413      	add	r3, r2
 800e252:	2200      	movs	r2, #0
 800e254:	f843 2c78 	str.w	r2, [r3, #-120]
    for (i = 0; i < RSA_INTS; i++)
 800e258:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e25a:	3301      	adds	r3, #1
 800e25c:	9320      	str	r3, [sp, #128]	; 0x80
 800e25e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e260:	2b07      	cmp	r3, #7
 800e262:	ddf2      	ble.n	800e24a <wc_RsaKeyToDer+0x3a>

    /* write all big ints from key to DER tmps */
    for (i = 0; i < RSA_INTS; i++) {
 800e264:	2300      	movs	r3, #0
 800e266:	9320      	str	r3, [sp, #128]	; 0x80
 800e268:	e04c      	b.n	800e304 <wc_RsaKeyToDer+0xf4>
        mp_int* keyInt = GetRsaInt(key, i);
 800e26a:	9920      	ldr	r1, [sp, #128]	; 0x80
 800e26c:	9803      	ldr	r0, [sp, #12]
 800e26e:	f7ff ff7f 	bl	800e170 <GetRsaInt>
 800e272:	901d      	str	r0, [sp, #116]	; 0x74

        rawLen = mp_unsigned_bin_size(keyInt) + 1;
 800e274:	981d      	ldr	r0, [sp, #116]	; 0x74
 800e276:	f7fc fa53 	bl	800a720 <mp_unsigned_bin_size>
 800e27a:	4603      	mov	r3, r0
 800e27c:	3301      	adds	r3, #1
 800e27e:	931c      	str	r3, [sp, #112]	; 0x70
        tmps[i] = (byte*)XMALLOC(rawLen + MAX_SEQ_SZ, key->heap,
 800e280:	9b03      	ldr	r3, [sp, #12]
 800e282:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800e286:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800e288:	3305      	adds	r3, #5
 800e28a:	4619      	mov	r1, r3
 800e28c:	4610      	mov	r0, r2
 800e28e:	f7f7 fae7 	bl	8005860 <chibios_alloc>
 800e292:	4602      	mov	r2, r0
 800e294:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e296:	009b      	lsls	r3, r3, #2
 800e298:	a922      	add	r1, sp, #136	; 0x88
 800e29a:	440b      	add	r3, r1
 800e29c:	f843 2c78 	str.w	r2, [r3, #-120]
                                 DYNAMIC_TYPE_RSA);
        if (tmps[i] == NULL) {
 800e2a0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e2a2:	009b      	lsls	r3, r3, #2
 800e2a4:	aa22      	add	r2, sp, #136	; 0x88
 800e2a6:	4413      	add	r3, r2
 800e2a8:	f853 3c78 	ldr.w	r3, [r3, #-120]
 800e2ac:	2b00      	cmp	r3, #0
 800e2ae:	d103      	bne.n	800e2b8 <wc_RsaKeyToDer+0xa8>
            ret = MEMORY_E;
 800e2b0:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e2b4:	931e      	str	r3, [sp, #120]	; 0x78
 800e2b6:	e028      	b.n	800e30a <wc_RsaKeyToDer+0xfa>
            break;
        }

        mpSz = SetASNIntMP(keyInt, MAX_RSA_INT_SZ, tmps[i]);
 800e2b8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e2ba:	009b      	lsls	r3, r3, #2
 800e2bc:	aa22      	add	r2, sp, #136	; 0x88
 800e2be:	4413      	add	r3, r2
 800e2c0:	f853 3c78 	ldr.w	r3, [r3, #-120]
 800e2c4:	461a      	mov	r2, r3
 800e2c6:	f240 2105 	movw	r1, #517	; 0x205
 800e2ca:	981d      	ldr	r0, [sp, #116]	; 0x74
 800e2cc:	f000 fe68 	bl	800efa0 <SetASNIntMP.lto_priv.384>
 800e2d0:	901b      	str	r0, [sp, #108]	; 0x6c
        if (mpSz < 0) {
 800e2d2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800e2d4:	2b00      	cmp	r3, #0
 800e2d6:	da02      	bge.n	800e2de <wc_RsaKeyToDer+0xce>
            ret = mpSz;
 800e2d8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800e2da:	931e      	str	r3, [sp, #120]	; 0x78
 800e2dc:	e015      	b.n	800e30a <wc_RsaKeyToDer+0xfa>
            break;
        }
        intTotalLen += (sizes[i] = mpSz);
 800e2de:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800e2e0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e2e2:	009b      	lsls	r3, r3, #2
 800e2e4:	a922      	add	r1, sp, #136	; 0x88
 800e2e6:	440b      	add	r3, r1
 800e2e8:	f843 2c48 	str.w	r2, [r3, #-72]
 800e2ec:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e2ee:	009b      	lsls	r3, r3, #2
 800e2f0:	aa22      	add	r2, sp, #136	; 0x88
 800e2f2:	4413      	add	r3, r2
 800e2f4:	f853 3c48 	ldr.w	r3, [r3, #-72]
 800e2f8:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800e2fa:	4413      	add	r3, r2
 800e2fc:	9321      	str	r3, [sp, #132]	; 0x84
    for (i = 0; i < RSA_INTS; i++) {
 800e2fe:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e300:	3301      	adds	r3, #1
 800e302:	9320      	str	r3, [sp, #128]	; 0x80
 800e304:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e306:	2b07      	cmp	r3, #7
 800e308:	ddaf      	ble.n	800e26a <wc_RsaKeyToDer+0x5a>
    }

    if (ret != 0) {
 800e30a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800e30c:	2b00      	cmp	r3, #0
 800e30e:	d009      	beq.n	800e324 <wc_RsaKeyToDer+0x114>
        FreeTmpRsas(tmps, key->heap);
 800e310:	9b03      	ldr	r3, [sp, #12]
 800e312:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800e316:	ab04      	add	r3, sp, #16
 800e318:	4611      	mov	r1, r2
 800e31a:	4618      	mov	r0, r3
 800e31c:	f7ff ff60 	bl	800e1e0 <FreeTmpRsas>
        return ret;
 800e320:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800e322:	e05e      	b.n	800e3e2 <wc_RsaKeyToDer+0x1d2>
    }

    /* make headers */
    verSz = SetMyVersion(0, ver, FALSE);
 800e324:	ab0c      	add	r3, sp, #48	; 0x30
 800e326:	2200      	movs	r2, #0
 800e328:	4619      	mov	r1, r3
 800e32a:	2000      	movs	r0, #0
 800e32c:	f7ff fbc8 	bl	800dac0 <SetMyVersion>
 800e330:	4603      	mov	r3, r0
 800e332:	931a      	str	r3, [sp, #104]	; 0x68
    seqSz = SetSequence(verSz + intTotalLen, seq);
 800e334:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800e336:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800e338:	4413      	add	r3, r2
 800e33a:	aa0e      	add	r2, sp, #56	; 0x38
 800e33c:	4611      	mov	r1, r2
 800e33e:	4618      	mov	r0, r3
 800e340:	f000 f8c6 	bl	800e4d0 <SetSequence>
 800e344:	9019      	str	r0, [sp, #100]	; 0x64

    outLen = seqSz + verSz + intTotalLen;
 800e346:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800e348:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800e34a:	441a      	add	r2, r3
 800e34c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800e34e:	4413      	add	r3, r2
 800e350:	9318      	str	r3, [sp, #96]	; 0x60
    if (outLen > (int)inLen)
 800e352:	9b01      	ldr	r3, [sp, #4]
 800e354:	9a18      	ldr	r2, [sp, #96]	; 0x60
 800e356:	429a      	cmp	r2, r3
 800e358:	dd02      	ble.n	800e360 <wc_RsaKeyToDer+0x150>
        return BAD_FUNC_ARG;
 800e35a:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e35e:	e040      	b.n	800e3e2 <wc_RsaKeyToDer+0x1d2>

    /* write to output */
    XMEMCPY(output, seq, seqSz);
 800e360:	ab0e      	add	r3, sp, #56	; 0x38
 800e362:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800e364:	4619      	mov	r1, r3
 800e366:	9802      	ldr	r0, [sp, #8]
 800e368:	f7f6 f9d8 	bl	800471c <memcpy>
    j = seqSz;
 800e36c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800e36e:	931f      	str	r3, [sp, #124]	; 0x7c
    XMEMCPY(output + j, ver, verSz);
 800e370:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800e372:	9a02      	ldr	r2, [sp, #8]
 800e374:	4413      	add	r3, r2
 800e376:	a90c      	add	r1, sp, #48	; 0x30
 800e378:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800e37a:	4618      	mov	r0, r3
 800e37c:	f7f6 f9ce 	bl	800471c <memcpy>
    j += verSz;
 800e380:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 800e382:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800e384:	4413      	add	r3, r2
 800e386:	931f      	str	r3, [sp, #124]	; 0x7c

    for (i = 0; i < RSA_INTS; i++) {
 800e388:	2300      	movs	r3, #0
 800e38a:	9320      	str	r3, [sp, #128]	; 0x80
 800e38c:	e01d      	b.n	800e3ca <wc_RsaKeyToDer+0x1ba>
        XMEMCPY(output + j, tmps[i], sizes[i]);
 800e38e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800e390:	9a02      	ldr	r2, [sp, #8]
 800e392:	18d0      	adds	r0, r2, r3
 800e394:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e396:	009b      	lsls	r3, r3, #2
 800e398:	aa22      	add	r2, sp, #136	; 0x88
 800e39a:	4413      	add	r3, r2
 800e39c:	f853 1c78 	ldr.w	r1, [r3, #-120]
 800e3a0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e3a2:	009b      	lsls	r3, r3, #2
 800e3a4:	aa22      	add	r2, sp, #136	; 0x88
 800e3a6:	4413      	add	r3, r2
 800e3a8:	f853 3c48 	ldr.w	r3, [r3, #-72]
 800e3ac:	461a      	mov	r2, r3
 800e3ae:	f7f6 f9b5 	bl	800471c <memcpy>
        j += sizes[i];
 800e3b2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e3b4:	009b      	lsls	r3, r3, #2
 800e3b6:	aa22      	add	r2, sp, #136	; 0x88
 800e3b8:	4413      	add	r3, r2
 800e3ba:	f853 2c48 	ldr.w	r2, [r3, #-72]
 800e3be:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800e3c0:	4413      	add	r3, r2
 800e3c2:	931f      	str	r3, [sp, #124]	; 0x7c
    for (i = 0; i < RSA_INTS; i++) {
 800e3c4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e3c6:	3301      	adds	r3, #1
 800e3c8:	9320      	str	r3, [sp, #128]	; 0x80
 800e3ca:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e3cc:	2b07      	cmp	r3, #7
 800e3ce:	ddde      	ble.n	800e38e <wc_RsaKeyToDer+0x17e>
    }
    FreeTmpRsas(tmps, key->heap);
 800e3d0:	9b03      	ldr	r3, [sp, #12]
 800e3d2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800e3d6:	ab04      	add	r3, sp, #16
 800e3d8:	4611      	mov	r1, r2
 800e3da:	4618      	mov	r0, r3
 800e3dc:	f7ff ff00 	bl	800e1e0 <FreeTmpRsas>

    return outLen;
 800e3e0:	9b18      	ldr	r3, [sp, #96]	; 0x60
}
 800e3e2:	4618      	mov	r0, r3
 800e3e4:	b023      	add	sp, #140	; 0x8c
 800e3e6:	f85d fb04 	ldr.w	pc, [sp], #4
 800e3ea:	bf00      	nop
 800e3ec:	0000      	movs	r0, r0
	...

0800e3f0 <wc_RsaKeyToPublicDer>:


/* Convert Rsa Public key to DER format, write to output (inLen), return bytes
   written */
int wc_RsaKeyToPublicDer(RsaKey* key, byte* output, word32 inLen)
{
 800e3f0:	b500      	push	{lr}
 800e3f2:	b085      	sub	sp, #20
 800e3f4:	9003      	str	r0, [sp, #12]
 800e3f6:	9102      	str	r1, [sp, #8]
 800e3f8:	9201      	str	r2, [sp, #4]
    return SetRsaPublicKey(output, key, inLen, 1);
 800e3fa:	9a01      	ldr	r2, [sp, #4]
 800e3fc:	2301      	movs	r3, #1
 800e3fe:	9903      	ldr	r1, [sp, #12]
 800e400:	9802      	ldr	r0, [sp, #8]
 800e402:	f7ff fd9d 	bl	800df40 <SetRsaPublicKey>
 800e406:	4603      	mov	r3, r0
}
 800e408:	4618      	mov	r0, r3
 800e40a:	b005      	add	sp, #20
 800e40c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e410 <BytePrecision>:
{
 800e410:	b084      	sub	sp, #16
 800e412:	9001      	str	r0, [sp, #4]
    for (i = sizeof(value); i; --i)
 800e414:	2304      	movs	r3, #4
 800e416:	9303      	str	r3, [sp, #12]
 800e418:	e00c      	b.n	800e434 <BytePrecision+0x24>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
 800e41a:	9b03      	ldr	r3, [sp, #12]
 800e41c:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800e420:	3b01      	subs	r3, #1
 800e422:	00db      	lsls	r3, r3, #3
 800e424:	9a01      	ldr	r2, [sp, #4]
 800e426:	fa22 f303 	lsr.w	r3, r2, r3
 800e42a:	2b00      	cmp	r3, #0
 800e42c:	d105      	bne.n	800e43a <BytePrecision+0x2a>
    for (i = sizeof(value); i; --i)
 800e42e:	9b03      	ldr	r3, [sp, #12]
 800e430:	3b01      	subs	r3, #1
 800e432:	9303      	str	r3, [sp, #12]
 800e434:	9b03      	ldr	r3, [sp, #12]
 800e436:	2b00      	cmp	r3, #0
 800e438:	d1ef      	bne.n	800e41a <BytePrecision+0xa>
    return i;
 800e43a:	9b03      	ldr	r3, [sp, #12]
}
 800e43c:	4618      	mov	r0, r3
 800e43e:	b004      	add	sp, #16
 800e440:	4770      	bx	lr
 800e442:	bf00      	nop
	...

0800e450 <SetLength>:
{
 800e450:	b510      	push	{r4, lr}
 800e452:	b084      	sub	sp, #16
 800e454:	9001      	str	r0, [sp, #4]
 800e456:	9100      	str	r1, [sp, #0]
    word32 i = 0, j;
 800e458:	2300      	movs	r3, #0
 800e45a:	9303      	str	r3, [sp, #12]
    if (length < ASN_LONG_LENGTH)
 800e45c:	9b01      	ldr	r3, [sp, #4]
 800e45e:	2b7f      	cmp	r3, #127	; 0x7f
 800e460:	d808      	bhi.n	800e474 <SetLength+0x24>
        output[i++] = (byte)length;
 800e462:	9b03      	ldr	r3, [sp, #12]
 800e464:	1c5a      	adds	r2, r3, #1
 800e466:	9203      	str	r2, [sp, #12]
 800e468:	9a00      	ldr	r2, [sp, #0]
 800e46a:	4413      	add	r3, r2
 800e46c:	9a01      	ldr	r2, [sp, #4]
 800e46e:	b2d2      	uxtb	r2, r2
 800e470:	701a      	strb	r2, [r3, #0]
 800e472:	e028      	b.n	800e4c6 <SetLength+0x76>
        output[i++] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
 800e474:	9b03      	ldr	r3, [sp, #12]
 800e476:	1c5a      	adds	r2, r3, #1
 800e478:	9203      	str	r2, [sp, #12]
 800e47a:	9a00      	ldr	r2, [sp, #0]
 800e47c:	18d4      	adds	r4, r2, r3
 800e47e:	9801      	ldr	r0, [sp, #4]
 800e480:	f7ff ffc6 	bl	800e410 <BytePrecision>
 800e484:	4603      	mov	r3, r0
 800e486:	b2db      	uxtb	r3, r3
 800e488:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800e48c:	b2db      	uxtb	r3, r3
 800e48e:	7023      	strb	r3, [r4, #0]
        for (j = BytePrecision(length); j; --j) {
 800e490:	9801      	ldr	r0, [sp, #4]
 800e492:	f7ff ffbd 	bl	800e410 <BytePrecision>
 800e496:	9002      	str	r0, [sp, #8]
 800e498:	e012      	b.n	800e4c0 <SetLength+0x70>
            output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 800e49a:	9a00      	ldr	r2, [sp, #0]
 800e49c:	9b03      	ldr	r3, [sp, #12]
 800e49e:	441a      	add	r2, r3
 800e4a0:	9b02      	ldr	r3, [sp, #8]
 800e4a2:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800e4a6:	3b01      	subs	r3, #1
 800e4a8:	00db      	lsls	r3, r3, #3
 800e4aa:	9901      	ldr	r1, [sp, #4]
 800e4ac:	fa21 f303 	lsr.w	r3, r1, r3
 800e4b0:	b2db      	uxtb	r3, r3
 800e4b2:	7013      	strb	r3, [r2, #0]
            i++;
 800e4b4:	9b03      	ldr	r3, [sp, #12]
 800e4b6:	3301      	adds	r3, #1
 800e4b8:	9303      	str	r3, [sp, #12]
        for (j = BytePrecision(length); j; --j) {
 800e4ba:	9b02      	ldr	r3, [sp, #8]
 800e4bc:	3b01      	subs	r3, #1
 800e4be:	9302      	str	r3, [sp, #8]
 800e4c0:	9b02      	ldr	r3, [sp, #8]
 800e4c2:	2b00      	cmp	r3, #0
 800e4c4:	d1e9      	bne.n	800e49a <SetLength+0x4a>
    return i;
 800e4c6:	9b03      	ldr	r3, [sp, #12]
}
 800e4c8:	4618      	mov	r0, r3
 800e4ca:	b004      	add	sp, #16
 800e4cc:	bd10      	pop	{r4, pc}
 800e4ce:	bf00      	nop

0800e4d0 <SetSequence>:
{
 800e4d0:	b500      	push	{lr}
 800e4d2:	b083      	sub	sp, #12
 800e4d4:	9001      	str	r0, [sp, #4]
 800e4d6:	9100      	str	r1, [sp, #0]
    output[0] = ASN_SEQUENCE | ASN_CONSTRUCTED;
 800e4d8:	9b00      	ldr	r3, [sp, #0]
 800e4da:	2230      	movs	r2, #48	; 0x30
 800e4dc:	701a      	strb	r2, [r3, #0]
    return SetLength(len, output + 1) + 1;
 800e4de:	9b00      	ldr	r3, [sp, #0]
 800e4e0:	3301      	adds	r3, #1
 800e4e2:	4619      	mov	r1, r3
 800e4e4:	9801      	ldr	r0, [sp, #4]
 800e4e6:	f7ff ffb3 	bl	800e450 <SetLength>
 800e4ea:	4603      	mov	r3, r0
 800e4ec:	3301      	adds	r3, #1
}
 800e4ee:	4618      	mov	r0, r3
 800e4f0:	b003      	add	sp, #12
 800e4f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800e4f6:	bf00      	nop
	...

0800e500 <IsSigAlgoECDSA>:
{
 800e500:	b082      	sub	sp, #8
 800e502:	9001      	str	r0, [sp, #4]
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
 800e504:	9b01      	ldr	r3, [sp, #4]
 800e506:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 800e50a:	d00d      	beq.n	800e528 <IsSigAlgoECDSA+0x28>
 800e50c:	9b01      	ldr	r3, [sp, #4]
 800e50e:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 800e512:	d009      	beq.n	800e528 <IsSigAlgoECDSA+0x28>
 800e514:	9b01      	ldr	r3, [sp, #4]
 800e516:	f240 220d 	movw	r2, #525	; 0x20d
 800e51a:	4293      	cmp	r3, r2
 800e51c:	d004      	beq.n	800e528 <IsSigAlgoECDSA+0x28>
        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {
 800e51e:	9b01      	ldr	r3, [sp, #4]
 800e520:	f240 220e 	movw	r2, #526	; 0x20e
 800e524:	4293      	cmp	r3, r2
 800e526:	d101      	bne.n	800e52c <IsSigAlgoECDSA+0x2c>
        return 1;
 800e528:	2301      	movs	r3, #1
 800e52a:	e000      	b.n	800e52e <IsSigAlgoECDSA+0x2e>
    return 0;
 800e52c:	2300      	movs	r3, #0
}
 800e52e:	4618      	mov	r0, r3
 800e530:	b002      	add	sp, #8
 800e532:	4770      	bx	lr
	...

0800e540 <SetAlgoID>:
{
 800e540:	b500      	push	{lr}
 800e542:	b08f      	sub	sp, #60	; 0x3c
 800e544:	9003      	str	r0, [sp, #12]
 800e546:	9102      	str	r1, [sp, #8]
 800e548:	9201      	str	r2, [sp, #4]
 800e54a:	9300      	str	r3, [sp, #0]
    word32 tagSz, idSz, seqSz, algoSz = 0;
 800e54c:	2300      	movs	r3, #0
 800e54e:	9309      	str	r3, [sp, #36]	; 0x24
    const  byte* algoName = 0;
 800e550:	2300      	movs	r3, #0
 800e552:	930d      	str	r3, [sp, #52]	; 0x34
             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;
 800e554:	9b01      	ldr	r3, [sp, #4]
 800e556:	2b00      	cmp	r3, #0
 800e558:	d014      	beq.n	800e584 <SetAlgoID+0x44>
    tagSz = (type == oidHashType ||
 800e55a:	9b01      	ldr	r3, [sp, #4]
 800e55c:	2b01      	cmp	r3, #1
 800e55e:	d109      	bne.n	800e574 <SetAlgoID+0x34>
             (type == oidSigType && !IsSigAlgoECDSA(algoOID) &&
 800e560:	9803      	ldr	r0, [sp, #12]
 800e562:	f7ff ffcd 	bl	800e500 <IsSigAlgoECDSA>
 800e566:	4603      	mov	r3, r0
 800e568:	2b00      	cmp	r3, #0
 800e56a:	d103      	bne.n	800e574 <SetAlgoID+0x34>
 800e56c:	9b03      	ldr	r3, [sp, #12]
 800e56e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800e572:	d107      	bne.n	800e584 <SetAlgoID+0x44>
                                         algoOID != ED25519k) ||
 800e574:	9b01      	ldr	r3, [sp, #4]
 800e576:	2b02      	cmp	r3, #2
 800e578:	d106      	bne.n	800e588 <SetAlgoID+0x48>
             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;
 800e57a:	9b03      	ldr	r3, [sp, #12]
 800e57c:	f240 2285 	movw	r2, #645	; 0x285
 800e580:	4293      	cmp	r3, r2
 800e582:	d101      	bne.n	800e588 <SetAlgoID+0x48>
 800e584:	2302      	movs	r3, #2
 800e586:	e000      	b.n	800e58a <SetAlgoID+0x4a>
 800e588:	2300      	movs	r3, #0
    tagSz = (type == oidHashType ||
 800e58a:	930c      	str	r3, [sp, #48]	; 0x30
    algoName = OidFromId(algoOID, type, &algoSz);
 800e58c:	9b03      	ldr	r3, [sp, #12]
 800e58e:	9901      	ldr	r1, [sp, #4]
 800e590:	aa09      	add	r2, sp, #36	; 0x24
 800e592:	4618      	mov	r0, r3
 800e594:	f000 fe6c 	bl	800f270 <OidFromId.lto_priv.408>
 800e598:	900d      	str	r0, [sp, #52]	; 0x34
    if (algoName == NULL) {
 800e59a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e59c:	2b00      	cmp	r3, #0
 800e59e:	d101      	bne.n	800e5a4 <SetAlgoID+0x64>
        return 0;
 800e5a0:	2300      	movs	r3, #0
 800e5a2:	e041      	b.n	800e628 <SetAlgoID+0xe8>
    idSz  = SetObjectId(algoSz, ID_Length);
 800e5a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e5a6:	461a      	mov	r2, r3
 800e5a8:	ab07      	add	r3, sp, #28
 800e5aa:	4619      	mov	r1, r3
 800e5ac:	4610      	mov	r0, r2
 800e5ae:	f001 fa3f 	bl	800fa30 <SetObjectId.lto_priv.390>
 800e5b2:	4603      	mov	r3, r0
 800e5b4:	930b      	str	r3, [sp, #44]	; 0x2c
    seqSz = SetSequence(idSz + algoSz + tagSz + curveSz, seqArray);
 800e5b6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e5b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e5ba:	441a      	add	r2, r3
 800e5bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e5be:	441a      	add	r2, r3
 800e5c0:	9b00      	ldr	r3, [sp, #0]
 800e5c2:	4413      	add	r3, r2
 800e5c4:	aa05      	add	r2, sp, #20
 800e5c6:	4611      	mov	r1, r2
 800e5c8:	4618      	mov	r0, r3
 800e5ca:	f7ff ff81 	bl	800e4d0 <SetSequence>
 800e5ce:	900a      	str	r0, [sp, #40]	; 0x28
    XMEMCPY(output, seqArray, seqSz);
 800e5d0:	ab05      	add	r3, sp, #20
 800e5d2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e5d4:	4619      	mov	r1, r3
 800e5d6:	9802      	ldr	r0, [sp, #8]
 800e5d8:	f7f6 f8a0 	bl	800471c <memcpy>
    XMEMCPY(output + seqSz, ID_Length, idSz);
 800e5dc:	9a02      	ldr	r2, [sp, #8]
 800e5de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e5e0:	4413      	add	r3, r2
 800e5e2:	a907      	add	r1, sp, #28
 800e5e4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800e5e6:	4618      	mov	r0, r3
 800e5e8:	f7f6 f898 	bl	800471c <memcpy>
    XMEMCPY(output + seqSz + idSz, algoName, algoSz);
 800e5ec:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e5ee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e5f0:	4413      	add	r3, r2
 800e5f2:	9a02      	ldr	r2, [sp, #8]
 800e5f4:	4413      	add	r3, r2
 800e5f6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e5f8:	990d      	ldr	r1, [sp, #52]	; 0x34
 800e5fa:	4618      	mov	r0, r3
 800e5fc:	f7f6 f88e 	bl	800471c <memcpy>
    if (tagSz == 2)
 800e600:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e602:	2b02      	cmp	r3, #2
 800e604:	d109      	bne.n	800e61a <SetAlgoID+0xda>
        SetASNNull(&output[seqSz + idSz + algoSz]);
 800e606:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e608:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e60a:	441a      	add	r2, r3
 800e60c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e60e:	4413      	add	r3, r2
 800e610:	9a02      	ldr	r2, [sp, #8]
 800e612:	4413      	add	r3, r2
 800e614:	4618      	mov	r0, r3
 800e616:	f000 fc13 	bl	800ee40 <SetASNNull.lto_priv.407>
    return seqSz + idSz + algoSz + tagSz;
 800e61a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e61c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e61e:	441a      	add	r2, r3
 800e620:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e622:	441a      	add	r2, r3
 800e624:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e626:	4413      	add	r3, r2
}
 800e628:	4618      	mov	r0, r3
 800e62a:	b00f      	add	sp, #60	; 0x3c
 800e62c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e630 <Hash_DRBG_Generate>:
    }
}

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG* drbg, byte* out, word32 outSz)
{
 800e630:	b500      	push	{lr}
 800e632:	b0ad      	sub	sp, #180	; 0xb4
 800e634:	9003      	str	r0, [sp, #12]
 800e636:	9102      	str	r1, [sp, #8]
 800e638:	9201      	str	r2, [sp, #4]
    int ret;
    wc_Sha256 sha;
    byte type;
    word32 reseedCtr;

    if (drbg->reseedCtr == RESEED_INTERVAL) {
 800e63a:	9b03      	ldr	r3, [sp, #12]
 800e63c:	681b      	ldr	r3, [r3, #0]
 800e63e:	4a3c      	ldr	r2, [pc, #240]	; (800e730 <Hash_DRBG_Generate+0x100>)
 800e640:	4293      	cmp	r3, r2
 800e642:	d101      	bne.n	800e648 <Hash_DRBG_Generate+0x18>
        return DRBG_NEED_RESEED;
 800e644:	2303      	movs	r3, #3
 800e646:	e06f      	b.n	800e728 <Hash_DRBG_Generate+0xf8>
    } else {
        DECLARE_VAR(digest, byte, WC_SHA256_DIGEST_SIZE, drbg->heap);
        type = drbgGenerateH;
 800e648:	2303      	movs	r3, #3
 800e64a:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
        reseedCtr = drbg->reseedCtr;
 800e64e:	9b03      	ldr	r3, [sp, #12]
 800e650:	681b      	ldr	r3, [r3, #0]
 800e652:	930d      	str	r3, [sp, #52]	; 0x34

        ret = Hash_gen(drbg, out, outSz, drbg->V);
 800e654:	9b03      	ldr	r3, [sp, #12]
 800e656:	3308      	adds	r3, #8
 800e658:	9a01      	ldr	r2, [sp, #4]
 800e65a:	9902      	ldr	r1, [sp, #8]
 800e65c:	9803      	ldr	r0, [sp, #12]
 800e65e:	f002 fe8f 	bl	8011380 <Hash_gen.lto_priv.479>
 800e662:	902b      	str	r0, [sp, #172]	; 0xac
        if (ret == DRBG_SUCCESS) {
 800e664:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e666:	2b00      	cmp	r3, #0
 800e668:	d153      	bne.n	800e712 <Hash_DRBG_Generate+0xe2>
        #ifdef WOLFSSL_ASYNC_CRYPT
            ret = wc_InitSha256_ex(&sha, drbg->heap, drbg->devId);
        #else
            ret = wc_InitSha256(&sha);
 800e66a:	ab0f      	add	r3, sp, #60	; 0x3c
 800e66c:	4618      	mov	r0, r3
 800e66e:	f7f8 f817 	bl	80066a0 <wc_InitSha256>
 800e672:	902b      	str	r0, [sp, #172]	; 0xac
        #endif
            if (ret == 0)
 800e674:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e676:	2b00      	cmp	r3, #0
 800e678:	d107      	bne.n	800e68a <Hash_DRBG_Generate+0x5a>
                ret = wc_Sha256Update(&sha, &type, sizeof(type));
 800e67a:	f10d 013b 	add.w	r1, sp, #59	; 0x3b
 800e67e:	ab0f      	add	r3, sp, #60	; 0x3c
 800e680:	2201      	movs	r2, #1
 800e682:	4618      	mov	r0, r3
 800e684:	f7f7 fe8c 	bl	80063a0 <wc_Sha256Update>
 800e688:	902b      	str	r0, [sp, #172]	; 0xac
            if (ret == 0)
 800e68a:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e68c:	2b00      	cmp	r3, #0
 800e68e:	d108      	bne.n	800e6a2 <Hash_DRBG_Generate+0x72>
                ret = wc_Sha256Update(&sha, drbg->V, sizeof(drbg->V));
 800e690:	9b03      	ldr	r3, [sp, #12]
 800e692:	f103 0108 	add.w	r1, r3, #8
 800e696:	ab0f      	add	r3, sp, #60	; 0x3c
 800e698:	2237      	movs	r2, #55	; 0x37
 800e69a:	4618      	mov	r0, r3
 800e69c:	f7f7 fe80 	bl	80063a0 <wc_Sha256Update>
 800e6a0:	902b      	str	r0, [sp, #172]	; 0xac
            if (ret == 0)
 800e6a2:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e6a4:	2b00      	cmp	r3, #0
 800e6a6:	d106      	bne.n	800e6b6 <Hash_DRBG_Generate+0x86>
                ret = wc_Sha256Final(&sha, digest);
 800e6a8:	aa05      	add	r2, sp, #20
 800e6aa:	ab0f      	add	r3, sp, #60	; 0x3c
 800e6ac:	4611      	mov	r1, r2
 800e6ae:	4618      	mov	r0, r3
 800e6b0:	f7f7 ff06 	bl	80064c0 <wc_Sha256Final>
 800e6b4:	902b      	str	r0, [sp, #172]	; 0xac

            wc_Sha256Free(&sha);
 800e6b6:	ab0f      	add	r3, sp, #60	; 0x3c
 800e6b8:	4618      	mov	r0, r3
 800e6ba:	f7f8 f801 	bl	80066c0 <wc_Sha256Free>

            if (ret == 0) {
 800e6be:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e6c0:	2b00      	cmp	r3, #0
 800e6c2:	d121      	bne.n	800e708 <Hash_DRBG_Generate+0xd8>
                array_add(drbg->V, sizeof(drbg->V), digest, WC_SHA256_DIGEST_SIZE);
 800e6c4:	9b03      	ldr	r3, [sp, #12]
 800e6c6:	f103 0008 	add.w	r0, r3, #8
 800e6ca:	aa05      	add	r2, sp, #20
 800e6cc:	2320      	movs	r3, #32
 800e6ce:	2137      	movs	r1, #55	; 0x37
 800e6d0:	f002 ff0e 	bl	80114f0 <array_add.lto_priv.477>
                array_add(drbg->V, sizeof(drbg->V), drbg->C, sizeof(drbg->C));
 800e6d4:	9b03      	ldr	r3, [sp, #12]
 800e6d6:	f103 0008 	add.w	r0, r3, #8
 800e6da:	9b03      	ldr	r3, [sp, #12]
 800e6dc:	f103 023f 	add.w	r2, r3, #63	; 0x3f
 800e6e0:	2337      	movs	r3, #55	; 0x37
 800e6e2:	2137      	movs	r1, #55	; 0x37
 800e6e4:	f002 ff04 	bl	80114f0 <array_add.lto_priv.477>
            #ifdef LITTLE_ENDIAN_ORDER
                reseedCtr = ByteReverseWord32(reseedCtr);
 800e6e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e6ea:	4618      	mov	r0, r3
 800e6ec:	f002 fcb8 	bl	8011060 <ByteReverseWord32.lto_priv.478>
 800e6f0:	4603      	mov	r3, r0
 800e6f2:	930d      	str	r3, [sp, #52]	; 0x34
            #endif
                array_add(drbg->V, sizeof(drbg->V),
 800e6f4:	9b03      	ldr	r3, [sp, #12]
 800e6f6:	f103 0008 	add.w	r0, r3, #8
 800e6fa:	aa0d      	add	r2, sp, #52	; 0x34
 800e6fc:	2304      	movs	r3, #4
 800e6fe:	2137      	movs	r1, #55	; 0x37
 800e700:	f002 fef6 	bl	80114f0 <array_add.lto_priv.477>
                                          (byte*)&reseedCtr, sizeof(reseedCtr));
                ret = DRBG_SUCCESS;
 800e704:	2300      	movs	r3, #0
 800e706:	932b      	str	r3, [sp, #172]	; 0xac
            }
            drbg->reseedCtr++;
 800e708:	9b03      	ldr	r3, [sp, #12]
 800e70a:	681b      	ldr	r3, [r3, #0]
 800e70c:	1c5a      	adds	r2, r3, #1
 800e70e:	9b03      	ldr	r3, [sp, #12]
 800e710:	601a      	str	r2, [r3, #0]
        }
        ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 800e712:	ab05      	add	r3, sp, #20
 800e714:	2120      	movs	r1, #32
 800e716:	4618      	mov	r0, r3
 800e718:	f002 fcba 	bl	8011090 <ForceZero.lto_priv.475>
        FREE_VAR(digest, drbg->heap);
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 800e71c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800e71e:	2b00      	cmp	r3, #0
 800e720:	d101      	bne.n	800e726 <Hash_DRBG_Generate+0xf6>
 800e722:	2300      	movs	r3, #0
 800e724:	e000      	b.n	800e728 <Hash_DRBG_Generate+0xf8>
 800e726:	2302      	movs	r3, #2
}
 800e728:	4618      	mov	r0, r3
 800e72a:	b02d      	add	sp, #180	; 0xb4
 800e72c:	f85d fb04 	ldr.w	pc, [sp], #4
 800e730:	000f4240 	.word	0x000f4240
	...

0800e740 <Hash_DRBG_Instantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Instantiate(DRBG* drbg, const byte* seed, word32 seedSz,
                                             const byte* nonce, word32 nonceSz,
                                             void* heap, int devId)
{
 800e740:	b500      	push	{lr}
 800e742:	b08b      	sub	sp, #44	; 0x2c
 800e744:	9007      	str	r0, [sp, #28]
 800e746:	9106      	str	r1, [sp, #24]
 800e748:	9205      	str	r2, [sp, #20]
 800e74a:	9304      	str	r3, [sp, #16]
    int ret = DRBG_FAILURE;
 800e74c:	2302      	movs	r3, #2
 800e74e:	9309      	str	r3, [sp, #36]	; 0x24

    XMEMSET(drbg, 0, sizeof(DRBG));
 800e750:	2278      	movs	r2, #120	; 0x78
 800e752:	2100      	movs	r1, #0
 800e754:	9807      	ldr	r0, [sp, #28]
 800e756:	f00f f83d 	bl	801d7d4 <memset>
#else
    (void)heap;
    (void)devId;
#endif

    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
 800e75a:	9b07      	ldr	r3, [sp, #28]
 800e75c:	f103 0108 	add.w	r1, r3, #8
 800e760:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e762:	9303      	str	r3, [sp, #12]
 800e764:	9b04      	ldr	r3, [sp, #16]
 800e766:	9302      	str	r3, [sp, #8]
 800e768:	9b05      	ldr	r3, [sp, #20]
 800e76a:	9301      	str	r3, [sp, #4]
 800e76c:	9b06      	ldr	r3, [sp, #24]
 800e76e:	9300      	str	r3, [sp, #0]
 800e770:	2304      	movs	r3, #4
 800e772:	2237      	movs	r2, #55	; 0x37
 800e774:	9807      	ldr	r0, [sp, #28]
 800e776:	f002 fccb 	bl	8011110 <Hash_df.lto_priv.476>
 800e77a:	4603      	mov	r3, r0
 800e77c:	2b00      	cmp	r3, #0
 800e77e:	d11f      	bne.n	800e7c0 <Hash_DRBG_Instantiate+0x80>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 800e780:	9b07      	ldr	r3, [sp, #28]
 800e782:	f103 013f 	add.w	r1, r3, #63	; 0x3f
 800e786:	9b07      	ldr	r3, [sp, #28]
 800e788:	3308      	adds	r3, #8
 800e78a:	2200      	movs	r2, #0
 800e78c:	9203      	str	r2, [sp, #12]
 800e78e:	2200      	movs	r2, #0
 800e790:	9202      	str	r2, [sp, #8]
 800e792:	2237      	movs	r2, #55	; 0x37
 800e794:	9201      	str	r2, [sp, #4]
 800e796:	9300      	str	r3, [sp, #0]
 800e798:	2300      	movs	r3, #0
 800e79a:	2237      	movs	r2, #55	; 0x37
 800e79c:	9807      	ldr	r0, [sp, #28]
 800e79e:	f002 fcb7 	bl	8011110 <Hash_df.lto_priv.476>
 800e7a2:	4603      	mov	r3, r0
                                              nonce, nonceSz) == DRBG_SUCCESS &&
 800e7a4:	2b00      	cmp	r3, #0
 800e7a6:	d10b      	bne.n	800e7c0 <Hash_DRBG_Instantiate+0x80>
                                    sizeof(drbg->V), NULL, 0) == DRBG_SUCCESS) {

        drbg->reseedCtr = 1;
 800e7a8:	9b07      	ldr	r3, [sp, #28]
 800e7aa:	2201      	movs	r2, #1
 800e7ac:	601a      	str	r2, [r3, #0]
        drbg->lastBlock = 0;
 800e7ae:	9b07      	ldr	r3, [sp, #28]
 800e7b0:	2200      	movs	r2, #0
 800e7b2:	605a      	str	r2, [r3, #4]
        drbg->matchCount = 0;
 800e7b4:	9b07      	ldr	r3, [sp, #28]
 800e7b6:	2200      	movs	r2, #0
 800e7b8:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
        ret = DRBG_SUCCESS;
 800e7bc:	2300      	movs	r3, #0
 800e7be:	9309      	str	r3, [sp, #36]	; 0x24
    }

    return ret;
 800e7c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800e7c2:	4618      	mov	r0, r3
 800e7c4:	b00b      	add	sp, #44	; 0x2c
 800e7c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7ca:	bf00      	nop
 800e7cc:	0000      	movs	r0, r0
	...

0800e7d0 <Hash_DRBG_Uninstantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Uninstantiate(DRBG* drbg)
{
 800e7d0:	b500      	push	{lr}
 800e7d2:	b087      	sub	sp, #28
 800e7d4:	9001      	str	r0, [sp, #4]
    word32 i;
    int    compareSum = 0;
 800e7d6:	2300      	movs	r3, #0
 800e7d8:	9304      	str	r3, [sp, #16]
    byte*  compareDrbg = (byte*)drbg;
 800e7da:	9b01      	ldr	r3, [sp, #4]
 800e7dc:	9303      	str	r3, [sp, #12]

    ForceZero(drbg, sizeof(DRBG));
 800e7de:	2178      	movs	r1, #120	; 0x78
 800e7e0:	9801      	ldr	r0, [sp, #4]
 800e7e2:	f002 fc55 	bl	8011090 <ForceZero.lto_priv.475>

    for (i = 0; i < sizeof(DRBG); i++)
 800e7e6:	2300      	movs	r3, #0
 800e7e8:	9305      	str	r3, [sp, #20]
 800e7ea:	e00a      	b.n	800e802 <Hash_DRBG_Uninstantiate+0x32>
        compareSum |= compareDrbg[i] ^ 0;
 800e7ec:	9a03      	ldr	r2, [sp, #12]
 800e7ee:	9b05      	ldr	r3, [sp, #20]
 800e7f0:	4413      	add	r3, r2
 800e7f2:	781b      	ldrb	r3, [r3, #0]
 800e7f4:	461a      	mov	r2, r3
 800e7f6:	9b04      	ldr	r3, [sp, #16]
 800e7f8:	4313      	orrs	r3, r2
 800e7fa:	9304      	str	r3, [sp, #16]
    for (i = 0; i < sizeof(DRBG); i++)
 800e7fc:	9b05      	ldr	r3, [sp, #20]
 800e7fe:	3301      	adds	r3, #1
 800e800:	9305      	str	r3, [sp, #20]
 800e802:	9b05      	ldr	r3, [sp, #20]
 800e804:	2b77      	cmp	r3, #119	; 0x77
 800e806:	d9f1      	bls.n	800e7ec <Hash_DRBG_Uninstantiate+0x1c>

    return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 800e808:	9b04      	ldr	r3, [sp, #16]
 800e80a:	2b00      	cmp	r3, #0
 800e80c:	d101      	bne.n	800e812 <Hash_DRBG_Uninstantiate+0x42>
 800e80e:	2300      	movs	r3, #0
 800e810:	e000      	b.n	800e814 <Hash_DRBG_Uninstantiate+0x44>
 800e812:	2302      	movs	r3, #2
}
 800e814:	4618      	mov	r0, r3
 800e816:	b007      	add	sp, #28
 800e818:	f85d fb04 	ldr.w	pc, [sp], #4
 800e81c:	0000      	movs	r0, r0
	...

0800e820 <wc_InitRng_ex>:
#endif /* HAVE_HASHDRBG */
/* End NIST DRBG Code */


int wc_InitRng_ex(WC_RNG* rng, void* heap, int devId)
{
 800e820:	b500      	push	{lr}
 800e822:	b097      	sub	sp, #92	; 0x5c
 800e824:	9007      	str	r0, [sp, #28]
 800e826:	9106      	str	r1, [sp, #24]
 800e828:	9205      	str	r2, [sp, #20]
    int ret = RNG_FAILURE_E;
 800e82a:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800e82e:	9315      	str	r3, [sp, #84]	; 0x54

    if (rng == NULL)
 800e830:	9b07      	ldr	r3, [sp, #28]
 800e832:	2b00      	cmp	r3, #0
 800e834:	d102      	bne.n	800e83c <wc_InitRng_ex+0x1c>
        return BAD_FUNC_ARG;
 800e836:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e83a:	e06d      	b.n	800e918 <wc_InitRng_ex+0xf8>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
 800e83c:	9b07      	ldr	r3, [sp, #28]
 800e83e:	9a06      	ldr	r2, [sp, #24]
 800e840:	605a      	str	r2, [r3, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
 800e842:	9b07      	ldr	r3, [sp, #28]
 800e844:	2200      	movs	r2, #0
 800e846:	609a      	str	r2, [r3, #8]
    rng->status = DRBG_NOT_INIT;
 800e848:	9b07      	ldr	r3, [sp, #28]
 800e84a:	2200      	movs	r2, #0
 800e84c:	731a      	strb	r2, [r3, #12]

#ifdef CUSTOM_RAND_GENERATE_BLOCK
	ret = 0; /* success */
#else
#ifdef HAVE_HASHDRBG
    if (wc_RNG_HealthTestLocal(0) == 0) {
 800e84e:	2000      	movs	r0, #0
 800e850:	f000 f996 	bl	800eb80 <wc_RNG_HealthTestLocal>
 800e854:	4603      	mov	r3, r0
 800e856:	2b00      	cmp	r3, #0
 800e858:	d13b      	bne.n	800e8d2 <wc_InitRng_ex+0xb2>
        DECLARE_VAR(entropy, byte, ENTROPY_NONCE_SZ, rng->heap);

        rng->drbg =
                (struct DRBG*)XMALLOC(sizeof(DRBG), rng->heap,
 800e85a:	9b07      	ldr	r3, [sp, #28]
 800e85c:	685b      	ldr	r3, [r3, #4]
 800e85e:	2178      	movs	r1, #120	; 0x78
 800e860:	4618      	mov	r0, r3
 800e862:	f7f6 fffd 	bl	8005860 <chibios_alloc>
 800e866:	4602      	mov	r2, r0
        rng->drbg =
 800e868:	9b07      	ldr	r3, [sp, #28]
 800e86a:	609a      	str	r2, [r3, #8]
                                                          DYNAMIC_TYPE_RNG);
        if (rng->drbg == NULL) {
 800e86c:	9b07      	ldr	r3, [sp, #28]
 800e86e:	689b      	ldr	r3, [r3, #8]
 800e870:	2b00      	cmp	r3, #0
 800e872:	d103      	bne.n	800e87c <wc_InitRng_ex+0x5c>
            ret = MEMORY_E;
 800e874:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800e878:	9315      	str	r3, [sp, #84]	; 0x54
 800e87a:	e024      	b.n	800e8c6 <wc_InitRng_ex+0xa6>
        }
        /* This doesn't use a separate nonce. The entropy input will be
         * the default size plus the size of the nonce making the seed
         * size. */
        else if (wc_GenerateSeed(&rng->seed, entropy, ENTROPY_NONCE_SZ) == 0 &&
 800e87c:	9b07      	ldr	r3, [sp, #28]
 800e87e:	a909      	add	r1, sp, #36	; 0x24
 800e880:	2230      	movs	r2, #48	; 0x30
 800e882:	4618      	mov	r0, r3
 800e884:	f000 f9dc 	bl	800ec40 <wc_GenerateSeed>
 800e888:	4603      	mov	r3, r0
 800e88a:	2b00      	cmp	r3, #0
 800e88c:	d119      	bne.n	800e8c2 <wc_InitRng_ex+0xa2>
                 Hash_DRBG_Instantiate(rng->drbg, entropy, ENTROPY_NONCE_SZ,
 800e88e:	9b07      	ldr	r3, [sp, #28]
 800e890:	6898      	ldr	r0, [r3, #8]
 800e892:	9b07      	ldr	r3, [sp, #28]
 800e894:	685b      	ldr	r3, [r3, #4]
 800e896:	a909      	add	r1, sp, #36	; 0x24
 800e898:	9a05      	ldr	r2, [sp, #20]
 800e89a:	9202      	str	r2, [sp, #8]
 800e89c:	9301      	str	r3, [sp, #4]
 800e89e:	2300      	movs	r3, #0
 800e8a0:	9300      	str	r3, [sp, #0]
 800e8a2:	2300      	movs	r3, #0
 800e8a4:	2230      	movs	r2, #48	; 0x30
 800e8a6:	f7ff ff4b 	bl	800e740 <Hash_DRBG_Instantiate>
 800e8aa:	4603      	mov	r3, r0
        else if (wc_GenerateSeed(&rng->seed, entropy, ENTROPY_NONCE_SZ) == 0 &&
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d108      	bne.n	800e8c2 <wc_InitRng_ex+0xa2>
                                   NULL, 0, rng->heap, devId) == DRBG_SUCCESS) {
            ret = Hash_DRBG_Generate(rng->drbg, NULL, 0);
 800e8b0:	9b07      	ldr	r3, [sp, #28]
 800e8b2:	689b      	ldr	r3, [r3, #8]
 800e8b4:	2200      	movs	r2, #0
 800e8b6:	2100      	movs	r1, #0
 800e8b8:	4618      	mov	r0, r3
 800e8ba:	f7ff feb9 	bl	800e630 <Hash_DRBG_Generate>
 800e8be:	9015      	str	r0, [sp, #84]	; 0x54
 800e8c0:	e001      	b.n	800e8c6 <wc_InitRng_ex+0xa6>
        }
        else
            ret = DRBG_FAILURE;
 800e8c2:	2302      	movs	r3, #2
 800e8c4:	9315      	str	r3, [sp, #84]	; 0x54

        ForceZero(entropy, ENTROPY_NONCE_SZ);
 800e8c6:	ab09      	add	r3, sp, #36	; 0x24
 800e8c8:	2130      	movs	r1, #48	; 0x30
 800e8ca:	4618      	mov	r0, r3
 800e8cc:	f002 fbe0 	bl	8011090 <ForceZero.lto_priv.475>
 800e8d0:	e001      	b.n	800e8d6 <wc_InitRng_ex+0xb6>
        FREE_VAR(entropy, rng->heap);
    }
    else
        ret = DRBG_CONT_FAILURE;
 800e8d2:	2304      	movs	r3, #4
 800e8d4:	9315      	str	r3, [sp, #84]	; 0x54

    if (ret == DRBG_SUCCESS) {
 800e8d6:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800e8d8:	2b00      	cmp	r3, #0
 800e8da:	d105      	bne.n	800e8e8 <wc_InitRng_ex+0xc8>
        rng->status = DRBG_OK;
 800e8dc:	9b07      	ldr	r3, [sp, #28]
 800e8de:	2201      	movs	r2, #1
 800e8e0:	731a      	strb	r2, [r3, #12]
        ret = 0;
 800e8e2:	2300      	movs	r3, #0
 800e8e4:	9315      	str	r3, [sp, #84]	; 0x54
 800e8e6:	e016      	b.n	800e916 <wc_InitRng_ex+0xf6>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 800e8e8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800e8ea:	2b04      	cmp	r3, #4
 800e8ec:	d106      	bne.n	800e8fc <wc_InitRng_ex+0xdc>
        rng->status = DRBG_CONT_FAILED;
 800e8ee:	9b07      	ldr	r3, [sp, #28]
 800e8f0:	2203      	movs	r2, #3
 800e8f2:	731a      	strb	r2, [r3, #12]
        ret = DRBG_CONT_FIPS_E;
 800e8f4:	f06f 03d0 	mvn.w	r3, #208	; 0xd0
 800e8f8:	9315      	str	r3, [sp, #84]	; 0x54
 800e8fa:	e00c      	b.n	800e916 <wc_InitRng_ex+0xf6>
    }
    else if (ret == DRBG_FAILURE) {
 800e8fc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800e8fe:	2b02      	cmp	r3, #2
 800e900:	d106      	bne.n	800e910 <wc_InitRng_ex+0xf0>
        rng->status = DRBG_FAILED;
 800e902:	9b07      	ldr	r3, [sp, #28]
 800e904:	2202      	movs	r2, #2
 800e906:	731a      	strb	r2, [r3, #12]
        ret = RNG_FAILURE_E;
 800e908:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800e90c:	9315      	str	r3, [sp, #84]	; 0x54
 800e90e:	e002      	b.n	800e916 <wc_InitRng_ex+0xf6>
    }
    else {
        rng->status = DRBG_FAILED;
 800e910:	9b07      	ldr	r3, [sp, #28]
 800e912:	2202      	movs	r2, #2
 800e914:	731a      	strb	r2, [r3, #12]
    }
#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 800e916:	9b15      	ldr	r3, [sp, #84]	; 0x54
}
 800e918:	4618      	mov	r0, r3
 800e91a:	b017      	add	sp, #92	; 0x5c
 800e91c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e920 <wc_InitRng>:

int wc_InitRng(WC_RNG* rng)
{
 800e920:	b500      	push	{lr}
 800e922:	b083      	sub	sp, #12
 800e924:	9001      	str	r0, [sp, #4]
    return wc_InitRng_ex(rng, NULL, INVALID_DEVID);
 800e926:	f06f 0201 	mvn.w	r2, #1
 800e92a:	2100      	movs	r1, #0
 800e92c:	9801      	ldr	r0, [sp, #4]
 800e92e:	f7ff ff77 	bl	800e820 <wc_InitRng_ex>
 800e932:	4603      	mov	r3, r0
}
 800e934:	4618      	mov	r0, r3
 800e936:	b003      	add	sp, #12
 800e938:	f85d fb04 	ldr.w	pc, [sp], #4
 800e93c:	0000      	movs	r0, r0
	...

0800e940 <wc_RNG_GenerateBlock>:


/* place a generated block in output */
int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
{
 800e940:	b500      	push	{lr}
 800e942:	b08f      	sub	sp, #60	; 0x3c
 800e944:	9003      	str	r0, [sp, #12]
 800e946:	9102      	str	r1, [sp, #8]
 800e948:	9201      	str	r2, [sp, #4]
    int ret;

    if (rng == NULL || output == NULL)
 800e94a:	9b03      	ldr	r3, [sp, #12]
 800e94c:	2b00      	cmp	r3, #0
 800e94e:	d002      	beq.n	800e956 <wc_RNG_GenerateBlock+0x16>
 800e950:	9b02      	ldr	r3, [sp, #8]
 800e952:	2b00      	cmp	r3, #0
 800e954:	d102      	bne.n	800e95c <wc_RNG_GenerateBlock+0x1c>
        return BAD_FUNC_ARG;
 800e956:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e95a:	e068      	b.n	800ea2e <wc_RNG_GenerateBlock+0xee>
    XMEMSET(output, 0, sz);
    ret = CUSTOM_RAND_GENERATE_BLOCK(output, sz);
#else

#ifdef HAVE_HASHDRBG
    if (sz > RNG_MAX_BLOCK_LEN)
 800e95c:	9b01      	ldr	r3, [sp, #4]
 800e95e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e962:	d902      	bls.n	800e96a <wc_RNG_GenerateBlock+0x2a>
        return BAD_FUNC_ARG;
 800e964:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800e968:	e061      	b.n	800ea2e <wc_RNG_GenerateBlock+0xee>

    if (rng->status != DRBG_OK)
 800e96a:	9b03      	ldr	r3, [sp, #12]
 800e96c:	7b1b      	ldrb	r3, [r3, #12]
 800e96e:	2b01      	cmp	r3, #1
 800e970:	d002      	beq.n	800e978 <wc_RNG_GenerateBlock+0x38>
        return RNG_FAILURE_E;
 800e972:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800e976:	e05a      	b.n	800ea2e <wc_RNG_GenerateBlock+0xee>

    ret = Hash_DRBG_Generate(rng->drbg, output, sz);
 800e978:	9b03      	ldr	r3, [sp, #12]
 800e97a:	689b      	ldr	r3, [r3, #8]
 800e97c:	9a01      	ldr	r2, [sp, #4]
 800e97e:	9902      	ldr	r1, [sp, #8]
 800e980:	4618      	mov	r0, r3
 800e982:	f7ff fe55 	bl	800e630 <Hash_DRBG_Generate>
 800e986:	900d      	str	r0, [sp, #52]	; 0x34
    if (ret == DRBG_NEED_RESEED) {
 800e988:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e98a:	2b03      	cmp	r3, #3
 800e98c:	d138      	bne.n	800ea00 <wc_RNG_GenerateBlock+0xc0>
        if (wc_RNG_HealthTestLocal(1) == 0) {
 800e98e:	2001      	movs	r0, #1
 800e990:	f000 f8f6 	bl	800eb80 <wc_RNG_HealthTestLocal>
 800e994:	4603      	mov	r3, r0
 800e996:	2b00      	cmp	r3, #0
 800e998:	d130      	bne.n	800e9fc <wc_RNG_GenerateBlock+0xbc>
            byte entropy[ENTROPY_SZ];

            if (wc_GenerateSeed(&rng->seed, entropy, ENTROPY_SZ) == 0 &&
 800e99a:	9b03      	ldr	r3, [sp, #12]
 800e99c:	a905      	add	r1, sp, #20
 800e99e:	2220      	movs	r2, #32
 800e9a0:	4618      	mov	r0, r3
 800e9a2:	f000 f94d 	bl	800ec40 <wc_GenerateSeed>
 800e9a6:	4603      	mov	r3, r0
 800e9a8:	2b00      	cmp	r3, #0
 800e9aa:	d11d      	bne.n	800e9e8 <wc_RNG_GenerateBlock+0xa8>
                Hash_DRBG_Reseed(rng->drbg, entropy, ENTROPY_SZ)
 800e9ac:	9b03      	ldr	r3, [sp, #12]
 800e9ae:	689b      	ldr	r3, [r3, #8]
 800e9b0:	a905      	add	r1, sp, #20
 800e9b2:	2220      	movs	r2, #32
 800e9b4:	4618      	mov	r0, r3
 800e9b6:	f002 fc63 	bl	8011280 <Hash_DRBG_Reseed.lto_priv.474>
 800e9ba:	4603      	mov	r3, r0
            if (wc_GenerateSeed(&rng->seed, entropy, ENTROPY_SZ) == 0 &&
 800e9bc:	2b00      	cmp	r3, #0
 800e9be:	d113      	bne.n	800e9e8 <wc_RNG_GenerateBlock+0xa8>
                                                              == DRBG_SUCCESS) {

                ret = Hash_DRBG_Generate(rng->drbg, NULL, 0);
 800e9c0:	9b03      	ldr	r3, [sp, #12]
 800e9c2:	689b      	ldr	r3, [r3, #8]
 800e9c4:	2200      	movs	r2, #0
 800e9c6:	2100      	movs	r1, #0
 800e9c8:	4618      	mov	r0, r3
 800e9ca:	f7ff fe31 	bl	800e630 <Hash_DRBG_Generate>
 800e9ce:	900d      	str	r0, [sp, #52]	; 0x34
                if (ret == DRBG_SUCCESS)
 800e9d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e9d2:	2b00      	cmp	r3, #0
 800e9d4:	d10b      	bne.n	800e9ee <wc_RNG_GenerateBlock+0xae>
                    ret = Hash_DRBG_Generate(rng->drbg, output, sz);
 800e9d6:	9b03      	ldr	r3, [sp, #12]
 800e9d8:	689b      	ldr	r3, [r3, #8]
 800e9da:	9a01      	ldr	r2, [sp, #4]
 800e9dc:	9902      	ldr	r1, [sp, #8]
 800e9de:	4618      	mov	r0, r3
 800e9e0:	f7ff fe26 	bl	800e630 <Hash_DRBG_Generate>
 800e9e4:	900d      	str	r0, [sp, #52]	; 0x34
 800e9e6:	e003      	b.n	800e9f0 <wc_RNG_GenerateBlock+0xb0>
            }
            else
                ret = DRBG_FAILURE;
 800e9e8:	2302      	movs	r3, #2
 800e9ea:	930d      	str	r3, [sp, #52]	; 0x34
 800e9ec:	e000      	b.n	800e9f0 <wc_RNG_GenerateBlock+0xb0>
                    ret = Hash_DRBG_Generate(rng->drbg, output, sz);
 800e9ee:	bf00      	nop

            ForceZero(entropy, ENTROPY_SZ);
 800e9f0:	ab05      	add	r3, sp, #20
 800e9f2:	2120      	movs	r1, #32
 800e9f4:	4618      	mov	r0, r3
 800e9f6:	f002 fb4b 	bl	8011090 <ForceZero.lto_priv.475>
 800e9fa:	e001      	b.n	800ea00 <wc_RNG_GenerateBlock+0xc0>
        }
        else
            ret = DRBG_CONT_FAILURE;
 800e9fc:	2304      	movs	r3, #4
 800e9fe:	930d      	str	r3, [sp, #52]	; 0x34
    }

    if (ret == DRBG_SUCCESS) {
 800ea00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ea02:	2b00      	cmp	r3, #0
 800ea04:	d102      	bne.n	800ea0c <wc_RNG_GenerateBlock+0xcc>
        ret = 0;
 800ea06:	2300      	movs	r3, #0
 800ea08:	930d      	str	r3, [sp, #52]	; 0x34
 800ea0a:	e00f      	b.n	800ea2c <wc_RNG_GenerateBlock+0xec>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 800ea0c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ea0e:	2b04      	cmp	r3, #4
 800ea10:	d106      	bne.n	800ea20 <wc_RNG_GenerateBlock+0xe0>
        ret = DRBG_CONT_FIPS_E;
 800ea12:	f06f 03d0 	mvn.w	r3, #208	; 0xd0
 800ea16:	930d      	str	r3, [sp, #52]	; 0x34
        rng->status = DRBG_CONT_FAILED;
 800ea18:	9b03      	ldr	r3, [sp, #12]
 800ea1a:	2203      	movs	r2, #3
 800ea1c:	731a      	strb	r2, [r3, #12]
 800ea1e:	e005      	b.n	800ea2c <wc_RNG_GenerateBlock+0xec>
    }
    else {
        ret = RNG_FAILURE_E;
 800ea20:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800ea24:	930d      	str	r3, [sp, #52]	; 0x34
        rng->status = DRBG_FAILED;
 800ea26:	9b03      	ldr	r3, [sp, #12]
 800ea28:	2202      	movs	r2, #2
 800ea2a:	731a      	strb	r2, [r3, #12]
    ret = RNG_FAILURE_E;

#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 800ea2c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
 800ea2e:	4618      	mov	r0, r3
 800ea30:	b00f      	add	sp, #60	; 0x3c
 800ea32:	f85d fb04 	ldr.w	pc, [sp], #4
 800ea36:	bf00      	nop
	...

0800ea40 <wc_FreeRng>:
    return wc_RNG_GenerateBlock(rng, b, 1);
}


int wc_FreeRng(WC_RNG* rng)
{
 800ea40:	b500      	push	{lr}
 800ea42:	b085      	sub	sp, #20
 800ea44:	9001      	str	r0, [sp, #4]
    int ret = 0;
 800ea46:	2300      	movs	r3, #0
 800ea48:	9303      	str	r3, [sp, #12]

    if (rng == NULL)
 800ea4a:	9b01      	ldr	r3, [sp, #4]
 800ea4c:	2b00      	cmp	r3, #0
 800ea4e:	d102      	bne.n	800ea56 <wc_FreeRng+0x16>
        return BAD_FUNC_ARG;
 800ea50:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ea54:	e01a      	b.n	800ea8c <wc_FreeRng+0x4c>
#if defined(WOLFSSL_ASYNC_CRYPT)
    wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
#endif

#ifdef HAVE_HASHDRBG
    if (rng->drbg != NULL) {
 800ea56:	9b01      	ldr	r3, [sp, #4]
 800ea58:	689b      	ldr	r3, [r3, #8]
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	d012      	beq.n	800ea84 <wc_FreeRng+0x44>
        if (Hash_DRBG_Uninstantiate(rng->drbg) != DRBG_SUCCESS)
 800ea5e:	9b01      	ldr	r3, [sp, #4]
 800ea60:	689b      	ldr	r3, [r3, #8]
 800ea62:	4618      	mov	r0, r3
 800ea64:	f7ff feb4 	bl	800e7d0 <Hash_DRBG_Uninstantiate>
 800ea68:	4603      	mov	r3, r0
 800ea6a:	2b00      	cmp	r3, #0
 800ea6c:	d002      	beq.n	800ea74 <wc_FreeRng+0x34>
            ret = RNG_FAILURE_E;
 800ea6e:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
 800ea72:	9303      	str	r3, [sp, #12]

        XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 800ea74:	9b01      	ldr	r3, [sp, #4]
 800ea76:	689b      	ldr	r3, [r3, #8]
 800ea78:	4618      	mov	r0, r3
 800ea7a:	f7f6 ff01 	bl	8005880 <chibios_free>
        rng->drbg = NULL;
 800ea7e:	9b01      	ldr	r3, [sp, #4]
 800ea80:	2200      	movs	r2, #0
 800ea82:	609a      	str	r2, [r3, #8]
    }

    rng->status = DRBG_NOT_INIT;
 800ea84:	9b01      	ldr	r3, [sp, #4]
 800ea86:	2200      	movs	r2, #0
 800ea88:	731a      	strb	r2, [r3, #12]
#endif /* HAVE_HASHDRBG */

    return ret;
 800ea8a:	9b03      	ldr	r3, [sp, #12]
}
 800ea8c:	4618      	mov	r0, r3
 800ea8e:	b005      	add	sp, #20
 800ea90:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800eaa0 <wc_RNG_HealthTest>:

#ifdef HAVE_HASHDRBG
int wc_RNG_HealthTest(int reseed, const byte* entropyA, word32 entropyASz,
                                  const byte* entropyB, word32 entropyBSz,
                                  byte* output, word32 outputSz)
{
 800eaa0:	b500      	push	{lr}
 800eaa2:	b08b      	sub	sp, #44	; 0x2c
 800eaa4:	9007      	str	r0, [sp, #28]
 800eaa6:	9106      	str	r1, [sp, #24]
 800eaa8:	9205      	str	r2, [sp, #20]
 800eaaa:	9304      	str	r3, [sp, #16]
    int ret = -1;
 800eaac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800eab0:	9309      	str	r3, [sp, #36]	; 0x24
    DRBG* drbg;
#ifndef WOLFSSL_SMALL_STACK
    DRBG  drbg_var;
#endif

    if (entropyA == NULL || output == NULL) {
 800eab2:	9b06      	ldr	r3, [sp, #24]
 800eab4:	2b00      	cmp	r3, #0
 800eab6:	d002      	beq.n	800eabe <wc_RNG_HealthTest+0x1e>
 800eab8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800eaba:	2b00      	cmp	r3, #0
 800eabc:	d102      	bne.n	800eac4 <wc_RNG_HealthTest+0x24>
        return BAD_FUNC_ARG;
 800eabe:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800eac2:	e052      	b.n	800eb6a <wc_RNG_HealthTest+0xca>
    }

    if (reseed != 0 && entropyB == NULL) {
 800eac4:	9b07      	ldr	r3, [sp, #28]
 800eac6:	2b00      	cmp	r3, #0
 800eac8:	d005      	beq.n	800ead6 <wc_RNG_HealthTest+0x36>
 800eaca:	9b04      	ldr	r3, [sp, #16]
 800eacc:	2b00      	cmp	r3, #0
 800eace:	d102      	bne.n	800ead6 <wc_RNG_HealthTest+0x36>
        return BAD_FUNC_ARG;
 800ead0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800ead4:	e049      	b.n	800eb6a <wc_RNG_HealthTest+0xca>
    }

    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
 800ead6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800ead8:	2b80      	cmp	r3, #128	; 0x80
 800eada:	d001      	beq.n	800eae0 <wc_RNG_HealthTest+0x40>
        return ret;
 800eadc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800eade:	e044      	b.n	800eb6a <wc_RNG_HealthTest+0xca>
    }

#ifdef WOLFSSL_SMALL_STACK
    drbg = (struct DRBG*)XMALLOC(sizeof(DRBG), NULL, DYNAMIC_TYPE_RNG);
 800eae0:	2178      	movs	r1, #120	; 0x78
 800eae2:	2000      	movs	r0, #0
 800eae4:	f7f6 febc 	bl	8005860 <chibios_alloc>
 800eae8:	9008      	str	r0, [sp, #32]
    if (drbg == NULL) {
 800eaea:	9b08      	ldr	r3, [sp, #32]
 800eaec:	2b00      	cmp	r3, #0
 800eaee:	d102      	bne.n	800eaf6 <wc_RNG_HealthTest+0x56>
        return MEMORY_E;
 800eaf0:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800eaf4:	e039      	b.n	800eb6a <wc_RNG_HealthTest+0xca>
    }
#else
    drbg = &drbg_var;
#endif

    if (Hash_DRBG_Instantiate(drbg, entropyA, entropyASz, NULL, 0, NULL,
 800eaf6:	f06f 0301 	mvn.w	r3, #1
 800eafa:	9302      	str	r3, [sp, #8]
 800eafc:	2300      	movs	r3, #0
 800eafe:	9301      	str	r3, [sp, #4]
 800eb00:	2300      	movs	r3, #0
 800eb02:	9300      	str	r3, [sp, #0]
 800eb04:	2300      	movs	r3, #0
 800eb06:	9a05      	ldr	r2, [sp, #20]
 800eb08:	9906      	ldr	r1, [sp, #24]
 800eb0a:	9808      	ldr	r0, [sp, #32]
 800eb0c:	f7ff fe18 	bl	800e740 <Hash_DRBG_Instantiate>
 800eb10:	4603      	mov	r3, r0
 800eb12:	2b00      	cmp	r3, #0
 800eb14:	d11c      	bne.n	800eb50 <wc_RNG_HealthTest+0xb0>
                                                    INVALID_DEVID) != 0) {
        goto exit_rng_ht;
    }

    if (reseed) {
 800eb16:	9b07      	ldr	r3, [sp, #28]
 800eb18:	2b00      	cmp	r3, #0
 800eb1a:	d007      	beq.n	800eb2c <wc_RNG_HealthTest+0x8c>
        if (Hash_DRBG_Reseed(drbg, entropyB, entropyBSz) != 0) {
 800eb1c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800eb1e:	9904      	ldr	r1, [sp, #16]
 800eb20:	9808      	ldr	r0, [sp, #32]
 800eb22:	f002 fbad 	bl	8011280 <Hash_DRBG_Reseed.lto_priv.474>
 800eb26:	4603      	mov	r3, r0
 800eb28:	2b00      	cmp	r3, #0
 800eb2a:	d111      	bne.n	800eb50 <wc_RNG_HealthTest+0xb0>
            goto exit_rng_ht;
        }
    }

    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 800eb2c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800eb2e:	990d      	ldr	r1, [sp, #52]	; 0x34
 800eb30:	9808      	ldr	r0, [sp, #32]
 800eb32:	f7ff fd7d 	bl	800e630 <Hash_DRBG_Generate>
 800eb36:	4603      	mov	r3, r0
 800eb38:	2b00      	cmp	r3, #0
 800eb3a:	d109      	bne.n	800eb50 <wc_RNG_HealthTest+0xb0>
        goto exit_rng_ht;
    }

    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 800eb3c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800eb3e:	990d      	ldr	r1, [sp, #52]	; 0x34
 800eb40:	9808      	ldr	r0, [sp, #32]
 800eb42:	f7ff fd75 	bl	800e630 <Hash_DRBG_Generate>
 800eb46:	4603      	mov	r3, r0
 800eb48:	2b00      	cmp	r3, #0
 800eb4a:	d101      	bne.n	800eb50 <wc_RNG_HealthTest+0xb0>
        goto exit_rng_ht;
    }

    /* Mark success */
    ret = 0;
 800eb4c:	2300      	movs	r3, #0
 800eb4e:	9309      	str	r3, [sp, #36]	; 0x24

exit_rng_ht:

    /* This is safe to call even if Hash_DRBG_Instantiate fails */
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
 800eb50:	9808      	ldr	r0, [sp, #32]
 800eb52:	f7ff fe3d 	bl	800e7d0 <Hash_DRBG_Uninstantiate>
 800eb56:	4603      	mov	r3, r0
 800eb58:	2b00      	cmp	r3, #0
 800eb5a:	d002      	beq.n	800eb62 <wc_RNG_HealthTest+0xc2>
        ret = -1;
 800eb5c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800eb60:	9309      	str	r3, [sp, #36]	; 0x24
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(drbg, NULL, DYNAMIC_TYPE_RNG);
 800eb62:	9808      	ldr	r0, [sp, #32]
 800eb64:	f7f6 fe8c 	bl	8005880 <chibios_free>
#endif

    return ret;
 800eb68:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800eb6a:	4618      	mov	r0, r3
 800eb6c:	b00b      	add	sp, #44	; 0x2c
 800eb6e:	f85d fb04 	ldr.w	pc, [sp], #4
 800eb72:	bf00      	nop
	...

0800eb80 <wc_RNG_HealthTestLocal>:
    0xd4, 0x31, 0xf4, 0xc9, 0xf7, 0x04, 0x27, 0xdf
};


static int wc_RNG_HealthTestLocal(int reseed)
{
 800eb80:	b500      	push	{lr}
 800eb82:	b089      	sub	sp, #36	; 0x24
 800eb84:	9005      	str	r0, [sp, #20]
    int ret = 0;
 800eb86:	2300      	movs	r3, #0
 800eb88:	9307      	str	r3, [sp, #28]
#else
    byte  check[RNG_HEALTH_TEST_CHECK_SIZE];
#endif

#ifdef WOLFSSL_SMALL_STACK
    check = (byte*)XMALLOC(RNG_HEALTH_TEST_CHECK_SIZE, NULL,
 800eb8a:	2180      	movs	r1, #128	; 0x80
 800eb8c:	2000      	movs	r0, #0
 800eb8e:	f7f6 fe67 	bl	8005860 <chibios_alloc>
 800eb92:	9006      	str	r0, [sp, #24]
                           DYNAMIC_TYPE_TMP_BUFFER);
    if (check == NULL) {
 800eb94:	9b06      	ldr	r3, [sp, #24]
 800eb96:	2b00      	cmp	r3, #0
 800eb98:	d102      	bne.n	800eba0 <wc_RNG_HealthTestLocal+0x20>
        return MEMORY_E;
 800eb9a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 800eb9e:	e03f      	b.n	800ec20 <wc_RNG_HealthTestLocal+0xa0>
    }
#endif

    if (reseed) {
 800eba0:	9b05      	ldr	r3, [sp, #20]
 800eba2:	2b00      	cmp	r3, #0
 800eba4:	d01b      	beq.n	800ebde <wc_RNG_HealthTestLocal+0x5e>
        ret = wc_RNG_HealthTest(1, entropyA, sizeof(entropyA),
 800eba6:	2380      	movs	r3, #128	; 0x80
 800eba8:	9302      	str	r3, [sp, #8]
 800ebaa:	9b06      	ldr	r3, [sp, #24]
 800ebac:	9301      	str	r3, [sp, #4]
 800ebae:	2320      	movs	r3, #32
 800ebb0:	9300      	str	r3, [sp, #0]
 800ebb2:	4b1d      	ldr	r3, [pc, #116]	; (800ec28 <wc_RNG_HealthTestLocal+0xa8>)
 800ebb4:	2230      	movs	r2, #48	; 0x30
 800ebb6:	491d      	ldr	r1, [pc, #116]	; (800ec2c <wc_RNG_HealthTestLocal+0xac>)
 800ebb8:	2001      	movs	r0, #1
 800ebba:	f7ff ff71 	bl	800eaa0 <wc_RNG_HealthTest>
 800ebbe:	9007      	str	r0, [sp, #28]
                                reseedEntropyA, sizeof(reseedEntropyA),
                                check, RNG_HEALTH_TEST_CHECK_SIZE);
        if (ret == 0) {
 800ebc0:	9b07      	ldr	r3, [sp, #28]
 800ebc2:	2b00      	cmp	r3, #0
 800ebc4:	d127      	bne.n	800ec16 <wc_RNG_HealthTestLocal+0x96>
            if (ConstantCompare(check, outputA,
 800ebc6:	2280      	movs	r2, #128	; 0x80
 800ebc8:	4919      	ldr	r1, [pc, #100]	; (800ec30 <wc_RNG_HealthTestLocal+0xb0>)
 800ebca:	9806      	ldr	r0, [sp, #24]
 800ebcc:	f002 fa78 	bl	80110c0 <ConstantCompare.lto_priv.473>
 800ebd0:	4603      	mov	r3, r0
 800ebd2:	2b00      	cmp	r3, #0
 800ebd4:	d01f      	beq.n	800ec16 <wc_RNG_HealthTestLocal+0x96>
                                RNG_HEALTH_TEST_CHECK_SIZE) != 0)
                ret = -1;
 800ebd6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ebda:	9307      	str	r3, [sp, #28]
 800ebdc:	e01c      	b.n	800ec18 <wc_RNG_HealthTestLocal+0x98>
        }
    }
    else {
        ret = wc_RNG_HealthTest(0, entropyB, sizeof(entropyB),
 800ebde:	2380      	movs	r3, #128	; 0x80
 800ebe0:	9302      	str	r3, [sp, #8]
 800ebe2:	9b06      	ldr	r3, [sp, #24]
 800ebe4:	9301      	str	r3, [sp, #4]
 800ebe6:	2300      	movs	r3, #0
 800ebe8:	9300      	str	r3, [sp, #0]
 800ebea:	2300      	movs	r3, #0
 800ebec:	2230      	movs	r2, #48	; 0x30
 800ebee:	4911      	ldr	r1, [pc, #68]	; (800ec34 <wc_RNG_HealthTestLocal+0xb4>)
 800ebf0:	2000      	movs	r0, #0
 800ebf2:	f7ff ff55 	bl	800eaa0 <wc_RNG_HealthTest>
 800ebf6:	9007      	str	r0, [sp, #28]
                                NULL, 0,
                                check, RNG_HEALTH_TEST_CHECK_SIZE);
        if (ret == 0) {
 800ebf8:	9b07      	ldr	r3, [sp, #28]
 800ebfa:	2b00      	cmp	r3, #0
 800ebfc:	d10c      	bne.n	800ec18 <wc_RNG_HealthTestLocal+0x98>
            if (ConstantCompare(check, outputB,
 800ebfe:	2280      	movs	r2, #128	; 0x80
 800ec00:	490d      	ldr	r1, [pc, #52]	; (800ec38 <wc_RNG_HealthTestLocal+0xb8>)
 800ec02:	9806      	ldr	r0, [sp, #24]
 800ec04:	f002 fa5c 	bl	80110c0 <ConstantCompare.lto_priv.473>
 800ec08:	4603      	mov	r3, r0
 800ec0a:	2b00      	cmp	r3, #0
 800ec0c:	d004      	beq.n	800ec18 <wc_RNG_HealthTestLocal+0x98>
                                RNG_HEALTH_TEST_CHECK_SIZE) != 0)
                ret = -1;
 800ec0e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ec12:	9307      	str	r3, [sp, #28]
 800ec14:	e000      	b.n	800ec18 <wc_RNG_HealthTestLocal+0x98>
                ret = -1;
 800ec16:	bf00      	nop
        }
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(check, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 800ec18:	9806      	ldr	r0, [sp, #24]
 800ec1a:	f7f6 fe31 	bl	8005880 <chibios_free>
#endif

    return ret;
 800ec1e:	9b07      	ldr	r3, [sp, #28]
}
 800ec20:	4618      	mov	r0, r3
 800ec22:	b009      	add	sp, #36	; 0x24
 800ec24:	f85d fb04 	ldr.w	pc, [sp], #4
 800ec28:	08024278 	.word	0x08024278
 800ec2c:	08024248 	.word	0x08024248
 800ec30:	08024298 	.word	0x08024298
 800ec34:	08024318 	.word	0x08024318
 800ec38:	08024348 	.word	0x08024348
 800ec3c:	00000000 	.word	0x00000000

0800ec40 <wc_GenerateSeed>:
    #else
        #pragma message("Warning: write a real random seed!!!!, just for testing now")
    #endif

    int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
    {
 800ec40:	b086      	sub	sp, #24
 800ec42:	9003      	str	r0, [sp, #12]
 800ec44:	9102      	str	r1, [sp, #8]
 800ec46:	9201      	str	r2, [sp, #4]
        word32 i;
        for (i = 0; i < sz; i++ )
 800ec48:	2300      	movs	r3, #0
 800ec4a:	9305      	str	r3, [sp, #20]
 800ec4c:	e008      	b.n	800ec60 <wc_GenerateSeed+0x20>
            output[i] = i;
 800ec4e:	9a02      	ldr	r2, [sp, #8]
 800ec50:	9b05      	ldr	r3, [sp, #20]
 800ec52:	4413      	add	r3, r2
 800ec54:	9a05      	ldr	r2, [sp, #20]
 800ec56:	b2d2      	uxtb	r2, r2
 800ec58:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < sz; i++ )
 800ec5a:	9b05      	ldr	r3, [sp, #20]
 800ec5c:	3301      	adds	r3, #1
 800ec5e:	9305      	str	r3, [sp, #20]
 800ec60:	9a05      	ldr	r2, [sp, #20]
 800ec62:	9b01      	ldr	r3, [sp, #4]
 800ec64:	429a      	cmp	r2, r3
 800ec66:	d3f2      	bcc.n	800ec4e <wc_GenerateSeed+0xe>

        (void)os;

        return 0;
 800ec68:	2300      	movs	r3, #0
    }
 800ec6a:	4618      	mov	r0, r3
 800ec6c:	b006      	add	sp, #24
 800ec6e:	4770      	bx	lr

0800ec70 <GetLength>:
{
 800ec70:	b088      	sub	sp, #32
 800ec72:	9003      	str	r0, [sp, #12]
 800ec74:	9102      	str	r1, [sp, #8]
 800ec76:	9201      	str	r2, [sp, #4]
 800ec78:	9300      	str	r3, [sp, #0]
    int     length = 0;
 800ec7a:	2300      	movs	r3, #0
 800ec7c:	9307      	str	r3, [sp, #28]
    word32  idx = *inOutIdx;
 800ec7e:	9b02      	ldr	r3, [sp, #8]
 800ec80:	681b      	ldr	r3, [r3, #0]
 800ec82:	9306      	str	r3, [sp, #24]
    *len = 0;    /* default length */
 800ec84:	9b01      	ldr	r3, [sp, #4]
 800ec86:	2200      	movs	r2, #0
 800ec88:	601a      	str	r2, [r3, #0]
    if ((idx + 1) > maxIdx) {   /* for first read */
 800ec8a:	9b06      	ldr	r3, [sp, #24]
 800ec8c:	1c5a      	adds	r2, r3, #1
 800ec8e:	9b00      	ldr	r3, [sp, #0]
 800ec90:	429a      	cmp	r2, r3
 800ec92:	d902      	bls.n	800ec9a <GetLength+0x2a>
        return BUFFER_E;
 800ec94:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800ec98:	e043      	b.n	800ed22 <GetLength+0xb2>
    b = input[idx++];
 800ec9a:	9b06      	ldr	r3, [sp, #24]
 800ec9c:	1c5a      	adds	r2, r3, #1
 800ec9e:	9206      	str	r2, [sp, #24]
 800eca0:	9a03      	ldr	r2, [sp, #12]
 800eca2:	4413      	add	r3, r2
 800eca4:	781b      	ldrb	r3, [r3, #0]
 800eca6:	f88d 3013 	strb.w	r3, [sp, #19]
    if (b >= ASN_LONG_LENGTH) {
 800ecaa:	f99d 3013 	ldrsb.w	r3, [sp, #19]
 800ecae:	2b00      	cmp	r3, #0
 800ecb0:	da21      	bge.n	800ecf6 <GetLength+0x86>
        word32 bytes = b & 0x7F;
 800ecb2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800ecb6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ecba:	9305      	str	r3, [sp, #20]
        if ((idx + bytes) > maxIdx) {   /* for reading bytes */
 800ecbc:	9a06      	ldr	r2, [sp, #24]
 800ecbe:	9b05      	ldr	r3, [sp, #20]
 800ecc0:	441a      	add	r2, r3
 800ecc2:	9b00      	ldr	r3, [sp, #0]
 800ecc4:	429a      	cmp	r2, r3
 800ecc6:	d910      	bls.n	800ecea <GetLength+0x7a>
            return BUFFER_E;
 800ecc8:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800eccc:	e029      	b.n	800ed22 <GetLength+0xb2>
            b = input[idx++];
 800ecce:	9b06      	ldr	r3, [sp, #24]
 800ecd0:	1c5a      	adds	r2, r3, #1
 800ecd2:	9206      	str	r2, [sp, #24]
 800ecd4:	9a03      	ldr	r2, [sp, #12]
 800ecd6:	4413      	add	r3, r2
 800ecd8:	781b      	ldrb	r3, [r3, #0]
 800ecda:	f88d 3013 	strb.w	r3, [sp, #19]
            length = (length << 8) | b;
 800ecde:	9b07      	ldr	r3, [sp, #28]
 800ece0:	021a      	lsls	r2, r3, #8
 800ece2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800ece6:	4313      	orrs	r3, r2
 800ece8:	9307      	str	r3, [sp, #28]
        while (bytes--) {
 800ecea:	9b05      	ldr	r3, [sp, #20]
 800ecec:	1e5a      	subs	r2, r3, #1
 800ecee:	9205      	str	r2, [sp, #20]
 800ecf0:	2b00      	cmp	r3, #0
 800ecf2:	d1ec      	bne.n	800ecce <GetLength+0x5e>
 800ecf4:	e002      	b.n	800ecfc <GetLength+0x8c>
        length = b;
 800ecf6:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800ecfa:	9307      	str	r3, [sp, #28]
    if ((idx + length) > maxIdx) {   /* for user of length */
 800ecfc:	9a07      	ldr	r2, [sp, #28]
 800ecfe:	9b06      	ldr	r3, [sp, #24]
 800ed00:	441a      	add	r2, r3
 800ed02:	9b00      	ldr	r3, [sp, #0]
 800ed04:	429a      	cmp	r2, r3
 800ed06:	d902      	bls.n	800ed0e <GetLength+0x9e>
        return BUFFER_E;
 800ed08:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800ed0c:	e009      	b.n	800ed22 <GetLength+0xb2>
    *inOutIdx = idx;
 800ed0e:	9b02      	ldr	r3, [sp, #8]
 800ed10:	9a06      	ldr	r2, [sp, #24]
 800ed12:	601a      	str	r2, [r3, #0]
    if (length > 0)
 800ed14:	9b07      	ldr	r3, [sp, #28]
 800ed16:	2b00      	cmp	r3, #0
 800ed18:	dd02      	ble.n	800ed20 <GetLength+0xb0>
        *len = length;
 800ed1a:	9b01      	ldr	r3, [sp, #4]
 800ed1c:	9a07      	ldr	r2, [sp, #28]
 800ed1e:	601a      	str	r2, [r3, #0]
    return length;
 800ed20:	9b07      	ldr	r3, [sp, #28]
}
 800ed22:	4618      	mov	r0, r3
 800ed24:	b008      	add	sp, #32
 800ed26:	4770      	bx	lr
	...

0800ed30 <GetASNHeader>:
{
 800ed30:	b500      	push	{lr}
 800ed32:	b089      	sub	sp, #36	; 0x24
 800ed34:	9003      	str	r0, [sp, #12]
 800ed36:	9201      	str	r2, [sp, #4]
 800ed38:	9300      	str	r3, [sp, #0]
 800ed3a:	460b      	mov	r3, r1
 800ed3c:	f88d 300b 	strb.w	r3, [sp, #11]
    word32 idx = *inOutIdx;
 800ed40:	9b01      	ldr	r3, [sp, #4]
 800ed42:	681b      	ldr	r3, [r3, #0]
 800ed44:	9306      	str	r3, [sp, #24]
    if ((idx + 1) > maxIdx)
 800ed46:	9b06      	ldr	r3, [sp, #24]
 800ed48:	1c5a      	adds	r2, r3, #1
 800ed4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ed4c:	429a      	cmp	r2, r3
 800ed4e:	d902      	bls.n	800ed56 <GetASNHeader+0x26>
        return BUFFER_E;
 800ed50:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800ed54:	e023      	b.n	800ed9e <GetASNHeader+0x6e>
    b = input[idx++];
 800ed56:	9b06      	ldr	r3, [sp, #24]
 800ed58:	1c5a      	adds	r2, r3, #1
 800ed5a:	9206      	str	r2, [sp, #24]
 800ed5c:	9a03      	ldr	r2, [sp, #12]
 800ed5e:	4413      	add	r3, r2
 800ed60:	781b      	ldrb	r3, [r3, #0]
 800ed62:	f88d 301f 	strb.w	r3, [sp, #31]
    if (b != tag)
 800ed66:	f89d 201f 	ldrb.w	r2, [sp, #31]
 800ed6a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800ed6e:	429a      	cmp	r2, r3
 800ed70:	d002      	beq.n	800ed78 <GetASNHeader+0x48>
        return ASN_PARSE_E;
 800ed72:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ed76:	e012      	b.n	800ed9e <GetASNHeader+0x6e>
    if (GetLength(input, &idx, &length, maxIdx) < 0)
 800ed78:	aa05      	add	r2, sp, #20
 800ed7a:	a906      	add	r1, sp, #24
 800ed7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ed7e:	9803      	ldr	r0, [sp, #12]
 800ed80:	f7ff ff76 	bl	800ec70 <GetLength>
 800ed84:	4603      	mov	r3, r0
 800ed86:	2b00      	cmp	r3, #0
 800ed88:	da02      	bge.n	800ed90 <GetASNHeader+0x60>
        return ASN_PARSE_E;
 800ed8a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ed8e:	e006      	b.n	800ed9e <GetASNHeader+0x6e>
    *len      = length;
 800ed90:	9a05      	ldr	r2, [sp, #20]
 800ed92:	9b00      	ldr	r3, [sp, #0]
 800ed94:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 800ed96:	9a06      	ldr	r2, [sp, #24]
 800ed98:	9b01      	ldr	r3, [sp, #4]
 800ed9a:	601a      	str	r2, [r3, #0]
    return length;
 800ed9c:	9b05      	ldr	r3, [sp, #20]
}
 800ed9e:	4618      	mov	r0, r3
 800eda0:	b009      	add	sp, #36	; 0x24
 800eda2:	f85d fb04 	ldr.w	pc, [sp], #4
 800eda6:	bf00      	nop
	...

0800edb0 <GetSequence>:
{
 800edb0:	b500      	push	{lr}
 800edb2:	b087      	sub	sp, #28
 800edb4:	9005      	str	r0, [sp, #20]
 800edb6:	9104      	str	r1, [sp, #16]
 800edb8:	9203      	str	r2, [sp, #12]
 800edba:	9302      	str	r3, [sp, #8]
    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 800edbc:	9b02      	ldr	r3, [sp, #8]
 800edbe:	9300      	str	r3, [sp, #0]
 800edc0:	9b03      	ldr	r3, [sp, #12]
 800edc2:	9a04      	ldr	r2, [sp, #16]
 800edc4:	2130      	movs	r1, #48	; 0x30
 800edc6:	9805      	ldr	r0, [sp, #20]
 800edc8:	f7ff ffb2 	bl	800ed30 <GetASNHeader>
 800edcc:	4603      	mov	r3, r0
}
 800edce:	4618      	mov	r0, r3
 800edd0:	b007      	add	sp, #28
 800edd2:	f85d fb04 	ldr.w	pc, [sp], #4
 800edd6:	bf00      	nop
	...

0800ede0 <GetASNNull>:
{
 800ede0:	b086      	sub	sp, #24
 800ede2:	9003      	str	r0, [sp, #12]
 800ede4:	9102      	str	r1, [sp, #8]
 800ede6:	9201      	str	r2, [sp, #4]
    word32 idx = *inOutIdx;
 800ede8:	9b02      	ldr	r3, [sp, #8]
 800edea:	681b      	ldr	r3, [r3, #0]
 800edec:	9305      	str	r3, [sp, #20]
    if ((idx + 2) > maxIdx)
 800edee:	9b05      	ldr	r3, [sp, #20]
 800edf0:	1c9a      	adds	r2, r3, #2
 800edf2:	9b01      	ldr	r3, [sp, #4]
 800edf4:	429a      	cmp	r2, r3
 800edf6:	d902      	bls.n	800edfe <GetASNNull+0x1e>
        return BUFFER_E;
 800edf8:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800edfc:	e01d      	b.n	800ee3a <GetASNNull+0x5a>
    b = input[idx++];
 800edfe:	9b05      	ldr	r3, [sp, #20]
 800ee00:	1c5a      	adds	r2, r3, #1
 800ee02:	9205      	str	r2, [sp, #20]
 800ee04:	9a03      	ldr	r2, [sp, #12]
 800ee06:	4413      	add	r3, r2
 800ee08:	781b      	ldrb	r3, [r3, #0]
 800ee0a:	f88d 3013 	strb.w	r3, [sp, #19]
    if (b != ASN_TAG_NULL)
 800ee0e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800ee12:	2b05      	cmp	r3, #5
 800ee14:	d002      	beq.n	800ee1c <GetASNNull+0x3c>
        return ASN_TAG_NULL_E;
 800ee16:	f06f 0390 	mvn.w	r3, #144	; 0x90
 800ee1a:	e00e      	b.n	800ee3a <GetASNNull+0x5a>
    if (input[idx++] != 0)
 800ee1c:	9b05      	ldr	r3, [sp, #20]
 800ee1e:	1c5a      	adds	r2, r3, #1
 800ee20:	9205      	str	r2, [sp, #20]
 800ee22:	9a03      	ldr	r2, [sp, #12]
 800ee24:	4413      	add	r3, r2
 800ee26:	781b      	ldrb	r3, [r3, #0]
 800ee28:	2b00      	cmp	r3, #0
 800ee2a:	d002      	beq.n	800ee32 <GetASNNull+0x52>
        return ASN_EXPECT_0_E;
 800ee2c:	f06f 0391 	mvn.w	r3, #145	; 0x91
 800ee30:	e003      	b.n	800ee3a <GetASNNull+0x5a>
    *inOutIdx = idx;
 800ee32:	9b02      	ldr	r3, [sp, #8]
 800ee34:	9a05      	ldr	r2, [sp, #20]
 800ee36:	601a      	str	r2, [r3, #0]
    return 0;
 800ee38:	2300      	movs	r3, #0
}
 800ee3a:	4618      	mov	r0, r3
 800ee3c:	b006      	add	sp, #24
 800ee3e:	4770      	bx	lr

0800ee40 <SetASNNull.lto_priv.407>:
{
 800ee40:	b082      	sub	sp, #8
 800ee42:	9001      	str	r0, [sp, #4]
    output[0] = ASN_TAG_NULL;
 800ee44:	9b01      	ldr	r3, [sp, #4]
 800ee46:	2205      	movs	r2, #5
 800ee48:	701a      	strb	r2, [r3, #0]
    output[1] = 0;
 800ee4a:	9b01      	ldr	r3, [sp, #4]
 800ee4c:	3301      	adds	r3, #1
 800ee4e:	2200      	movs	r2, #0
 800ee50:	701a      	strb	r2, [r3, #0]
    return 2;
 800ee52:	2302      	movs	r3, #2
}
 800ee54:	4618      	mov	r0, r3
 800ee56:	b002      	add	sp, #8
 800ee58:	4770      	bx	lr
 800ee5a:	bf00      	nop
 800ee5c:	0000      	movs	r0, r0
	...

0800ee60 <GetOctetString.lto_priv.403>:
{
 800ee60:	b500      	push	{lr}
 800ee62:	b087      	sub	sp, #28
 800ee64:	9005      	str	r0, [sp, #20]
 800ee66:	9104      	str	r1, [sp, #16]
 800ee68:	9203      	str	r2, [sp, #12]
 800ee6a:	9302      	str	r3, [sp, #8]
    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);
 800ee6c:	9b02      	ldr	r3, [sp, #8]
 800ee6e:	9300      	str	r3, [sp, #0]
 800ee70:	9b03      	ldr	r3, [sp, #12]
 800ee72:	9a04      	ldr	r2, [sp, #16]
 800ee74:	2104      	movs	r1, #4
 800ee76:	9805      	ldr	r0, [sp, #20]
 800ee78:	f7ff ff5a 	bl	800ed30 <GetASNHeader>
 800ee7c:	4603      	mov	r3, r0
}
 800ee7e:	4618      	mov	r0, r3
 800ee80:	b007      	add	sp, #28
 800ee82:	f85d fb04 	ldr.w	pc, [sp], #4
 800ee86:	bf00      	nop
	...

0800ee90 <GetASNInt.lto_priv.391>:
{
 800ee90:	b500      	push	{lr}
 800ee92:	b089      	sub	sp, #36	; 0x24
 800ee94:	9005      	str	r0, [sp, #20]
 800ee96:	9104      	str	r1, [sp, #16]
 800ee98:	9203      	str	r2, [sp, #12]
 800ee9a:	9302      	str	r3, [sp, #8]
    ret = GetASNHeader(input, ASN_INTEGER, inOutIdx, len, maxIdx);
 800ee9c:	9b02      	ldr	r3, [sp, #8]
 800ee9e:	9300      	str	r3, [sp, #0]
 800eea0:	9b03      	ldr	r3, [sp, #12]
 800eea2:	9a04      	ldr	r2, [sp, #16]
 800eea4:	2102      	movs	r1, #2
 800eea6:	9805      	ldr	r0, [sp, #20]
 800eea8:	f7ff ff42 	bl	800ed30 <GetASNHeader>
 800eeac:	9007      	str	r0, [sp, #28]
    if (ret < 0)
 800eeae:	9b07      	ldr	r3, [sp, #28]
 800eeb0:	2b00      	cmp	r3, #0
 800eeb2:	da01      	bge.n	800eeb8 <GetASNInt.lto_priv.391+0x28>
        return ret;
 800eeb4:	9b07      	ldr	r3, [sp, #28]
 800eeb6:	e033      	b.n	800ef20 <GetASNInt.lto_priv.391+0x90>
    if (*len > 0) {
 800eeb8:	9b03      	ldr	r3, [sp, #12]
 800eeba:	681b      	ldr	r3, [r3, #0]
 800eebc:	2b00      	cmp	r3, #0
 800eebe:	dd2e      	ble.n	800ef1e <GetASNInt.lto_priv.391+0x8e>
        if ((input[*inOutIdx] == 0x00) && (*len > 1)) {
 800eec0:	9b04      	ldr	r3, [sp, #16]
 800eec2:	681b      	ldr	r3, [r3, #0]
 800eec4:	9a05      	ldr	r2, [sp, #20]
 800eec6:	4413      	add	r3, r2
 800eec8:	781b      	ldrb	r3, [r3, #0]
 800eeca:	2b00      	cmp	r3, #0
 800eecc:	d11c      	bne.n	800ef08 <GetASNInt.lto_priv.391+0x78>
 800eece:	9b03      	ldr	r3, [sp, #12]
 800eed0:	681b      	ldr	r3, [r3, #0]
 800eed2:	2b01      	cmp	r3, #1
 800eed4:	dd18      	ble.n	800ef08 <GetASNInt.lto_priv.391+0x78>
            (*inOutIdx)++;
 800eed6:	9b04      	ldr	r3, [sp, #16]
 800eed8:	681b      	ldr	r3, [r3, #0]
 800eeda:	1c5a      	adds	r2, r3, #1
 800eedc:	9b04      	ldr	r3, [sp, #16]
 800eede:	601a      	str	r2, [r3, #0]
            (*len)--;
 800eee0:	9b03      	ldr	r3, [sp, #12]
 800eee2:	681b      	ldr	r3, [r3, #0]
 800eee4:	1e5a      	subs	r2, r3, #1
 800eee6:	9b03      	ldr	r3, [sp, #12]
 800eee8:	601a      	str	r2, [r3, #0]
            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)
 800eeea:	9b03      	ldr	r3, [sp, #12]
 800eeec:	681b      	ldr	r3, [r3, #0]
 800eeee:	2b00      	cmp	r3, #0
 800eef0:	dd15      	ble.n	800ef1e <GetASNInt.lto_priv.391+0x8e>
 800eef2:	9b04      	ldr	r3, [sp, #16]
 800eef4:	681b      	ldr	r3, [r3, #0]
 800eef6:	9a05      	ldr	r2, [sp, #20]
 800eef8:	4413      	add	r3, r2
 800eefa:	781b      	ldrb	r3, [r3, #0]
 800eefc:	b25b      	sxtb	r3, r3
 800eefe:	2b00      	cmp	r3, #0
 800ef00:	db0d      	blt.n	800ef1e <GetASNInt.lto_priv.391+0x8e>
                return ASN_PARSE_E;
 800ef02:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ef06:	e00b      	b.n	800ef20 <GetASNInt.lto_priv.391+0x90>
        else if ((input[*inOutIdx] & 0x80) == 0x80)
 800ef08:	9b04      	ldr	r3, [sp, #16]
 800ef0a:	681b      	ldr	r3, [r3, #0]
 800ef0c:	9a05      	ldr	r2, [sp, #20]
 800ef0e:	4413      	add	r3, r2
 800ef10:	781b      	ldrb	r3, [r3, #0]
 800ef12:	b25b      	sxtb	r3, r3
 800ef14:	2b00      	cmp	r3, #0
 800ef16:	da02      	bge.n	800ef1e <GetASNInt.lto_priv.391+0x8e>
            return ASN_PARSE_E;
 800ef18:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800ef1c:	e000      	b.n	800ef20 <GetASNInt.lto_priv.391+0x90>
    return 0;
 800ef1e:	2300      	movs	r3, #0
}
 800ef20:	4618      	mov	r0, r3
 800ef22:	b009      	add	sp, #36	; 0x24
 800ef24:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800ef30 <SetASNInt>:
{
 800ef30:	b500      	push	{lr}
 800ef32:	b087      	sub	sp, #28
 800ef34:	9003      	str	r0, [sp, #12]
 800ef36:	460b      	mov	r3, r1
 800ef38:	9201      	str	r2, [sp, #4]
 800ef3a:	f88d 300b 	strb.w	r3, [sp, #11]
    word32 idx = 0;
 800ef3e:	2300      	movs	r3, #0
 800ef40:	9305      	str	r3, [sp, #20]
    output[idx++] = ASN_INTEGER;
 800ef42:	9b05      	ldr	r3, [sp, #20]
 800ef44:	1c5a      	adds	r2, r3, #1
 800ef46:	9205      	str	r2, [sp, #20]
 800ef48:	9a01      	ldr	r2, [sp, #4]
 800ef4a:	4413      	add	r3, r2
 800ef4c:	2202      	movs	r2, #2
 800ef4e:	701a      	strb	r2, [r3, #0]
    if (firstByte & 0x80)
 800ef50:	f99d 300b 	ldrsb.w	r3, [sp, #11]
 800ef54:	2b00      	cmp	r3, #0
 800ef56:	da02      	bge.n	800ef5e <SetASNInt+0x2e>
        len++;
 800ef58:	9b03      	ldr	r3, [sp, #12]
 800ef5a:	3301      	adds	r3, #1
 800ef5c:	9303      	str	r3, [sp, #12]
    idx += SetLength(len, output + idx);
 800ef5e:	9803      	ldr	r0, [sp, #12]
 800ef60:	9a01      	ldr	r2, [sp, #4]
 800ef62:	9b05      	ldr	r3, [sp, #20]
 800ef64:	4413      	add	r3, r2
 800ef66:	4619      	mov	r1, r3
 800ef68:	f7ff fa72 	bl	800e450 <SetLength>
 800ef6c:	4602      	mov	r2, r0
 800ef6e:	9b05      	ldr	r3, [sp, #20]
 800ef70:	4413      	add	r3, r2
 800ef72:	9305      	str	r3, [sp, #20]
    if (firstByte & 0x80)
 800ef74:	f99d 300b 	ldrsb.w	r3, [sp, #11]
 800ef78:	2b00      	cmp	r3, #0
 800ef7a:	da06      	bge.n	800ef8a <SetASNInt+0x5a>
        output[idx++] = 0x00;
 800ef7c:	9b05      	ldr	r3, [sp, #20]
 800ef7e:	1c5a      	adds	r2, r3, #1
 800ef80:	9205      	str	r2, [sp, #20]
 800ef82:	9a01      	ldr	r2, [sp, #4]
 800ef84:	4413      	add	r3, r2
 800ef86:	2200      	movs	r2, #0
 800ef88:	701a      	strb	r2, [r3, #0]
    return idx;
 800ef8a:	9b05      	ldr	r3, [sp, #20]
}
 800ef8c:	4618      	mov	r0, r3
 800ef8e:	b007      	add	sp, #28
 800ef90:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800efa0 <SetASNIntMP.lto_priv.384>:
{
 800efa0:	b500      	push	{lr}
 800efa2:	b089      	sub	sp, #36	; 0x24
 800efa4:	9003      	str	r0, [sp, #12]
 800efa6:	9102      	str	r1, [sp, #8]
 800efa8:	9201      	str	r2, [sp, #4]
    int idx = 0;
 800efaa:	2300      	movs	r3, #0
 800efac:	9307      	str	r3, [sp, #28]
    leadingBit = mp_leading_bit(n);
 800efae:	9803      	ldr	r0, [sp, #12]
 800efb0:	f7fb fc06 	bl	800a7c0 <mp_leading_bit>
 800efb4:	9006      	str	r0, [sp, #24]
    length = mp_unsigned_bin_size(n);
 800efb6:	9803      	ldr	r0, [sp, #12]
 800efb8:	f7fb fbb2 	bl	800a720 <mp_unsigned_bin_size>
 800efbc:	9005      	str	r0, [sp, #20]
    idx = SetASNInt(length, leadingBit ? 0x80 : 0x00, output);
 800efbe:	9b06      	ldr	r3, [sp, #24]
 800efc0:	2b00      	cmp	r3, #0
 800efc2:	d001      	beq.n	800efc8 <SetASNIntMP.lto_priv.384+0x28>
 800efc4:	2380      	movs	r3, #128	; 0x80
 800efc6:	e000      	b.n	800efca <SetASNIntMP.lto_priv.384+0x2a>
 800efc8:	2300      	movs	r3, #0
 800efca:	9a01      	ldr	r2, [sp, #4]
 800efcc:	4619      	mov	r1, r3
 800efce:	9805      	ldr	r0, [sp, #20]
 800efd0:	f7ff ffae 	bl	800ef30 <SetASNInt>
 800efd4:	9007      	str	r0, [sp, #28]
    if (maxSz >= 0 && (idx + length) > maxSz)
 800efd6:	9b02      	ldr	r3, [sp, #8]
 800efd8:	2b00      	cmp	r3, #0
 800efda:	db08      	blt.n	800efee <SetASNIntMP.lto_priv.384+0x4e>
 800efdc:	9a07      	ldr	r2, [sp, #28]
 800efde:	9b05      	ldr	r3, [sp, #20]
 800efe0:	441a      	add	r2, r3
 800efe2:	9b02      	ldr	r3, [sp, #8]
 800efe4:	429a      	cmp	r2, r3
 800efe6:	dd02      	ble.n	800efee <SetASNIntMP.lto_priv.384+0x4e>
        return BUFFER_E;
 800efe8:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800efec:	e012      	b.n	800f014 <SetASNIntMP.lto_priv.384+0x74>
    err = mp_to_unsigned_bin(n, output + idx);
 800efee:	9b07      	ldr	r3, [sp, #28]
 800eff0:	9a01      	ldr	r2, [sp, #4]
 800eff2:	4413      	add	r3, r2
 800eff4:	4619      	mov	r1, r3
 800eff6:	9803      	ldr	r0, [sp, #12]
 800eff8:	f7fb fc42 	bl	800a880 <mp_to_unsigned_bin>
 800effc:	9004      	str	r0, [sp, #16]
    if (err != MP_OKAY)
 800effe:	9b04      	ldr	r3, [sp, #16]
 800f000:	2b00      	cmp	r3, #0
 800f002:	d002      	beq.n	800f00a <SetASNIntMP.lto_priv.384+0x6a>
        return MP_TO_E;
 800f004:	f06f 0370 	mvn.w	r3, #112	; 0x70
 800f008:	e004      	b.n	800f014 <SetASNIntMP.lto_priv.384+0x74>
    idx += length;
 800f00a:	9a07      	ldr	r2, [sp, #28]
 800f00c:	9b05      	ldr	r3, [sp, #20]
 800f00e:	4413      	add	r3, r2
 800f010:	9307      	str	r3, [sp, #28]
    return idx;
 800f012:	9b07      	ldr	r3, [sp, #28]
}
 800f014:	4618      	mov	r0, r3
 800f016:	b009      	add	sp, #36	; 0x24
 800f018:	f85d fb04 	ldr.w	pc, [sp], #4
 800f01c:	0000      	movs	r0, r0
	...

0800f020 <GetMyVersion>:
{
 800f020:	b086      	sub	sp, #24
 800f022:	9003      	str	r0, [sp, #12]
 800f024:	9102      	str	r1, [sp, #8]
 800f026:	9201      	str	r2, [sp, #4]
 800f028:	9300      	str	r3, [sp, #0]
    word32 idx = *inOutIdx;
 800f02a:	9b02      	ldr	r3, [sp, #8]
 800f02c:	681b      	ldr	r3, [r3, #0]
 800f02e:	9305      	str	r3, [sp, #20]
    if ((idx + MIN_VERSION_SZ) > maxIdx)
 800f030:	9b05      	ldr	r3, [sp, #20]
 800f032:	1cda      	adds	r2, r3, #3
 800f034:	9b00      	ldr	r3, [sp, #0]
 800f036:	429a      	cmp	r2, r3
 800f038:	d902      	bls.n	800f040 <GetMyVersion+0x20>
        return ASN_PARSE_E;
 800f03a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800f03e:	e023      	b.n	800f088 <GetMyVersion+0x68>
    if (input[idx++] != ASN_INTEGER)
 800f040:	9b05      	ldr	r3, [sp, #20]
 800f042:	1c5a      	adds	r2, r3, #1
 800f044:	9205      	str	r2, [sp, #20]
 800f046:	9a03      	ldr	r2, [sp, #12]
 800f048:	4413      	add	r3, r2
 800f04a:	781b      	ldrb	r3, [r3, #0]
 800f04c:	2b02      	cmp	r3, #2
 800f04e:	d002      	beq.n	800f056 <GetMyVersion+0x36>
        return ASN_PARSE_E;
 800f050:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800f054:	e018      	b.n	800f088 <GetMyVersion+0x68>
    if (input[idx++] != 0x01)
 800f056:	9b05      	ldr	r3, [sp, #20]
 800f058:	1c5a      	adds	r2, r3, #1
 800f05a:	9205      	str	r2, [sp, #20]
 800f05c:	9a03      	ldr	r2, [sp, #12]
 800f05e:	4413      	add	r3, r2
 800f060:	781b      	ldrb	r3, [r3, #0]
 800f062:	2b01      	cmp	r3, #1
 800f064:	d002      	beq.n	800f06c <GetMyVersion+0x4c>
        return ASN_VERSION_E;
 800f066:	f06f 038c 	mvn.w	r3, #140	; 0x8c
 800f06a:	e00d      	b.n	800f088 <GetMyVersion+0x68>
    *version  = input[idx++];
 800f06c:	9b05      	ldr	r3, [sp, #20]
 800f06e:	1c5a      	adds	r2, r3, #1
 800f070:	9205      	str	r2, [sp, #20]
 800f072:	9a03      	ldr	r2, [sp, #12]
 800f074:	4413      	add	r3, r2
 800f076:	781b      	ldrb	r3, [r3, #0]
 800f078:	461a      	mov	r2, r3
 800f07a:	9b01      	ldr	r3, [sp, #4]
 800f07c:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 800f07e:	9b02      	ldr	r3, [sp, #8]
 800f080:	9a05      	ldr	r2, [sp, #20]
 800f082:	601a      	str	r2, [r3, #0]
    return *version;
 800f084:	9b01      	ldr	r3, [sp, #4]
 800f086:	681b      	ldr	r3, [r3, #0]
}
 800f088:	4618      	mov	r0, r3
 800f08a:	b006      	add	sp, #24
 800f08c:	4770      	bx	lr
 800f08e:	bf00      	nop

0800f090 <GetInt>:
{
 800f090:	b500      	push	{lr}
 800f092:	b089      	sub	sp, #36	; 0x24
 800f094:	9003      	str	r0, [sp, #12]
 800f096:	9102      	str	r1, [sp, #8]
 800f098:	9201      	str	r2, [sp, #4]
 800f09a:	9300      	str	r3, [sp, #0]
    word32 idx = *inOutIdx;
 800f09c:	9b01      	ldr	r3, [sp, #4]
 800f09e:	681b      	ldr	r3, [r3, #0]
 800f0a0:	9306      	str	r3, [sp, #24]
    ret = GetASNInt(input, &idx, &length, maxIdx);
 800f0a2:	aa05      	add	r2, sp, #20
 800f0a4:	a906      	add	r1, sp, #24
 800f0a6:	9b00      	ldr	r3, [sp, #0]
 800f0a8:	9802      	ldr	r0, [sp, #8]
 800f0aa:	f7ff fef1 	bl	800ee90 <GetASNInt.lto_priv.391>
 800f0ae:	9007      	str	r0, [sp, #28]
    if (ret != 0)
 800f0b0:	9b07      	ldr	r3, [sp, #28]
 800f0b2:	2b00      	cmp	r3, #0
 800f0b4:	d001      	beq.n	800f0ba <GetInt+0x2a>
        return ret;
 800f0b6:	9b07      	ldr	r3, [sp, #28]
 800f0b8:	e01f      	b.n	800f0fa <GetInt+0x6a>
    if (mp_init(mpi) != MP_OKAY)
 800f0ba:	9803      	ldr	r0, [sp, #12]
 800f0bc:	f7fb faa0 	bl	800a600 <mp_init>
 800f0c0:	4603      	mov	r3, r0
 800f0c2:	2b00      	cmp	r3, #0
 800f0c4:	d002      	beq.n	800f0cc <GetInt+0x3c>
        return MP_INIT_E;
 800f0c6:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 800f0ca:	e016      	b.n	800f0fa <GetInt+0x6a>
    if (mp_read_unsigned_bin(mpi, (byte*)input + idx, length) != 0) {
 800f0cc:	9b06      	ldr	r3, [sp, #24]
 800f0ce:	9a02      	ldr	r2, [sp, #8]
 800f0d0:	4413      	add	r3, r2
 800f0d2:	9a05      	ldr	r2, [sp, #20]
 800f0d4:	4619      	mov	r1, r3
 800f0d6:	9803      	ldr	r0, [sp, #12]
 800f0d8:	f7fb feca 	bl	800ae70 <mp_read_unsigned_bin>
 800f0dc:	4603      	mov	r3, r0
 800f0de:	2b00      	cmp	r3, #0
 800f0e0:	d005      	beq.n	800f0ee <GetInt+0x5e>
        mp_clear(mpi);
 800f0e2:	9803      	ldr	r0, [sp, #12]
 800f0e4:	f7fb faa4 	bl	800a630 <mp_clear>
        return ASN_GETINT_E;
 800f0e8:	f06f 038d 	mvn.w	r3, #141	; 0x8d
 800f0ec:	e005      	b.n	800f0fa <GetInt+0x6a>
    *inOutIdx = idx + length;
 800f0ee:	9b06      	ldr	r3, [sp, #24]
 800f0f0:	9a05      	ldr	r2, [sp, #20]
 800f0f2:	441a      	add	r2, r3
 800f0f4:	9b01      	ldr	r3, [sp, #4]
 800f0f6:	601a      	str	r2, [r3, #0]
    return 0;
 800f0f8:	2300      	movs	r3, #0
}
 800f0fa:	4618      	mov	r0, r3
 800f0fc:	b009      	add	sp, #36	; 0x24
 800f0fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800f102:	bf00      	nop
	...

0800f110 <CheckBitString.lto_priv.381>:
{
 800f110:	b500      	push	{lr}
 800f112:	b089      	sub	sp, #36	; 0x24
 800f114:	9003      	str	r0, [sp, #12]
 800f116:	9102      	str	r1, [sp, #8]
 800f118:	9201      	str	r2, [sp, #4]
 800f11a:	9300      	str	r3, [sp, #0]
    word32 idx = *inOutIdx;
 800f11c:	9b02      	ldr	r3, [sp, #8]
 800f11e:	681b      	ldr	r3, [r3, #0]
 800f120:	9306      	str	r3, [sp, #24]
    if ((idx + 1) > maxIdx)
 800f122:	9b06      	ldr	r3, [sp, #24]
 800f124:	1c5a      	adds	r2, r3, #1
 800f126:	9b00      	ldr	r3, [sp, #0]
 800f128:	429a      	cmp	r2, r3
 800f12a:	d902      	bls.n	800f132 <CheckBitString.lto_priv.381+0x22>
        return BUFFER_E;
 800f12c:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800f130:	e06a      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (input[idx++] != ASN_BIT_STRING)
 800f132:	9b06      	ldr	r3, [sp, #24]
 800f134:	1c5a      	adds	r2, r3, #1
 800f136:	9206      	str	r2, [sp, #24]
 800f138:	9a03      	ldr	r2, [sp, #12]
 800f13a:	4413      	add	r3, r2
 800f13c:	781b      	ldrb	r3, [r3, #0]
 800f13e:	2b03      	cmp	r3, #3
 800f140:	d002      	beq.n	800f148 <CheckBitString.lto_priv.381+0x38>
        return ASN_BITSTR_E;
 800f142:	f06f 0392 	mvn.w	r3, #146	; 0x92
 800f146:	e05f      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (GetLength(input, &idx, &length, maxIdx) < 0)
 800f148:	aa05      	add	r2, sp, #20
 800f14a:	a906      	add	r1, sp, #24
 800f14c:	9b00      	ldr	r3, [sp, #0]
 800f14e:	9803      	ldr	r0, [sp, #12]
 800f150:	f7ff fd8e 	bl	800ec70 <GetLength>
 800f154:	4603      	mov	r3, r0
 800f156:	2b00      	cmp	r3, #0
 800f158:	da02      	bge.n	800f160 <CheckBitString.lto_priv.381+0x50>
        return ASN_PARSE_E;
 800f15a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800f15e:	e053      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (length <= 0) {
 800f160:	9b05      	ldr	r3, [sp, #20]
 800f162:	2b00      	cmp	r3, #0
 800f164:	dc02      	bgt.n	800f16c <CheckBitString.lto_priv.381+0x5c>
        return BUFFER_E;
 800f166:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800f16a:	e04d      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (idx + 1 > maxIdx) {
 800f16c:	9b06      	ldr	r3, [sp, #24]
 800f16e:	1c5a      	adds	r2, r3, #1
 800f170:	9b00      	ldr	r3, [sp, #0]
 800f172:	429a      	cmp	r2, r3
 800f174:	d902      	bls.n	800f17c <CheckBitString.lto_priv.381+0x6c>
        return BUFFER_E;
 800f176:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800f17a:	e045      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    b = input[idx];
 800f17c:	9b06      	ldr	r3, [sp, #24]
 800f17e:	9a03      	ldr	r2, [sp, #12]
 800f180:	4413      	add	r3, r2
 800f182:	781b      	ldrb	r3, [r3, #0]
 800f184:	f88d 301f 	strb.w	r3, [sp, #31]
    if (zeroBits && b != 0x00)
 800f188:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f18a:	2b00      	cmp	r3, #0
 800f18c:	d006      	beq.n	800f19c <CheckBitString.lto_priv.381+0x8c>
 800f18e:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800f192:	2b00      	cmp	r3, #0
 800f194:	d002      	beq.n	800f19c <CheckBitString.lto_priv.381+0x8c>
        return ASN_EXPECT_0_E;
 800f196:	f06f 0391 	mvn.w	r3, #145	; 0x91
 800f19a:	e035      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (b >= 0x08)
 800f19c:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800f1a0:	2b07      	cmp	r3, #7
 800f1a2:	d902      	bls.n	800f1aa <CheckBitString.lto_priv.381+0x9a>
        return ASN_PARSE_E;
 800f1a4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800f1a8:	e02e      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    if (b != 0) {
 800f1aa:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800f1ae:	2b00      	cmp	r3, #0
 800f1b0:	d013      	beq.n	800f1da <CheckBitString.lto_priv.381+0xca>
        if ((byte)(input[idx + length - 1] << (8 - b)) != 0)
 800f1b2:	9b06      	ldr	r3, [sp, #24]
 800f1b4:	9a05      	ldr	r2, [sp, #20]
 800f1b6:	4413      	add	r3, r2
 800f1b8:	3b01      	subs	r3, #1
 800f1ba:	9a03      	ldr	r2, [sp, #12]
 800f1bc:	4413      	add	r3, r2
 800f1be:	781b      	ldrb	r3, [r3, #0]
 800f1c0:	461a      	mov	r2, r3
 800f1c2:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800f1c6:	f1c3 0308 	rsb	r3, r3, #8
 800f1ca:	fa02 f303 	lsl.w	r3, r2, r3
 800f1ce:	b2db      	uxtb	r3, r3
 800f1d0:	2b00      	cmp	r3, #0
 800f1d2:	d002      	beq.n	800f1da <CheckBitString.lto_priv.381+0xca>
            return ASN_PARSE_E;
 800f1d4:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800f1d8:	e016      	b.n	800f208 <CheckBitString.lto_priv.381+0xf8>
    idx++;
 800f1da:	9b06      	ldr	r3, [sp, #24]
 800f1dc:	3301      	adds	r3, #1
 800f1de:	9306      	str	r3, [sp, #24]
    length--; /* length has been checked for greater than 0 */
 800f1e0:	9b05      	ldr	r3, [sp, #20]
 800f1e2:	3b01      	subs	r3, #1
 800f1e4:	9305      	str	r3, [sp, #20]
    *inOutIdx = idx;
 800f1e6:	9a06      	ldr	r2, [sp, #24]
 800f1e8:	9b02      	ldr	r3, [sp, #8]
 800f1ea:	601a      	str	r2, [r3, #0]
    if (len != NULL)
 800f1ec:	9b01      	ldr	r3, [sp, #4]
 800f1ee:	2b00      	cmp	r3, #0
 800f1f0:	d002      	beq.n	800f1f8 <CheckBitString.lto_priv.381+0xe8>
        *len = length;
 800f1f2:	9a05      	ldr	r2, [sp, #20]
 800f1f4:	9b01      	ldr	r3, [sp, #4]
 800f1f6:	601a      	str	r2, [r3, #0]
    if (unusedBits != NULL)
 800f1f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f1fa:	2b00      	cmp	r3, #0
 800f1fc:	d003      	beq.n	800f206 <CheckBitString.lto_priv.381+0xf6>
        *unusedBits = b;
 800f1fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f200:	f89d 201f 	ldrb.w	r2, [sp, #31]
 800f204:	701a      	strb	r2, [r3, #0]
    return 0;
 800f206:	2300      	movs	r3, #0
}
 800f208:	4618      	mov	r0, r3
 800f20a:	b009      	add	sp, #36	; 0x24
 800f20c:	f85d fb04 	ldr.w	pc, [sp], #4

0800f210 <SetBitString.lto_priv.378>:
{
 800f210:	b500      	push	{lr}
 800f212:	b087      	sub	sp, #28
 800f214:	9003      	str	r0, [sp, #12]
 800f216:	460b      	mov	r3, r1
 800f218:	9201      	str	r2, [sp, #4]
 800f21a:	f88d 300b 	strb.w	r3, [sp, #11]
    word32 idx = 0;
 800f21e:	2300      	movs	r3, #0
 800f220:	9305      	str	r3, [sp, #20]
    output[idx++] = ASN_BIT_STRING;
 800f222:	9b05      	ldr	r3, [sp, #20]
 800f224:	1c5a      	adds	r2, r3, #1
 800f226:	9205      	str	r2, [sp, #20]
 800f228:	9a01      	ldr	r2, [sp, #4]
 800f22a:	4413      	add	r3, r2
 800f22c:	2203      	movs	r2, #3
 800f22e:	701a      	strb	r2, [r3, #0]
    idx += SetLength(len + 1, output + idx);
 800f230:	9b03      	ldr	r3, [sp, #12]
 800f232:	1c58      	adds	r0, r3, #1
 800f234:	9a01      	ldr	r2, [sp, #4]
 800f236:	9b05      	ldr	r3, [sp, #20]
 800f238:	4413      	add	r3, r2
 800f23a:	4619      	mov	r1, r3
 800f23c:	f7ff f908 	bl	800e450 <SetLength>
 800f240:	4602      	mov	r2, r0
 800f242:	9b05      	ldr	r3, [sp, #20]
 800f244:	4413      	add	r3, r2
 800f246:	9305      	str	r3, [sp, #20]
    output[idx++] = unusedBits;
 800f248:	9b05      	ldr	r3, [sp, #20]
 800f24a:	1c5a      	adds	r2, r3, #1
 800f24c:	9205      	str	r2, [sp, #20]
 800f24e:	9a01      	ldr	r2, [sp, #4]
 800f250:	4413      	add	r3, r2
 800f252:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800f256:	701a      	strb	r2, [r3, #0]
    return idx;
 800f258:	9b05      	ldr	r3, [sp, #20]
}
 800f25a:	4618      	mov	r0, r3
 800f25c:	b007      	add	sp, #28
 800f25e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f262:	bf00      	nop
	...

0800f270 <OidFromId.lto_priv.408>:
{
 800f270:	b500      	push	{lr}
 800f272:	b087      	sub	sp, #28
 800f274:	9003      	str	r0, [sp, #12]
 800f276:	9102      	str	r1, [sp, #8]
 800f278:	9201      	str	r2, [sp, #4]
    const byte* oid = NULL;
 800f27a:	2300      	movs	r3, #0
 800f27c:	9305      	str	r3, [sp, #20]
    *oidSz = 0;
 800f27e:	9b01      	ldr	r3, [sp, #4]
 800f280:	2200      	movs	r2, #0
 800f282:	601a      	str	r2, [r3, #0]
    switch (type) {
 800f284:	9b02      	ldr	r3, [sp, #8]
 800f286:	2b0d      	cmp	r3, #13
 800f288:	f200 8350 	bhi.w	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f28c:	a201      	add	r2, pc, #4	; (adr r2, 800f294 <OidFromId.lto_priv.408+0x24>)
 800f28e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f292:	bf00      	nop
 800f294:	0800f2cd 	.word	0x0800f2cd
 800f298:	0800f35b 	.word	0x0800f35b
 800f29c:	0800f475 	.word	0x0800f475
 800f2a0:	0800f4b5 	.word	0x0800f4b5
 800f2a4:	0800f4c3 	.word	0x0800f4c3
 800f2a8:	0800f92d 	.word	0x0800f92d
 800f2ac:	0800f599 	.word	0x0800f599
 800f2b0:	0800f7bd 	.word	0x0800f7bd
 800f2b4:	0800f7e1 	.word	0x0800f7e1
 800f2b8:	0800f7f5 	.word	0x0800f7f5
 800f2bc:	0800f809 	.word	0x0800f809
 800f2c0:	0800f883 	.word	0x0800f883
 800f2c4:	0800f897 	.word	0x0800f897
 800f2c8:	0800f8d5 	.word	0x0800f8d5
            switch (id) {
 800f2cc:	9b03      	ldr	r3, [sp, #12]
 800f2ce:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
 800f2d2:	d03c      	beq.n	800f34e <OidFromId.lto_priv.408+0xde>
 800f2d4:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
 800f2d8:	d808      	bhi.n	800f2ec <OidFromId.lto_priv.408+0x7c>
 800f2da:	f5b3 7fcf 	cmp.w	r3, #414	; 0x19e
 800f2de:	d02a      	beq.n	800f336 <OidFromId.lto_priv.408+0xc6>
 800f2e0:	f5b3 7fcf 	cmp.w	r3, #414	; 0x19e
 800f2e4:	d82d      	bhi.n	800f342 <OidFromId.lto_priv.408+0xd2>
 800f2e6:	2b58      	cmp	r3, #88	; 0x58
 800f2e8:	d019      	beq.n	800f31e <OidFromId.lto_priv.408+0xae>
 800f2ea:	e31f      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f2ec:	f240 2286 	movw	r2, #646	; 0x286
 800f2f0:	4293      	cmp	r3, r2
 800f2f2:	d008      	beq.n	800f306 <OidFromId.lto_priv.408+0x96>
 800f2f4:	f240 2289 	movw	r2, #649	; 0x289
 800f2f8:	4293      	cmp	r3, r2
 800f2fa:	d00a      	beq.n	800f312 <OidFromId.lto_priv.408+0xa2>
 800f2fc:	f240 12a1 	movw	r2, #417	; 0x1a1
 800f300:	4293      	cmp	r3, r2
 800f302:	d012      	beq.n	800f32a <OidFromId.lto_priv.408+0xba>
 800f304:	e312      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashMd2hOid;
 800f306:	4b88      	ldr	r3, [pc, #544]	; (800f528 <OidFromId.lto_priv.408+0x2b8>)
 800f308:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashMd2hOid);
 800f30a:	9b01      	ldr	r3, [sp, #4]
 800f30c:	2208      	movs	r2, #8
 800f30e:	601a      	str	r2, [r3, #0]
 800f310:	e30c      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashMd5hOid;
 800f312:	4b86      	ldr	r3, [pc, #536]	; (800f52c <OidFromId.lto_priv.408+0x2bc>)
 800f314:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashMd5hOid);
 800f316:	9b01      	ldr	r3, [sp, #4]
 800f318:	2208      	movs	r2, #8
 800f31a:	601a      	str	r2, [r3, #0]
 800f31c:	e306      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashSha1hOid;
 800f31e:	4b84      	ldr	r3, [pc, #528]	; (800f530 <OidFromId.lto_priv.408+0x2c0>)
 800f320:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashSha1hOid);
 800f322:	9b01      	ldr	r3, [sp, #4]
 800f324:	2205      	movs	r2, #5
 800f326:	601a      	str	r2, [r3, #0]
 800f328:	e300      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashSha224hOid;
 800f32a:	4b82      	ldr	r3, [pc, #520]	; (800f534 <OidFromId.lto_priv.408+0x2c4>)
 800f32c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashSha224hOid);
 800f32e:	9b01      	ldr	r3, [sp, #4]
 800f330:	2209      	movs	r2, #9
 800f332:	601a      	str	r2, [r3, #0]
 800f334:	e2fa      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashSha256hOid;
 800f336:	4b80      	ldr	r3, [pc, #512]	; (800f538 <OidFromId.lto_priv.408+0x2c8>)
 800f338:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashSha256hOid);
 800f33a:	9b01      	ldr	r3, [sp, #4]
 800f33c:	2209      	movs	r2, #9
 800f33e:	601a      	str	r2, [r3, #0]
 800f340:	e2f4      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashSha384hOid;
 800f342:	4b7e      	ldr	r3, [pc, #504]	; (800f53c <OidFromId.lto_priv.408+0x2cc>)
 800f344:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashSha384hOid);
 800f346:	9b01      	ldr	r3, [sp, #4]
 800f348:	2209      	movs	r2, #9
 800f34a:	601a      	str	r2, [r3, #0]
 800f34c:	e2ee      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = hashSha512hOid;
 800f34e:	4b7c      	ldr	r3, [pc, #496]	; (800f540 <OidFromId.lto_priv.408+0x2d0>)
 800f350:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(hashSha512hOid);
 800f352:	9b01      	ldr	r3, [sp, #4]
 800f354:	2209      	movs	r2, #9
 800f356:	601a      	str	r2, [r3, #0]
 800f358:	e2e8      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f35a:	9b03      	ldr	r3, [sp, #12]
 800f35c:	f240 2286 	movw	r2, #646	; 0x286
 800f360:	4293      	cmp	r3, r2
 800f362:	d03f      	beq.n	800f3e4 <OidFromId.lto_priv.408+0x174>
 800f364:	f240 2286 	movw	r2, #646	; 0x286
 800f368:	4293      	cmp	r3, r2
 800f36a:	d81a      	bhi.n	800f3a2 <OidFromId.lto_priv.408+0x132>
 800f36c:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 800f370:	d06e      	beq.n	800f450 <OidFromId.lto_priv.408+0x1e0>
 800f372:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
 800f376:	d807      	bhi.n	800f388 <OidFromId.lto_priv.408+0x118>
 800f378:	f240 2205 	movw	r2, #517	; 0x205
 800f37c:	4293      	cmp	r3, r2
 800f37e:	d02b      	beq.n	800f3d8 <OidFromId.lto_priv.408+0x168>
 800f380:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 800f384:	d058      	beq.n	800f438 <OidFromId.lto_priv.408+0x1c8>
 800f386:	e2d1      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f388:	f240 220e 	movw	r2, #526	; 0x20e
 800f38c:	4293      	cmp	r3, r2
 800f38e:	d06b      	beq.n	800f468 <OidFromId.lto_priv.408+0x1f8>
 800f390:	f240 220e 	movw	r2, #526	; 0x20e
 800f394:	4293      	cmp	r3, r2
 800f396:	d361      	bcc.n	800f45c <OidFromId.lto_priv.408+0x1ec>
 800f398:	f240 220f 	movw	r2, #527	; 0x20f
 800f39c:	4293      	cmp	r3, r2
 800f39e:	d051      	beq.n	800f444 <OidFromId.lto_priv.408+0x1d4>
 800f3a0:	e2c4      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f3a2:	f240 228f 	movw	r2, #655	; 0x28f
 800f3a6:	4293      	cmp	r3, r2
 800f3a8:	d034      	beq.n	800f414 <OidFromId.lto_priv.408+0x1a4>
 800f3aa:	f5b3 7f24 	cmp.w	r3, #656	; 0x290
 800f3ae:	d207      	bcs.n	800f3c0 <OidFromId.lto_priv.408+0x150>
 800f3b0:	f5b3 7f22 	cmp.w	r3, #648	; 0x288
 800f3b4:	d01c      	beq.n	800f3f0 <OidFromId.lto_priv.408+0x180>
 800f3b6:	f240 2289 	movw	r2, #649	; 0x289
 800f3ba:	4293      	cmp	r3, r2
 800f3bc:	d01e      	beq.n	800f3fc <OidFromId.lto_priv.408+0x18c>
 800f3be:	e2b5      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f3c0:	f240 2291 	movw	r2, #657	; 0x291
 800f3c4:	4293      	cmp	r3, r2
 800f3c6:	d031      	beq.n	800f42c <OidFromId.lto_priv.408+0x1bc>
 800f3c8:	f5b3 7f24 	cmp.w	r3, #656	; 0x290
 800f3cc:	d928      	bls.n	800f420 <OidFromId.lto_priv.408+0x1b0>
 800f3ce:	f240 2292 	movw	r2, #658	; 0x292
 800f3d2:	4293      	cmp	r3, r2
 800f3d4:	d018      	beq.n	800f408 <OidFromId.lto_priv.408+0x198>
 800f3d6:	e2a9      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha1wDsaOid;
 800f3d8:	4b5a      	ldr	r3, [pc, #360]	; (800f544 <OidFromId.lto_priv.408+0x2d4>)
 800f3da:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha1wDsaOid);
 800f3dc:	9b01      	ldr	r3, [sp, #4]
 800f3de:	2207      	movs	r2, #7
 800f3e0:	601a      	str	r2, [r3, #0]
 800f3e2:	e2a3      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigMd2wRsaOid;
 800f3e4:	4b58      	ldr	r3, [pc, #352]	; (800f548 <OidFromId.lto_priv.408+0x2d8>)
 800f3e6:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigMd2wRsaOid);
 800f3e8:	9b01      	ldr	r3, [sp, #4]
 800f3ea:	2209      	movs	r2, #9
 800f3ec:	601a      	str	r2, [r3, #0]
 800f3ee:	e29d      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigMd5wRsaOid;
 800f3f0:	4b56      	ldr	r3, [pc, #344]	; (800f54c <OidFromId.lto_priv.408+0x2dc>)
 800f3f2:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigMd5wRsaOid);
 800f3f4:	9b01      	ldr	r3, [sp, #4]
 800f3f6:	2209      	movs	r2, #9
 800f3f8:	601a      	str	r2, [r3, #0]
 800f3fa:	e297      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha1wRsaOid;
 800f3fc:	4b54      	ldr	r3, [pc, #336]	; (800f550 <OidFromId.lto_priv.408+0x2e0>)
 800f3fe:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha1wRsaOid);
 800f400:	9b01      	ldr	r3, [sp, #4]
 800f402:	2209      	movs	r2, #9
 800f404:	601a      	str	r2, [r3, #0]
 800f406:	e291      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha224wRsaOid;
 800f408:	4b52      	ldr	r3, [pc, #328]	; (800f554 <OidFromId.lto_priv.408+0x2e4>)
 800f40a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha224wRsaOid);
 800f40c:	9b01      	ldr	r3, [sp, #4]
 800f40e:	2209      	movs	r2, #9
 800f410:	601a      	str	r2, [r3, #0]
 800f412:	e28b      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha256wRsaOid;
 800f414:	4b50      	ldr	r3, [pc, #320]	; (800f558 <OidFromId.lto_priv.408+0x2e8>)
 800f416:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha256wRsaOid);
 800f418:	9b01      	ldr	r3, [sp, #4]
 800f41a:	2209      	movs	r2, #9
 800f41c:	601a      	str	r2, [r3, #0]
 800f41e:	e285      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha384wRsaOid;
 800f420:	4b4e      	ldr	r3, [pc, #312]	; (800f55c <OidFromId.lto_priv.408+0x2ec>)
 800f422:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha384wRsaOid);
 800f424:	9b01      	ldr	r3, [sp, #4]
 800f426:	2209      	movs	r2, #9
 800f428:	601a      	str	r2, [r3, #0]
 800f42a:	e27f      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha512wRsaOid;
 800f42c:	4b4c      	ldr	r3, [pc, #304]	; (800f560 <OidFromId.lto_priv.408+0x2f0>)
 800f42e:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha512wRsaOid);
 800f430:	9b01      	ldr	r3, [sp, #4]
 800f432:	2209      	movs	r2, #9
 800f434:	601a      	str	r2, [r3, #0]
 800f436:	e279      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha1wEcdsaOid;
 800f438:	4b4a      	ldr	r3, [pc, #296]	; (800f564 <OidFromId.lto_priv.408+0x2f4>)
 800f43a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha1wEcdsaOid);
 800f43c:	9b01      	ldr	r3, [sp, #4]
 800f43e:	2207      	movs	r2, #7
 800f440:	601a      	str	r2, [r3, #0]
 800f442:	e273      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha224wEcdsaOid;
 800f444:	4b48      	ldr	r3, [pc, #288]	; (800f568 <OidFromId.lto_priv.408+0x2f8>)
 800f446:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha224wEcdsaOid);
 800f448:	9b01      	ldr	r3, [sp, #4]
 800f44a:	2208      	movs	r2, #8
 800f44c:	601a      	str	r2, [r3, #0]
 800f44e:	e26d      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha256wEcdsaOid;
 800f450:	4b46      	ldr	r3, [pc, #280]	; (800f56c <OidFromId.lto_priv.408+0x2fc>)
 800f452:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha256wEcdsaOid);
 800f454:	9b01      	ldr	r3, [sp, #4]
 800f456:	2208      	movs	r2, #8
 800f458:	601a      	str	r2, [r3, #0]
 800f45a:	e267      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha384wEcdsaOid;
 800f45c:	4b44      	ldr	r3, [pc, #272]	; (800f570 <OidFromId.lto_priv.408+0x300>)
 800f45e:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha384wEcdsaOid);
 800f460:	9b01      	ldr	r3, [sp, #4]
 800f462:	2208      	movs	r2, #8
 800f464:	601a      	str	r2, [r3, #0]
 800f466:	e261      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = sigSha512wEcdsaOid;
 800f468:	4b42      	ldr	r3, [pc, #264]	; (800f574 <OidFromId.lto_priv.408+0x304>)
 800f46a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(sigSha512wEcdsaOid);
 800f46c:	9b01      	ldr	r3, [sp, #4]
 800f46e:	2208      	movs	r2, #8
 800f470:	601a      	str	r2, [r3, #0]
 800f472:	e25b      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f474:	9b03      	ldr	r3, [sp, #12]
 800f476:	f240 2206 	movw	r2, #518	; 0x206
 800f47a:	4293      	cmp	r3, r2
 800f47c:	d014      	beq.n	800f4a8 <OidFromId.lto_priv.408+0x238>
 800f47e:	f240 2285 	movw	r2, #645	; 0x285
 800f482:	4293      	cmp	r3, r2
 800f484:	d00a      	beq.n	800f49c <OidFromId.lto_priv.408+0x22c>
 800f486:	f240 2203 	movw	r2, #515	; 0x203
 800f48a:	4293      	cmp	r3, r2
 800f48c:	f040 824e 	bne.w	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = keyDsaOid;
 800f490:	4b39      	ldr	r3, [pc, #228]	; (800f578 <OidFromId.lto_priv.408+0x308>)
 800f492:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(keyDsaOid);
 800f494:	9b01      	ldr	r3, [sp, #4]
 800f496:	2207      	movs	r2, #7
 800f498:	601a      	str	r2, [r3, #0]
 800f49a:	e247      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = keyRsaOid;
 800f49c:	4b37      	ldr	r3, [pc, #220]	; (800f57c <OidFromId.lto_priv.408+0x30c>)
 800f49e:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(keyRsaOid);
 800f4a0:	9b01      	ldr	r3, [sp, #4]
 800f4a2:	2209      	movs	r2, #9
 800f4a4:	601a      	str	r2, [r3, #0]
 800f4a6:	e241      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = keyEcdsaOid;
 800f4a8:	4b35      	ldr	r3, [pc, #212]	; (800f580 <OidFromId.lto_priv.408+0x310>)
 800f4aa:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(keyEcdsaOid);
 800f4ac:	9b01      	ldr	r3, [sp, #4]
 800f4ae:	2207      	movs	r2, #7
 800f4b0:	601a      	str	r2, [r3, #0]
 800f4b2:	e23b      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
 800f4b4:	ab05      	add	r3, sp, #20
 800f4b6:	9a01      	ldr	r2, [sp, #4]
 800f4b8:	4619      	mov	r1, r3
 800f4ba:	9803      	ldr	r0, [sp, #12]
 800f4bc:	f000 fcc0 	bl	800fe40 <wc_ecc_get_oid>
 800f4c0:	e234      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f4c2:	9b03      	ldr	r3, [sp, #12]
 800f4c4:	f5b3 7fd9 	cmp.w	r3, #434	; 0x1b2
 800f4c8:	d015      	beq.n	800f4f6 <OidFromId.lto_priv.408+0x286>
 800f4ca:	f5b3 7fd9 	cmp.w	r3, #434	; 0x1b2
 800f4ce:	d805      	bhi.n	800f4dc <OidFromId.lto_priv.408+0x26c>
 800f4d0:	2b45      	cmp	r3, #69	; 0x45
 800f4d2:	d01c      	beq.n	800f50e <OidFromId.lto_priv.408+0x29e>
 800f4d4:	f5b3 7fcf 	cmp.w	r3, #414	; 0x19e
 800f4d8:	d007      	beq.n	800f4ea <OidFromId.lto_priv.408+0x27a>
 800f4da:	e227      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f4dc:	f5b3 7fe3 	cmp.w	r3, #454	; 0x1c6
 800f4e0:	d00f      	beq.n	800f502 <OidFromId.lto_priv.408+0x292>
 800f4e2:	f5b3 7f23 	cmp.w	r3, #652	; 0x28c
 800f4e6:	d018      	beq.n	800f51a <OidFromId.lto_priv.408+0x2aa>
 800f4e8:	e220      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = blkAes128CbcOid;
 800f4ea:	4b26      	ldr	r3, [pc, #152]	; (800f584 <OidFromId.lto_priv.408+0x314>)
 800f4ec:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(blkAes128CbcOid);
 800f4ee:	9b01      	ldr	r3, [sp, #4]
 800f4f0:	2209      	movs	r2, #9
 800f4f2:	601a      	str	r2, [r3, #0]
 800f4f4:	e21a      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = blkAes192CbcOid;
 800f4f6:	4b24      	ldr	r3, [pc, #144]	; (800f588 <OidFromId.lto_priv.408+0x318>)
 800f4f8:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(blkAes192CbcOid);
 800f4fa:	9b01      	ldr	r3, [sp, #4]
 800f4fc:	2209      	movs	r2, #9
 800f4fe:	601a      	str	r2, [r3, #0]
 800f500:	e214      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = blkAes256CbcOid;
 800f502:	4b22      	ldr	r3, [pc, #136]	; (800f58c <OidFromId.lto_priv.408+0x31c>)
 800f504:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(blkAes256CbcOid);
 800f506:	9b01      	ldr	r3, [sp, #4]
 800f508:	2209      	movs	r2, #9
 800f50a:	601a      	str	r2, [r3, #0]
 800f50c:	e20e      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = blkDesCbcOid;
 800f50e:	4b20      	ldr	r3, [pc, #128]	; (800f590 <OidFromId.lto_priv.408+0x320>)
 800f510:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(blkDesCbcOid);
 800f512:	9b01      	ldr	r3, [sp, #4]
 800f514:	2205      	movs	r2, #5
 800f516:	601a      	str	r2, [r3, #0]
 800f518:	e208      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = blkDes3CbcOid;
 800f51a:	4b1e      	ldr	r3, [pc, #120]	; (800f594 <OidFromId.lto_priv.408+0x324>)
 800f51c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(blkDes3CbcOid);
 800f51e:	9b01      	ldr	r3, [sp, #4]
 800f520:	2208      	movs	r2, #8
 800f522:	601a      	str	r2, [r3, #0]
 800f524:	e202      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f526:	bf00      	nop
 800f528:	080243c8 	.word	0x080243c8
 800f52c:	080243d0 	.word	0x080243d0
 800f530:	080243d8 	.word	0x080243d8
 800f534:	080243e0 	.word	0x080243e0
 800f538:	080243ec 	.word	0x080243ec
 800f53c:	080243f8 	.word	0x080243f8
 800f540:	08024404 	.word	0x08024404
 800f544:	08024410 	.word	0x08024410
 800f548:	08024418 	.word	0x08024418
 800f54c:	08024424 	.word	0x08024424
 800f550:	08024430 	.word	0x08024430
 800f554:	0802443c 	.word	0x0802443c
 800f558:	08024448 	.word	0x08024448
 800f55c:	08024454 	.word	0x08024454
 800f560:	08024460 	.word	0x08024460
 800f564:	0802446c 	.word	0x0802446c
 800f568:	08024474 	.word	0x08024474
 800f56c:	0802447c 	.word	0x0802447c
 800f570:	08024484 	.word	0x08024484
 800f574:	0802448c 	.word	0x0802448c
 800f578:	08024494 	.word	0x08024494
 800f57c:	0802449c 	.word	0x0802449c
 800f580:	080244a8 	.word	0x080244a8
 800f584:	080244b0 	.word	0x080244b0
 800f588:	080244bc 	.word	0x080244bc
 800f58c:	080244c8 	.word	0x080244c8
 800f590:	080244d4 	.word	0x080244d4
 800f594:	080244dc 	.word	0x080244dc
            switch (id) {
 800f598:	9b03      	ldr	r3, [sp, #12]
 800f59a:	3b45      	subs	r3, #69	; 0x45
 800f59c:	2b63      	cmp	r3, #99	; 0x63
 800f59e:	f200 81c5 	bhi.w	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f5a2:	a201      	add	r2, pc, #4	; (adr r2, 800f5a8 <OidFromId.lto_priv.408+0x338>)
 800f5a4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f5a8:	0800f75d 	.word	0x0800f75d
 800f5ac:	0800f92d 	.word	0x0800f92d
 800f5b0:	0800f92d 	.word	0x0800f92d
 800f5b4:	0800f92d 	.word	0x0800f92d
 800f5b8:	0800f92d 	.word	0x0800f92d
 800f5bc:	0800f92d 	.word	0x0800f92d
 800f5c0:	0800f92d 	.word	0x0800f92d
 800f5c4:	0800f92d 	.word	0x0800f92d
 800f5c8:	0800f92d 	.word	0x0800f92d
 800f5cc:	0800f92d 	.word	0x0800f92d
 800f5d0:	0800f92d 	.word	0x0800f92d
 800f5d4:	0800f92d 	.word	0x0800f92d
 800f5d8:	0800f92d 	.word	0x0800f92d
 800f5dc:	0800f92d 	.word	0x0800f92d
 800f5e0:	0800f92d 	.word	0x0800f92d
 800f5e4:	0800f92d 	.word	0x0800f92d
 800f5e8:	0800f92d 	.word	0x0800f92d
 800f5ec:	0800f92d 	.word	0x0800f92d
 800f5f0:	0800f92d 	.word	0x0800f92d
 800f5f4:	0800f92d 	.word	0x0800f92d
 800f5f8:	0800f92d 	.word	0x0800f92d
 800f5fc:	0800f92d 	.word	0x0800f92d
 800f600:	0800f92d 	.word	0x0800f92d
 800f604:	0800f92d 	.word	0x0800f92d
 800f608:	0800f92d 	.word	0x0800f92d
 800f60c:	0800f92d 	.word	0x0800f92d
 800f610:	0800f92d 	.word	0x0800f92d
 800f614:	0800f92d 	.word	0x0800f92d
 800f618:	0800f92d 	.word	0x0800f92d
 800f61c:	0800f92d 	.word	0x0800f92d
 800f620:	0800f92d 	.word	0x0800f92d
 800f624:	0800f92d 	.word	0x0800f92d
 800f628:	0800f92d 	.word	0x0800f92d
 800f62c:	0800f92d 	.word	0x0800f92d
 800f630:	0800f92d 	.word	0x0800f92d
 800f634:	0800f92d 	.word	0x0800f92d
 800f638:	0800f92d 	.word	0x0800f92d
 800f63c:	0800f92d 	.word	0x0800f92d
 800f640:	0800f92d 	.word	0x0800f92d
 800f644:	0800f92d 	.word	0x0800f92d
 800f648:	0800f92d 	.word	0x0800f92d
 800f64c:	0800f92d 	.word	0x0800f92d
 800f650:	0800f92d 	.word	0x0800f92d
 800f654:	0800f92d 	.word	0x0800f92d
 800f658:	0800f92d 	.word	0x0800f92d
 800f65c:	0800f92d 	.word	0x0800f92d
 800f660:	0800f92d 	.word	0x0800f92d
 800f664:	0800f92d 	.word	0x0800f92d
 800f668:	0800f92d 	.word	0x0800f92d
 800f66c:	0800f92d 	.word	0x0800f92d
 800f670:	0800f92d 	.word	0x0800f92d
 800f674:	0800f92d 	.word	0x0800f92d
 800f678:	0800f92d 	.word	0x0800f92d
 800f67c:	0800f92d 	.word	0x0800f92d
 800f680:	0800f92d 	.word	0x0800f92d
 800f684:	0800f92d 	.word	0x0800f92d
 800f688:	0800f92d 	.word	0x0800f92d
 800f68c:	0800f92d 	.word	0x0800f92d
 800f690:	0800f92d 	.word	0x0800f92d
 800f694:	0800f775 	.word	0x0800f775
 800f698:	0800f78d 	.word	0x0800f78d
 800f69c:	0800f92d 	.word	0x0800f92d
 800f6a0:	0800f745 	.word	0x0800f745
 800f6a4:	0800f92d 	.word	0x0800f92d
 800f6a8:	0800f739 	.word	0x0800f739
 800f6ac:	0800f92d 	.word	0x0800f92d
 800f6b0:	0800f92d 	.word	0x0800f92d
 800f6b4:	0800f92d 	.word	0x0800f92d
 800f6b8:	0800f92d 	.word	0x0800f92d
 800f6bc:	0800f92d 	.word	0x0800f92d
 800f6c0:	0800f92d 	.word	0x0800f92d
 800f6c4:	0800f92d 	.word	0x0800f92d
 800f6c8:	0800f92d 	.word	0x0800f92d
 800f6cc:	0800f92d 	.word	0x0800f92d
 800f6d0:	0800f92d 	.word	0x0800f92d
 800f6d4:	0800f7b1 	.word	0x0800f7b1
 800f6d8:	0800f751 	.word	0x0800f751
 800f6dc:	0800f781 	.word	0x0800f781
 800f6e0:	0800f92d 	.word	0x0800f92d
 800f6e4:	0800f92d 	.word	0x0800f92d
 800f6e8:	0800f769 	.word	0x0800f769
 800f6ec:	0800f92d 	.word	0x0800f92d
 800f6f0:	0800f7a5 	.word	0x0800f7a5
 800f6f4:	0800f92d 	.word	0x0800f92d
 800f6f8:	0800f92d 	.word	0x0800f92d
 800f6fc:	0800f92d 	.word	0x0800f92d
 800f700:	0800f92d 	.word	0x0800f92d
 800f704:	0800f92d 	.word	0x0800f92d
 800f708:	0800f92d 	.word	0x0800f92d
 800f70c:	0800f92d 	.word	0x0800f92d
 800f710:	0800f92d 	.word	0x0800f92d
 800f714:	0800f92d 	.word	0x0800f92d
 800f718:	0800f92d 	.word	0x0800f92d
 800f71c:	0800f92d 	.word	0x0800f92d
 800f720:	0800f92d 	.word	0x0800f92d
 800f724:	0800f92d 	.word	0x0800f92d
 800f728:	0800f92d 	.word	0x0800f92d
 800f72c:	0800f92d 	.word	0x0800f92d
 800f730:	0800f92d 	.word	0x0800f92d
 800f734:	0800f799 	.word	0x0800f799
                    oid = extBasicCaOid;
 800f738:	4b7f      	ldr	r3, [pc, #508]	; (800f938 <OidFromId.lto_priv.408+0x6c8>)
 800f73a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extBasicCaOid);
 800f73c:	9b01      	ldr	r3, [sp, #4]
 800f73e:	2203      	movs	r2, #3
 800f740:	601a      	str	r2, [r3, #0]
 800f742:	e0f3      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAltNamesOid;
 800f744:	4b7d      	ldr	r3, [pc, #500]	; (800f93c <OidFromId.lto_priv.408+0x6cc>)
 800f746:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAltNamesOid);
 800f748:	9b01      	ldr	r3, [sp, #4]
 800f74a:	2203      	movs	r2, #3
 800f74c:	601a      	str	r2, [r3, #0]
 800f74e:	e0ed      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extCrlDistOid;
 800f750:	4b7b      	ldr	r3, [pc, #492]	; (800f940 <OidFromId.lto_priv.408+0x6d0>)
 800f752:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extCrlDistOid);
 800f754:	9b01      	ldr	r3, [sp, #4]
 800f756:	2203      	movs	r2, #3
 800f758:	601a      	str	r2, [r3, #0]
 800f75a:	e0e7      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAuthInfoOid;
 800f75c:	4b79      	ldr	r3, [pc, #484]	; (800f944 <OidFromId.lto_priv.408+0x6d4>)
 800f75e:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAuthInfoOid);
 800f760:	9b01      	ldr	r3, [sp, #4]
 800f762:	2208      	movs	r2, #8
 800f764:	601a      	str	r2, [r3, #0]
 800f766:	e0e1      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAuthKeyOid;
 800f768:	4b77      	ldr	r3, [pc, #476]	; (800f948 <OidFromId.lto_priv.408+0x6d8>)
 800f76a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAuthKeyOid);
 800f76c:	9b01      	ldr	r3, [sp, #4]
 800f76e:	2203      	movs	r2, #3
 800f770:	601a      	str	r2, [r3, #0]
 800f772:	e0db      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extSubjKeyOid;
 800f774:	4b75      	ldr	r3, [pc, #468]	; (800f94c <OidFromId.lto_priv.408+0x6dc>)
 800f776:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extSubjKeyOid);
 800f778:	9b01      	ldr	r3, [sp, #4]
 800f77a:	2203      	movs	r2, #3
 800f77c:	601a      	str	r2, [r3, #0]
 800f77e:	e0d5      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extCertPolicyOid;
 800f780:	4b73      	ldr	r3, [pc, #460]	; (800f950 <OidFromId.lto_priv.408+0x6e0>)
 800f782:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extCertPolicyOid);
 800f784:	9b01      	ldr	r3, [sp, #4]
 800f786:	2203      	movs	r2, #3
 800f788:	601a      	str	r2, [r3, #0]
 800f78a:	e0cf      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extKeyUsageOid;
 800f78c:	4b71      	ldr	r3, [pc, #452]	; (800f954 <OidFromId.lto_priv.408+0x6e4>)
 800f78e:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extKeyUsageOid);
 800f790:	9b01      	ldr	r3, [sp, #4]
 800f792:	2203      	movs	r2, #3
 800f794:	601a      	str	r2, [r3, #0]
 800f796:	e0c9      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extInhibitAnyOid;
 800f798:	4b6f      	ldr	r3, [pc, #444]	; (800f958 <OidFromId.lto_priv.408+0x6e8>)
 800f79a:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extInhibitAnyOid);
 800f79c:	9b01      	ldr	r3, [sp, #4]
 800f79e:	2203      	movs	r2, #3
 800f7a0:	601a      	str	r2, [r3, #0]
 800f7a2:	e0c3      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageOid;
 800f7a4:	4b6d      	ldr	r3, [pc, #436]	; (800f95c <OidFromId.lto_priv.408+0x6ec>)
 800f7a6:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageOid);
 800f7a8:	9b01      	ldr	r3, [sp, #4]
 800f7aa:	2203      	movs	r2, #3
 800f7ac:	601a      	str	r2, [r3, #0]
 800f7ae:	e0bd      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extNameConsOid;
 800f7b0:	4b6b      	ldr	r3, [pc, #428]	; (800f960 <OidFromId.lto_priv.408+0x6f0>)
 800f7b2:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extNameConsOid);
 800f7b4:	9b01      	ldr	r3, [sp, #4]
 800f7b6:	2203      	movs	r2, #3
 800f7b8:	601a      	str	r2, [r3, #0]
 800f7ba:	e0b7      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f7bc:	9b03      	ldr	r3, [sp, #12]
 800f7be:	2b74      	cmp	r3, #116	; 0x74
 800f7c0:	d002      	beq.n	800f7c8 <OidFromId.lto_priv.408+0x558>
 800f7c2:	2b75      	cmp	r3, #117	; 0x75
 800f7c4:	d006      	beq.n	800f7d4 <OidFromId.lto_priv.408+0x564>
 800f7c6:	e0b1      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAuthInfoOcspOid;
 800f7c8:	4b66      	ldr	r3, [pc, #408]	; (800f964 <OidFromId.lto_priv.408+0x6f4>)
 800f7ca:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAuthInfoOcspOid);
 800f7cc:	9b01      	ldr	r3, [sp, #4]
 800f7ce:	2208      	movs	r2, #8
 800f7d0:	601a      	str	r2, [r3, #0]
 800f7d2:	e0ab      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAuthInfoCaIssuerOid;
 800f7d4:	4b64      	ldr	r3, [pc, #400]	; (800f968 <OidFromId.lto_priv.408+0x6f8>)
 800f7d6:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
 800f7d8:	9b01      	ldr	r3, [sp, #4]
 800f7da:	2208      	movs	r2, #8
 800f7dc:	601a      	str	r2, [r3, #0]
 800f7de:	e0a5      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f7e0:	9b03      	ldr	r3, [sp, #12]
 800f7e2:	2b92      	cmp	r3, #146	; 0x92
 800f7e4:	f040 80a2 	bne.w	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extCertPolicyAnyOid;
 800f7e8:	4b60      	ldr	r3, [pc, #384]	; (800f96c <OidFromId.lto_priv.408+0x6fc>)
 800f7ea:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extCertPolicyAnyOid);
 800f7ec:	9b01      	ldr	r3, [sp, #4]
 800f7ee:	2204      	movs	r2, #4
 800f7f0:	601a      	str	r2, [r3, #0]
 800f7f2:	e09b      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f7f4:	9b03      	ldr	r3, [sp, #12]
 800f7f6:	2b4f      	cmp	r3, #79	; 0x4f
 800f7f8:	f040 8098 	bne.w	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extAltNamesHwNameOid;
 800f7fc:	4b5c      	ldr	r3, [pc, #368]	; (800f970 <OidFromId.lto_priv.408+0x700>)
 800f7fe:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extAltNamesHwNameOid);
 800f800:	9b01      	ldr	r3, [sp, #4]
 800f802:	2208      	movs	r2, #8
 800f804:	601a      	str	r2, [r3, #0]
 800f806:	e091      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f808:	9b03      	ldr	r3, [sp, #12]
 800f80a:	2b4a      	cmp	r3, #74	; 0x4a
 800f80c:	d027      	beq.n	800f85e <OidFromId.lto_priv.408+0x5ee>
 800f80e:	2b4a      	cmp	r3, #74	; 0x4a
 800f810:	d806      	bhi.n	800f820 <OidFromId.lto_priv.408+0x5b0>
 800f812:	2b48      	cmp	r3, #72	; 0x48
 800f814:	d017      	beq.n	800f846 <OidFromId.lto_priv.408+0x5d6>
 800f816:	2b48      	cmp	r3, #72	; 0x48
 800f818:	d81b      	bhi.n	800f852 <OidFromId.lto_priv.408+0x5e2>
 800f81a:	2b47      	cmp	r3, #71	; 0x47
 800f81c:	d00d      	beq.n	800f83a <OidFromId.lto_priv.408+0x5ca>
 800f81e:	e085      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f820:	2b4f      	cmp	r3, #79	; 0x4f
 800f822:	d028      	beq.n	800f876 <OidFromId.lto_priv.408+0x606>
 800f824:	2b97      	cmp	r3, #151	; 0x97
 800f826:	d002      	beq.n	800f82e <OidFromId.lto_priv.408+0x5be>
 800f828:	2b4e      	cmp	r3, #78	; 0x4e
 800f82a:	d01e      	beq.n	800f86a <OidFromId.lto_priv.408+0x5fa>
 800f82c:	e07e      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageAnyOid;
 800f82e:	4b51      	ldr	r3, [pc, #324]	; (800f974 <OidFromId.lto_priv.408+0x704>)
 800f830:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 800f832:	9b01      	ldr	r3, [sp, #4]
 800f834:	2204      	movs	r2, #4
 800f836:	601a      	str	r2, [r3, #0]
 800f838:	e078      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageServerAuthOid;
 800f83a:	4b4f      	ldr	r3, [pc, #316]	; (800f978 <OidFromId.lto_priv.408+0x708>)
 800f83c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);
 800f83e:	9b01      	ldr	r3, [sp, #4]
 800f840:	2208      	movs	r2, #8
 800f842:	601a      	str	r2, [r3, #0]
 800f844:	e072      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageClientAuthOid;
 800f846:	4b4d      	ldr	r3, [pc, #308]	; (800f97c <OidFromId.lto_priv.408+0x70c>)
 800f848:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);
 800f84a:	9b01      	ldr	r3, [sp, #4]
 800f84c:	2208      	movs	r2, #8
 800f84e:	601a      	str	r2, [r3, #0]
 800f850:	e06c      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageCodeSigningOid;
 800f852:	4b4b      	ldr	r3, [pc, #300]	; (800f980 <OidFromId.lto_priv.408+0x710>)
 800f854:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);
 800f856:	9b01      	ldr	r3, [sp, #4]
 800f858:	2208      	movs	r2, #8
 800f85a:	601a      	str	r2, [r3, #0]
 800f85c:	e066      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageEmailProtectOid;
 800f85e:	4b49      	ldr	r3, [pc, #292]	; (800f984 <OidFromId.lto_priv.408+0x714>)
 800f860:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);
 800f862:	9b01      	ldr	r3, [sp, #4]
 800f864:	2208      	movs	r2, #8
 800f866:	601a      	str	r2, [r3, #0]
 800f868:	e060      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageTimestampOid;
 800f86a:	4b47      	ldr	r3, [pc, #284]	; (800f988 <OidFromId.lto_priv.408+0x718>)
 800f86c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageTimestampOid);
 800f86e:	9b01      	ldr	r3, [sp, #4]
 800f870:	2208      	movs	r2, #8
 800f872:	601a      	str	r2, [r3, #0]
 800f874:	e05a      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = extExtKeyUsageOcspSignOid;
 800f876:	4b45      	ldr	r3, [pc, #276]	; (800f98c <OidFromId.lto_priv.408+0x71c>)
 800f878:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
 800f87a:	9b01      	ldr	r3, [sp, #4]
 800f87c:	2208      	movs	r2, #8
 800f87e:	601a      	str	r2, [r3, #0]
 800f880:	e054      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f882:	9b03      	ldr	r3, [sp, #12]
 800f884:	f5b3 7f25 	cmp.w	r3, #660	; 0x294
 800f888:	d150      	bne.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = pbkdf2Oid;
 800f88a:	4b41      	ldr	r3, [pc, #260]	; (800f990 <OidFromId.lto_priv.408+0x720>)
 800f88c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(pbkdf2Oid);
 800f88e:	9b01      	ldr	r3, [sp, #4]
 800f890:	2209      	movs	r2, #9
 800f892:	601a      	str	r2, [r3, #0]
 800f894:	e04a      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f896:	9b03      	ldr	r3, [sp, #12]
 800f898:	f240 12b5 	movw	r2, #437	; 0x1b5
 800f89c:	4293      	cmp	r3, r2
 800f89e:	d00d      	beq.n	800f8bc <OidFromId.lto_priv.408+0x64c>
 800f8a0:	f240 12c9 	movw	r2, #457	; 0x1c9
 800f8a4:	4293      	cmp	r3, r2
 800f8a6:	d00f      	beq.n	800f8c8 <OidFromId.lto_priv.408+0x658>
 800f8a8:	f240 12a1 	movw	r2, #417	; 0x1a1
 800f8ac:	4293      	cmp	r3, r2
 800f8ae:	d13d      	bne.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = wrapAes128Oid;
 800f8b0:	4b38      	ldr	r3, [pc, #224]	; (800f994 <OidFromId.lto_priv.408+0x724>)
 800f8b2:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(wrapAes128Oid);
 800f8b4:	9b01      	ldr	r3, [sp, #4]
 800f8b6:	2209      	movs	r2, #9
 800f8b8:	601a      	str	r2, [r3, #0]
 800f8ba:	e037      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = wrapAes192Oid;
 800f8bc:	4b36      	ldr	r3, [pc, #216]	; (800f998 <OidFromId.lto_priv.408+0x728>)
 800f8be:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(wrapAes192Oid);
 800f8c0:	9b01      	ldr	r3, [sp, #4]
 800f8c2:	2209      	movs	r2, #9
 800f8c4:	601a      	str	r2, [r3, #0]
 800f8c6:	e031      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = wrapAes256Oid;
 800f8c8:	4b34      	ldr	r3, [pc, #208]	; (800f99c <OidFromId.lto_priv.408+0x72c>)
 800f8ca:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(wrapAes256Oid);
 800f8cc:	9b01      	ldr	r3, [sp, #4]
 800f8ce:	2209      	movs	r2, #9
 800f8d0:	601a      	str	r2, [r3, #0]
 800f8d2:	e02b      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
            switch (id) {
 800f8d4:	9b03      	ldr	r3, [sp, #12]
 800f8d6:	2bbe      	cmp	r3, #190	; 0xbe
 800f8d8:	d01d      	beq.n	800f916 <OidFromId.lto_priv.408+0x6a6>
 800f8da:	2bbe      	cmp	r3, #190	; 0xbe
 800f8dc:	d804      	bhi.n	800f8e8 <OidFromId.lto_priv.408+0x678>
 800f8de:	2bbc      	cmp	r3, #188	; 0xbc
 800f8e0:	d00d      	beq.n	800f8fe <OidFromId.lto_priv.408+0x68e>
 800f8e2:	2bbd      	cmp	r3, #189	; 0xbd
 800f8e4:	d011      	beq.n	800f90a <OidFromId.lto_priv.408+0x69a>
 800f8e6:	e021      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
 800f8e8:	2bbf      	cmp	r3, #191	; 0xbf
 800f8ea:	d01a      	beq.n	800f922 <OidFromId.lto_priv.408+0x6b2>
 800f8ec:	f5b3 7fe8 	cmp.w	r3, #464	; 0x1d0
 800f8f0:	d11c      	bne.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = dhSinglePass_stdDH_sha1kdf_Oid;
 800f8f2:	4b2b      	ldr	r3, [pc, #172]	; (800f9a0 <OidFromId.lto_priv.408+0x730>)
 800f8f4:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha1kdf_Oid);
 800f8f6:	9b01      	ldr	r3, [sp, #4]
 800f8f8:	2209      	movs	r2, #9
 800f8fa:	601a      	str	r2, [r3, #0]
 800f8fc:	e016      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = dhSinglePass_stdDH_sha224kdf_Oid;
 800f8fe:	4b29      	ldr	r3, [pc, #164]	; (800f9a4 <OidFromId.lto_priv.408+0x734>)
 800f900:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);
 800f902:	9b01      	ldr	r3, [sp, #4]
 800f904:	2206      	movs	r2, #6
 800f906:	601a      	str	r2, [r3, #0]
 800f908:	e010      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 800f90a:	4b27      	ldr	r3, [pc, #156]	; (800f9a8 <OidFromId.lto_priv.408+0x738>)
 800f90c:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);
 800f90e:	9b01      	ldr	r3, [sp, #4]
 800f910:	2206      	movs	r2, #6
 800f912:	601a      	str	r2, [r3, #0]
 800f914:	e00a      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = dhSinglePass_stdDH_sha384kdf_Oid;
 800f916:	4b25      	ldr	r3, [pc, #148]	; (800f9ac <OidFromId.lto_priv.408+0x73c>)
 800f918:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha384kdf_Oid);
 800f91a:	9b01      	ldr	r3, [sp, #4]
 800f91c:	2206      	movs	r2, #6
 800f91e:	601a      	str	r2, [r3, #0]
 800f920:	e004      	b.n	800f92c <OidFromId.lto_priv.408+0x6bc>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
 800f922:	4b23      	ldr	r3, [pc, #140]	; (800f9b0 <OidFromId.lto_priv.408+0x740>)
 800f924:	9305      	str	r3, [sp, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
 800f926:	9b01      	ldr	r3, [sp, #4]
 800f928:	2206      	movs	r2, #6
 800f92a:	601a      	str	r2, [r3, #0]
    return oid;
 800f92c:	9b05      	ldr	r3, [sp, #20]
}
 800f92e:	4618      	mov	r0, r3
 800f930:	b007      	add	sp, #28
 800f932:	f85d fb04 	ldr.w	pc, [sp], #4
 800f936:	bf00      	nop
 800f938:	08024534 	.word	0x08024534
 800f93c:	08024538 	.word	0x08024538
 800f940:	0802453c 	.word	0x0802453c
 800f944:	08024540 	.word	0x08024540
 800f948:	08024548 	.word	0x08024548
 800f94c:	0802454c 	.word	0x0802454c
 800f950:	08024550 	.word	0x08024550
 800f954:	08024554 	.word	0x08024554
 800f958:	08024558 	.word	0x08024558
 800f95c:	0802455c 	.word	0x0802455c
 800f960:	08024560 	.word	0x08024560
 800f964:	08024564 	.word	0x08024564
 800f968:	0802456c 	.word	0x0802456c
 800f96c:	08024574 	.word	0x08024574
 800f970:	08024578 	.word	0x08024578
 800f974:	08024580 	.word	0x08024580
 800f978:	08024584 	.word	0x08024584
 800f97c:	0802458c 	.word	0x0802458c
 800f980:	08024594 	.word	0x08024594
 800f984:	0802459c 	.word	0x0802459c
 800f988:	080245a4 	.word	0x080245a4
 800f98c:	080245ac 	.word	0x080245ac
 800f990:	080245b4 	.word	0x080245b4
 800f994:	080244e4 	.word	0x080244e4
 800f998:	080244f0 	.word	0x080244f0
 800f99c:	080244fc 	.word	0x080244fc
 800f9a0:	08024508 	.word	0x08024508
 800f9a4:	08024514 	.word	0x08024514
 800f9a8:	0802451c 	.word	0x0802451c
 800f9ac:	08024524 	.word	0x08024524
 800f9b0:	0802452c 	.word	0x0802452c
	...

0800f9c0 <GetASNObjectId.lto_priv.413>:
{
 800f9c0:	b500      	push	{lr}
 800f9c2:	b089      	sub	sp, #36	; 0x24
 800f9c4:	9003      	str	r0, [sp, #12]
 800f9c6:	9102      	str	r1, [sp, #8]
 800f9c8:	9201      	str	r2, [sp, #4]
 800f9ca:	9300      	str	r3, [sp, #0]
    word32 idx = *inOutIdx;
 800f9cc:	9b02      	ldr	r3, [sp, #8]
 800f9ce:	681b      	ldr	r3, [r3, #0]
 800f9d0:	9306      	str	r3, [sp, #24]
    if ((idx + 1) > maxIdx)
 800f9d2:	9b06      	ldr	r3, [sp, #24]
 800f9d4:	1c5a      	adds	r2, r3, #1
 800f9d6:	9b00      	ldr	r3, [sp, #0]
 800f9d8:	429a      	cmp	r2, r3
 800f9da:	d902      	bls.n	800f9e2 <GetASNObjectId.lto_priv.413+0x22>
        return BUFFER_E;
 800f9dc:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800f9e0:	e021      	b.n	800fa26 <GetASNObjectId.lto_priv.413+0x66>
    b = input[idx++];
 800f9e2:	9b06      	ldr	r3, [sp, #24]
 800f9e4:	1c5a      	adds	r2, r3, #1
 800f9e6:	9206      	str	r2, [sp, #24]
 800f9e8:	9a03      	ldr	r2, [sp, #12]
 800f9ea:	4413      	add	r3, r2
 800f9ec:	781b      	ldrb	r3, [r3, #0]
 800f9ee:	f88d 301f 	strb.w	r3, [sp, #31]
    if (b != ASN_OBJECT_ID)
 800f9f2:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800f9f6:	2b06      	cmp	r3, #6
 800f9f8:	d002      	beq.n	800fa00 <GetASNObjectId.lto_priv.413+0x40>
        return ASN_OBJECT_ID_E;
 800f9fa:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800f9fe:	e012      	b.n	800fa26 <GetASNObjectId.lto_priv.413+0x66>
    if (GetLength(input, &idx, &length, maxIdx) < 0)
 800fa00:	aa05      	add	r2, sp, #20
 800fa02:	a906      	add	r1, sp, #24
 800fa04:	9b00      	ldr	r3, [sp, #0]
 800fa06:	9803      	ldr	r0, [sp, #12]
 800fa08:	f7ff f932 	bl	800ec70 <GetLength>
 800fa0c:	4603      	mov	r3, r0
 800fa0e:	2b00      	cmp	r3, #0
 800fa10:	da02      	bge.n	800fa18 <GetASNObjectId.lto_priv.413+0x58>
        return ASN_PARSE_E;
 800fa12:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fa16:	e006      	b.n	800fa26 <GetASNObjectId.lto_priv.413+0x66>
    *len = length;
 800fa18:	9a05      	ldr	r2, [sp, #20]
 800fa1a:	9b01      	ldr	r3, [sp, #4]
 800fa1c:	601a      	str	r2, [r3, #0]
    *inOutIdx = idx;
 800fa1e:	9a06      	ldr	r2, [sp, #24]
 800fa20:	9b02      	ldr	r3, [sp, #8]
 800fa22:	601a      	str	r2, [r3, #0]
    return 0;
 800fa24:	2300      	movs	r3, #0
}
 800fa26:	4618      	mov	r0, r3
 800fa28:	b009      	add	sp, #36	; 0x24
 800fa2a:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa2e:	bf00      	nop

0800fa30 <SetObjectId.lto_priv.390>:
{
 800fa30:	b500      	push	{lr}
 800fa32:	b085      	sub	sp, #20
 800fa34:	9001      	str	r0, [sp, #4]
 800fa36:	9100      	str	r1, [sp, #0]
    int idx = 0;
 800fa38:	2300      	movs	r3, #0
 800fa3a:	9303      	str	r3, [sp, #12]
    output[idx++] = ASN_OBJECT_ID;
 800fa3c:	9b03      	ldr	r3, [sp, #12]
 800fa3e:	1c5a      	adds	r2, r3, #1
 800fa40:	9203      	str	r2, [sp, #12]
 800fa42:	461a      	mov	r2, r3
 800fa44:	9b00      	ldr	r3, [sp, #0]
 800fa46:	4413      	add	r3, r2
 800fa48:	2206      	movs	r2, #6
 800fa4a:	701a      	strb	r2, [r3, #0]
    idx += SetLength(len, output + idx);
 800fa4c:	9801      	ldr	r0, [sp, #4]
 800fa4e:	9b03      	ldr	r3, [sp, #12]
 800fa50:	9a00      	ldr	r2, [sp, #0]
 800fa52:	4413      	add	r3, r2
 800fa54:	4619      	mov	r1, r3
 800fa56:	f7fe fcfb 	bl	800e450 <SetLength>
 800fa5a:	4602      	mov	r2, r0
 800fa5c:	9b03      	ldr	r3, [sp, #12]
 800fa5e:	4413      	add	r3, r2
 800fa60:	9303      	str	r3, [sp, #12]
    return idx;
 800fa62:	9b03      	ldr	r3, [sp, #12]
}
 800fa64:	4618      	mov	r0, r3
 800fa66:	b005      	add	sp, #20
 800fa68:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa6c:	0000      	movs	r0, r0
	...

0800fa70 <GetObjectId>:
{
 800fa70:	b500      	push	{lr}
 800fa72:	b08d      	sub	sp, #52	; 0x34
 800fa74:	9003      	str	r0, [sp, #12]
 800fa76:	9102      	str	r1, [sp, #8]
 800fa78:	9201      	str	r2, [sp, #4]
 800fa7a:	9300      	str	r3, [sp, #0]
    int    ret = 0, length;
 800fa7c:	2300      	movs	r3, #0
 800fa7e:	930a      	str	r3, [sp, #40]	; 0x28
    word32 idx = *inOutIdx;
 800fa80:	9b02      	ldr	r3, [sp, #8]
 800fa82:	681b      	ldr	r3, [r3, #0]
 800fa84:	9306      	str	r3, [sp, #24]
    word32 actualOidSz = 0;
 800fa86:	2300      	movs	r3, #0
 800fa88:	930b      	str	r3, [sp, #44]	; 0x2c
    *oid = 0;
 800fa8a:	9b01      	ldr	r3, [sp, #4]
 800fa8c:	2200      	movs	r2, #0
 800fa8e:	601a      	str	r2, [r3, #0]
    ret = GetASNObjectId(input, &idx, &length, maxIdx);
 800fa90:	aa07      	add	r2, sp, #28
 800fa92:	a906      	add	r1, sp, #24
 800fa94:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800fa96:	9803      	ldr	r0, [sp, #12]
 800fa98:	f7ff ff92 	bl	800f9c0 <GetASNObjectId.lto_priv.413>
 800fa9c:	900a      	str	r0, [sp, #40]	; 0x28
    if (ret != 0)
 800fa9e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800faa0:	2b00      	cmp	r3, #0
 800faa2:	d001      	beq.n	800faa8 <GetObjectId+0x38>
        return ret;
 800faa4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800faa6:	e03e      	b.n	800fb26 <GetObjectId+0xb6>
    actualOid = &input[idx];
 800faa8:	9b06      	ldr	r3, [sp, #24]
 800faaa:	9a03      	ldr	r2, [sp, #12]
 800faac:	4413      	add	r3, r2
 800faae:	9309      	str	r3, [sp, #36]	; 0x24
    if (length > 0)
 800fab0:	9b07      	ldr	r3, [sp, #28]
 800fab2:	2b00      	cmp	r3, #0
 800fab4:	dd0e      	ble.n	800fad4 <GetObjectId+0x64>
        actualOidSz = (word32)length;
 800fab6:	9b07      	ldr	r3, [sp, #28]
 800fab8:	930b      	str	r3, [sp, #44]	; 0x2c
 800faba:	e00b      	b.n	800fad4 <GetObjectId+0x64>
        *oid += (word32)input[idx];
 800fabc:	9b01      	ldr	r3, [sp, #4]
 800fabe:	681b      	ldr	r3, [r3, #0]
 800fac0:	9a06      	ldr	r2, [sp, #24]
 800fac2:	9903      	ldr	r1, [sp, #12]
 800fac4:	440a      	add	r2, r1
 800fac6:	7812      	ldrb	r2, [r2, #0]
 800fac8:	441a      	add	r2, r3
 800faca:	9b01      	ldr	r3, [sp, #4]
 800facc:	601a      	str	r2, [r3, #0]
        idx++;
 800face:	9b06      	ldr	r3, [sp, #24]
 800fad0:	3301      	adds	r3, #1
 800fad2:	9306      	str	r3, [sp, #24]
    while (length--) {
 800fad4:	9b07      	ldr	r3, [sp, #28]
 800fad6:	1e5a      	subs	r2, r3, #1
 800fad8:	9207      	str	r2, [sp, #28]
 800fada:	2b00      	cmp	r3, #0
 800fadc:	d1ee      	bne.n	800fabc <GetObjectId+0x4c>
    *inOutIdx = idx;
 800fade:	9a06      	ldr	r2, [sp, #24]
 800fae0:	9b02      	ldr	r3, [sp, #8]
 800fae2:	601a      	str	r2, [r3, #0]
        const byte* checkOid = NULL;
 800fae4:	2300      	movs	r3, #0
 800fae6:	9308      	str	r3, [sp, #32]
        if (oidType != oidIgnoreType) {
 800fae8:	9b00      	ldr	r3, [sp, #0]
 800faea:	2b0e      	cmp	r3, #14
 800faec:	d01a      	beq.n	800fb24 <GetObjectId+0xb4>
            checkOid = OidFromId(*oid, oidType, &checkOidSz);
 800faee:	9b01      	ldr	r3, [sp, #4]
 800faf0:	681b      	ldr	r3, [r3, #0]
 800faf2:	aa05      	add	r2, sp, #20
 800faf4:	9900      	ldr	r1, [sp, #0]
 800faf6:	4618      	mov	r0, r3
 800faf8:	f7ff fbba 	bl	800f270 <OidFromId.lto_priv.408>
 800fafc:	9008      	str	r0, [sp, #32]
            if (checkOid != NULL &&
 800fafe:	9b08      	ldr	r3, [sp, #32]
 800fb00:	2b00      	cmp	r3, #0
 800fb02:	d00f      	beq.n	800fb24 <GetObjectId+0xb4>
                (checkOidSz != actualOidSz ||
 800fb04:	9a05      	ldr	r2, [sp, #20]
            if (checkOid != NULL &&
 800fb06:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fb08:	429a      	cmp	r2, r3
 800fb0a:	d108      	bne.n	800fb1e <GetObjectId+0xae>
                    XMEMCMP(actualOid, checkOid, checkOidSz) != 0)) {
 800fb0c:	9b05      	ldr	r3, [sp, #20]
 800fb0e:	461a      	mov	r2, r3
 800fb10:	9908      	ldr	r1, [sp, #32]
 800fb12:	9809      	ldr	r0, [sp, #36]	; 0x24
 800fb14:	f00e fb22 	bl	801e15c <memcmp>
 800fb18:	4603      	mov	r3, r0
                (checkOidSz != actualOidSz ||
 800fb1a:	2b00      	cmp	r3, #0
 800fb1c:	d002      	beq.n	800fb24 <GetObjectId+0xb4>
                return ASN_UNKNOWN_OID_E;
 800fb1e:	f06f 0393 	mvn.w	r3, #147	; 0x93
 800fb22:	e000      	b.n	800fb26 <GetObjectId+0xb6>
    return ret;
 800fb24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 800fb26:	4618      	mov	r0, r3
 800fb28:	b00d      	add	sp, #52	; 0x34
 800fb2a:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb2e:	bf00      	nop

0800fb30 <SkipObjectId.lto_priv.382>:
{
 800fb30:	b500      	push	{lr}
 800fb32:	b089      	sub	sp, #36	; 0x24
 800fb34:	9003      	str	r0, [sp, #12]
 800fb36:	9102      	str	r1, [sp, #8]
 800fb38:	9201      	str	r2, [sp, #4]
    word32 idx = *inOutIdx;
 800fb3a:	9b02      	ldr	r3, [sp, #8]
 800fb3c:	681b      	ldr	r3, [r3, #0]
 800fb3e:	9306      	str	r3, [sp, #24]
    ret = GetASNObjectId(input, &idx, &length, maxIdx);
 800fb40:	aa05      	add	r2, sp, #20
 800fb42:	a906      	add	r1, sp, #24
 800fb44:	9b01      	ldr	r3, [sp, #4]
 800fb46:	9803      	ldr	r0, [sp, #12]
 800fb48:	f7ff ff3a 	bl	800f9c0 <GetASNObjectId.lto_priv.413>
 800fb4c:	9007      	str	r0, [sp, #28]
    if (ret != 0)
 800fb4e:	9b07      	ldr	r3, [sp, #28]
 800fb50:	2b00      	cmp	r3, #0
 800fb52:	d001      	beq.n	800fb58 <SkipObjectId.lto_priv.382+0x28>
        return ret;
 800fb54:	9b07      	ldr	r3, [sp, #28]
 800fb56:	e007      	b.n	800fb68 <SkipObjectId.lto_priv.382+0x38>
    idx += length;
 800fb58:	9b06      	ldr	r3, [sp, #24]
 800fb5a:	9a05      	ldr	r2, [sp, #20]
 800fb5c:	4413      	add	r3, r2
 800fb5e:	9306      	str	r3, [sp, #24]
    *inOutIdx = idx;
 800fb60:	9a06      	ldr	r2, [sp, #24]
 800fb62:	9b02      	ldr	r3, [sp, #8]
 800fb64:	601a      	str	r2, [r3, #0]
    return 0;
 800fb66:	2300      	movs	r3, #0
}
 800fb68:	4618      	mov	r0, r3
 800fb6a:	b009      	add	sp, #36	; 0x24
 800fb6c:	f85d fb04 	ldr.w	pc, [sp], #4

0800fb70 <GetAlgoId>:
{
 800fb70:	b500      	push	{lr}
 800fb72:	b08b      	sub	sp, #44	; 0x2c
 800fb74:	9005      	str	r0, [sp, #20]
 800fb76:	9104      	str	r1, [sp, #16]
 800fb78:	9203      	str	r2, [sp, #12]
 800fb7a:	9302      	str	r3, [sp, #8]
    word32 idx = *inOutIdx;
 800fb7c:	9b04      	ldr	r3, [sp, #16]
 800fb7e:	681b      	ldr	r3, [r3, #0]
 800fb80:	9307      	str	r3, [sp, #28]
    *oid = 0;
 800fb82:	9b03      	ldr	r3, [sp, #12]
 800fb84:	2200      	movs	r2, #0
 800fb86:	601a      	str	r2, [r3, #0]
    if (GetSequence(input, &idx, &length, maxIdx) < 0)
 800fb88:	aa08      	add	r2, sp, #32
 800fb8a:	a907      	add	r1, sp, #28
 800fb8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800fb8e:	9805      	ldr	r0, [sp, #20]
 800fb90:	f7ff f90e 	bl	800edb0 <GetSequence>
 800fb94:	4603      	mov	r3, r0
 800fb96:	2b00      	cmp	r3, #0
 800fb98:	da02      	bge.n	800fba0 <GetAlgoId+0x30>
        return ASN_PARSE_E;
 800fb9a:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fb9e:	e023      	b.n	800fbe8 <GetAlgoId+0x78>
    if (GetObjectId(input, &idx, oid, oidType, maxIdx) < 0)
 800fba0:	a907      	add	r1, sp, #28
 800fba2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800fba4:	9300      	str	r3, [sp, #0]
 800fba6:	9b02      	ldr	r3, [sp, #8]
 800fba8:	9a03      	ldr	r2, [sp, #12]
 800fbaa:	9805      	ldr	r0, [sp, #20]
 800fbac:	f7ff ff60 	bl	800fa70 <GetObjectId>
 800fbb0:	4603      	mov	r3, r0
 800fbb2:	2b00      	cmp	r3, #0
 800fbb4:	da02      	bge.n	800fbbc <GetAlgoId+0x4c>
        return ASN_OBJECT_ID_E;
 800fbb6:	f06f 038f 	mvn.w	r3, #143	; 0x8f
 800fbba:	e015      	b.n	800fbe8 <GetAlgoId+0x78>
    if (input[idx] == ASN_TAG_NULL) {
 800fbbc:	9b07      	ldr	r3, [sp, #28]
 800fbbe:	9a05      	ldr	r2, [sp, #20]
 800fbc0:	4413      	add	r3, r2
 800fbc2:	781b      	ldrb	r3, [r3, #0]
 800fbc4:	2b05      	cmp	r3, #5
 800fbc6:	d10b      	bne.n	800fbe0 <GetAlgoId+0x70>
        ret = GetASNNull(input, &idx, maxIdx);
 800fbc8:	ab07      	add	r3, sp, #28
 800fbca:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800fbcc:	4619      	mov	r1, r3
 800fbce:	9805      	ldr	r0, [sp, #20]
 800fbd0:	f7ff f906 	bl	800ede0 <GetASNNull>
 800fbd4:	9009      	str	r0, [sp, #36]	; 0x24
        if (ret != 0)
 800fbd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fbd8:	2b00      	cmp	r3, #0
 800fbda:	d001      	beq.n	800fbe0 <GetAlgoId+0x70>
            return ret;
 800fbdc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fbde:	e003      	b.n	800fbe8 <GetAlgoId+0x78>
    *inOutIdx = idx;
 800fbe0:	9a07      	ldr	r2, [sp, #28]
 800fbe2:	9b04      	ldr	r3, [sp, #16]
 800fbe4:	601a      	str	r2, [r3, #0]
    return 0;
 800fbe6:	2300      	movs	r3, #0
}
 800fbe8:	4618      	mov	r0, r3
 800fbea:	b00b      	add	sp, #44	; 0x2c
 800fbec:	f85d fb04 	ldr.w	pc, [sp], #4

0800fbf0 <ToTraditionalInline>:
{
 800fbf0:	b500      	push	{lr}
 800fbf2:	b08d      	sub	sp, #52	; 0x34
 800fbf4:	9005      	str	r0, [sp, #20]
 800fbf6:	9104      	str	r1, [sp, #16]
 800fbf8:	9203      	str	r2, [sp, #12]
    if (input == NULL || inOutIdx == NULL)
 800fbfa:	9b05      	ldr	r3, [sp, #20]
 800fbfc:	2b00      	cmp	r3, #0
 800fbfe:	d002      	beq.n	800fc06 <ToTraditionalInline+0x16>
 800fc00:	9b04      	ldr	r3, [sp, #16]
 800fc02:	2b00      	cmp	r3, #0
 800fc04:	d102      	bne.n	800fc0c <ToTraditionalInline+0x1c>
        return BAD_FUNC_ARG;
 800fc06:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fc0a:	e04a      	b.n	800fca2 <ToTraditionalInline+0xb2>
    idx = *inOutIdx;
 800fc0c:	9b04      	ldr	r3, [sp, #16]
 800fc0e:	681b      	ldr	r3, [r3, #0]
 800fc10:	930a      	str	r3, [sp, #40]	; 0x28
    if (GetSequence(input, &idx, &length, sz) < 0)
 800fc12:	aa07      	add	r2, sp, #28
 800fc14:	a90a      	add	r1, sp, #40	; 0x28
 800fc16:	9b03      	ldr	r3, [sp, #12]
 800fc18:	9805      	ldr	r0, [sp, #20]
 800fc1a:	f7ff f8c9 	bl	800edb0 <GetSequence>
 800fc1e:	4603      	mov	r3, r0
 800fc20:	2b00      	cmp	r3, #0
 800fc22:	da02      	bge.n	800fc2a <ToTraditionalInline+0x3a>
        return ASN_PARSE_E;
 800fc24:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fc28:	e03b      	b.n	800fca2 <ToTraditionalInline+0xb2>
    if (GetMyVersion(input, &idx, &version, sz) < 0)
 800fc2a:	aa08      	add	r2, sp, #32
 800fc2c:	a90a      	add	r1, sp, #40	; 0x28
 800fc2e:	9b03      	ldr	r3, [sp, #12]
 800fc30:	9805      	ldr	r0, [sp, #20]
 800fc32:	f7ff f9f5 	bl	800f020 <GetMyVersion>
 800fc36:	4603      	mov	r3, r0
 800fc38:	2b00      	cmp	r3, #0
 800fc3a:	da02      	bge.n	800fc42 <ToTraditionalInline+0x52>
        return ASN_PARSE_E;
 800fc3c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fc40:	e02f      	b.n	800fca2 <ToTraditionalInline+0xb2>
    if (GetAlgoId(input, &idx, &oid, oidKeyType, sz) < 0)
 800fc42:	aa09      	add	r2, sp, #36	; 0x24
 800fc44:	a90a      	add	r1, sp, #40	; 0x28
 800fc46:	9b03      	ldr	r3, [sp, #12]
 800fc48:	9300      	str	r3, [sp, #0]
 800fc4a:	2302      	movs	r3, #2
 800fc4c:	9805      	ldr	r0, [sp, #20]
 800fc4e:	f7ff ff8f 	bl	800fb70 <GetAlgoId>
 800fc52:	4603      	mov	r3, r0
 800fc54:	2b00      	cmp	r3, #0
 800fc56:	da02      	bge.n	800fc5e <ToTraditionalInline+0x6e>
        return ASN_PARSE_E;
 800fc58:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fc5c:	e021      	b.n	800fca2 <ToTraditionalInline+0xb2>
    if (input[idx] == ASN_OBJECT_ID) {
 800fc5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800fc60:	9a05      	ldr	r2, [sp, #20]
 800fc62:	4413      	add	r3, r2
 800fc64:	781b      	ldrb	r3, [r3, #0]
 800fc66:	2b06      	cmp	r3, #6
 800fc68:	d10b      	bne.n	800fc82 <ToTraditionalInline+0x92>
        if (SkipObjectId(input, &idx, sz) < 0)
 800fc6a:	ab0a      	add	r3, sp, #40	; 0x28
 800fc6c:	9a03      	ldr	r2, [sp, #12]
 800fc6e:	4619      	mov	r1, r3
 800fc70:	9805      	ldr	r0, [sp, #20]
 800fc72:	f7ff ff5d 	bl	800fb30 <SkipObjectId.lto_priv.382>
 800fc76:	4603      	mov	r3, r0
 800fc78:	2b00      	cmp	r3, #0
 800fc7a:	da02      	bge.n	800fc82 <ToTraditionalInline+0x92>
            return ASN_PARSE_E;
 800fc7c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fc80:	e00f      	b.n	800fca2 <ToTraditionalInline+0xb2>
    ret = GetOctetString(input, &idx, &length, sz);
 800fc82:	aa07      	add	r2, sp, #28
 800fc84:	a90a      	add	r1, sp, #40	; 0x28
 800fc86:	9b03      	ldr	r3, [sp, #12]
 800fc88:	9805      	ldr	r0, [sp, #20]
 800fc8a:	f7ff f8e9 	bl	800ee60 <GetOctetString.lto_priv.403>
 800fc8e:	900b      	str	r0, [sp, #44]	; 0x2c
    if (ret < 0)
 800fc90:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fc92:	2b00      	cmp	r3, #0
 800fc94:	da01      	bge.n	800fc9a <ToTraditionalInline+0xaa>
        return ret;
 800fc96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fc98:	e003      	b.n	800fca2 <ToTraditionalInline+0xb2>
    *inOutIdx = idx;
 800fc9a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800fc9c:	9b04      	ldr	r3, [sp, #16]
 800fc9e:	601a      	str	r2, [r3, #0]
    return length;
 800fca0:	9b07      	ldr	r3, [sp, #28]
}
 800fca2:	4618      	mov	r0, r3
 800fca4:	b00d      	add	sp, #52	; 0x34
 800fca6:	f85d fb04 	ldr.w	pc, [sp], #4
 800fcaa:	bf00      	nop
 800fcac:	0000      	movs	r0, r0
	...

0800fcb0 <ToTraditional>:
{
 800fcb0:	b500      	push	{lr}
 800fcb2:	b085      	sub	sp, #20
 800fcb4:	9001      	str	r0, [sp, #4]
 800fcb6:	9100      	str	r1, [sp, #0]
    word32 inOutIdx = 0;
 800fcb8:	2300      	movs	r3, #0
 800fcba:	9302      	str	r3, [sp, #8]
    if (input == NULL)
 800fcbc:	9b01      	ldr	r3, [sp, #4]
 800fcbe:	2b00      	cmp	r3, #0
 800fcc0:	d102      	bne.n	800fcc8 <ToTraditional+0x18>
        return BAD_FUNC_ARG;
 800fcc2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fcc6:	e014      	b.n	800fcf2 <ToTraditional+0x42>
    length = ToTraditionalInline(input, &inOutIdx, sz);
 800fcc8:	ab02      	add	r3, sp, #8
 800fcca:	9a00      	ldr	r2, [sp, #0]
 800fccc:	4619      	mov	r1, r3
 800fcce:	9801      	ldr	r0, [sp, #4]
 800fcd0:	f7ff ff8e 	bl	800fbf0 <ToTraditionalInline>
 800fcd4:	9003      	str	r0, [sp, #12]
    if (length < 0)
 800fcd6:	9b03      	ldr	r3, [sp, #12]
 800fcd8:	2b00      	cmp	r3, #0
 800fcda:	da01      	bge.n	800fce0 <ToTraditional+0x30>
        return length;
 800fcdc:	9b03      	ldr	r3, [sp, #12]
 800fcde:	e008      	b.n	800fcf2 <ToTraditional+0x42>
    XMEMMOVE(input, input + inOutIdx, length);
 800fce0:	9b02      	ldr	r3, [sp, #8]
 800fce2:	9a01      	ldr	r2, [sp, #4]
 800fce4:	4413      	add	r3, r2
 800fce6:	9a03      	ldr	r2, [sp, #12]
 800fce8:	4619      	mov	r1, r3
 800fcea:	9801      	ldr	r0, [sp, #4]
 800fcec:	f00e f9d2 	bl	801e094 <memmove>
    return length;
 800fcf0:	9b03      	ldr	r3, [sp, #12]
}
 800fcf2:	4618      	mov	r0, r3
 800fcf4:	b005      	add	sp, #20
 800fcf6:	f85d fb04 	ldr.w	pc, [sp], #4
 800fcfa:	bf00      	nop
 800fcfc:	0000      	movs	r0, r0
	...

0800fd00 <wc_RsaPublicKeyDecode>:
{
 800fd00:	b500      	push	{lr}
 800fd02:	b08b      	sub	sp, #44	; 0x2c
 800fd04:	9005      	str	r0, [sp, #20]
 800fd06:	9104      	str	r1, [sp, #16]
 800fd08:	9203      	str	r2, [sp, #12]
 800fd0a:	9302      	str	r3, [sp, #8]
    if (input == NULL || inOutIdx == NULL || key == NULL)
 800fd0c:	9b05      	ldr	r3, [sp, #20]
 800fd0e:	2b00      	cmp	r3, #0
 800fd10:	d005      	beq.n	800fd1e <wc_RsaPublicKeyDecode+0x1e>
 800fd12:	9b04      	ldr	r3, [sp, #16]
 800fd14:	2b00      	cmp	r3, #0
 800fd16:	d002      	beq.n	800fd1e <wc_RsaPublicKeyDecode+0x1e>
 800fd18:	9b03      	ldr	r3, [sp, #12]
 800fd1a:	2b00      	cmp	r3, #0
 800fd1c:	d102      	bne.n	800fd24 <wc_RsaPublicKeyDecode+0x24>
        return BAD_FUNC_ARG;
 800fd1e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fd22:	e087      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800fd24:	aa07      	add	r2, sp, #28
 800fd26:	9b02      	ldr	r3, [sp, #8]
 800fd28:	9904      	ldr	r1, [sp, #16]
 800fd2a:	9805      	ldr	r0, [sp, #20]
 800fd2c:	f7ff f840 	bl	800edb0 <GetSequence>
 800fd30:	4603      	mov	r3, r0
 800fd32:	2b00      	cmp	r3, #0
 800fd34:	da02      	bge.n	800fd3c <wc_RsaPublicKeyDecode+0x3c>
        return ASN_PARSE_E;
 800fd36:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fd3a:	e07b      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    key->type = RSA_PUBLIC;
 800fd3c:	9b03      	ldr	r3, [sp, #12]
 800fd3e:	2200      	movs	r2, #0
 800fd40:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    if ((*inOutIdx + 1) > inSz)
 800fd44:	9b04      	ldr	r3, [sp, #16]
 800fd46:	681b      	ldr	r3, [r3, #0]
 800fd48:	1c5a      	adds	r2, r3, #1
 800fd4a:	9b02      	ldr	r3, [sp, #8]
 800fd4c:	429a      	cmp	r2, r3
 800fd4e:	d902      	bls.n	800fd56 <wc_RsaPublicKeyDecode+0x56>
        return BUFFER_E;
 800fd50:	f06f 0383 	mvn.w	r3, #131	; 0x83
 800fd54:	e06e      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    b = input[*inOutIdx];
 800fd56:	9b04      	ldr	r3, [sp, #16]
 800fd58:	681b      	ldr	r3, [r3, #0]
 800fd5a:	9a05      	ldr	r2, [sp, #20]
 800fd5c:	4413      	add	r3, r2
 800fd5e:	781b      	ldrb	r3, [r3, #0]
 800fd60:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    if (b != ASN_INTEGER) {
 800fd64:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 800fd68:	2b02      	cmp	r3, #2
 800fd6a:	d044      	beq.n	800fdf6 <wc_RsaPublicKeyDecode+0xf6>
        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800fd6c:	aa07      	add	r2, sp, #28
 800fd6e:	9b02      	ldr	r3, [sp, #8]
 800fd70:	9904      	ldr	r1, [sp, #16]
 800fd72:	9805      	ldr	r0, [sp, #20]
 800fd74:	f7ff f81c 	bl	800edb0 <GetSequence>
 800fd78:	4603      	mov	r3, r0
 800fd7a:	2b00      	cmp	r3, #0
 800fd7c:	da02      	bge.n	800fd84 <wc_RsaPublicKeyDecode+0x84>
            return ASN_PARSE_E;
 800fd7e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fd82:	e057      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
        if (SkipObjectId(input, inOutIdx, inSz) < 0)
 800fd84:	9a02      	ldr	r2, [sp, #8]
 800fd86:	9904      	ldr	r1, [sp, #16]
 800fd88:	9805      	ldr	r0, [sp, #20]
 800fd8a:	f7ff fed1 	bl	800fb30 <SkipObjectId.lto_priv.382>
 800fd8e:	4603      	mov	r3, r0
 800fd90:	2b00      	cmp	r3, #0
 800fd92:	da02      	bge.n	800fd9a <wc_RsaPublicKeyDecode+0x9a>
            return ASN_PARSE_E;
 800fd94:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fd98:	e04c      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
        if (input[*inOutIdx] == ASN_TAG_NULL) {
 800fd9a:	9b04      	ldr	r3, [sp, #16]
 800fd9c:	681b      	ldr	r3, [r3, #0]
 800fd9e:	9a05      	ldr	r2, [sp, #20]
 800fda0:	4413      	add	r3, r2
 800fda2:	781b      	ldrb	r3, [r3, #0]
 800fda4:	2b05      	cmp	r3, #5
 800fda6:	d10a      	bne.n	800fdbe <wc_RsaPublicKeyDecode+0xbe>
            ret = GetASNNull(input, inOutIdx, inSz);
 800fda8:	9a02      	ldr	r2, [sp, #8]
 800fdaa:	9904      	ldr	r1, [sp, #16]
 800fdac:	9805      	ldr	r0, [sp, #20]
 800fdae:	f7ff f817 	bl	800ede0 <GetASNNull>
 800fdb2:	9008      	str	r0, [sp, #32]
            if (ret != 0)
 800fdb4:	9b08      	ldr	r3, [sp, #32]
 800fdb6:	2b00      	cmp	r3, #0
 800fdb8:	d001      	beq.n	800fdbe <wc_RsaPublicKeyDecode+0xbe>
                return ret;
 800fdba:	9b08      	ldr	r3, [sp, #32]
 800fdbc:	e03a      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);
 800fdbe:	2300      	movs	r3, #0
 800fdc0:	9301      	str	r3, [sp, #4]
 800fdc2:	2301      	movs	r3, #1
 800fdc4:	9300      	str	r3, [sp, #0]
 800fdc6:	9b02      	ldr	r3, [sp, #8]
 800fdc8:	2200      	movs	r2, #0
 800fdca:	9904      	ldr	r1, [sp, #16]
 800fdcc:	9805      	ldr	r0, [sp, #20]
 800fdce:	f7ff f99f 	bl	800f110 <CheckBitString.lto_priv.381>
 800fdd2:	9008      	str	r0, [sp, #32]
        if (ret != 0)
 800fdd4:	9b08      	ldr	r3, [sp, #32]
 800fdd6:	2b00      	cmp	r3, #0
 800fdd8:	d001      	beq.n	800fdde <wc_RsaPublicKeyDecode+0xde>
            return ret;
 800fdda:	9b08      	ldr	r3, [sp, #32]
 800fddc:	e02a      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 800fdde:	aa07      	add	r2, sp, #28
 800fde0:	9b02      	ldr	r3, [sp, #8]
 800fde2:	9904      	ldr	r1, [sp, #16]
 800fde4:	9805      	ldr	r0, [sp, #20]
 800fde6:	f7fe ffe3 	bl	800edb0 <GetSequence>
 800fdea:	4603      	mov	r3, r0
 800fdec:	2b00      	cmp	r3, #0
 800fdee:	da02      	bge.n	800fdf6 <wc_RsaPublicKeyDecode+0xf6>
            return ASN_PARSE_E;
 800fdf0:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 800fdf4:	e01e      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    if (GetInt(&key->n,  input, inOutIdx, inSz) < 0)
 800fdf6:	9803      	ldr	r0, [sp, #12]
 800fdf8:	9b02      	ldr	r3, [sp, #8]
 800fdfa:	9a04      	ldr	r2, [sp, #16]
 800fdfc:	9905      	ldr	r1, [sp, #20]
 800fdfe:	f7ff f947 	bl	800f090 <GetInt>
 800fe02:	4603      	mov	r3, r0
 800fe04:	2b00      	cmp	r3, #0
 800fe06:	da02      	bge.n	800fe0e <wc_RsaPublicKeyDecode+0x10e>
        return ASN_RSA_KEY_E;
 800fe08:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 800fe0c:	e012      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    if (GetInt(&key->e,  input, inOutIdx, inSz) < 0) {
 800fe0e:	9b03      	ldr	r3, [sp, #12]
 800fe10:	f103 0010 	add.w	r0, r3, #16
 800fe14:	9b02      	ldr	r3, [sp, #8]
 800fe16:	9a04      	ldr	r2, [sp, #16]
 800fe18:	9905      	ldr	r1, [sp, #20]
 800fe1a:	f7ff f939 	bl	800f090 <GetInt>
 800fe1e:	4603      	mov	r3, r0
 800fe20:	2b00      	cmp	r3, #0
 800fe22:	da06      	bge.n	800fe32 <wc_RsaPublicKeyDecode+0x132>
        mp_clear(&key->n);
 800fe24:	9b03      	ldr	r3, [sp, #12]
 800fe26:	4618      	mov	r0, r3
 800fe28:	f7fa fc02 	bl	800a630 <mp_clear>
        return ASN_RSA_KEY_E;
 800fe2c:	f06f 038e 	mvn.w	r3, #142	; 0x8e
 800fe30:	e000      	b.n	800fe34 <wc_RsaPublicKeyDecode+0x134>
    return 0;
 800fe32:	2300      	movs	r3, #0
}
 800fe34:	4618      	mov	r0, r3
 800fe36:	b00b      	add	sp, #44	; 0x2c
 800fe38:	f85d fb04 	ldr.w	pc, [sp], #4
 800fe3c:	0000      	movs	r0, r0
	...

0800fe40 <wc_ecc_get_oid>:

#endif /* HAVE_COMP_KEY */


int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
 800fe40:	b086      	sub	sp, #24
 800fe42:	9003      	str	r0, [sp, #12]
 800fe44:	9102      	str	r1, [sp, #8]
 800fe46:	9201      	str	r2, [sp, #4]
    int x;

    if (oidSum == 0) {
 800fe48:	9b03      	ldr	r3, [sp, #12]
 800fe4a:	2b00      	cmp	r3, #0
 800fe4c:	d102      	bne.n	800fe54 <wc_ecc_get_oid+0x14>
        return BAD_FUNC_ARG;
 800fe4e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 800fe52:	e045      	b.n	800fee0 <wc_ecc_get_oid+0xa0>
    }

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
 800fe54:	2300      	movs	r3, #0
 800fe56:	9305      	str	r3, [sp, #20]
 800fe58:	e037      	b.n	800feca <wc_ecc_get_oid+0x8a>
        if (ecc_sets[x].oidSum == oidSum) {
 800fe5a:	4a23      	ldr	r2, [pc, #140]	; (800fee8 <wc_ecc_get_oid+0xa8>)
 800fe5c:	9b05      	ldr	r3, [sp, #20]
 800fe5e:	2134      	movs	r1, #52	; 0x34
 800fe60:	fb01 f303 	mul.w	r3, r1, r3
 800fe64:	4413      	add	r3, r2
 800fe66:	332c      	adds	r3, #44	; 0x2c
 800fe68:	681a      	ldr	r2, [r3, #0]
 800fe6a:	9b03      	ldr	r3, [sp, #12]
 800fe6c:	429a      	cmp	r2, r3
 800fe6e:	d129      	bne.n	800fec4 <wc_ecc_get_oid+0x84>
            int ret = 0;
 800fe70:	2300      	movs	r3, #0
 800fe72:	9304      	str	r3, [sp, #16]
            }
            if (oid) {
                *oid = o->oid;
            }
        #else
            if (oidSz) {
 800fe74:	9b01      	ldr	r3, [sp, #4]
 800fe76:	2b00      	cmp	r3, #0
 800fe78:	d009      	beq.n	800fe8e <wc_ecc_get_oid+0x4e>
                *oidSz = ecc_sets[x].oidSz;
 800fe7a:	4a1b      	ldr	r2, [pc, #108]	; (800fee8 <wc_ecc_get_oid+0xa8>)
 800fe7c:	9b05      	ldr	r3, [sp, #20]
 800fe7e:	2134      	movs	r1, #52	; 0x34
 800fe80:	fb01 f303 	mul.w	r3, r1, r3
 800fe84:	4413      	add	r3, r2
 800fe86:	3328      	adds	r3, #40	; 0x28
 800fe88:	681a      	ldr	r2, [r3, #0]
 800fe8a:	9b01      	ldr	r3, [sp, #4]
 800fe8c:	601a      	str	r2, [r3, #0]
            }
            if (oid) {
 800fe8e:	9b02      	ldr	r3, [sp, #8]
 800fe90:	2b00      	cmp	r3, #0
 800fe92:	d009      	beq.n	800fea8 <wc_ecc_get_oid+0x68>
                *oid = ecc_sets[x].oid;
 800fe94:	4a14      	ldr	r2, [pc, #80]	; (800fee8 <wc_ecc_get_oid+0xa8>)
 800fe96:	9b05      	ldr	r3, [sp, #20]
 800fe98:	2134      	movs	r1, #52	; 0x34
 800fe9a:	fb01 f303 	mul.w	r3, r1, r3
 800fe9e:	4413      	add	r3, r2
 800fea0:	3324      	adds	r3, #36	; 0x24
 800fea2:	681a      	ldr	r2, [r3, #0]
 800fea4:	9b02      	ldr	r3, [sp, #8]
 800fea6:	601a      	str	r2, [r3, #0]
            }
        #endif
            /* on success return curve id */
            if (ret == 0) {
 800fea8:	9b04      	ldr	r3, [sp, #16]
 800feaa:	2b00      	cmp	r3, #0
 800feac:	d108      	bne.n	800fec0 <wc_ecc_get_oid+0x80>
                ret = ecc_sets[x].id;
 800feae:	4a0e      	ldr	r2, [pc, #56]	; (800fee8 <wc_ecc_get_oid+0xa8>)
 800feb0:	9b05      	ldr	r3, [sp, #20]
 800feb2:	2134      	movs	r1, #52	; 0x34
 800feb4:	fb01 f303 	mul.w	r3, r1, r3
 800feb8:	4413      	add	r3, r2
 800feba:	3304      	adds	r3, #4
 800febc:	681b      	ldr	r3, [r3, #0]
 800febe:	9304      	str	r3, [sp, #16]
            }
            return ret;
 800fec0:	9b04      	ldr	r3, [sp, #16]
 800fec2:	e00d      	b.n	800fee0 <wc_ecc_get_oid+0xa0>
    for (x = 0; ecc_sets[x].size != 0; x++) {
 800fec4:	9b05      	ldr	r3, [sp, #20]
 800fec6:	3301      	adds	r3, #1
 800fec8:	9305      	str	r3, [sp, #20]
 800feca:	4a07      	ldr	r2, [pc, #28]	; (800fee8 <wc_ecc_get_oid+0xa8>)
 800fecc:	9b05      	ldr	r3, [sp, #20]
 800fece:	2134      	movs	r1, #52	; 0x34
 800fed0:	fb01 f303 	mul.w	r3, r1, r3
 800fed4:	4413      	add	r3, r2
 800fed6:	681b      	ldr	r3, [r3, #0]
 800fed8:	2b00      	cmp	r3, #0
 800feda:	d1be      	bne.n	800fe5a <wc_ecc_get_oid+0x1a>
        }
    }

    return NOT_COMPILED_IN;
 800fedc:	f06f 03ad 	mvn.w	r3, #173	; 0xad
}
 800fee0:	4618      	mov	r0, r3
 800fee2:	b006      	add	sp, #24
 800fee4:	4770      	bx	lr
 800fee6:	bf00      	nop
 800fee8:	080241e0 	.word	0x080241e0
 800feec:	00000000 	.word	0x00000000

0800fef0 <ForceZero>:
{
 800fef0:	b084      	sub	sp, #16
 800fef2:	9001      	str	r0, [sp, #4]
 800fef4:	9100      	str	r1, [sp, #0]
    volatile byte* z = (volatile byte*)mem;
 800fef6:	9b01      	ldr	r3, [sp, #4]
 800fef8:	9303      	str	r3, [sp, #12]
 800fefa:	e004      	b.n	800ff06 <ForceZero+0x16>
    while (len--) *z++ = 0;
 800fefc:	9b03      	ldr	r3, [sp, #12]
 800fefe:	1c5a      	adds	r2, r3, #1
 800ff00:	9203      	str	r2, [sp, #12]
 800ff02:	2200      	movs	r2, #0
 800ff04:	701a      	strb	r2, [r3, #0]
 800ff06:	9b00      	ldr	r3, [sp, #0]
 800ff08:	1e5a      	subs	r2, r3, #1
 800ff0a:	9200      	str	r2, [sp, #0]
 800ff0c:	2b00      	cmp	r3, #0
 800ff0e:	d1f5      	bne.n	800fefc <ForceZero+0xc>
}
 800ff10:	b004      	add	sp, #16
 800ff12:	4770      	bx	lr
	...

0800ff20 <ConstantCompare>:
{
 800ff20:	b086      	sub	sp, #24
 800ff22:	9003      	str	r0, [sp, #12]
 800ff24:	9102      	str	r1, [sp, #8]
 800ff26:	9201      	str	r2, [sp, #4]
    int compareSum = 0;
 800ff28:	2300      	movs	r3, #0
 800ff2a:	9304      	str	r3, [sp, #16]
    for (i = 0; i < length; i++) {
 800ff2c:	2300      	movs	r3, #0
 800ff2e:	9305      	str	r3, [sp, #20]
 800ff30:	e010      	b.n	800ff54 <ConstantCompare+0x34>
        compareSum |= a[i] ^ b[i];
 800ff32:	9b05      	ldr	r3, [sp, #20]
 800ff34:	9a03      	ldr	r2, [sp, #12]
 800ff36:	4413      	add	r3, r2
 800ff38:	781a      	ldrb	r2, [r3, #0]
 800ff3a:	9b05      	ldr	r3, [sp, #20]
 800ff3c:	9902      	ldr	r1, [sp, #8]
 800ff3e:	440b      	add	r3, r1
 800ff40:	781b      	ldrb	r3, [r3, #0]
 800ff42:	4053      	eors	r3, r2
 800ff44:	b2db      	uxtb	r3, r3
 800ff46:	461a      	mov	r2, r3
 800ff48:	9b04      	ldr	r3, [sp, #16]
 800ff4a:	4313      	orrs	r3, r2
 800ff4c:	9304      	str	r3, [sp, #16]
    for (i = 0; i < length; i++) {
 800ff4e:	9b05      	ldr	r3, [sp, #20]
 800ff50:	3301      	adds	r3, #1
 800ff52:	9305      	str	r3, [sp, #20]
 800ff54:	9a05      	ldr	r2, [sp, #20]
 800ff56:	9b01      	ldr	r3, [sp, #4]
 800ff58:	429a      	cmp	r2, r3
 800ff5a:	dbea      	blt.n	800ff32 <ConstantCompare+0x12>
    return compareSum;
 800ff5c:	9b04      	ldr	r3, [sp, #16]
}
 800ff5e:	4618      	mov	r0, r3
 800ff60:	b006      	add	sp, #24
 800ff62:	4770      	bx	lr
	...

0800ff70 <wc_RsaCleanup>:
    RSA_STATE_DECRYPT_UNPAD,
    RSA_STATE_DECRYPT_RES,
};

static void wc_RsaCleanup(RsaKey* key)
{
 800ff70:	b500      	push	{lr}
 800ff72:	b083      	sub	sp, #12
 800ff74:	9001      	str	r0, [sp, #4]
    if (key && key->data) {
 800ff76:	9b01      	ldr	r3, [sp, #4]
 800ff78:	2b00      	cmp	r3, #0
 800ff7a:	d02f      	beq.n	800ffdc <wc_RsaCleanup+0x6c>
 800ff7c:	9b01      	ldr	r3, [sp, #4]
 800ff7e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d02a      	beq.n	800ffdc <wc_RsaCleanup+0x6c>
        /* make sure any allocated memory is free'd */
        if (key->dataIsAlloc) {
 800ff86:	9b01      	ldr	r3, [sp, #4]
 800ff88:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 800ff8c:	2b00      	cmp	r3, #0
 800ff8e:	d01d      	beq.n	800ffcc <wc_RsaCleanup+0x5c>
            if (key->type == RSA_PRIVATE_DECRYPT ||
 800ff90:	9b01      	ldr	r3, [sp, #4]
 800ff92:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ff96:	2b03      	cmp	r3, #3
 800ff98:	d004      	beq.n	800ffa4 <wc_RsaCleanup+0x34>
                key->type == RSA_PRIVATE_ENCRYPT) {
 800ff9a:	9b01      	ldr	r3, [sp, #4]
 800ff9c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
            if (key->type == RSA_PRIVATE_DECRYPT ||
 800ffa0:	2b02      	cmp	r3, #2
 800ffa2:	d109      	bne.n	800ffb8 <wc_RsaCleanup+0x48>
                ForceZero(key->data, key->dataLen);
 800ffa4:	9b01      	ldr	r3, [sp, #4]
 800ffa6:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800ffaa:	9b01      	ldr	r3, [sp, #4]
 800ffac:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ffb0:	4619      	mov	r1, r3
 800ffb2:	4610      	mov	r0, r2
 800ffb4:	f7ff ff9c 	bl	800fef0 <ForceZero>
            }
            XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 800ffb8:	9b01      	ldr	r3, [sp, #4]
 800ffba:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800ffbe:	4618      	mov	r0, r3
 800ffc0:	f7f5 fc5e 	bl	8005880 <chibios_free>
            key->dataIsAlloc = 0;
 800ffc4:	9b01      	ldr	r3, [sp, #4]
 800ffc6:	2200      	movs	r2, #0
 800ffc8:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
        }
        key->data = NULL;
 800ffcc:	9b01      	ldr	r3, [sp, #4]
 800ffce:	2200      	movs	r2, #0
 800ffd0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        key->dataLen = 0;
 800ffd4:	9b01      	ldr	r3, [sp, #4]
 800ffd6:	2200      	movs	r2, #0
 800ffd8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }
}
 800ffdc:	b003      	add	sp, #12
 800ffde:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffe2:	bf00      	nop
	...

0800fff0 <wc_InitRsaKey_ex>:

int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
{
 800fff0:	b530      	push	{r4, r5, lr}
 800fff2:	b089      	sub	sp, #36	; 0x24
 800fff4:	9005      	str	r0, [sp, #20]
 800fff6:	9104      	str	r1, [sp, #16]
 800fff8:	9203      	str	r2, [sp, #12]
    int ret = 0;
 800fffa:	2300      	movs	r3, #0
 800fffc:	9307      	str	r3, [sp, #28]

    if (key == NULL) {
 800fffe:	9b05      	ldr	r3, [sp, #20]
 8010000:	2b00      	cmp	r3, #0
 8010002:	d102      	bne.n	801000a <wc_InitRsaKey_ex+0x1a>
        return BAD_FUNC_ARG;
 8010004:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010008:	e054      	b.n	80100b4 <wc_InitRsaKey_ex+0xc4>
    }

    key->type = RSA_TYPE_UNKNOWN;
 801000a:	9b05      	ldr	r3, [sp, #20]
 801000c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8010010:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    key->state = RSA_STATE_NONE;
 8010014:	9b05      	ldr	r3, [sp, #20]
 8010016:	2200      	movs	r2, #0
 8010018:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    key->heap = heap;
 801001c:	9b05      	ldr	r3, [sp, #20]
 801001e:	9a04      	ldr	r2, [sp, #16]
 8010020:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    key->data = NULL;
 8010024:	9b05      	ldr	r3, [sp, #20]
 8010026:	2200      	movs	r2, #0
 8010028:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    key->dataLen = 0;
 801002c:	9b05      	ldr	r3, [sp, #20]
 801002e:	2200      	movs	r2, #0
 8010030:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    key->dataIsAlloc = 0;
 8010034:	9b05      	ldr	r3, [sp, #20]
 8010036:	2200      	movs	r2, #0
 8010038:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
#ifdef WC_RSA_BLINDING
    key->rng = NULL;
 801003c:	9b05      	ldr	r3, [sp, #20]
 801003e:	2200      	movs	r2, #0
 8010040:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    #endif /* WC_ASYNC_ENABLE_RSA */
#else
    (void)devId;
#endif /* WOLFSSL_ASYNC_CRYPT */

    ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 8010044:	9805      	ldr	r0, [sp, #20]
 8010046:	9b05      	ldr	r3, [sp, #20]
 8010048:	f103 0110 	add.w	r1, r3, #16
 801004c:	2300      	movs	r3, #0
 801004e:	9301      	str	r3, [sp, #4]
 8010050:	2300      	movs	r3, #0
 8010052:	9300      	str	r3, [sp, #0]
 8010054:	2300      	movs	r3, #0
 8010056:	2200      	movs	r2, #0
 8010058:	f7fc fd1a 	bl	800ca90 <mp_init_multi>
 801005c:	9007      	str	r0, [sp, #28]
    if (ret != MP_OKAY)
 801005e:	9b07      	ldr	r3, [sp, #28]
 8010060:	2b00      	cmp	r3, #0
 8010062:	d001      	beq.n	8010068 <wc_InitRsaKey_ex+0x78>
        return ret;
 8010064:	9b07      	ldr	r3, [sp, #28]
 8010066:	e025      	b.n	80100b4 <wc_InitRsaKey_ex+0xc4>

    ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 8010068:	9b05      	ldr	r3, [sp, #20]
 801006a:	f103 0020 	add.w	r0, r3, #32
 801006e:	9b05      	ldr	r3, [sp, #20]
 8010070:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8010074:	9b05      	ldr	r3, [sp, #20]
 8010076:	f103 0440 	add.w	r4, r3, #64	; 0x40
 801007a:	9b05      	ldr	r3, [sp, #20]
 801007c:	f103 0550 	add.w	r5, r3, #80	; 0x50
 8010080:	9b05      	ldr	r3, [sp, #20]
 8010082:	3360      	adds	r3, #96	; 0x60
 8010084:	9a05      	ldr	r2, [sp, #20]
 8010086:	3270      	adds	r2, #112	; 0x70
 8010088:	9201      	str	r2, [sp, #4]
 801008a:	9300      	str	r3, [sp, #0]
 801008c:	462b      	mov	r3, r5
 801008e:	4622      	mov	r2, r4
 8010090:	f7fc fcfe 	bl	800ca90 <mp_init_multi>
 8010094:	9007      	str	r0, [sp, #28]
    if (ret != MP_OKAY) {
 8010096:	9b07      	ldr	r3, [sp, #28]
 8010098:	2b00      	cmp	r3, #0
 801009a:	d00a      	beq.n	80100b2 <wc_InitRsaKey_ex+0xc2>
        mp_clear(&key->n);
 801009c:	9b05      	ldr	r3, [sp, #20]
 801009e:	4618      	mov	r0, r3
 80100a0:	f7fa fac6 	bl	800a630 <mp_clear>
        mp_clear(&key->e);
 80100a4:	9b05      	ldr	r3, [sp, #20]
 80100a6:	3310      	adds	r3, #16
 80100a8:	4618      	mov	r0, r3
 80100aa:	f7fa fac1 	bl	800a630 <mp_clear>
        return ret;
 80100ae:	9b07      	ldr	r3, [sp, #28]
 80100b0:	e000      	b.n	80100b4 <wc_InitRsaKey_ex+0xc4>
#ifdef WOLFSSL_XILINX_CRYPT
    key->pubExp = 0;
    key->mod    = NULL;
#endif

    return ret;
 80100b2:	9b07      	ldr	r3, [sp, #28]
}
 80100b4:	4618      	mov	r0, r3
 80100b6:	b009      	add	sp, #36	; 0x24
 80100b8:	bd30      	pop	{r4, r5, pc}
 80100ba:	bf00      	nop
 80100bc:	0000      	movs	r0, r0
	...

080100c0 <wc_InitRsaKey>:

int wc_InitRsaKey(RsaKey* key, void* heap)
{
 80100c0:	b500      	push	{lr}
 80100c2:	b083      	sub	sp, #12
 80100c4:	9001      	str	r0, [sp, #4]
 80100c6:	9100      	str	r1, [sp, #0]
    return wc_InitRsaKey_ex(key, heap, INVALID_DEVID);
 80100c8:	f06f 0201 	mvn.w	r2, #1
 80100cc:	9900      	ldr	r1, [sp, #0]
 80100ce:	9801      	ldr	r0, [sp, #4]
 80100d0:	f7ff ff8e 	bl	800fff0 <wc_InitRsaKey_ex>
 80100d4:	4603      	mov	r3, r0
}
 80100d6:	4618      	mov	r0, r3
 80100d8:	b003      	add	sp, #12
 80100da:	f85d fb04 	ldr.w	pc, [sp], #4
 80100de:	bf00      	nop

080100e0 <wc_FreeRsaKey>:
    return 0;
}
#endif /* WOLFSSL_XILINX_CRYPT */

int wc_FreeRsaKey(RsaKey* key)
{
 80100e0:	b500      	push	{lr}
 80100e2:	b085      	sub	sp, #20
 80100e4:	9001      	str	r0, [sp, #4]
    int ret = 0;
 80100e6:	2300      	movs	r3, #0
 80100e8:	9303      	str	r3, [sp, #12]

    if (key == NULL) {
 80100ea:	9b01      	ldr	r3, [sp, #4]
 80100ec:	2b00      	cmp	r3, #0
 80100ee:	d102      	bne.n	80100f6 <wc_FreeRsaKey+0x16>
        return BAD_FUNC_ARG;
 80100f0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80100f4:	e04d      	b.n	8010192 <wc_FreeRsaKey+0xb2>
    }

    wc_RsaCleanup(key);
 80100f6:	9801      	ldr	r0, [sp, #4]
 80100f8:	f7ff ff3a 	bl	800ff70 <wc_RsaCleanup>

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
#endif

    if (key->type == RSA_PRIVATE) {
 80100fc:	9b01      	ldr	r3, [sp, #4]
 80100fe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010102:	2b01      	cmp	r3, #1
 8010104:	d11d      	bne.n	8010142 <wc_FreeRsaKey+0x62>
        mp_forcezero(&key->u);
 8010106:	9b01      	ldr	r3, [sp, #4]
 8010108:	3370      	adds	r3, #112	; 0x70
 801010a:	4618      	mov	r0, r3
 801010c:	f7fa fad8 	bl	800a6c0 <mp_forcezero>
        mp_forcezero(&key->dQ);
 8010110:	9b01      	ldr	r3, [sp, #4]
 8010112:	3360      	adds	r3, #96	; 0x60
 8010114:	4618      	mov	r0, r3
 8010116:	f7fa fad3 	bl	800a6c0 <mp_forcezero>
        mp_forcezero(&key->dP);
 801011a:	9b01      	ldr	r3, [sp, #4]
 801011c:	3350      	adds	r3, #80	; 0x50
 801011e:	4618      	mov	r0, r3
 8010120:	f7fa face 	bl	800a6c0 <mp_forcezero>
        mp_forcezero(&key->q);
 8010124:	9b01      	ldr	r3, [sp, #4]
 8010126:	3340      	adds	r3, #64	; 0x40
 8010128:	4618      	mov	r0, r3
 801012a:	f7fa fac9 	bl	800a6c0 <mp_forcezero>
        mp_forcezero(&key->p);
 801012e:	9b01      	ldr	r3, [sp, #4]
 8010130:	3330      	adds	r3, #48	; 0x30
 8010132:	4618      	mov	r0, r3
 8010134:	f7fa fac4 	bl	800a6c0 <mp_forcezero>
        mp_forcezero(&key->d);
 8010138:	9b01      	ldr	r3, [sp, #4]
 801013a:	3320      	adds	r3, #32
 801013c:	4618      	mov	r0, r3
 801013e:	f7fa fabf 	bl	800a6c0 <mp_forcezero>
    }
    /* private part */
    mp_clear(&key->u);
 8010142:	9b01      	ldr	r3, [sp, #4]
 8010144:	3370      	adds	r3, #112	; 0x70
 8010146:	4618      	mov	r0, r3
 8010148:	f7fa fa72 	bl	800a630 <mp_clear>
    mp_clear(&key->dQ);
 801014c:	9b01      	ldr	r3, [sp, #4]
 801014e:	3360      	adds	r3, #96	; 0x60
 8010150:	4618      	mov	r0, r3
 8010152:	f7fa fa6d 	bl	800a630 <mp_clear>
    mp_clear(&key->dP);
 8010156:	9b01      	ldr	r3, [sp, #4]
 8010158:	3350      	adds	r3, #80	; 0x50
 801015a:	4618      	mov	r0, r3
 801015c:	f7fa fa68 	bl	800a630 <mp_clear>
    mp_clear(&key->q);
 8010160:	9b01      	ldr	r3, [sp, #4]
 8010162:	3340      	adds	r3, #64	; 0x40
 8010164:	4618      	mov	r0, r3
 8010166:	f7fa fa63 	bl	800a630 <mp_clear>
    mp_clear(&key->p);
 801016a:	9b01      	ldr	r3, [sp, #4]
 801016c:	3330      	adds	r3, #48	; 0x30
 801016e:	4618      	mov	r0, r3
 8010170:	f7fa fa5e 	bl	800a630 <mp_clear>
    mp_clear(&key->d);
 8010174:	9b01      	ldr	r3, [sp, #4]
 8010176:	3320      	adds	r3, #32
 8010178:	4618      	mov	r0, r3
 801017a:	f7fa fa59 	bl	800a630 <mp_clear>

    /* public part */
    mp_clear(&key->e);
 801017e:	9b01      	ldr	r3, [sp, #4]
 8010180:	3310      	adds	r3, #16
 8010182:	4618      	mov	r0, r3
 8010184:	f7fa fa54 	bl	800a630 <mp_clear>
    mp_clear(&key->n);
 8010188:	9b01      	ldr	r3, [sp, #4]
 801018a:	4618      	mov	r0, r3
 801018c:	f7fa fa50 	bl	800a630 <mp_clear>
#ifdef WOLFSSL_XILINX_CRYPT
    XFREE(key->mod, key->heap, DYNAMIC_TYPE_KEY);
    key->mod = NULL;
#endif

    return ret;
 8010190:	9b03      	ldr	r3, [sp, #12]
}
 8010192:	4618      	mov	r0, r3
 8010194:	b005      	add	sp, #20
 8010196:	f85d fb04 	ldr.w	pc, [sp], #4
 801019a:	bf00      	nop
 801019c:	0000      	movs	r0, r0
	...

080101a0 <RsaMGF1>:
   out:   mask output after generation
   outSz: size of output buffer
 */
static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
                                        byte* out, word32 outSz, void* heap)
{
 80101a0:	b500      	push	{lr}
 80101a2:	b099      	sub	sp, #100	; 0x64
 80101a4:	9104      	str	r1, [sp, #16]
 80101a6:	9203      	str	r2, [sp, #12]
 80101a8:	9302      	str	r3, [sp, #8]
 80101aa:	4603      	mov	r3, r0
 80101ac:	f88d 3017 	strb.w	r3, [sp, #23]
    word32 tmpSz;
    int hLen;
    int ret;
    word32 counter;
    word32 idx;
    hLen    = wc_HashGetDigestSize(hType);
 80101b0:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80101b4:	4618      	mov	r0, r3
 80101b6:	f7fc fac3 	bl	800c740 <wc_HashGetDigestSize>
 80101ba:	9011      	str	r0, [sp, #68]	; 0x44
    counter = 0;
 80101bc:	2300      	movs	r3, #0
 80101be:	9314      	str	r3, [sp, #80]	; 0x50
    idx     = 0;
 80101c0:	2300      	movs	r3, #0
 80101c2:	9313      	str	r3, [sp, #76]	; 0x4c

    (void)heap;

    /* check error return of wc_HashGetDigestSize */
    if (hLen < 0) {
 80101c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80101c6:	2b00      	cmp	r3, #0
 80101c8:	da01      	bge.n	80101ce <RsaMGF1+0x2e>
        return hLen;
 80101ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80101cc:	e087      	b.n	80102de <RsaMGF1+0x13e>
    }

    /* if tmp is not large enough than use some dynamic memory */
    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 80101ce:	9b03      	ldr	r3, [sp, #12]
 80101d0:	3304      	adds	r3, #4
 80101d2:	2b24      	cmp	r3, #36	; 0x24
 80101d4:	d802      	bhi.n	80101dc <RsaMGF1+0x3c>
 80101d6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80101d8:	2b24      	cmp	r3, #36	; 0x24
 80101da:	d916      	bls.n	801020a <RsaMGF1+0x6a>
        /* find largest amount of memory needed which will be the max of
         * hLen and (seedSz + 4) since tmp is used to store the hash digest */
        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 80101dc:	9b03      	ldr	r3, [sp, #12]
 80101de:	1d1a      	adds	r2, r3, #4
 80101e0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80101e2:	4293      	cmp	r3, r2
 80101e4:	bf38      	it	cc
 80101e6:	4613      	movcc	r3, r2
 80101e8:	9315      	str	r3, [sp, #84]	; 0x54
        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80101ea:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80101ec:	4619      	mov	r1, r3
 80101ee:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80101f0:	f7f5 fb36 	bl	8005860 <chibios_alloc>
 80101f4:	9017      	str	r0, [sp, #92]	; 0x5c
        if (tmp == NULL) {
 80101f6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80101f8:	2b00      	cmp	r3, #0
 80101fa:	d102      	bne.n	8010202 <RsaMGF1+0x62>
            return MEMORY_E;
 80101fc:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8010200:	e06d      	b.n	80102de <RsaMGF1+0x13e>
        }
        tmpF = 1; /* make sure to free memory when done */
 8010202:	2301      	movs	r3, #1
 8010204:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
 8010208:	e006      	b.n	8010218 <RsaMGF1+0x78>
    }
    else {
        /* use array on the stack */
        tmpSz = sizeof(tmpA);
 801020a:	2324      	movs	r3, #36	; 0x24
 801020c:	9315      	str	r3, [sp, #84]	; 0x54
        tmp  = tmpA;
 801020e:	ab07      	add	r3, sp, #28
 8010210:	9317      	str	r3, [sp, #92]	; 0x5c
        tmpF = 0; /* no need to free memory at end */
 8010212:	2300      	movs	r3, #0
 8010214:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
    }

    do {
        int i = 0;
 8010218:	2300      	movs	r3, #0
 801021a:	9312      	str	r3, [sp, #72]	; 0x48
        XMEMCPY(tmp, seed, seedSz);
 801021c:	9a03      	ldr	r2, [sp, #12]
 801021e:	9904      	ldr	r1, [sp, #16]
 8010220:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8010222:	f7f4 fa7b 	bl	800471c <memcpy>

        /* counter to byte array appended to tmp */
        tmp[seedSz]     = (counter >> 24) & 0xFF;
 8010226:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8010228:	9b03      	ldr	r3, [sp, #12]
 801022a:	4413      	add	r3, r2
 801022c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801022e:	0e12      	lsrs	r2, r2, #24
 8010230:	b2d2      	uxtb	r2, r2
 8010232:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 1] = (counter >> 16) & 0xFF;
 8010234:	9b03      	ldr	r3, [sp, #12]
 8010236:	3301      	adds	r3, #1
 8010238:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801023a:	4413      	add	r3, r2
 801023c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801023e:	0c12      	lsrs	r2, r2, #16
 8010240:	b2d2      	uxtb	r2, r2
 8010242:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 2] = (counter >>  8) & 0xFF;
 8010244:	9b03      	ldr	r3, [sp, #12]
 8010246:	3302      	adds	r3, #2
 8010248:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801024a:	4413      	add	r3, r2
 801024c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801024e:	0a12      	lsrs	r2, r2, #8
 8010250:	b2d2      	uxtb	r2, r2
 8010252:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 3] = (counter)       & 0xFF;
 8010254:	9b03      	ldr	r3, [sp, #12]
 8010256:	3303      	adds	r3, #3
 8010258:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801025a:	4413      	add	r3, r2
 801025c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801025e:	b2d2      	uxtb	r2, r2
 8010260:	701a      	strb	r2, [r3, #0]

        /* hash and append to existing output */
        if ((ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz)) != 0) {
 8010262:	9b03      	ldr	r3, [sp, #12]
 8010264:	1d1a      	adds	r2, r3, #4
 8010266:	f89d 0017 	ldrb.w	r0, [sp, #23]
 801026a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801026c:	9300      	str	r3, [sp, #0]
 801026e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8010270:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8010272:	f7fc fa9d 	bl	800c7b0 <wc_Hash>
 8010276:	9010      	str	r0, [sp, #64]	; 0x40
 8010278:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801027a:	2b00      	cmp	r3, #0
 801027c:	d008      	beq.n	8010290 <RsaMGF1+0xf0>
            /* check for if dynamic memory was needed, then free */
            if (tmpF) {
 801027e:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
 8010282:	2b00      	cmp	r3, #0
 8010284:	d002      	beq.n	801028c <RsaMGF1+0xec>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8010286:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8010288:	f7f5 fafa 	bl	8005880 <chibios_free>
            }
            return ret;
 801028c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801028e:	e026      	b.n	80102de <RsaMGF1+0x13e>
        }

        for (i = 0; i < hLen && idx < outSz; i++) {
 8010290:	2300      	movs	r3, #0
 8010292:	9312      	str	r3, [sp, #72]	; 0x48
 8010294:	e00c      	b.n	80102b0 <RsaMGF1+0x110>
            out[idx++] = tmp[i];
 8010296:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010298:	1c5a      	adds	r2, r3, #1
 801029a:	9213      	str	r2, [sp, #76]	; 0x4c
 801029c:	9a02      	ldr	r2, [sp, #8]
 801029e:	4413      	add	r3, r2
 80102a0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80102a2:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80102a4:	440a      	add	r2, r1
 80102a6:	7812      	ldrb	r2, [r2, #0]
 80102a8:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < hLen && idx < outSz; i++) {
 80102aa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80102ac:	3301      	adds	r3, #1
 80102ae:	9312      	str	r3, [sp, #72]	; 0x48
 80102b0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80102b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80102b4:	429a      	cmp	r2, r3
 80102b6:	da03      	bge.n	80102c0 <RsaMGF1+0x120>
 80102b8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80102ba:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80102bc:	429a      	cmp	r2, r3
 80102be:	d3ea      	bcc.n	8010296 <RsaMGF1+0xf6>
        }
        counter++;
 80102c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80102c2:	3301      	adds	r3, #1
 80102c4:	9314      	str	r3, [sp, #80]	; 0x50
    } while (idx < outSz);
 80102c6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80102c8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80102ca:	429a      	cmp	r2, r3
 80102cc:	d3a4      	bcc.n	8010218 <RsaMGF1+0x78>

    /* check for if dynamic memory was needed, then free */
    if (tmpF) {
 80102ce:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
 80102d2:	2b00      	cmp	r3, #0
 80102d4:	d002      	beq.n	80102dc <RsaMGF1+0x13c>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80102d6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80102d8:	f7f5 fad2 	bl	8005880 <chibios_free>
    }

    return 0;
 80102dc:	2300      	movs	r3, #0
}
 80102de:	4618      	mov	r0, r3
 80102e0:	b019      	add	sp, #100	; 0x64
 80102e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80102e6:	bf00      	nop
	...

080102f0 <RsaMGF>:
/* helper function to direct which mask generation function is used
   switeched on type input
 */
static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
                                                    word32 outSz, void* heap)
{
 80102f0:	b500      	push	{lr}
 80102f2:	b089      	sub	sp, #36	; 0x24
 80102f4:	9005      	str	r0, [sp, #20]
 80102f6:	9104      	str	r1, [sp, #16]
 80102f8:	9203      	str	r2, [sp, #12]
 80102fa:	9302      	str	r3, [sp, #8]
    int ret;

    switch(type) {
 80102fc:	9b05      	ldr	r3, [sp, #20]
 80102fe:	2b04      	cmp	r3, #4
 8010300:	d010      	beq.n	8010324 <RsaMGF+0x34>
 8010302:	2b1a      	cmp	r3, #26
 8010304:	d002      	beq.n	801030c <RsaMGF+0x1c>
 8010306:	2b01      	cmp	r3, #1
 8010308:	d018      	beq.n	801033c <RsaMGF+0x4c>
 801030a:	e023      	b.n	8010354 <RsaMGF+0x64>
    #ifndef NO_SHA
        case WC_MGF1SHA1:
            ret = RsaMGF1(WC_HASH_TYPE_SHA, seed, seedSz, out, outSz, heap);
 801030c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801030e:	9301      	str	r3, [sp, #4]
 8010310:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010312:	9300      	str	r3, [sp, #0]
 8010314:	9b02      	ldr	r3, [sp, #8]
 8010316:	9a03      	ldr	r2, [sp, #12]
 8010318:	9904      	ldr	r1, [sp, #16]
 801031a:	2004      	movs	r0, #4
 801031c:	f7ff ff40 	bl	80101a0 <RsaMGF1>
 8010320:	9007      	str	r0, [sp, #28]
 8010322:	e01a      	b.n	801035a <RsaMGF+0x6a>
            break;
    #endif
    #ifndef NO_SHA256
    #ifdef WOLFSSL_SHA224
        case WC_MGF1SHA224:
            ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
 8010324:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010326:	9301      	str	r3, [sp, #4]
 8010328:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801032a:	9300      	str	r3, [sp, #0]
 801032c:	9b02      	ldr	r3, [sp, #8]
 801032e:	9a03      	ldr	r2, [sp, #12]
 8010330:	9904      	ldr	r1, [sp, #16]
 8010332:	2009      	movs	r0, #9
 8010334:	f7ff ff34 	bl	80101a0 <RsaMGF1>
 8010338:	9007      	str	r0, [sp, #28]
 801033a:	e00e      	b.n	801035a <RsaMGF+0x6a>
            break;
    #endif
        case WC_MGF1SHA256:
            ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 801033c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801033e:	9301      	str	r3, [sp, #4]
 8010340:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010342:	9300      	str	r3, [sp, #0]
 8010344:	9b02      	ldr	r3, [sp, #8]
 8010346:	9a03      	ldr	r2, [sp, #12]
 8010348:	9904      	ldr	r1, [sp, #16]
 801034a:	2005      	movs	r0, #5
 801034c:	f7ff ff28 	bl	80101a0 <RsaMGF1>
 8010350:	9007      	str	r0, [sp, #28]
 8010352:	e002      	b.n	801035a <RsaMGF+0x6a>
            ret = RsaMGF1(WC_HASH_TYPE_SHA512, seed, seedSz, out, outSz, heap);
            break;
    #endif
        default:
            WOLFSSL_MSG("Unknown MGF type: check build options");
            ret = BAD_FUNC_ARG;
 8010354:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010358:	9307      	str	r3, [sp, #28]
    (void)seedSz;
    (void)out;
    (void)outSz;
    (void)heap;

    return ret;
 801035a:	9b07      	ldr	r3, [sp, #28]
}
 801035c:	4618      	mov	r0, r3
 801035e:	b009      	add	sp, #36	; 0x24
 8010360:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08010370 <RsaUnPad_OAEP>:
/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
                            byte **output, enum wc_HashType hType, int mgf,
                            byte* optLabel, word32 labelLen, void* heap)
{
 8010370:	b500      	push	{lr}
 8010372:	b093      	sub	sp, #76	; 0x4c
 8010374:	9005      	str	r0, [sp, #20]
 8010376:	9104      	str	r1, [sp, #16]
 8010378:	9203      	str	r2, [sp, #12]
 801037a:	f88d 300b 	strb.w	r3, [sp, #11]
    byte h[WC_MAX_DIGEST_SIZE]; /* max digest size */
    byte* tmp;
    word32 idx;

    /* no label is allowed, but catch if no label provided and length > 0 */
    if (optLabel == NULL && labelLen > 0) {
 801037e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8010380:	2b00      	cmp	r3, #0
 8010382:	d105      	bne.n	8010390 <RsaUnPad_OAEP+0x20>
 8010384:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8010386:	2b00      	cmp	r3, #0
 8010388:	d002      	beq.n	8010390 <RsaUnPad_OAEP+0x20>
        return BUFFER_E;
 801038a:	f06f 0383 	mvn.w	r3, #131	; 0x83
 801038e:	e0e8      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }

    hLen = wc_HashGetDigestSize(hType);
 8010390:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8010394:	4618      	mov	r0, r3
 8010396:	f7fc f9d3 	bl	800c740 <wc_HashGetDigestSize>
 801039a:	9010      	str	r0, [sp, #64]	; 0x40
    if ((hLen < 0) || (pkcsBlockLen < (2 * (word32)hLen + 2))) {
 801039c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801039e:	2b00      	cmp	r3, #0
 80103a0:	db05      	blt.n	80103ae <RsaUnPad_OAEP+0x3e>
 80103a2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80103a4:	3301      	adds	r3, #1
 80103a6:	005a      	lsls	r2, r3, #1
 80103a8:	9b04      	ldr	r3, [sp, #16]
 80103aa:	429a      	cmp	r2, r3
 80103ac:	d902      	bls.n	80103b4 <RsaUnPad_OAEP+0x44>
        return BAD_FUNC_ARG;
 80103ae:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80103b2:	e0d6      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }

    tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80103b4:	9b04      	ldr	r3, [sp, #16]
 80103b6:	4619      	mov	r1, r3
 80103b8:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80103ba:	f7f5 fa51 	bl	8005860 <chibios_alloc>
 80103be:	900f      	str	r0, [sp, #60]	; 0x3c
    if (tmp == NULL) {
 80103c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80103c2:	2b00      	cmp	r3, #0
 80103c4:	d102      	bne.n	80103cc <RsaUnPad_OAEP+0x5c>
        return MEMORY_E;
 80103c6:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 80103ca:	e0ca      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }
    XMEMSET(tmp, 0, pkcsBlockLen);
 80103cc:	9a04      	ldr	r2, [sp, #16]
 80103ce:	2100      	movs	r1, #0
 80103d0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80103d2:	f00d f9ff 	bl	801d7d4 <memset>

    /* find seedMask value */
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 80103d6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80103d8:	3301      	adds	r3, #1
 80103da:	9a05      	ldr	r2, [sp, #20]
 80103dc:	18d1      	adds	r1, r2, r3
                            pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 80103de:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80103e0:	9a04      	ldr	r2, [sp, #16]
 80103e2:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 80103e4:	1e58      	subs	r0, r3, #1
 80103e6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80103e8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80103ea:	9201      	str	r2, [sp, #4]
 80103ec:	9300      	str	r3, [sp, #0]
 80103ee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80103f0:	4602      	mov	r2, r0
 80103f2:	9814      	ldr	r0, [sp, #80]	; 0x50
 80103f4:	f7ff ff7c 	bl	80102f0 <RsaMGF>
 80103f8:	900e      	str	r0, [sp, #56]	; 0x38
 80103fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80103fc:	2b00      	cmp	r3, #0
 80103fe:	d004      	beq.n	801040a <RsaUnPad_OAEP+0x9a>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8010400:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010402:	f7f5 fa3d 	bl	8005880 <chibios_free>
        return ret;
 8010406:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010408:	e0ab      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }

    /* xor seedMask value with maskedSeed to get seed value */
    for (idx = 0; idx < (word32)hLen; idx++) {
 801040a:	2300      	movs	r3, #0
 801040c:	9311      	str	r3, [sp, #68]	; 0x44
 801040e:	e011      	b.n	8010434 <RsaUnPad_OAEP+0xc4>
        tmp[idx] = tmp[idx] ^ pkcsBlock[1 + idx];
 8010410:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010412:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8010414:	4413      	add	r3, r2
 8010416:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8010418:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801041a:	440a      	add	r2, r1
 801041c:	7811      	ldrb	r1, [r2, #0]
 801041e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010420:	3201      	adds	r2, #1
 8010422:	9805      	ldr	r0, [sp, #20]
 8010424:	4402      	add	r2, r0
 8010426:	7812      	ldrb	r2, [r2, #0]
 8010428:	404a      	eors	r2, r1
 801042a:	b2d2      	uxtb	r2, r2
 801042c:	701a      	strb	r2, [r3, #0]
    for (idx = 0; idx < (word32)hLen; idx++) {
 801042e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8010430:	3301      	adds	r3, #1
 8010432:	9311      	str	r3, [sp, #68]	; 0x44
 8010434:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010436:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010438:	429a      	cmp	r2, r3
 801043a:	d3e9      	bcc.n	8010410 <RsaUnPad_OAEP+0xa0>
    }

    /* get dbMask value */
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 801043c:	9910      	ldr	r1, [sp, #64]	; 0x40
 801043e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010440:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010442:	18d0      	adds	r0, r2, r3
                                       pkcsBlockLen - hLen - 1, heap)) != 0) {
 8010444:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010446:	9a04      	ldr	r2, [sp, #16]
 8010448:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 801044a:	3b01      	subs	r3, #1
 801044c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801044e:	9201      	str	r2, [sp, #4]
 8010450:	9300      	str	r3, [sp, #0]
 8010452:	4603      	mov	r3, r0
 8010454:	460a      	mov	r2, r1
 8010456:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8010458:	9814      	ldr	r0, [sp, #80]	; 0x50
 801045a:	f7ff ff49 	bl	80102f0 <RsaMGF>
 801045e:	900e      	str	r0, [sp, #56]	; 0x38
 8010460:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010462:	2b00      	cmp	r3, #0
 8010464:	d004      	beq.n	8010470 <RsaUnPad_OAEP+0x100>
        XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 8010466:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010468:	f7f5 fa0a 	bl	8005880 <chibios_free>
        return ret;
 801046c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801046e:	e078      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }

    /* get DB value by doing maskedDB xor dbMask */
    for (idx = 0; idx < (pkcsBlockLen - hLen - 1); idx++) {
 8010470:	2300      	movs	r3, #0
 8010472:	9311      	str	r3, [sp, #68]	; 0x44
 8010474:	e018      	b.n	80104a8 <RsaUnPad_OAEP+0x138>
        pkcsBlock[hLen + 1 + idx] = pkcsBlock[hLen + 1 + idx] ^ tmp[idx + hLen];
 8010476:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8010478:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801047a:	4413      	add	r3, r2
 801047c:	3301      	adds	r3, #1
 801047e:	9a05      	ldr	r2, [sp, #20]
 8010480:	4413      	add	r3, r2
 8010482:	9910      	ldr	r1, [sp, #64]	; 0x40
 8010484:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010486:	440a      	add	r2, r1
 8010488:	3201      	adds	r2, #1
 801048a:	9905      	ldr	r1, [sp, #20]
 801048c:	440a      	add	r2, r1
 801048e:	7811      	ldrb	r1, [r2, #0]
 8010490:	9810      	ldr	r0, [sp, #64]	; 0x40
 8010492:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010494:	4402      	add	r2, r0
 8010496:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010498:	4402      	add	r2, r0
 801049a:	7812      	ldrb	r2, [r2, #0]
 801049c:	404a      	eors	r2, r1
 801049e:	b2d2      	uxtb	r2, r2
 80104a0:	701a      	strb	r2, [r3, #0]
    for (idx = 0; idx < (pkcsBlockLen - hLen - 1); idx++) {
 80104a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80104a4:	3301      	adds	r3, #1
 80104a6:	9311      	str	r3, [sp, #68]	; 0x44
 80104a8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80104aa:	9a04      	ldr	r2, [sp, #16]
 80104ac:	1ad3      	subs	r3, r2, r3
 80104ae:	1e5a      	subs	r2, r3, #1
 80104b0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80104b2:	429a      	cmp	r2, r3
 80104b4:	d8df      	bhi.n	8010476 <RsaUnPad_OAEP+0x106>
    }

    /* done with use of tmp buffer */
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80104b6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80104b8:	f7f5 f9e2 	bl	8005880 <chibios_free>

    /* advance idx to index of PS and msg separator, account for PS size of 0*/
    idx = hLen + 1 + hLen;
 80104bc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80104be:	1c5a      	adds	r2, r3, #1
 80104c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80104c2:	4413      	add	r3, r2
 80104c4:	9311      	str	r3, [sp, #68]	; 0x44
 80104c6:	e002      	b.n	80104ce <RsaUnPad_OAEP+0x15e>
    while (idx < pkcsBlockLen && pkcsBlock[idx] == 0) {idx++;}
 80104c8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80104ca:	3301      	adds	r3, #1
 80104cc:	9311      	str	r3, [sp, #68]	; 0x44
 80104ce:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80104d0:	9b04      	ldr	r3, [sp, #16]
 80104d2:	429a      	cmp	r2, r3
 80104d4:	d205      	bcs.n	80104e2 <RsaUnPad_OAEP+0x172>
 80104d6:	9a05      	ldr	r2, [sp, #20]
 80104d8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80104da:	4413      	add	r3, r2
 80104dc:	781b      	ldrb	r3, [r3, #0]
 80104de:	2b00      	cmp	r3, #0
 80104e0:	d0f2      	beq.n	80104c8 <RsaUnPad_OAEP+0x158>

    /* create hash of label for comparison with hash sent */
    if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 80104e2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80104e4:	aa06      	add	r2, sp, #24
 80104e6:	f89d 000b 	ldrb.w	r0, [sp, #11]
 80104ea:	9300      	str	r3, [sp, #0]
 80104ec:	4613      	mov	r3, r2
 80104ee:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80104f0:	9915      	ldr	r1, [sp, #84]	; 0x54
 80104f2:	f7fc f95d 	bl	800c7b0 <wc_Hash>
 80104f6:	900e      	str	r0, [sp, #56]	; 0x38
 80104f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80104fa:	2b00      	cmp	r3, #0
 80104fc:	d001      	beq.n	8010502 <RsaUnPad_OAEP+0x192>
        return ret;
 80104fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010500:	e02f      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
       Comparison of lHash, Y, and separator value needs to all happen in
       constant time.
       Attackers should not be able to get error condition from the timing of
       these checks.
     */
    ret = 0;
 8010502:	2300      	movs	r3, #0
 8010504:	930e      	str	r3, [sp, #56]	; 0x38
    ret |= ConstantCompare(pkcsBlock + hLen + 1, h, hLen);
 8010506:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010508:	3301      	adds	r3, #1
 801050a:	9a05      	ldr	r2, [sp, #20]
 801050c:	4413      	add	r3, r2
 801050e:	a906      	add	r1, sp, #24
 8010510:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8010512:	4618      	mov	r0, r3
 8010514:	f7ff fd04 	bl	800ff20 <ConstantCompare>
 8010518:	4602      	mov	r2, r0
 801051a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801051c:	4313      	orrs	r3, r2
 801051e:	930e      	str	r3, [sp, #56]	; 0x38
    ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 8010520:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8010522:	1c5a      	adds	r2, r3, #1
 8010524:	9211      	str	r2, [sp, #68]	; 0x44
 8010526:	9a05      	ldr	r2, [sp, #20]
 8010528:	4413      	add	r3, r2
 801052a:	781b      	ldrb	r3, [r3, #0]
 801052c:	f083 0301 	eor.w	r3, r3, #1
 8010530:	b2db      	uxtb	r3, r3
 8010532:	461a      	mov	r2, r3
 8010534:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010536:	4413      	add	r3, r2
 8010538:	930e      	str	r3, [sp, #56]	; 0x38
    ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 801053a:	9b05      	ldr	r3, [sp, #20]
 801053c:	781b      	ldrb	r3, [r3, #0]
 801053e:	461a      	mov	r2, r3
 8010540:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010542:	4413      	add	r3, r2
 8010544:	930e      	str	r3, [sp, #56]	; 0x38

    if (ret != 0) {
 8010546:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010548:	2b00      	cmp	r3, #0
 801054a:	d002      	beq.n	8010552 <RsaUnPad_OAEP+0x1e2>
        WOLFSSL_MSG("RsaUnPad_OAEP: Padding Error");
        return BAD_PADDING_E;
 801054c:	f06f 03c0 	mvn.w	r3, #192	; 0xc0
 8010550:	e007      	b.n	8010562 <RsaUnPad_OAEP+0x1f2>
    }

    /* adjust pointer to correct location in array and return size of M */
    *output = (byte*)(pkcsBlock + idx);
 8010552:	9a05      	ldr	r2, [sp, #20]
 8010554:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8010556:	441a      	add	r2, r3
 8010558:	9b03      	ldr	r3, [sp, #12]
 801055a:	601a      	str	r2, [r3, #0]
    return pkcsBlockLen - idx;
 801055c:	9a04      	ldr	r2, [sp, #16]
 801055e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8010560:	1ad3      	subs	r3, r2, r3
}
 8010562:	4618      	mov	r0, r3
 8010564:	b013      	add	sp, #76	; 0x4c
 8010566:	f85d fb04 	ldr.w	pc, [sp], #4
 801056a:	bf00      	nop
 801056c:	0000      	movs	r0, r0
	...

08010570 <RsaUnPad>:

/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
                                               byte **output, byte padValue)
{
 8010570:	b088      	sub	sp, #32
 8010572:	9003      	str	r0, [sp, #12]
 8010574:	9102      	str	r1, [sp, #8]
 8010576:	9201      	str	r2, [sp, #4]
 8010578:	f88d 3003 	strb.w	r3, [sp, #3]
    word32 maxOutputLen = (pkcsBlockLen > 10) ? (pkcsBlockLen - 10) : 0;
 801057c:	9b02      	ldr	r3, [sp, #8]
 801057e:	2b0a      	cmp	r3, #10
 8010580:	d902      	bls.n	8010588 <RsaUnPad+0x18>
 8010582:	9b02      	ldr	r3, [sp, #8]
 8010584:	3b0a      	subs	r3, #10
 8010586:	e000      	b.n	801058a <RsaUnPad+0x1a>
 8010588:	2300      	movs	r3, #0
 801058a:	9305      	str	r3, [sp, #20]
    word32 invalid = 0;
 801058c:	2300      	movs	r3, #0
 801058e:	9307      	str	r3, [sp, #28]
    word32 i = 1;
 8010590:	2301      	movs	r3, #1
 8010592:	9306      	str	r3, [sp, #24]
    word32 outputLen;

    if (output == NULL || pkcsBlockLen == 0) {
 8010594:	9b01      	ldr	r3, [sp, #4]
 8010596:	2b00      	cmp	r3, #0
 8010598:	d002      	beq.n	80105a0 <RsaUnPad+0x30>
 801059a:	9b02      	ldr	r3, [sp, #8]
 801059c:	2b00      	cmp	r3, #0
 801059e:	d102      	bne.n	80105a6 <RsaUnPad+0x36>
        return BAD_FUNC_ARG;
 80105a0:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80105a4:	e05e      	b.n	8010664 <RsaUnPad+0xf4>
    }

    if (pkcsBlock[0] != 0x0) { /* skip past zero */
 80105a6:	9b03      	ldr	r3, [sp, #12]
 80105a8:	781b      	ldrb	r3, [r3, #0]
 80105aa:	2b00      	cmp	r3, #0
 80105ac:	d001      	beq.n	80105b2 <RsaUnPad+0x42>
        invalid = 1;
 80105ae:	2301      	movs	r3, #1
 80105b0:	9307      	str	r3, [sp, #28]
    }
    pkcsBlock++; pkcsBlockLen--;
 80105b2:	9b03      	ldr	r3, [sp, #12]
 80105b4:	3301      	adds	r3, #1
 80105b6:	9303      	str	r3, [sp, #12]
 80105b8:	9b02      	ldr	r3, [sp, #8]
 80105ba:	3b01      	subs	r3, #1
 80105bc:	9302      	str	r3, [sp, #8]

    /* Require block type padValue */
    invalid = (pkcsBlock[0] != padValue) || invalid;
 80105be:	9b03      	ldr	r3, [sp, #12]
 80105c0:	781b      	ldrb	r3, [r3, #0]
 80105c2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80105c6:	429a      	cmp	r2, r3
 80105c8:	d102      	bne.n	80105d0 <RsaUnPad+0x60>
 80105ca:	9b07      	ldr	r3, [sp, #28]
 80105cc:	2b00      	cmp	r3, #0
 80105ce:	d001      	beq.n	80105d4 <RsaUnPad+0x64>
 80105d0:	2301      	movs	r3, #1
 80105d2:	e000      	b.n	80105d6 <RsaUnPad+0x66>
 80105d4:	2300      	movs	r3, #0
 80105d6:	9307      	str	r3, [sp, #28]

    /* verify the padding until we find the separator */
    if (padValue == RSA_BLOCK_TYPE_1) {
 80105d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80105dc:	2b01      	cmp	r3, #1
 80105de:	d10c      	bne.n	80105fa <RsaUnPad+0x8a>
        while (i<pkcsBlockLen && pkcsBlock[i++] == 0xFF) {/* Null body */}
 80105e0:	9a06      	ldr	r2, [sp, #24]
 80105e2:	9b02      	ldr	r3, [sp, #8]
 80105e4:	429a      	cmp	r2, r3
 80105e6:	d214      	bcs.n	8010612 <RsaUnPad+0xa2>
 80105e8:	9b06      	ldr	r3, [sp, #24]
 80105ea:	1c5a      	adds	r2, r3, #1
 80105ec:	9206      	str	r2, [sp, #24]
 80105ee:	9a03      	ldr	r2, [sp, #12]
 80105f0:	4413      	add	r3, r2
 80105f2:	781b      	ldrb	r3, [r3, #0]
 80105f4:	2bff      	cmp	r3, #255	; 0xff
 80105f6:	d0f3      	beq.n	80105e0 <RsaUnPad+0x70>
 80105f8:	e00b      	b.n	8010612 <RsaUnPad+0xa2>
    }
    else {
        while (i<pkcsBlockLen && pkcsBlock[i++]) {/* Null body */}
 80105fa:	9a06      	ldr	r2, [sp, #24]
 80105fc:	9b02      	ldr	r3, [sp, #8]
 80105fe:	429a      	cmp	r2, r3
 8010600:	d207      	bcs.n	8010612 <RsaUnPad+0xa2>
 8010602:	9b06      	ldr	r3, [sp, #24]
 8010604:	1c5a      	adds	r2, r3, #1
 8010606:	9206      	str	r2, [sp, #24]
 8010608:	9a03      	ldr	r2, [sp, #12]
 801060a:	4413      	add	r3, r2
 801060c:	781b      	ldrb	r3, [r3, #0]
 801060e:	2b00      	cmp	r3, #0
 8010610:	d1f3      	bne.n	80105fa <RsaUnPad+0x8a>
    }

    if (!(i==pkcsBlockLen || pkcsBlock[i-1]==0)) {
 8010612:	9a06      	ldr	r2, [sp, #24]
 8010614:	9b02      	ldr	r3, [sp, #8]
 8010616:	429a      	cmp	r2, r3
 8010618:	d009      	beq.n	801062e <RsaUnPad+0xbe>
 801061a:	9b06      	ldr	r3, [sp, #24]
 801061c:	3b01      	subs	r3, #1
 801061e:	9a03      	ldr	r2, [sp, #12]
 8010620:	4413      	add	r3, r2
 8010622:	781b      	ldrb	r3, [r3, #0]
 8010624:	2b00      	cmp	r3, #0
 8010626:	d002      	beq.n	801062e <RsaUnPad+0xbe>
        WOLFSSL_MSG("RsaUnPad error, bad formatting");
        return RSA_PAD_E;
 8010628:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 801062c:	e01a      	b.n	8010664 <RsaUnPad+0xf4>
    }

    outputLen = pkcsBlockLen - i;
 801062e:	9a02      	ldr	r2, [sp, #8]
 8010630:	9b06      	ldr	r3, [sp, #24]
 8010632:	1ad3      	subs	r3, r2, r3
 8010634:	9304      	str	r3, [sp, #16]
    invalid = (outputLen > maxOutputLen) || invalid;
 8010636:	9a04      	ldr	r2, [sp, #16]
 8010638:	9b05      	ldr	r3, [sp, #20]
 801063a:	429a      	cmp	r2, r3
 801063c:	d802      	bhi.n	8010644 <RsaUnPad+0xd4>
 801063e:	9b07      	ldr	r3, [sp, #28]
 8010640:	2b00      	cmp	r3, #0
 8010642:	d001      	beq.n	8010648 <RsaUnPad+0xd8>
 8010644:	2301      	movs	r3, #1
 8010646:	e000      	b.n	801064a <RsaUnPad+0xda>
 8010648:	2300      	movs	r3, #0
 801064a:	9307      	str	r3, [sp, #28]

    if (invalid) {
 801064c:	9b07      	ldr	r3, [sp, #28]
 801064e:	2b00      	cmp	r3, #0
 8010650:	d002      	beq.n	8010658 <RsaUnPad+0xe8>
        WOLFSSL_MSG("RsaUnPad error, invalid formatting");
        return RSA_PAD_E;
 8010652:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 8010656:	e005      	b.n	8010664 <RsaUnPad+0xf4>
    }

    *output = (byte *)(pkcsBlock + i);
 8010658:	9a03      	ldr	r2, [sp, #12]
 801065a:	9b06      	ldr	r3, [sp, #24]
 801065c:	441a      	add	r2, r3
 801065e:	9b01      	ldr	r3, [sp, #4]
 8010660:	601a      	str	r2, [r3, #0]
    return outputLen;
 8010662:	9b04      	ldr	r3, [sp, #16]
}
 8010664:	4618      	mov	r0, r3
 8010666:	b008      	add	sp, #32
 8010668:	4770      	bx	lr
 801066a:	bf00      	nop
 801066c:	0000      	movs	r0, r0
	...

08010670 <wc_RsaUnPad_ex>:
/* helper function to direct unpadding */
static int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
                          byte padValue, int padType, enum wc_HashType hType,
                          int mgf, byte* optLabel, word32 labelLen, int bits,
                          void* heap)
{
 8010670:	b500      	push	{lr}
 8010672:	b08b      	sub	sp, #44	; 0x2c
 8010674:	9007      	str	r0, [sp, #28]
 8010676:	9106      	str	r1, [sp, #24]
 8010678:	9205      	str	r2, [sp, #20]
 801067a:	f88d 3013 	strb.w	r3, [sp, #19]
    int ret;

    switch (padType) {
 801067e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010680:	2b00      	cmp	r3, #0
 8010682:	d002      	beq.n	801068a <wc_RsaUnPad_ex+0x1a>
 8010684:	2b01      	cmp	r3, #1
 8010686:	d009      	beq.n	801069c <wc_RsaUnPad_ex+0x2c>
 8010688:	e01a      	b.n	80106c0 <wc_RsaUnPad_ex+0x50>
        case WC_RSA_PKCSV15_PAD:
            /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
            ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 801068a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 801068e:	9a05      	ldr	r2, [sp, #20]
 8010690:	9906      	ldr	r1, [sp, #24]
 8010692:	9807      	ldr	r0, [sp, #28]
 8010694:	f7ff ff6c 	bl	8010570 <RsaUnPad>
 8010698:	9009      	str	r0, [sp, #36]	; 0x24
 801069a:	e014      	b.n	80106c6 <wc_RsaUnPad_ex+0x56>
            break;

    #ifndef WC_NO_RSA_OAEP
        case WC_RSA_OAEP_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
            ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 801069c:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
 80106a0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80106a2:	9303      	str	r3, [sp, #12]
 80106a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80106a6:	9302      	str	r3, [sp, #8]
 80106a8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80106aa:	9301      	str	r3, [sp, #4]
 80106ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80106ae:	9300      	str	r3, [sp, #0]
 80106b0:	4613      	mov	r3, r2
 80106b2:	9a05      	ldr	r2, [sp, #20]
 80106b4:	9906      	ldr	r1, [sp, #24]
 80106b6:	9807      	ldr	r0, [sp, #28]
 80106b8:	f7ff fe5a 	bl	8010370 <RsaUnPad_OAEP>
 80106bc:	9009      	str	r0, [sp, #36]	; 0x24
 80106be:	e002      	b.n	80106c6 <wc_RsaUnPad_ex+0x56>
            break;
    #endif

        default:
            WOLFSSL_MSG("Unknown RSA UnPad Type");
            ret = RSA_PAD_E;
 80106c0:	f06f 03c8 	mvn.w	r3, #200	; 0xc8
 80106c4:	9309      	str	r3, [sp, #36]	; 0x24
    (void)optLabel;
    (void)labelLen;
    (void)bits;
    (void)heap;

    return ret;
 80106c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 80106c8:	4618      	mov	r0, r3
 80106ca:	b00b      	add	sp, #44	; 0x2c
 80106cc:	f85d fb04 	ldr.w	pc, [sp], #4

080106d0 <wc_RsaFunctionSync>:
}
#endif /* WOLFSSL_XILINX_CRYPT */

static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 80106d0:	b500      	push	{lr}
 80106d2:	b09f      	sub	sp, #124	; 0x7c
 80106d4:	9005      	str	r0, [sp, #20]
 80106d6:	9104      	str	r1, [sp, #16]
 80106d8:	9203      	str	r2, [sp, #12]
 80106da:	9302      	str	r3, [sp, #8]
    mp_int tmp;
#ifdef WC_RSA_BLINDING
    mp_int rnd, rndi;
#endif
    int    ret = 0;
 80106dc:	2300      	movs	r3, #0
 80106de:	931d      	str	r3, [sp, #116]	; 0x74
#endif
#endif /* WOLFSSL_HAVE_SP_RSA */

    (void)rng;

    if (mp_init(&tmp) != MP_OKAY)
 80106e0:	ab16      	add	r3, sp, #88	; 0x58
 80106e2:	4618      	mov	r0, r3
 80106e4:	f7f9 ff8c 	bl	800a600 <mp_init>
 80106e8:	4603      	mov	r3, r0
 80106ea:	2b00      	cmp	r3, #0
 80106ec:	d002      	beq.n	80106f4 <wc_RsaFunctionSync+0x24>
        return MP_INIT_E;
 80106ee:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 80106f2:	e1a6      	b.n	8010a42 <wc_RsaFunctionSync+0x372>

#ifdef WC_RSA_BLINDING
    if (type == RSA_PRIVATE_DECRYPT || type == RSA_PRIVATE_ENCRYPT) {
 80106f4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80106f6:	2b03      	cmp	r3, #3
 80106f8:	d002      	beq.n	8010700 <wc_RsaFunctionSync+0x30>
 80106fa:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80106fc:	2b02      	cmp	r3, #2
 80106fe:	d113      	bne.n	8010728 <wc_RsaFunctionSync+0x58>
        if (mp_init_multi(&rnd, &rndi, NULL, NULL, NULL, NULL) != MP_OKAY) {
 8010700:	a90e      	add	r1, sp, #56	; 0x38
 8010702:	a812      	add	r0, sp, #72	; 0x48
 8010704:	2300      	movs	r3, #0
 8010706:	9301      	str	r3, [sp, #4]
 8010708:	2300      	movs	r3, #0
 801070a:	9300      	str	r3, [sp, #0]
 801070c:	2300      	movs	r3, #0
 801070e:	2200      	movs	r2, #0
 8010710:	f7fc f9be 	bl	800ca90 <mp_init_multi>
 8010714:	4603      	mov	r3, r0
 8010716:	2b00      	cmp	r3, #0
 8010718:	d006      	beq.n	8010728 <wc_RsaFunctionSync+0x58>
            mp_clear(&tmp);
 801071a:	ab16      	add	r3, sp, #88	; 0x58
 801071c:	4618      	mov	r0, r3
 801071e:	f7f9 ff87 	bl	800a630 <mp_clear>
            return MP_INIT_E;
 8010722:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 8010726:	e18c      	b.n	8010a42 <wc_RsaFunctionSync+0x372>
        }
    }
#endif

    if (mp_read_unsigned_bin(&tmp, (byte*)in, inLen) != MP_OKAY)
 8010728:	9a04      	ldr	r2, [sp, #16]
 801072a:	ab16      	add	r3, sp, #88	; 0x58
 801072c:	9905      	ldr	r1, [sp, #20]
 801072e:	4618      	mov	r0, r3
 8010730:	f7fa fb9e 	bl	800ae70 <mp_read_unsigned_bin>
 8010734:	4603      	mov	r3, r0
 8010736:	2b00      	cmp	r3, #0
 8010738:	d003      	beq.n	8010742 <wc_RsaFunctionSync+0x72>
        ERROR_OUT(MP_READ_E);
 801073a:	f06f 036e 	mvn.w	r3, #110	; 0x6e
 801073e:	931d      	str	r3, [sp, #116]	; 0x74
 8010740:	e16c      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>

    switch(type) {
 8010742:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8010744:	2b03      	cmp	r3, #3
 8010746:	f200 8134 	bhi.w	80109b2 <wc_RsaFunctionSync+0x2e2>
 801074a:	a201      	add	r2, pc, #4	; (adr r2, 8010750 <wc_RsaFunctionSync+0x80>)
 801074c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010750:	08010995 	.word	0x08010995
 8010754:	08010995 	.word	0x08010995
 8010758:	08010761 	.word	0x08010761
 801075c:	08010761 	.word	0x08010761
    case RSA_PRIVATE_DECRYPT:
    case RSA_PRIVATE_ENCRYPT:
    {
    #ifdef WC_RSA_BLINDING
        /* blind */
        ret = mp_rand(&rnd, get_digit_count(&key->n), rng);
 8010760:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8010762:	4618      	mov	r0, r3
 8010764:	f7fb fb74 	bl	800be50 <get_digit_count>
 8010768:	4601      	mov	r1, r0
 801076a:	ab12      	add	r3, sp, #72	; 0x48
 801076c:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801076e:	4618      	mov	r0, r3
 8010770:	f7fb fb8e 	bl	800be90 <mp_rand>
 8010774:	901d      	str	r0, [sp, #116]	; 0x74
        if (ret != MP_OKAY)
 8010776:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010778:	2b00      	cmp	r3, #0
 801077a:	f040 814f 	bne.w	8010a1c <wc_RsaFunctionSync+0x34c>
            goto done;

        /* rndi = 1/rnd mod n */
        if (mp_invmod(&rnd, &key->n, &rndi) != MP_OKAY)
 801077e:	9921      	ldr	r1, [sp, #132]	; 0x84
 8010780:	aa0e      	add	r2, sp, #56	; 0x38
 8010782:	ab12      	add	r3, sp, #72	; 0x48
 8010784:	4618      	mov	r0, r3
 8010786:	f7fa fd8b 	bl	800b2a0 <mp_invmod>
 801078a:	4603      	mov	r3, r0
 801078c:	2b00      	cmp	r3, #0
 801078e:	d003      	beq.n	8010798 <wc_RsaFunctionSync+0xc8>
            ERROR_OUT(MP_INVMOD_E);
 8010790:	f06f 0376 	mvn.w	r3, #118	; 0x76
 8010794:	931d      	str	r3, [sp, #116]	; 0x74
 8010796:	e141      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>

        /* rnd = rnd^e */
        if (mp_exptmod(&rnd, &key->e, &key->n, &rnd) != MP_OKAY)
 8010798:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801079a:	f103 0110 	add.w	r1, r3, #16
 801079e:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80107a0:	ab12      	add	r3, sp, #72	; 0x48
 80107a2:	a812      	add	r0, sp, #72	; 0x48
 80107a4:	f7fa fcb4 	bl	800b110 <mp_exptmod>
 80107a8:	4603      	mov	r3, r0
 80107aa:	2b00      	cmp	r3, #0
 80107ac:	d003      	beq.n	80107b6 <wc_RsaFunctionSync+0xe6>
            ERROR_OUT(MP_EXPTMOD_E);
 80107ae:	f06f 036f 	mvn.w	r3, #111	; 0x6f
 80107b2:	931d      	str	r3, [sp, #116]	; 0x74
 80107b4:	e132      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>

        /* tmp = tmp*rnd mod n */
        if (mp_mulmod(&tmp, &rnd, &key->n, &tmp) != MP_OKAY)
 80107b6:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80107b8:	ab16      	add	r3, sp, #88	; 0x58
 80107ba:	a912      	add	r1, sp, #72	; 0x48
 80107bc:	a816      	add	r0, sp, #88	; 0x58
 80107be:	f7f8 fc07 	bl	8008fd0 <mp_mulmod>
 80107c2:	4603      	mov	r3, r0
 80107c4:	2b00      	cmp	r3, #0
 80107c6:	d003      	beq.n	80107d0 <wc_RsaFunctionSync+0x100>
            ERROR_OUT(MP_MULMOD_E);
 80107c8:	f06f 0374 	mvn.w	r3, #116	; 0x74
 80107cc:	931d      	str	r3, [sp, #116]	; 0x74
 80107ce:	e125      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>

        { /* tmpa/b scope */
        mp_int tmpa, tmpb;
        int r;

        if (mp_init(&tmpa) != MP_OKAY)
 80107d0:	ab0a      	add	r3, sp, #40	; 0x28
 80107d2:	4618      	mov	r0, r3
 80107d4:	f7f9 ff14 	bl	800a600 <mp_init>
 80107d8:	4603      	mov	r3, r0
 80107da:	2b00      	cmp	r3, #0
 80107dc:	d003      	beq.n	80107e6 <wc_RsaFunctionSync+0x116>
            ERROR_OUT(MP_INIT_E);
 80107de:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 80107e2:	931d      	str	r3, [sp, #116]	; 0x74
 80107e4:	e119      	b.n	8010a1a <wc_RsaFunctionSync+0x34a>

        if (mp_init(&tmpb) != MP_OKAY) {
 80107e6:	ab06      	add	r3, sp, #24
 80107e8:	4618      	mov	r0, r3
 80107ea:	f7f9 ff09 	bl	800a600 <mp_init>
 80107ee:	4603      	mov	r3, r0
 80107f0:	2b00      	cmp	r3, #0
 80107f2:	d007      	beq.n	8010804 <wc_RsaFunctionSync+0x134>
            mp_clear(&tmpa);
 80107f4:	ab0a      	add	r3, sp, #40	; 0x28
 80107f6:	4618      	mov	r0, r3
 80107f8:	f7f9 ff1a 	bl	800a630 <mp_clear>
            ERROR_OUT(MP_INIT_E);
 80107fc:	f06f 036d 	mvn.w	r3, #109	; 0x6d
 8010800:	931d      	str	r3, [sp, #116]	; 0x74
            ERROR_OUT(MP_INIT_E);
 8010802:	e10a      	b.n	8010a1a <wc_RsaFunctionSync+0x34a>
        }

        /* tmpa = tmp^dP mod p */
        r = mp_exptmod(&tmp, &key->dP, &key->p, &tmpa);
 8010804:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8010806:	f103 0150 	add.w	r1, r3, #80	; 0x50
 801080a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801080c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8010810:	ab0a      	add	r3, sp, #40	; 0x28
 8010812:	a816      	add	r0, sp, #88	; 0x58
 8010814:	f7fa fc7c 	bl	800b110 <mp_exptmod>
 8010818:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_EXPTMOD_E);
 801081a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801081c:	2b00      	cmp	r3, #0
 801081e:	bf0c      	ite	eq
 8010820:	2301      	moveq	r3, #1
 8010822:	2300      	movne	r3, #0
 8010824:	b2db      	uxtb	r3, r3
 8010826:	425a      	negs	r2, r3
 8010828:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801082a:	2b00      	cmp	r3, #0
 801082c:	bf14      	ite	ne
 801082e:	2301      	movne	r3, #1
 8010830:	2300      	moveq	r3, #0
 8010832:	b2db      	uxtb	r3, r3
 8010834:	425b      	negs	r3, r3
 8010836:	f023 036f 	bic.w	r3, r3, #111	; 0x6f
 801083a:	4013      	ands	r3, r2
 801083c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801083e:	4313      	orrs	r3, r2
 8010840:	931d      	str	r3, [sp, #116]	; 0x74

        /* tmpb = tmp^dQ mod q */
        r = mp_exptmod(&tmp, &key->dQ, &key->q, &tmpb);
 8010842:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8010844:	f103 0160 	add.w	r1, r3, #96	; 0x60
 8010848:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801084a:	f103 0240 	add.w	r2, r3, #64	; 0x40
 801084e:	ab06      	add	r3, sp, #24
 8010850:	a816      	add	r0, sp, #88	; 0x58
 8010852:	f7fa fc5d 	bl	800b110 <mp_exptmod>
 8010856:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_EXPTMOD_E);
 8010858:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801085a:	2b00      	cmp	r3, #0
 801085c:	bf0c      	ite	eq
 801085e:	2301      	moveq	r3, #1
 8010860:	2300      	movne	r3, #0
 8010862:	b2db      	uxtb	r3, r3
 8010864:	425a      	negs	r2, r3
 8010866:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010868:	2b00      	cmp	r3, #0
 801086a:	bf14      	ite	ne
 801086c:	2301      	movne	r3, #1
 801086e:	2300      	moveq	r3, #0
 8010870:	b2db      	uxtb	r3, r3
 8010872:	425b      	negs	r3, r3
 8010874:	f023 036f 	bic.w	r3, r3, #111	; 0x6f
 8010878:	4013      	ands	r3, r2
 801087a:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801087c:	4313      	orrs	r3, r2
 801087e:	931d      	str	r3, [sp, #116]	; 0x74

        /* tmp = (tmpa - tmpb) * qInv (mod p) */
        r = mp_sub(&tmpa, &tmpb, &tmp);
 8010880:	aa16      	add	r2, sp, #88	; 0x58
 8010882:	a906      	add	r1, sp, #24
 8010884:	ab0a      	add	r3, sp, #40	; 0x28
 8010886:	4618      	mov	r0, r3
 8010888:	f7f7 fbba 	bl	8008000 <mp_sub>
 801088c:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_SUB_E);
 801088e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010890:	2b00      	cmp	r3, #0
 8010892:	bf0c      	ite	eq
 8010894:	2301      	moveq	r3, #1
 8010896:	2300      	movne	r3, #0
 8010898:	b2db      	uxtb	r3, r3
 801089a:	425a      	negs	r2, r3
 801089c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801089e:	2b00      	cmp	r3, #0
 80108a0:	bf14      	ite	ne
 80108a2:	2301      	movne	r3, #1
 80108a4:	2300      	moveq	r3, #0
 80108a6:	b2db      	uxtb	r3, r3
 80108a8:	425b      	negs	r3, r3
 80108aa:	f023 0371 	bic.w	r3, r3, #113	; 0x71
 80108ae:	4013      	ands	r3, r2
 80108b0:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80108b2:	4313      	orrs	r3, r2
 80108b4:	931d      	str	r3, [sp, #116]	; 0x74

        r = mp_mulmod(&tmp, &key->u, &key->p, &tmp);
 80108b6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80108b8:	f103 0170 	add.w	r1, r3, #112	; 0x70
 80108bc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80108be:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80108c2:	ab16      	add	r3, sp, #88	; 0x58
 80108c4:	a816      	add	r0, sp, #88	; 0x58
 80108c6:	f7f8 fb83 	bl	8008fd0 <mp_mulmod>
 80108ca:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_MULMOD_E);
 80108cc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80108ce:	2b00      	cmp	r3, #0
 80108d0:	bf0c      	ite	eq
 80108d2:	2301      	moveq	r3, #1
 80108d4:	2300      	movne	r3, #0
 80108d6:	b2db      	uxtb	r3, r3
 80108d8:	425a      	negs	r2, r3
 80108da:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80108dc:	2b00      	cmp	r3, #0
 80108de:	bf14      	ite	ne
 80108e0:	2301      	movne	r3, #1
 80108e2:	2300      	moveq	r3, #0
 80108e4:	b2db      	uxtb	r3, r3
 80108e6:	425b      	negs	r3, r3
 80108e8:	f023 0374 	bic.w	r3, r3, #116	; 0x74
 80108ec:	4013      	ands	r3, r2
 80108ee:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80108f0:	4313      	orrs	r3, r2
 80108f2:	931d      	str	r3, [sp, #116]	; 0x74

        /* tmp = tmpb + q * tmp */
        r = mp_mul(&tmp, &key->q, &tmp);
 80108f4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80108f6:	f103 0140 	add.w	r1, r3, #64	; 0x40
 80108fa:	aa16      	add	r2, sp, #88	; 0x58
 80108fc:	ab16      	add	r3, sp, #88	; 0x58
 80108fe:	4618      	mov	r0, r3
 8010900:	f7f8 fbbe 	bl	8009080 <mp_mul>
 8010904:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_MUL_E);
 8010906:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010908:	2b00      	cmp	r3, #0
 801090a:	bf0c      	ite	eq
 801090c:	2301      	moveq	r3, #1
 801090e:	2300      	movne	r3, #0
 8010910:	b2db      	uxtb	r3, r3
 8010912:	425a      	negs	r2, r3
 8010914:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010916:	2b00      	cmp	r3, #0
 8010918:	bf14      	ite	ne
 801091a:	2301      	movne	r3, #1
 801091c:	2300      	moveq	r3, #0
 801091e:	b2db      	uxtb	r3, r3
 8010920:	425b      	negs	r3, r3
 8010922:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8010926:	4013      	ands	r3, r2
 8010928:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801092a:	4313      	orrs	r3, r2
 801092c:	931d      	str	r3, [sp, #116]	; 0x74

        r = mp_add(&tmp, &tmpb, &tmp);
 801092e:	aa16      	add	r2, sp, #88	; 0x58
 8010930:	a906      	add	r1, sp, #24
 8010932:	ab16      	add	r3, sp, #88	; 0x58
 8010934:	4618      	mov	r0, r3
 8010936:	f7f7 f9fb 	bl	8007d30 <mp_add>
 801093a:	901b      	str	r0, [sp, #108]	; 0x6c
        ret = RET_ERR(ret, r, MP_ADD_E);
 801093c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801093e:	2b00      	cmp	r3, #0
 8010940:	bf0c      	ite	eq
 8010942:	2301      	moveq	r3, #1
 8010944:	2300      	movne	r3, #0
 8010946:	b2db      	uxtb	r3, r3
 8010948:	425a      	negs	r2, r3
 801094a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801094c:	2b00      	cmp	r3, #0
 801094e:	bf14      	ite	ne
 8010950:	2301      	movne	r3, #1
 8010952:	2300      	moveq	r3, #0
 8010954:	b2db      	uxtb	r3, r3
 8010956:	425b      	negs	r3, r3
 8010958:	f023 0372 	bic.w	r3, r3, #114	; 0x72
 801095c:	4013      	ands	r3, r2
 801095e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8010960:	4313      	orrs	r3, r2
 8010962:	931d      	str	r3, [sp, #116]	; 0x74

        mp_clear(&tmpa);
 8010964:	ab0a      	add	r3, sp, #40	; 0x28
 8010966:	4618      	mov	r0, r3
 8010968:	f7f9 fe62 	bl	800a630 <mp_clear>
        mp_clear(&tmpb);
 801096c:	ab06      	add	r3, sp, #24
 801096e:	4618      	mov	r0, r3
 8010970:	f7f9 fe5e 	bl	800a630 <mp_clear>

        if (ret != 0) {
 8010974:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010976:	2b00      	cmp	r3, #0
 8010978:	d14f      	bne.n	8010a1a <wc_RsaFunctionSync+0x34a>
        } /* tmpa/b scope */
    #endif   /* RSA_LOW_MEM */

    #ifdef WC_RSA_BLINDING
        /* unblind */
        if (mp_mulmod(&tmp, &rndi, &key->n, &tmp) != MP_OKAY)
 801097a:	9a21      	ldr	r2, [sp, #132]	; 0x84
 801097c:	ab16      	add	r3, sp, #88	; 0x58
 801097e:	a90e      	add	r1, sp, #56	; 0x38
 8010980:	a816      	add	r0, sp, #88	; 0x58
 8010982:	f7f8 fb25 	bl	8008fd0 <mp_mulmod>
 8010986:	4603      	mov	r3, r0
 8010988:	2b00      	cmp	r3, #0
 801098a:	d016      	beq.n	80109ba <wc_RsaFunctionSync+0x2ea>
            ERROR_OUT(MP_MULMOD_E);
 801098c:	f06f 0374 	mvn.w	r3, #116	; 0x74
 8010990:	931d      	str	r3, [sp, #116]	; 0x74
 8010992:	e043      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>
    case RSA_PUBLIC_DECRYPT:
    #ifdef WOLFSSL_XILINX_CRYPT
        ret = wc_RsaFunctionXil(in, inLen, out, outLen, type, key, rng);
        goto done;
    #else
        if (mp_exptmod(&tmp, &key->e, &key->n, &tmp) != MP_OKAY)
 8010994:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8010996:	f103 0110 	add.w	r1, r3, #16
 801099a:	9a21      	ldr	r2, [sp, #132]	; 0x84
 801099c:	ab16      	add	r3, sp, #88	; 0x58
 801099e:	a816      	add	r0, sp, #88	; 0x58
 80109a0:	f7fa fbb6 	bl	800b110 <mp_exptmod>
 80109a4:	4603      	mov	r3, r0
 80109a6:	2b00      	cmp	r3, #0
 80109a8:	d007      	beq.n	80109ba <wc_RsaFunctionSync+0x2ea>
            ERROR_OUT(MP_EXPTMOD_E);
 80109aa:	f06f 036f 	mvn.w	r3, #111	; 0x6f
 80109ae:	931d      	str	r3, [sp, #116]	; 0x74
 80109b0:	e034      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>
        break;
    #endif
    default:
        ERROR_OUT(RSA_WRONG_TYPE_E);
 80109b2:	f06f 0381 	mvn.w	r3, #129	; 0x81
 80109b6:	931d      	str	r3, [sp, #116]	; 0x74
 80109b8:	e030      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>
    }

    keyLen = wc_RsaEncryptSize(key);
 80109ba:	9821      	ldr	r0, [sp, #132]	; 0x84
 80109bc:	f000 f9a8 	bl	8010d10 <wc_RsaEncryptSize>
 80109c0:	4603      	mov	r3, r0
 80109c2:	931a      	str	r3, [sp, #104]	; 0x68
    if (keyLen > *outLen) {
 80109c4:	9b02      	ldr	r3, [sp, #8]
 80109c6:	681a      	ldr	r2, [r3, #0]
 80109c8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80109ca:	429a      	cmp	r2, r3
 80109cc:	d203      	bcs.n	80109d6 <wc_RsaFunctionSync+0x306>
        ERROR_OUT(RSA_BUFFER_E);
 80109ce:	f06f 0382 	mvn.w	r3, #130	; 0x82
 80109d2:	931d      	str	r3, [sp, #116]	; 0x74
 80109d4:	e022      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>
    }

    len = mp_unsigned_bin_size(&tmp);
 80109d6:	ab16      	add	r3, sp, #88	; 0x58
 80109d8:	4618      	mov	r0, r3
 80109da:	f7f9 fea1 	bl	800a720 <mp_unsigned_bin_size>
 80109de:	4603      	mov	r3, r0
 80109e0:	931c      	str	r3, [sp, #112]	; 0x70
 80109e2:	e007      	b.n	80109f4 <wc_RsaFunctionSync+0x324>

    /* pad front w/ zeros to match key length */
    while (len < keyLen) {
        *out++ = 0x00;
 80109e4:	9b03      	ldr	r3, [sp, #12]
 80109e6:	1c5a      	adds	r2, r3, #1
 80109e8:	9203      	str	r2, [sp, #12]
 80109ea:	2200      	movs	r2, #0
 80109ec:	701a      	strb	r2, [r3, #0]
        len++;
 80109ee:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80109f0:	3301      	adds	r3, #1
 80109f2:	931c      	str	r3, [sp, #112]	; 0x70
    while (len < keyLen) {
 80109f4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80109f6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80109f8:	429a      	cmp	r2, r3
 80109fa:	d3f3      	bcc.n	80109e4 <wc_RsaFunctionSync+0x314>
    }

    *outLen = keyLen;
 80109fc:	9b02      	ldr	r3, [sp, #8]
 80109fe:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8010a00:	601a      	str	r2, [r3, #0]

    /* convert */
    if (mp_to_unsigned_bin(&tmp, out) != MP_OKAY)
 8010a02:	ab16      	add	r3, sp, #88	; 0x58
 8010a04:	9903      	ldr	r1, [sp, #12]
 8010a06:	4618      	mov	r0, r3
 8010a08:	f7f9 ff3a 	bl	800a880 <mp_to_unsigned_bin>
 8010a0c:	4603      	mov	r3, r0
 8010a0e:	2b00      	cmp	r3, #0
 8010a10:	d004      	beq.n	8010a1c <wc_RsaFunctionSync+0x34c>
        ERROR_OUT(MP_TO_E);
 8010a12:	f06f 0370 	mvn.w	r3, #112	; 0x70
 8010a16:	931d      	str	r3, [sp, #116]	; 0x74
 8010a18:	e000      	b.n	8010a1c <wc_RsaFunctionSync+0x34c>
            ERROR_OUT(MP_INIT_E);
 8010a1a:	bf00      	nop

done:
    mp_clear(&tmp);
 8010a1c:	ab16      	add	r3, sp, #88	; 0x58
 8010a1e:	4618      	mov	r0, r3
 8010a20:	f7f9 fe06 	bl	800a630 <mp_clear>
#ifdef WC_RSA_BLINDING
    if (type == RSA_PRIVATE_DECRYPT || type == RSA_PRIVATE_ENCRYPT) {
 8010a24:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8010a26:	2b03      	cmp	r3, #3
 8010a28:	d002      	beq.n	8010a30 <wc_RsaFunctionSync+0x360>
 8010a2a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8010a2c:	2b02      	cmp	r3, #2
 8010a2e:	d107      	bne.n	8010a40 <wc_RsaFunctionSync+0x370>
        mp_clear(&rndi);
 8010a30:	ab0e      	add	r3, sp, #56	; 0x38
 8010a32:	4618      	mov	r0, r3
 8010a34:	f7f9 fdfc 	bl	800a630 <mp_clear>
        mp_clear(&rnd);
 8010a38:	ab12      	add	r3, sp, #72	; 0x48
 8010a3a:	4618      	mov	r0, r3
 8010a3c:	f7f9 fdf8 	bl	800a630 <mp_clear>
    }
#endif
    return ret;
 8010a40:	9b1d      	ldr	r3, [sp, #116]	; 0x74
}
 8010a42:	4618      	mov	r0, r3
 8010a44:	b01f      	add	sp, #124	; 0x7c
 8010a46:	f85d fb04 	ldr.w	pc, [sp], #4
 8010a4a:	bf00      	nop
 8010a4c:	0000      	movs	r0, r0
	...

08010a50 <wc_RsaFunction>:
}
#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_RSA */

int wc_RsaFunction(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8010a50:	b500      	push	{lr}
 8010a52:	b08b      	sub	sp, #44	; 0x2c
 8010a54:	9007      	str	r0, [sp, #28]
 8010a56:	9106      	str	r1, [sp, #24]
 8010a58:	9205      	str	r2, [sp, #20]
 8010a5a:	9304      	str	r3, [sp, #16]
    int ret;

    if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 8010a5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010a5e:	2b00      	cmp	r3, #0
 8010a60:	d013      	beq.n	8010a8a <wc_RsaFunction+0x3a>
 8010a62:	9b07      	ldr	r3, [sp, #28]
 8010a64:	2b00      	cmp	r3, #0
 8010a66:	d010      	beq.n	8010a8a <wc_RsaFunction+0x3a>
 8010a68:	9b06      	ldr	r3, [sp, #24]
 8010a6a:	2b00      	cmp	r3, #0
 8010a6c:	d00d      	beq.n	8010a8a <wc_RsaFunction+0x3a>
 8010a6e:	9b05      	ldr	r3, [sp, #20]
 8010a70:	2b00      	cmp	r3, #0
 8010a72:	d00a      	beq.n	8010a8a <wc_RsaFunction+0x3a>
 8010a74:	9b04      	ldr	r3, [sp, #16]
 8010a76:	2b00      	cmp	r3, #0
 8010a78:	d007      	beq.n	8010a8a <wc_RsaFunction+0x3a>
            outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 8010a7a:	9b04      	ldr	r3, [sp, #16]
 8010a7c:	681b      	ldr	r3, [r3, #0]
 8010a7e:	2b00      	cmp	r3, #0
 8010a80:	d003      	beq.n	8010a8a <wc_RsaFunction+0x3a>
 8010a82:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010a84:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8010a88:	d102      	bne.n	8010a90 <wc_RsaFunction+0x40>
        return BAD_FUNC_ARG;
 8010a8a:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010a8e:	e01b      	b.n	8010ac8 <wc_RsaFunction+0x78>
        ret = wc_RsaFunctionAsync(in, inLen, out, outLen, type, key, rng);
    }
    else
#endif
    {
        ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8010a90:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010a92:	9302      	str	r3, [sp, #8]
 8010a94:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010a96:	9301      	str	r3, [sp, #4]
 8010a98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010a9a:	9300      	str	r3, [sp, #0]
 8010a9c:	9b04      	ldr	r3, [sp, #16]
 8010a9e:	9a05      	ldr	r2, [sp, #20]
 8010aa0:	9906      	ldr	r1, [sp, #24]
 8010aa2:	9807      	ldr	r0, [sp, #28]
 8010aa4:	f7ff fe14 	bl	80106d0 <wc_RsaFunctionSync>
 8010aa8:	9009      	str	r0, [sp, #36]	; 0x24
    }

    /* handle error */
    if (ret < 0 && ret != WC_PENDING_E) {
 8010aaa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010aac:	2b00      	cmp	r3, #0
 8010aae:	da0a      	bge.n	8010ac6 <wc_RsaFunction+0x76>
 8010ab0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010ab2:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 8010ab6:	d006      	beq.n	8010ac6 <wc_RsaFunction+0x76>
        if (ret == MP_EXPTMOD_E) {
            /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
            WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
        }

        key->state = RSA_STATE_NONE;
 8010ab8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010aba:	2200      	movs	r2, #0
 8010abc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        wc_RsaCleanup(key);
 8010ac0:	980d      	ldr	r0, [sp, #52]	; 0x34
 8010ac2:	f7ff fa55 	bl	800ff70 <wc_RsaCleanup>
    }

    return ret;
 8010ac6:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8010ac8:	4618      	mov	r0, r3
 8010aca:	b00b      	add	sp, #44	; 0x2c
 8010acc:	f85d fb04 	ldr.w	pc, [sp], #4

08010ad0 <RsaPrivateDecryptEx>:
static int RsaPrivateDecryptEx(byte* in, word32 inLen, byte* out,
                            word32 outLen, byte** outPtr, RsaKey* key,
                            int rsa_type, byte pad_value, int pad_type,
                            enum wc_HashType hash, int mgf,
                            byte* label, word32 labelSz, WC_RNG* rng)
{
 8010ad0:	b530      	push	{r4, r5, lr}
 8010ad2:	b08f      	sub	sp, #60	; 0x3c
 8010ad4:	900b      	str	r0, [sp, #44]	; 0x2c
 8010ad6:	910a      	str	r1, [sp, #40]	; 0x28
 8010ad8:	9209      	str	r2, [sp, #36]	; 0x24
 8010ada:	9308      	str	r3, [sp, #32]
    int ret = RSA_WRONG_TYPE_E;
 8010adc:	f06f 0381 	mvn.w	r3, #129	; 0x81
 8010ae0:	930d      	str	r3, [sp, #52]	; 0x34

    if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 8010ae2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010ae4:	2b00      	cmp	r3, #0
 8010ae6:	d008      	beq.n	8010afa <RsaPrivateDecryptEx+0x2a>
 8010ae8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010aea:	2b00      	cmp	r3, #0
 8010aec:	d005      	beq.n	8010afa <RsaPrivateDecryptEx+0x2a>
 8010aee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010af0:	2b00      	cmp	r3, #0
 8010af2:	d002      	beq.n	8010afa <RsaPrivateDecryptEx+0x2a>
 8010af4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010af6:	2b00      	cmp	r3, #0
 8010af8:	d102      	bne.n	8010b00 <RsaPrivateDecryptEx+0x30>
        return BAD_FUNC_ARG;
 8010afa:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010afe:	e0d1      	b.n	8010ca4 <RsaPrivateDecryptEx+0x1d4>
    }

    switch (key->state) {
 8010b00:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b02:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8010b06:	2b06      	cmp	r3, #6
 8010b08:	f200 80b9 	bhi.w	8010c7e <RsaPrivateDecryptEx+0x1ae>
 8010b0c:	a201      	add	r2, pc, #4	; (adr r2, 8010b14 <RsaPrivateDecryptEx+0x44>)
 8010b0e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010b12:	bf00      	nop
 8010b14:	08010b31 	.word	0x08010b31
 8010b18:	08010c7f 	.word	0x08010c7f
 8010b1c:	08010c7f 	.word	0x08010c7f
 8010b20:	08010c7f 	.word	0x08010c7f
 8010b24:	08010b31 	.word	0x08010b31
 8010b28:	08010be9 	.word	0x08010be9
 8010b2c:	08010c89 	.word	0x08010c89
    case RSA_STATE_NONE:
    case RSA_STATE_DECRYPT_EXPTMOD:
        key->state = RSA_STATE_DECRYPT_EXPTMOD;
 8010b30:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b32:	2204      	movs	r2, #4
 8010b34:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        key->dataLen = inLen;
 8010b38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b3a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010b3c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
            }
        }
    #endif

        /* verify the tmp ptr is NULL, otherwise indicates bad state */
        if (key->data != NULL) {
 8010b40:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b42:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8010b46:	2b00      	cmp	r3, #0
 8010b48:	d003      	beq.n	8010b52 <RsaPrivateDecryptEx+0x82>
            ret = BAD_STATE_E;
 8010b4a:	f06f 03bf 	mvn.w	r3, #191	; 0xbf
 8010b4e:	930d      	str	r3, [sp, #52]	; 0x34
 8010b50:	e09a      	b.n	8010c88 <RsaPrivateDecryptEx+0x1b8>
            break;
        }

        /* if not doing this inline then allocate a buffer for it */
        if (outPtr == NULL) {
 8010b52:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8010b54:	2b00      	cmp	r3, #0
 8010b56:	d121      	bne.n	8010b9c <RsaPrivateDecryptEx+0xcc>
            key->data = (byte*)XMALLOC(inLen, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 8010b58:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b5a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8010b5e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010b60:	4611      	mov	r1, r2
 8010b62:	4618      	mov	r0, r3
 8010b64:	f7f4 fe7c 	bl	8005860 <chibios_alloc>
 8010b68:	4602      	mov	r2, r0
 8010b6a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b6c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            key->dataIsAlloc = 1;
 8010b70:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b72:	2201      	movs	r2, #1
 8010b74:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
            if (key->data == NULL) {
 8010b78:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b7a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8010b7e:	2b00      	cmp	r3, #0
 8010b80:	d103      	bne.n	8010b8a <RsaPrivateDecryptEx+0xba>
                ret = MEMORY_E;
 8010b82:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8010b86:	930d      	str	r3, [sp, #52]	; 0x34
 8010b88:	e07e      	b.n	8010c88 <RsaPrivateDecryptEx+0x1b8>
                break;
            }
            XMEMCPY(key->data, in, inLen);
 8010b8a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b8c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8010b90:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010b92:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8010b94:	4618      	mov	r0, r3
 8010b96:	f7f3 fdc1 	bl	800471c <memcpy>
 8010b9a:	e003      	b.n	8010ba4 <RsaPrivateDecryptEx+0xd4>
        }
        else {
            key->data = out;
 8010b9c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010b9e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010ba0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        }
        ret = wc_RsaFunction(key->data, inLen, key->data, &key->dataLen, rsa_type,
 8010ba4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010ba6:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
 8010baa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bac:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8010bb0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bb2:	f103 0190 	add.w	r1, r3, #144	; 0x90
 8010bb6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010bb8:	9302      	str	r3, [sp, #8]
 8010bba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bbc:	9301      	str	r3, [sp, #4]
 8010bbe:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8010bc0:	9300      	str	r3, [sp, #0]
 8010bc2:	460b      	mov	r3, r1
 8010bc4:	990a      	ldr	r1, [sp, #40]	; 0x28
 8010bc6:	f7ff ff43 	bl	8010a50 <wc_RsaFunction>
 8010bca:	900d      	str	r0, [sp, #52]	; 0x34
                                                                      key, rng);

        if (ret >= 0 || ret == WC_PENDING_E) {
 8010bcc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010bce:	2b00      	cmp	r3, #0
 8010bd0:	da03      	bge.n	8010bda <RsaPrivateDecryptEx+0x10a>
 8010bd2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010bd4:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 8010bd8:	d103      	bne.n	8010be2 <RsaPrivateDecryptEx+0x112>
            key->state = RSA_STATE_DECRYPT_UNPAD;
 8010bda:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bdc:	2205      	movs	r2, #5
 8010bde:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        }
        if (ret < 0) {
 8010be2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010be4:	2b00      	cmp	r3, #0
 8010be6:	db4f      	blt.n	8010c88 <RsaPrivateDecryptEx+0x1b8>

        FALL_THROUGH;

    case RSA_STATE_DECRYPT_UNPAD:
    {
        byte* pad = NULL;
 8010be8:	2300      	movs	r3, #0
 8010bea:	930c      	str	r3, [sp, #48]	; 0x30
        ret = wc_RsaUnPad_ex(key->data, key->dataLen, &pad, pad_value, pad_type,
 8010bec:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bee:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8010bf2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bf4:	f8d3 5090 	ldr.w	r5, [r3, #144]	; 0x90
 8010bf8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010bfa:	4618      	mov	r0, r3
 8010bfc:	f7f9 fdb0 	bl	800a760 <mp_count_bits>
 8010c00:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010c02:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8010c06:	f89d 1054 	ldrb.w	r1, [sp, #84]	; 0x54
 8010c0a:	aa0c      	add	r2, sp, #48	; 0x30
 8010c0c:	9306      	str	r3, [sp, #24]
 8010c0e:	9005      	str	r0, [sp, #20]
 8010c10:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8010c12:	9304      	str	r3, [sp, #16]
 8010c14:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8010c16:	9303      	str	r3, [sp, #12]
 8010c18:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8010c1a:	9302      	str	r3, [sp, #8]
 8010c1c:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 8010c20:	9301      	str	r3, [sp, #4]
 8010c22:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8010c24:	9300      	str	r3, [sp, #0]
 8010c26:	460b      	mov	r3, r1
 8010c28:	4629      	mov	r1, r5
 8010c2a:	4620      	mov	r0, r4
 8010c2c:	f7ff fd20 	bl	8010670 <wc_RsaUnPad_ex>
 8010c30:	900d      	str	r0, [sp, #52]	; 0x34
                             hash, mgf, label, labelSz, mp_count_bits(&key->n),
                             key->heap);
        if (ret > 0 && ret <= (int)outLen && pad != NULL) {
 8010c32:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010c34:	2b00      	cmp	r3, #0
 8010c36:	dd14      	ble.n	8010c62 <RsaPrivateDecryptEx+0x192>
 8010c38:	9b08      	ldr	r3, [sp, #32]
 8010c3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010c3c:	429a      	cmp	r2, r3
 8010c3e:	dc10      	bgt.n	8010c62 <RsaPrivateDecryptEx+0x192>
 8010c40:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010c42:	2b00      	cmp	r3, #0
 8010c44:	d00d      	beq.n	8010c62 <RsaPrivateDecryptEx+0x192>
            /* only copy output if not inline */
            if (outPtr == NULL) {
 8010c46:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8010c48:	2b00      	cmp	r3, #0
 8010c4a:	d106      	bne.n	8010c5a <RsaPrivateDecryptEx+0x18a>
                XMEMCPY(out, pad, ret);
 8010c4c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010c4e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010c50:	4619      	mov	r1, r3
 8010c52:	9809      	ldr	r0, [sp, #36]	; 0x24
 8010c54:	f7f3 fd62 	bl	800471c <memcpy>
            }
            else {
                *outPtr = pad;
 8010c58:	e009      	b.n	8010c6e <RsaPrivateDecryptEx+0x19e>
 8010c5a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010c5c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8010c5e:	601a      	str	r2, [r3, #0]
 8010c60:	e005      	b.n	8010c6e <RsaPrivateDecryptEx+0x19e>
            }
        }
        else if (ret >= 0) {
 8010c62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010c64:	2b00      	cmp	r3, #0
 8010c66:	db02      	blt.n	8010c6e <RsaPrivateDecryptEx+0x19e>
            ret = RSA_BUFFER_E;
 8010c68:	f06f 0382 	mvn.w	r3, #130	; 0x82
 8010c6c:	930d      	str	r3, [sp, #52]	; 0x34
        }
        if (ret < 0) {
 8010c6e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010c70:	2b00      	cmp	r3, #0
 8010c72:	db08      	blt.n	8010c86 <RsaPrivateDecryptEx+0x1b6>
            break;
        }

        key->state = RSA_STATE_DECRYPT_RES;
 8010c74:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010c76:	2206      	movs	r2, #6
 8010c78:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8010c7c:	e004      	b.n	8010c88 <RsaPrivateDecryptEx+0x1b8>
        }
    #endif
        break;

    default:
        ret = BAD_STATE_E;
 8010c7e:	f06f 03bf 	mvn.w	r3, #191	; 0xbf
 8010c82:	930d      	str	r3, [sp, #52]	; 0x34
 8010c84:	e000      	b.n	8010c88 <RsaPrivateDecryptEx+0x1b8>
            break;
 8010c86:	bf00      	nop
        break;
    }

    /* if async pending then return and skip done cleanup below */
    if (ret == WC_PENDING_E) {
 8010c88:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010c8a:	f113 0f6c 	cmn.w	r3, #108	; 0x6c
 8010c8e:	d101      	bne.n	8010c94 <RsaPrivateDecryptEx+0x1c4>
        return ret;
 8010c90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010c92:	e007      	b.n	8010ca4 <RsaPrivateDecryptEx+0x1d4>
    }

    key->state = RSA_STATE_NONE;
 8010c94:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010c96:	2200      	movs	r2, #0
 8010c98:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    wc_RsaCleanup(key);
 8010c9c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8010c9e:	f7ff f967 	bl	800ff70 <wc_RsaCleanup>

    return ret;
 8010ca2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
 8010ca4:	4618      	mov	r0, r3
 8010ca6:	b00f      	add	sp, #60	; 0x3c
 8010ca8:	bd30      	pop	{r4, r5, pc}
 8010caa:	bf00      	nop
 8010cac:	0000      	movs	r0, r0
	...

08010cb0 <wc_RsaSSL_VerifyInline>:
}
#endif /* WC_NO_RSA_OAEP */


int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
{
 8010cb0:	b500      	push	{lr}
 8010cb2:	b091      	sub	sp, #68	; 0x44
 8010cb4:	900d      	str	r0, [sp, #52]	; 0x34
 8010cb6:	910c      	str	r1, [sp, #48]	; 0x30
 8010cb8:	920b      	str	r2, [sp, #44]	; 0x2c
 8010cba:	930a      	str	r3, [sp, #40]	; 0x28
    WC_RNG* rng = NULL;
 8010cbc:	2300      	movs	r3, #0
 8010cbe:	930f      	str	r3, [sp, #60]	; 0x3c
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8010cc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010cc2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8010cc6:	930f      	str	r3, [sp, #60]	; 0x3c
#endif
    return RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8010cc8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8010cca:	9309      	str	r3, [sp, #36]	; 0x24
 8010ccc:	2300      	movs	r3, #0
 8010cce:	9308      	str	r3, [sp, #32]
 8010cd0:	2300      	movs	r3, #0
 8010cd2:	9307      	str	r3, [sp, #28]
 8010cd4:	2300      	movs	r3, #0
 8010cd6:	9306      	str	r3, [sp, #24]
 8010cd8:	2300      	movs	r3, #0
 8010cda:	9305      	str	r3, [sp, #20]
 8010cdc:	2300      	movs	r3, #0
 8010cde:	9304      	str	r3, [sp, #16]
 8010ce0:	2301      	movs	r3, #1
 8010ce2:	9303      	str	r3, [sp, #12]
 8010ce4:	2301      	movs	r3, #1
 8010ce6:	9302      	str	r3, [sp, #8]
 8010ce8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010cea:	9301      	str	r3, [sp, #4]
 8010cec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010cee:	9300      	str	r3, [sp, #0]
 8010cf0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010cf2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010cf4:	990c      	ldr	r1, [sp, #48]	; 0x30
 8010cf6:	980d      	ldr	r0, [sp, #52]	; 0x34
 8010cf8:	f7ff feea 	bl	8010ad0 <RsaPrivateDecryptEx>
 8010cfc:	4603      	mov	r3, r0
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, rng);
}
 8010cfe:	4618      	mov	r0, r3
 8010d00:	b011      	add	sp, #68	; 0x44
 8010d02:	f85d fb04 	ldr.w	pc, [sp], #4
 8010d06:	bf00      	nop
	...

08010d10 <wc_RsaEncryptSize>:
        hash, mgf, NULL, 0, rng);
}
#endif

int wc_RsaEncryptSize(RsaKey* key)
{
 8010d10:	b500      	push	{lr}
 8010d12:	b083      	sub	sp, #12
 8010d14:	9001      	str	r0, [sp, #4]
    if (key == NULL) {
 8010d16:	9b01      	ldr	r3, [sp, #4]
 8010d18:	2b00      	cmp	r3, #0
 8010d1a:	d102      	bne.n	8010d22 <wc_RsaEncryptSize+0x12>
        return BAD_FUNC_ARG;
 8010d1c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d20:	e004      	b.n	8010d2c <wc_RsaEncryptSize+0x1c>
    }
    return mp_unsigned_bin_size(&key->n);
 8010d22:	9b01      	ldr	r3, [sp, #4]
 8010d24:	4618      	mov	r0, r3
 8010d26:	f7f9 fcfb 	bl	800a720 <mp_unsigned_bin_size>
 8010d2a:	4603      	mov	r3, r0
}
 8010d2c:	4618      	mov	r0, r3
 8010d2e:	b003      	add	sp, #12
 8010d30:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08010d40 <wc_MakeRsaKey>:
}

#ifdef WOLFSSL_KEY_GEN
/* Make an RSA key for size bits, with e specified, 65537 is a good e */
int wc_MakeRsaKey(RsaKey* key, int size, long e, WC_RNG* rng)
{
 8010d40:	b530      	push	{r4, r5, lr}
 8010d42:	b09d      	sub	sp, #116	; 0x74
 8010d44:	9005      	str	r0, [sp, #20]
 8010d46:	9104      	str	r1, [sp, #16]
 8010d48:	9203      	str	r2, [sp, #12]
 8010d4a:	9302      	str	r3, [sp, #8]
    mp_int p, q, tmp1, tmp2, tmp3;
    int    err;

    if (key == NULL || rng == NULL)
 8010d4c:	9b05      	ldr	r3, [sp, #20]
 8010d4e:	2b00      	cmp	r3, #0
 8010d50:	d002      	beq.n	8010d58 <wc_MakeRsaKey+0x18>
 8010d52:	9b02      	ldr	r3, [sp, #8]
 8010d54:	2b00      	cmp	r3, #0
 8010d56:	d102      	bne.n	8010d5e <wc_MakeRsaKey+0x1e>
        return BAD_FUNC_ARG;
 8010d58:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d5c:	e167      	b.n	801102e <wc_MakeRsaKey+0x2ee>

    if (size < RSA_MIN_SIZE || size > RSA_MAX_SIZE)
 8010d5e:	9b04      	ldr	r3, [sp, #16]
 8010d60:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8010d64:	db03      	blt.n	8010d6e <wc_MakeRsaKey+0x2e>
 8010d66:	9b04      	ldr	r3, [sp, #16]
 8010d68:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8010d6c:	dd02      	ble.n	8010d74 <wc_MakeRsaKey+0x34>
        return BAD_FUNC_ARG;
 8010d6e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d72:	e15c      	b.n	801102e <wc_MakeRsaKey+0x2ee>

    if (e < 3 || (e & 1) == 0)
 8010d74:	9b03      	ldr	r3, [sp, #12]
 8010d76:	2b02      	cmp	r3, #2
 8010d78:	dd04      	ble.n	8010d84 <wc_MakeRsaKey+0x44>
 8010d7a:	9b03      	ldr	r3, [sp, #12]
 8010d7c:	f003 0301 	and.w	r3, r3, #1
 8010d80:	2b00      	cmp	r3, #0
 8010d82:	d102      	bne.n	8010d8a <wc_MakeRsaKey+0x4a>
        return BAD_FUNC_ARG;
 8010d84:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8010d88:	e151      	b.n	801102e <wc_MakeRsaKey+0x2ee>
        }
    #endif
    }
#endif

    if ((err = mp_init_multi(&p, &q, &tmp1, &tmp2, &tmp3, NULL)) != MP_OKAY)
 8010d8a:	ac0b      	add	r4, sp, #44	; 0x2c
 8010d8c:	aa0f      	add	r2, sp, #60	; 0x3c
 8010d8e:	a913      	add	r1, sp, #76	; 0x4c
 8010d90:	a817      	add	r0, sp, #92	; 0x5c
 8010d92:	2300      	movs	r3, #0
 8010d94:	9301      	str	r3, [sp, #4]
 8010d96:	ab07      	add	r3, sp, #28
 8010d98:	9300      	str	r3, [sp, #0]
 8010d9a:	4623      	mov	r3, r4
 8010d9c:	f7fb fe78 	bl	800ca90 <mp_init_multi>
 8010da0:	901b      	str	r0, [sp, #108]	; 0x6c
 8010da2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010da4:	2b00      	cmp	r3, #0
 8010da6:	d001      	beq.n	8010dac <wc_MakeRsaKey+0x6c>
        return err;
 8010da8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010daa:	e140      	b.n	801102e <wc_MakeRsaKey+0x2ee>

    err = mp_set_int(&tmp3, e);
 8010dac:	9a03      	ldr	r2, [sp, #12]
 8010dae:	ab07      	add	r3, sp, #28
 8010db0:	4611      	mov	r1, r2
 8010db2:	4618      	mov	r0, r3
 8010db4:	f7f5 fc8c 	bl	80066d0 <mp_set_int>
 8010db8:	901b      	str	r0, [sp, #108]	; 0x6c
    /* make p */
    if (err == MP_OKAY) {
 8010dba:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010dbc:	2b00      	cmp	r3, #0
 8010dbe:	d12c      	bne.n	8010e1a <wc_MakeRsaKey+0xda>
        do {
            err = mp_rand_prime(&p, size/16, rng, key->heap); /* size in bytes/2 */
 8010dc0:	9b04      	ldr	r3, [sp, #16]
 8010dc2:	2b00      	cmp	r3, #0
 8010dc4:	da00      	bge.n	8010dc8 <wc_MakeRsaKey+0x88>
 8010dc6:	330f      	adds	r3, #15
 8010dc8:	111b      	asrs	r3, r3, #4
 8010dca:	4619      	mov	r1, r3
 8010dcc:	9b05      	ldr	r3, [sp, #20]
 8010dce:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8010dd2:	a817      	add	r0, sp, #92	; 0x5c
 8010dd4:	9a02      	ldr	r2, [sp, #8]
 8010dd6:	f7f6 f8ab 	bl	8006f30 <mp_rand_prime>
 8010dda:	901b      	str	r0, [sp, #108]	; 0x6c

            if (err == MP_OKAY)
 8010ddc:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010dde:	2b00      	cmp	r3, #0
 8010de0:	d106      	bne.n	8010df0 <wc_MakeRsaKey+0xb0>
                err = mp_sub_d(&p, 1, &tmp1);  /* tmp1 = p-1 */
 8010de2:	aa0f      	add	r2, sp, #60	; 0x3c
 8010de4:	ab17      	add	r3, sp, #92	; 0x5c
 8010de6:	2101      	movs	r1, #1
 8010de8:	4618      	mov	r0, r3
 8010dea:	f7f5 fda1 	bl	8006930 <mp_sub_d>
 8010dee:	901b      	str	r0, [sp, #108]	; 0x6c

            if (err == MP_OKAY)
 8010df0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010df2:	2b00      	cmp	r3, #0
 8010df4:	d106      	bne.n	8010e04 <wc_MakeRsaKey+0xc4>
                err = mp_gcd(&tmp1, &tmp3, &tmp2);  /* tmp2 = gcd(p-1, e) */
 8010df6:	aa0b      	add	r2, sp, #44	; 0x2c
 8010df8:	a907      	add	r1, sp, #28
 8010dfa:	ab0f      	add	r3, sp, #60	; 0x3c
 8010dfc:	4618      	mov	r0, r3
 8010dfe:	f7f6 f9ff 	bl	8007200 <mp_gcd>
 8010e02:	901b      	str	r0, [sp, #108]	; 0x6c
        } while (err == MP_OKAY && mp_cmp_d(&tmp2, 1) != 0);  /* e divides p-1 */
 8010e04:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e06:	2b00      	cmp	r3, #0
 8010e08:	d107      	bne.n	8010e1a <wc_MakeRsaKey+0xda>
 8010e0a:	ab0b      	add	r3, sp, #44	; 0x2c
 8010e0c:	2101      	movs	r1, #1
 8010e0e:	4618      	mov	r0, r3
 8010e10:	f7fa fe86 	bl	800bb20 <mp_cmp_d>
 8010e14:	4603      	mov	r3, r0
 8010e16:	2b00      	cmp	r3, #0
 8010e18:	d1d2      	bne.n	8010dc0 <wc_MakeRsaKey+0x80>
    }

    /* make q */
    if (err == MP_OKAY) {
 8010e1a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e1c:	2b00      	cmp	r3, #0
 8010e1e:	d12c      	bne.n	8010e7a <wc_MakeRsaKey+0x13a>
        do {
            err = mp_rand_prime(&q, size/16, rng, key->heap); /* size in bytes/2 */
 8010e20:	9b04      	ldr	r3, [sp, #16]
 8010e22:	2b00      	cmp	r3, #0
 8010e24:	da00      	bge.n	8010e28 <wc_MakeRsaKey+0xe8>
 8010e26:	330f      	adds	r3, #15
 8010e28:	111b      	asrs	r3, r3, #4
 8010e2a:	4619      	mov	r1, r3
 8010e2c:	9b05      	ldr	r3, [sp, #20]
 8010e2e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8010e32:	a813      	add	r0, sp, #76	; 0x4c
 8010e34:	9a02      	ldr	r2, [sp, #8]
 8010e36:	f7f6 f87b 	bl	8006f30 <mp_rand_prime>
 8010e3a:	901b      	str	r0, [sp, #108]	; 0x6c

            if (err == MP_OKAY)
 8010e3c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e3e:	2b00      	cmp	r3, #0
 8010e40:	d106      	bne.n	8010e50 <wc_MakeRsaKey+0x110>
                err = mp_sub_d(&q, 1, &tmp1);  /* tmp1 = q-1 */
 8010e42:	aa0f      	add	r2, sp, #60	; 0x3c
 8010e44:	ab13      	add	r3, sp, #76	; 0x4c
 8010e46:	2101      	movs	r1, #1
 8010e48:	4618      	mov	r0, r3
 8010e4a:	f7f5 fd71 	bl	8006930 <mp_sub_d>
 8010e4e:	901b      	str	r0, [sp, #108]	; 0x6c

            if (err == MP_OKAY)
 8010e50:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e52:	2b00      	cmp	r3, #0
 8010e54:	d106      	bne.n	8010e64 <wc_MakeRsaKey+0x124>
                err = mp_gcd(&tmp1, &tmp3, &tmp2);  /* tmp2 = gcd(q-1, e) */
 8010e56:	aa0b      	add	r2, sp, #44	; 0x2c
 8010e58:	a907      	add	r1, sp, #28
 8010e5a:	ab0f      	add	r3, sp, #60	; 0x3c
 8010e5c:	4618      	mov	r0, r3
 8010e5e:	f7f6 f9cf 	bl	8007200 <mp_gcd>
 8010e62:	901b      	str	r0, [sp, #108]	; 0x6c
        } while (err == MP_OKAY && mp_cmp_d(&tmp2, 1) != 0);  /* e divides q-1 */
 8010e64:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e66:	2b00      	cmp	r3, #0
 8010e68:	d107      	bne.n	8010e7a <wc_MakeRsaKey+0x13a>
 8010e6a:	ab0b      	add	r3, sp, #44	; 0x2c
 8010e6c:	2101      	movs	r1, #1
 8010e6e:	4618      	mov	r0, r3
 8010e70:	f7fa fe56 	bl	800bb20 <mp_cmp_d>
 8010e74:	4603      	mov	r3, r0
 8010e76:	2b00      	cmp	r3, #0
 8010e78:	d1d2      	bne.n	8010e20 <wc_MakeRsaKey+0xe0>
    }

    if (err == MP_OKAY)
 8010e7a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e7c:	2b00      	cmp	r3, #0
 8010e7e:	d113      	bne.n	8010ea8 <wc_MakeRsaKey+0x168>
        err = mp_init_multi(&key->n, &key->e, &key->d, &key->p, &key->q, NULL);
 8010e80:	9805      	ldr	r0, [sp, #20]
 8010e82:	9b05      	ldr	r3, [sp, #20]
 8010e84:	f103 0110 	add.w	r1, r3, #16
 8010e88:	9b05      	ldr	r3, [sp, #20]
 8010e8a:	f103 0420 	add.w	r4, r3, #32
 8010e8e:	9b05      	ldr	r3, [sp, #20]
 8010e90:	f103 0530 	add.w	r5, r3, #48	; 0x30
 8010e94:	9b05      	ldr	r3, [sp, #20]
 8010e96:	3340      	adds	r3, #64	; 0x40
 8010e98:	2200      	movs	r2, #0
 8010e9a:	9201      	str	r2, [sp, #4]
 8010e9c:	9300      	str	r3, [sp, #0]
 8010e9e:	462b      	mov	r3, r5
 8010ea0:	4622      	mov	r2, r4
 8010ea2:	f7fb fdf5 	bl	800ca90 <mp_init_multi>
 8010ea6:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010ea8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010eaa:	2b00      	cmp	r3, #0
 8010eac:	d110      	bne.n	8010ed0 <wc_MakeRsaKey+0x190>
        err = mp_init_multi(&key->dP, &key->dQ, &key->u, NULL, NULL, NULL);
 8010eae:	9b05      	ldr	r3, [sp, #20]
 8010eb0:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8010eb4:	9b05      	ldr	r3, [sp, #20]
 8010eb6:	f103 0160 	add.w	r1, r3, #96	; 0x60
 8010eba:	9b05      	ldr	r3, [sp, #20]
 8010ebc:	f103 0270 	add.w	r2, r3, #112	; 0x70
 8010ec0:	2300      	movs	r3, #0
 8010ec2:	9301      	str	r3, [sp, #4]
 8010ec4:	2300      	movs	r3, #0
 8010ec6:	9300      	str	r3, [sp, #0]
 8010ec8:	2300      	movs	r3, #0
 8010eca:	f7fb fde1 	bl	800ca90 <mp_init_multi>
 8010ece:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010ed0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010ed2:	2b00      	cmp	r3, #0
 8010ed4:	d106      	bne.n	8010ee4 <wc_MakeRsaKey+0x1a4>
        err = mp_sub_d(&p, 1, &tmp2);  /* tmp2 = p-1 */
 8010ed6:	aa0b      	add	r2, sp, #44	; 0x2c
 8010ed8:	ab17      	add	r3, sp, #92	; 0x5c
 8010eda:	2101      	movs	r1, #1
 8010edc:	4618      	mov	r0, r3
 8010ede:	f7f5 fd27 	bl	8006930 <mp_sub_d>
 8010ee2:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010ee4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010ee6:	2b00      	cmp	r3, #0
 8010ee8:	d106      	bne.n	8010ef8 <wc_MakeRsaKey+0x1b8>
        err = mp_lcm(&tmp1, &tmp2, &tmp1);  /* tmp1 = lcm(p-1, q-1),last loop */
 8010eea:	aa0f      	add	r2, sp, #60	; 0x3c
 8010eec:	a90b      	add	r1, sp, #44	; 0x2c
 8010eee:	ab0f      	add	r3, sp, #60	; 0x3c
 8010ef0:	4618      	mov	r0, r3
 8010ef2:	f7f6 f925 	bl	8007140 <mp_lcm>
 8010ef6:	901b      	str	r0, [sp, #108]	; 0x6c

    /* make key */
    if (err == MP_OKAY)
 8010ef8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010efa:	2b00      	cmp	r3, #0
 8010efc:	d107      	bne.n	8010f0e <wc_MakeRsaKey+0x1ce>
        err = mp_set_int(&key->e, (mp_digit)e);  /* key->e = e */
 8010efe:	9b05      	ldr	r3, [sp, #20]
 8010f00:	3310      	adds	r3, #16
 8010f02:	9a03      	ldr	r2, [sp, #12]
 8010f04:	4611      	mov	r1, r2
 8010f06:	4618      	mov	r0, r3
 8010f08:	f7f5 fbe2 	bl	80066d0 <mp_set_int>
 8010f0c:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)                /* key->d = 1/e mod lcm(p-1, q-1) */
 8010f0e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f10:	2b00      	cmp	r3, #0
 8010f12:	d10a      	bne.n	8010f2a <wc_MakeRsaKey+0x1ea>
        err = mp_invmod(&key->e, &tmp1, &key->d);
 8010f14:	9b05      	ldr	r3, [sp, #20]
 8010f16:	f103 0010 	add.w	r0, r3, #16
 8010f1a:	9b05      	ldr	r3, [sp, #20]
 8010f1c:	f103 0220 	add.w	r2, r3, #32
 8010f20:	ab0f      	add	r3, sp, #60	; 0x3c
 8010f22:	4619      	mov	r1, r3
 8010f24:	f7fa f9bc 	bl	800b2a0 <mp_invmod>
 8010f28:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f2a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f2c:	2b00      	cmp	r3, #0
 8010f2e:	d106      	bne.n	8010f3e <wc_MakeRsaKey+0x1fe>
        err = mp_mul(&p, &q, &key->n);  /* key->n = pq */
 8010f30:	9a05      	ldr	r2, [sp, #20]
 8010f32:	a913      	add	r1, sp, #76	; 0x4c
 8010f34:	ab17      	add	r3, sp, #92	; 0x5c
 8010f36:	4618      	mov	r0, r3
 8010f38:	f7f8 f8a2 	bl	8009080 <mp_mul>
 8010f3c:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f3e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f40:	2b00      	cmp	r3, #0
 8010f42:	d106      	bne.n	8010f52 <wc_MakeRsaKey+0x212>
        err = mp_sub_d(&p, 1, &tmp1);
 8010f44:	aa0f      	add	r2, sp, #60	; 0x3c
 8010f46:	ab17      	add	r3, sp, #92	; 0x5c
 8010f48:	2101      	movs	r1, #1
 8010f4a:	4618      	mov	r0, r3
 8010f4c:	f7f5 fcf0 	bl	8006930 <mp_sub_d>
 8010f50:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f52:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f54:	2b00      	cmp	r3, #0
 8010f56:	d106      	bne.n	8010f66 <wc_MakeRsaKey+0x226>
        err = mp_sub_d(&q, 1, &tmp2);
 8010f58:	aa0b      	add	r2, sp, #44	; 0x2c
 8010f5a:	ab13      	add	r3, sp, #76	; 0x4c
 8010f5c:	2101      	movs	r1, #1
 8010f5e:	4618      	mov	r0, r3
 8010f60:	f7f5 fce6 	bl	8006930 <mp_sub_d>
 8010f64:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f66:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f68:	2b00      	cmp	r3, #0
 8010f6a:	d10a      	bne.n	8010f82 <wc_MakeRsaKey+0x242>
        err = mp_mod(&key->d, &tmp1, &key->dP);
 8010f6c:	9b05      	ldr	r3, [sp, #20]
 8010f6e:	f103 0020 	add.w	r0, r3, #32
 8010f72:	9b05      	ldr	r3, [sp, #20]
 8010f74:	f103 0250 	add.w	r2, r3, #80	; 0x50
 8010f78:	ab0f      	add	r3, sp, #60	; 0x3c
 8010f7a:	4619      	mov	r1, r3
 8010f7c:	f7fa fe30 	bl	800bbe0 <mp_mod>
 8010f80:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f82:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010f84:	2b00      	cmp	r3, #0
 8010f86:	d10a      	bne.n	8010f9e <wc_MakeRsaKey+0x25e>
        err = mp_mod(&key->d, &tmp2, &key->dQ);
 8010f88:	9b05      	ldr	r3, [sp, #20]
 8010f8a:	f103 0020 	add.w	r0, r3, #32
 8010f8e:	9b05      	ldr	r3, [sp, #20]
 8010f90:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8010f94:	ab0b      	add	r3, sp, #44	; 0x2c
 8010f96:	4619      	mov	r1, r3
 8010f98:	f7fa fe22 	bl	800bbe0 <mp_mod>
 8010f9c:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010f9e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010fa0:	2b00      	cmp	r3, #0
 8010fa2:	d108      	bne.n	8010fb6 <wc_MakeRsaKey+0x276>
        err = mp_invmod(&q, &p, &key->u);
 8010fa4:	9b05      	ldr	r3, [sp, #20]
 8010fa6:	f103 0270 	add.w	r2, r3, #112	; 0x70
 8010faa:	a917      	add	r1, sp, #92	; 0x5c
 8010fac:	ab13      	add	r3, sp, #76	; 0x4c
 8010fae:	4618      	mov	r0, r3
 8010fb0:	f7fa f976 	bl	800b2a0 <mp_invmod>
 8010fb4:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010fb6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010fb8:	2b00      	cmp	r3, #0
 8010fba:	d108      	bne.n	8010fce <wc_MakeRsaKey+0x28e>
        err = mp_copy(&p, &key->p);
 8010fbc:	9b05      	ldr	r3, [sp, #20]
 8010fbe:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8010fc2:	ab17      	add	r3, sp, #92	; 0x5c
 8010fc4:	4611      	mov	r1, r2
 8010fc6:	4618      	mov	r0, r3
 8010fc8:	f7f9 fcaa 	bl	800a920 <mp_copy>
 8010fcc:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010fce:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010fd0:	2b00      	cmp	r3, #0
 8010fd2:	d108      	bne.n	8010fe6 <wc_MakeRsaKey+0x2a6>
        err = mp_copy(&q, &key->q);
 8010fd4:	9b05      	ldr	r3, [sp, #20]
 8010fd6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8010fda:	ab13      	add	r3, sp, #76	; 0x4c
 8010fdc:	4611      	mov	r1, r2
 8010fde:	4618      	mov	r0, r3
 8010fe0:	f7f9 fc9e 	bl	800a920 <mp_copy>
 8010fe4:	901b      	str	r0, [sp, #108]	; 0x6c

    if (err == MP_OKAY)
 8010fe6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010fe8:	2b00      	cmp	r3, #0
 8010fea:	d103      	bne.n	8010ff4 <wc_MakeRsaKey+0x2b4>
        key->type = RSA_PRIVATE;
 8010fec:	9b05      	ldr	r3, [sp, #20]
 8010fee:	2201      	movs	r2, #1
 8010ff0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    mp_clear(&tmp3);
 8010ff4:	ab07      	add	r3, sp, #28
 8010ff6:	4618      	mov	r0, r3
 8010ff8:	f7f9 fb1a 	bl	800a630 <mp_clear>
    mp_clear(&tmp2);
 8010ffc:	ab0b      	add	r3, sp, #44	; 0x2c
 8010ffe:	4618      	mov	r0, r3
 8011000:	f7f9 fb16 	bl	800a630 <mp_clear>
    mp_clear(&tmp1);
 8011004:	ab0f      	add	r3, sp, #60	; 0x3c
 8011006:	4618      	mov	r0, r3
 8011008:	f7f9 fb12 	bl	800a630 <mp_clear>
    mp_clear(&q);
 801100c:	ab13      	add	r3, sp, #76	; 0x4c
 801100e:	4618      	mov	r0, r3
 8011010:	f7f9 fb0e 	bl	800a630 <mp_clear>
    mp_clear(&p);
 8011014:	ab17      	add	r3, sp, #92	; 0x5c
 8011016:	4618      	mov	r0, r3
 8011018:	f7f9 fb0a 	bl	800a630 <mp_clear>


    if (err != MP_OKAY) {
 801101c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801101e:	2b00      	cmp	r3, #0
 8011020:	d004      	beq.n	801102c <wc_MakeRsaKey+0x2ec>
        wc_FreeRsaKey(key);
 8011022:	9805      	ldr	r0, [sp, #20]
 8011024:	f7ff f85c 	bl	80100e0 <wc_FreeRsaKey>
        return err;
 8011028:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801102a:	e000      	b.n	801102e <wc_MakeRsaKey+0x2ee>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 801102c:	2300      	movs	r3, #0
}
 801102e:	4618      	mov	r0, r3
 8011030:	b01d      	add	sp, #116	; 0x74
 8011032:	bd30      	pop	{r4, r5, pc}
	...

08011040 <rotlFixed>:
    {
 8011040:	b082      	sub	sp, #8
 8011042:	9001      	str	r0, [sp, #4]
 8011044:	9100      	str	r1, [sp, #0]
        return (x << y) | (x >> (sizeof(y) * 8 - y));
 8011046:	9a01      	ldr	r2, [sp, #4]
 8011048:	9b00      	ldr	r3, [sp, #0]
 801104a:	f1c3 0320 	rsb	r3, r3, #32
 801104e:	fa62 f303 	ror.w	r3, r2, r3
    }
 8011052:	4618      	mov	r0, r3
 8011054:	b002      	add	sp, #8
 8011056:	4770      	bx	lr
	...

08011060 <ByteReverseWord32.lto_priv.478>:
{
 8011060:	b500      	push	{lr}
 8011062:	b083      	sub	sp, #12
 8011064:	9001      	str	r0, [sp, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 8011066:	9b01      	ldr	r3, [sp, #4]
 8011068:	0a1b      	lsrs	r3, r3, #8
 801106a:	f003 12ff 	and.w	r2, r3, #16711935	; 0xff00ff
 801106e:	9b01      	ldr	r3, [sp, #4]
 8011070:	021b      	lsls	r3, r3, #8
 8011072:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 8011076:	4313      	orrs	r3, r2
 8011078:	9301      	str	r3, [sp, #4]
    return rotlFixed(value, 16U);
 801107a:	2110      	movs	r1, #16
 801107c:	9801      	ldr	r0, [sp, #4]
 801107e:	f7ff ffdf 	bl	8011040 <rotlFixed>
 8011082:	4603      	mov	r3, r0
}
 8011084:	4618      	mov	r0, r3
 8011086:	b003      	add	sp, #12
 8011088:	f85d fb04 	ldr.w	pc, [sp], #4
 801108c:	0000      	movs	r0, r0
	...

08011090 <ForceZero.lto_priv.475>:
{
 8011090:	b084      	sub	sp, #16
 8011092:	9001      	str	r0, [sp, #4]
 8011094:	9100      	str	r1, [sp, #0]
    volatile byte* z = (volatile byte*)mem;
 8011096:	9b01      	ldr	r3, [sp, #4]
 8011098:	9303      	str	r3, [sp, #12]
 801109a:	e004      	b.n	80110a6 <ForceZero.lto_priv.475+0x16>
    while (len--) *z++ = 0;
 801109c:	9b03      	ldr	r3, [sp, #12]
 801109e:	1c5a      	adds	r2, r3, #1
 80110a0:	9203      	str	r2, [sp, #12]
 80110a2:	2200      	movs	r2, #0
 80110a4:	701a      	strb	r2, [r3, #0]
 80110a6:	9b00      	ldr	r3, [sp, #0]
 80110a8:	1e5a      	subs	r2, r3, #1
 80110aa:	9200      	str	r2, [sp, #0]
 80110ac:	2b00      	cmp	r3, #0
 80110ae:	d1f5      	bne.n	801109c <ForceZero.lto_priv.475+0xc>
}
 80110b0:	b004      	add	sp, #16
 80110b2:	4770      	bx	lr
	...

080110c0 <ConstantCompare.lto_priv.473>:
{
 80110c0:	b086      	sub	sp, #24
 80110c2:	9003      	str	r0, [sp, #12]
 80110c4:	9102      	str	r1, [sp, #8]
 80110c6:	9201      	str	r2, [sp, #4]
    int compareSum = 0;
 80110c8:	2300      	movs	r3, #0
 80110ca:	9304      	str	r3, [sp, #16]
    for (i = 0; i < length; i++) {
 80110cc:	2300      	movs	r3, #0
 80110ce:	9305      	str	r3, [sp, #20]
 80110d0:	e010      	b.n	80110f4 <ConstantCompare.lto_priv.473+0x34>
        compareSum |= a[i] ^ b[i];
 80110d2:	9b05      	ldr	r3, [sp, #20]
 80110d4:	9a03      	ldr	r2, [sp, #12]
 80110d6:	4413      	add	r3, r2
 80110d8:	781a      	ldrb	r2, [r3, #0]
 80110da:	9b05      	ldr	r3, [sp, #20]
 80110dc:	9902      	ldr	r1, [sp, #8]
 80110de:	440b      	add	r3, r1
 80110e0:	781b      	ldrb	r3, [r3, #0]
 80110e2:	4053      	eors	r3, r2
 80110e4:	b2db      	uxtb	r3, r3
 80110e6:	461a      	mov	r2, r3
 80110e8:	9b04      	ldr	r3, [sp, #16]
 80110ea:	4313      	orrs	r3, r2
 80110ec:	9304      	str	r3, [sp, #16]
    for (i = 0; i < length; i++) {
 80110ee:	9b05      	ldr	r3, [sp, #20]
 80110f0:	3301      	adds	r3, #1
 80110f2:	9305      	str	r3, [sp, #20]
 80110f4:	9a05      	ldr	r2, [sp, #20]
 80110f6:	9b01      	ldr	r3, [sp, #4]
 80110f8:	429a      	cmp	r2, r3
 80110fa:	dbea      	blt.n	80110d2 <ConstantCompare.lto_priv.473+0x12>
    return compareSum;
 80110fc:	9b04      	ldr	r3, [sp, #16]
}
 80110fe:	4618      	mov	r0, r3
 8011100:	b006      	add	sp, #24
 8011102:	4770      	bx	lr
	...

08011110 <Hash_df.lto_priv.476>:
{
 8011110:	b530      	push	{r4, r5, lr}
 8011112:	b0af      	sub	sp, #188	; 0xbc
 8011114:	9003      	str	r0, [sp, #12]
 8011116:	9102      	str	r1, [sp, #8]
 8011118:	9201      	str	r2, [sp, #4]
 801111a:	f88d 3003 	strb.w	r3, [sp, #3]
    int ret = DRBG_FAILURE;
 801111e:	2302      	movs	r3, #2
 8011120:	932d      	str	r3, [sp, #180]	; 0xb4
    word32 bits = (outSz * 8); /* reverse byte order */
 8011122:	9b01      	ldr	r3, [sp, #4]
 8011124:	00db      	lsls	r3, r3, #3
 8011126:	9329      	str	r3, [sp, #164]	; 0xa4
    bits = ByteReverseWord32(bits);
 8011128:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 801112a:	4618      	mov	r0, r3
 801112c:	f7ff ff98 	bl	8011060 <ByteReverseWord32.lto_priv.478>
 8011130:	4603      	mov	r3, r0
 8011132:	9329      	str	r3, [sp, #164]	; 0xa4
    len = (outSz / OUTPUT_BLOCK_LEN)
 8011134:	9b01      	ldr	r3, [sp, #4]
 8011136:	095a      	lsrs	r2, r3, #5
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 8011138:	9b01      	ldr	r3, [sp, #4]
 801113a:	f003 031f 	and.w	r3, r3, #31
 801113e:	2b00      	cmp	r3, #0
 8011140:	d001      	beq.n	8011146 <Hash_df.lto_priv.476+0x36>
 8011142:	2301      	movs	r3, #1
 8011144:	e000      	b.n	8011148 <Hash_df.lto_priv.476+0x38>
 8011146:	2300      	movs	r3, #0
 8011148:	4413      	add	r3, r2
    len = (outSz / OUTPUT_BLOCK_LEN)
 801114a:	932b      	str	r3, [sp, #172]	; 0xac
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
 801114c:	2300      	movs	r3, #0
 801114e:	932c      	str	r3, [sp, #176]	; 0xb0
 8011150:	2301      	movs	r3, #1
 8011152:	f88d 30ab 	strb.w	r3, [sp, #171]	; 0xab
 8011156:	e07c      	b.n	8011252 <Hash_df.lto_priv.476+0x142>
        ret = wc_InitSha256(&sha);
 8011158:	ab0d      	add	r3, sp, #52	; 0x34
 801115a:	4618      	mov	r0, r3
 801115c:	f7f5 faa0 	bl	80066a0 <wc_InitSha256>
 8011160:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret != 0)
 8011162:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8011164:	2b00      	cmp	r3, #0
 8011166:	d179      	bne.n	801125c <Hash_df.lto_priv.476+0x14c>
        if (ret == 0)
 8011168:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801116a:	2b00      	cmp	r3, #0
 801116c:	d107      	bne.n	801117e <Hash_df.lto_priv.476+0x6e>
            ret = wc_Sha256Update(&sha, &ctr, sizeof(ctr));
 801116e:	f10d 01ab 	add.w	r1, sp, #171	; 0xab
 8011172:	ab0d      	add	r3, sp, #52	; 0x34
 8011174:	2201      	movs	r2, #1
 8011176:	4618      	mov	r0, r3
 8011178:	f7f5 f912 	bl	80063a0 <wc_Sha256Update>
 801117c:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret == 0)
 801117e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8011180:	2b00      	cmp	r3, #0
 8011182:	d106      	bne.n	8011192 <Hash_df.lto_priv.476+0x82>
            ret = wc_Sha256Update(&sha, (byte*)&bits, sizeof(bits));
 8011184:	a929      	add	r1, sp, #164	; 0xa4
 8011186:	ab0d      	add	r3, sp, #52	; 0x34
 8011188:	2204      	movs	r2, #4
 801118a:	4618      	mov	r0, r3
 801118c:	f7f5 f908 	bl	80063a0 <wc_Sha256Update>
 8011190:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret == 0) {
 8011192:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8011194:	2b00      	cmp	r3, #0
 8011196:	d10b      	bne.n	80111b0 <Hash_df.lto_priv.476+0xa0>
            if (type != drbgInitV)
 8011198:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801119c:	2b04      	cmp	r3, #4
 801119e:	d007      	beq.n	80111b0 <Hash_df.lto_priv.476+0xa0>
                ret = wc_Sha256Update(&sha, &type, sizeof(type));
 80111a0:	f10d 0103 	add.w	r1, sp, #3
 80111a4:	ab0d      	add	r3, sp, #52	; 0x34
 80111a6:	2201      	movs	r2, #1
 80111a8:	4618      	mov	r0, r3
 80111aa:	f7f5 f8f9 	bl	80063a0 <wc_Sha256Update>
 80111ae:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret == 0)
 80111b0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80111b2:	2b00      	cmp	r3, #0
 80111b4:	d106      	bne.n	80111c4 <Hash_df.lto_priv.476+0xb4>
            ret = wc_Sha256Update(&sha, inA, inASz);
 80111b6:	ab0d      	add	r3, sp, #52	; 0x34
 80111b8:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 80111ba:	9932      	ldr	r1, [sp, #200]	; 0xc8
 80111bc:	4618      	mov	r0, r3
 80111be:	f7f5 f8ef 	bl	80063a0 <wc_Sha256Update>
 80111c2:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret == 0) {
 80111c4:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80111c6:	2b00      	cmp	r3, #0
 80111c8:	d10c      	bne.n	80111e4 <Hash_df.lto_priv.476+0xd4>
            if (inB != NULL && inBSz > 0)
 80111ca:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 80111cc:	2b00      	cmp	r3, #0
 80111ce:	d009      	beq.n	80111e4 <Hash_df.lto_priv.476+0xd4>
 80111d0:	9b35      	ldr	r3, [sp, #212]	; 0xd4
 80111d2:	2b00      	cmp	r3, #0
 80111d4:	d006      	beq.n	80111e4 <Hash_df.lto_priv.476+0xd4>
                ret = wc_Sha256Update(&sha, inB, inBSz);
 80111d6:	ab0d      	add	r3, sp, #52	; 0x34
 80111d8:	9a35      	ldr	r2, [sp, #212]	; 0xd4
 80111da:	9934      	ldr	r1, [sp, #208]	; 0xd0
 80111dc:	4618      	mov	r0, r3
 80111de:	f7f5 f8df 	bl	80063a0 <wc_Sha256Update>
 80111e2:	902d      	str	r0, [sp, #180]	; 0xb4
        if (ret == 0)
 80111e4:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80111e6:	2b00      	cmp	r3, #0
 80111e8:	d106      	bne.n	80111f8 <Hash_df.lto_priv.476+0xe8>
            ret = wc_Sha256Final(&sha, digest);
 80111ea:	aa05      	add	r2, sp, #20
 80111ec:	ab0d      	add	r3, sp, #52	; 0x34
 80111ee:	4611      	mov	r1, r2
 80111f0:	4618      	mov	r0, r3
 80111f2:	f7f5 f965 	bl	80064c0 <wc_Sha256Final>
 80111f6:	902d      	str	r0, [sp, #180]	; 0xb4
        wc_Sha256Free(&sha);
 80111f8:	ab0d      	add	r3, sp, #52	; 0x34
 80111fa:	4618      	mov	r0, r3
 80111fc:	f7f5 fa60 	bl	80066c0 <wc_Sha256Free>
        if (ret == 0) {
 8011200:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8011202:	2b00      	cmp	r3, #0
 8011204:	d11c      	bne.n	8011240 <Hash_df.lto_priv.476+0x130>
            if (outSz > OUTPUT_BLOCK_LEN) {
 8011206:	9b01      	ldr	r3, [sp, #4]
 8011208:	2b20      	cmp	r3, #32
 801120a:	d913      	bls.n	8011234 <Hash_df.lto_priv.476+0x124>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801120c:	9b02      	ldr	r3, [sp, #8]
 801120e:	461d      	mov	r5, r3
 8011210:	ac05      	add	r4, sp, #20
 8011212:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8011214:	6028      	str	r0, [r5, #0]
 8011216:	6069      	str	r1, [r5, #4]
 8011218:	60aa      	str	r2, [r5, #8]
 801121a:	60eb      	str	r3, [r5, #12]
 801121c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801121e:	6128      	str	r0, [r5, #16]
 8011220:	6169      	str	r1, [r5, #20]
 8011222:	61aa      	str	r2, [r5, #24]
 8011224:	61eb      	str	r3, [r5, #28]
                outSz -= OUTPUT_BLOCK_LEN;
 8011226:	9b01      	ldr	r3, [sp, #4]
 8011228:	3b20      	subs	r3, #32
 801122a:	9301      	str	r3, [sp, #4]
                out += OUTPUT_BLOCK_LEN;
 801122c:	9b02      	ldr	r3, [sp, #8]
 801122e:	3320      	adds	r3, #32
 8011230:	9302      	str	r3, [sp, #8]
 8011232:	e005      	b.n	8011240 <Hash_df.lto_priv.476+0x130>
                XMEMCPY(out, digest, outSz);
 8011234:	ab05      	add	r3, sp, #20
 8011236:	9a01      	ldr	r2, [sp, #4]
 8011238:	4619      	mov	r1, r3
 801123a:	9802      	ldr	r0, [sp, #8]
 801123c:	f7f3 fa6e 	bl	800471c <memcpy>
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
 8011240:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8011242:	3301      	adds	r3, #1
 8011244:	932c      	str	r3, [sp, #176]	; 0xb0
 8011246:	f89d 30ab 	ldrb.w	r3, [sp, #171]	; 0xab
 801124a:	3301      	adds	r3, #1
 801124c:	b2db      	uxtb	r3, r3
 801124e:	f88d 30ab 	strb.w	r3, [sp, #171]	; 0xab
 8011252:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8011254:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8011256:	429a      	cmp	r2, r3
 8011258:	f6ff af7e 	blt.w	8011158 <Hash_df.lto_priv.476+0x48>
    ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801125c:	ab05      	add	r3, sp, #20
 801125e:	2120      	movs	r1, #32
 8011260:	4618      	mov	r0, r3
 8011262:	f7ff ff15 	bl	8011090 <ForceZero.lto_priv.475>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 8011266:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8011268:	2b00      	cmp	r3, #0
 801126a:	d101      	bne.n	8011270 <Hash_df.lto_priv.476+0x160>
 801126c:	2300      	movs	r3, #0
 801126e:	e000      	b.n	8011272 <Hash_df.lto_priv.476+0x162>
 8011270:	2302      	movs	r3, #2
}
 8011272:	4618      	mov	r0, r3
 8011274:	b02f      	add	sp, #188	; 0xbc
 8011276:	bd30      	pop	{r4, r5, pc}
	...

08011280 <Hash_DRBG_Reseed.lto_priv.474>:
{
 8011280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011282:	b097      	sub	sp, #92	; 0x5c
 8011284:	9007      	str	r0, [sp, #28]
 8011286:	9106      	str	r1, [sp, #24]
 8011288:	9205      	str	r2, [sp, #20]
    if (Hash_df(drbg, seed, sizeof(seed), drbgReseed, drbg->V, sizeof(drbg->V),
 801128a:	9b07      	ldr	r3, [sp, #28]
 801128c:	3308      	adds	r3, #8
 801128e:	a908      	add	r1, sp, #32
 8011290:	9a05      	ldr	r2, [sp, #20]
 8011292:	9203      	str	r2, [sp, #12]
 8011294:	9a06      	ldr	r2, [sp, #24]
 8011296:	9202      	str	r2, [sp, #8]
 8011298:	2237      	movs	r2, #55	; 0x37
 801129a:	9201      	str	r2, [sp, #4]
 801129c:	9300      	str	r3, [sp, #0]
 801129e:	2301      	movs	r3, #1
 80112a0:	2237      	movs	r2, #55	; 0x37
 80112a2:	9807      	ldr	r0, [sp, #28]
 80112a4:	f7ff ff34 	bl	8011110 <Hash_df.lto_priv.476>
 80112a8:	4603      	mov	r3, r0
 80112aa:	2b00      	cmp	r3, #0
 80112ac:	d001      	beq.n	80112b2 <Hash_DRBG_Reseed.lto_priv.474+0x32>
        return DRBG_FAILURE;
 80112ae:	2302      	movs	r3, #2
 80112b0:	e03e      	b.n	8011330 <Hash_DRBG_Reseed.lto_priv.474+0xb0>
    XMEMCPY(drbg->V, seed, sizeof(drbg->V));
 80112b2:	9b07      	ldr	r3, [sp, #28]
 80112b4:	3308      	adds	r3, #8
 80112b6:	ac08      	add	r4, sp, #32
 80112b8:	461f      	mov	r7, r3
 80112ba:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 80112be:	463d      	mov	r5, r7
 80112c0:	4626      	mov	r6, r4
 80112c2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80112c4:	6028      	str	r0, [r5, #0]
 80112c6:	6069      	str	r1, [r5, #4]
 80112c8:	60aa      	str	r2, [r5, #8]
 80112ca:	60eb      	str	r3, [r5, #12]
 80112cc:	3410      	adds	r4, #16
 80112ce:	3710      	adds	r7, #16
 80112d0:	4574      	cmp	r4, lr
 80112d2:	d1f4      	bne.n	80112be <Hash_DRBG_Reseed.lto_priv.474+0x3e>
 80112d4:	463b      	mov	r3, r7
 80112d6:	4622      	mov	r2, r4
 80112d8:	6810      	ldr	r0, [r2, #0]
 80112da:	6018      	str	r0, [r3, #0]
 80112dc:	8891      	ldrh	r1, [r2, #4]
 80112de:	7992      	ldrb	r2, [r2, #6]
 80112e0:	8099      	strh	r1, [r3, #4]
 80112e2:	719a      	strb	r2, [r3, #6]
    ForceZero(seed, sizeof(seed));
 80112e4:	ab08      	add	r3, sp, #32
 80112e6:	2137      	movs	r1, #55	; 0x37
 80112e8:	4618      	mov	r0, r3
 80112ea:	f7ff fed1 	bl	8011090 <ForceZero.lto_priv.475>
    if (Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 80112ee:	9b07      	ldr	r3, [sp, #28]
 80112f0:	f103 013f 	add.w	r1, r3, #63	; 0x3f
 80112f4:	9b07      	ldr	r3, [sp, #28]
 80112f6:	3308      	adds	r3, #8
 80112f8:	2200      	movs	r2, #0
 80112fa:	9203      	str	r2, [sp, #12]
 80112fc:	2200      	movs	r2, #0
 80112fe:	9202      	str	r2, [sp, #8]
 8011300:	2237      	movs	r2, #55	; 0x37
 8011302:	9201      	str	r2, [sp, #4]
 8011304:	9300      	str	r3, [sp, #0]
 8011306:	2300      	movs	r3, #0
 8011308:	2237      	movs	r2, #55	; 0x37
 801130a:	9807      	ldr	r0, [sp, #28]
 801130c:	f7ff ff00 	bl	8011110 <Hash_df.lto_priv.476>
 8011310:	4603      	mov	r3, r0
 8011312:	2b00      	cmp	r3, #0
 8011314:	d001      	beq.n	801131a <Hash_DRBG_Reseed.lto_priv.474+0x9a>
        return DRBG_FAILURE;
 8011316:	2302      	movs	r3, #2
 8011318:	e00a      	b.n	8011330 <Hash_DRBG_Reseed.lto_priv.474+0xb0>
    drbg->reseedCtr = 1;
 801131a:	9b07      	ldr	r3, [sp, #28]
 801131c:	2201      	movs	r2, #1
 801131e:	601a      	str	r2, [r3, #0]
    drbg->lastBlock = 0;
 8011320:	9b07      	ldr	r3, [sp, #28]
 8011322:	2200      	movs	r2, #0
 8011324:	605a      	str	r2, [r3, #4]
    drbg->matchCount = 0;
 8011326:	9b07      	ldr	r3, [sp, #28]
 8011328:	2200      	movs	r2, #0
 801132a:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
    return DRBG_SUCCESS;
 801132e:	2300      	movs	r3, #0
}
 8011330:	4618      	mov	r0, r3
 8011332:	b017      	add	sp, #92	; 0x5c
 8011334:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011336:	bf00      	nop
	...

08011340 <array_add_one>:
{
 8011340:	b084      	sub	sp, #16
 8011342:	9001      	str	r0, [sp, #4]
 8011344:	9100      	str	r1, [sp, #0]
    for (i = dataSz - 1; i >= 0; i--)
 8011346:	9b00      	ldr	r3, [sp, #0]
 8011348:	3b01      	subs	r3, #1
 801134a:	9303      	str	r3, [sp, #12]
 801134c:	e00f      	b.n	801136e <array_add_one+0x2e>
        data[i]++;
 801134e:	9b03      	ldr	r3, [sp, #12]
 8011350:	9a01      	ldr	r2, [sp, #4]
 8011352:	4413      	add	r3, r2
 8011354:	781a      	ldrb	r2, [r3, #0]
 8011356:	3201      	adds	r2, #1
 8011358:	b2d2      	uxtb	r2, r2
 801135a:	701a      	strb	r2, [r3, #0]
        if (data[i] != 0) break;
 801135c:	9b03      	ldr	r3, [sp, #12]
 801135e:	9a01      	ldr	r2, [sp, #4]
 8011360:	4413      	add	r3, r2
 8011362:	781b      	ldrb	r3, [r3, #0]
 8011364:	2b00      	cmp	r3, #0
 8011366:	d105      	bne.n	8011374 <array_add_one+0x34>
    for (i = dataSz - 1; i >= 0; i--)
 8011368:	9b03      	ldr	r3, [sp, #12]
 801136a:	3b01      	subs	r3, #1
 801136c:	9303      	str	r3, [sp, #12]
 801136e:	9b03      	ldr	r3, [sp, #12]
 8011370:	2b00      	cmp	r3, #0
 8011372:	daec      	bge.n	801134e <array_add_one+0xe>
}
 8011374:	b004      	add	sp, #16
 8011376:	4770      	bx	lr
	...

08011380 <Hash_gen.lto_priv.479>:
{
 8011380:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011382:	b0bb      	sub	sp, #236	; 0xec
 8011384:	9003      	str	r0, [sp, #12]
 8011386:	9102      	str	r1, [sp, #8]
 8011388:	9201      	str	r2, [sp, #4]
 801138a:	9300      	str	r3, [sp, #0]
    int ret = DRBG_FAILURE;
 801138c:	2302      	movs	r3, #2
 801138e:	9339      	str	r3, [sp, #228]	; 0xe4
    if (outSz == 0) outSz = 1;
 8011390:	9b01      	ldr	r3, [sp, #4]
 8011392:	2b00      	cmp	r3, #0
 8011394:	d101      	bne.n	801139a <Hash_gen.lto_priv.479+0x1a>
 8011396:	2301      	movs	r3, #1
 8011398:	9301      	str	r3, [sp, #4]
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801139a:	9b01      	ldr	r3, [sp, #4]
 801139c:	095a      	lsrs	r2, r3, #5
 801139e:	9b01      	ldr	r3, [sp, #4]
 80113a0:	f003 031f 	and.w	r3, r3, #31
 80113a4:	2b00      	cmp	r3, #0
 80113a6:	d001      	beq.n	80113ac <Hash_gen.lto_priv.479+0x2c>
 80113a8:	2301      	movs	r3, #1
 80113aa:	e000      	b.n	80113ae <Hash_gen.lto_priv.479+0x2e>
 80113ac:	2300      	movs	r3, #0
 80113ae:	4413      	add	r3, r2
 80113b0:	9337      	str	r3, [sp, #220]	; 0xdc
    XMEMCPY(data, V, sizeof(data));
 80113b2:	9b00      	ldr	r3, [sp, #0]
 80113b4:	461c      	mov	r4, r3
 80113b6:	ae29      	add	r6, sp, #164	; 0xa4
 80113b8:	f104 0730 	add.w	r7, r4, #48	; 0x30
 80113bc:	4635      	mov	r5, r6
 80113be:	4623      	mov	r3, r4
 80113c0:	6818      	ldr	r0, [r3, #0]
 80113c2:	6859      	ldr	r1, [r3, #4]
 80113c4:	689a      	ldr	r2, [r3, #8]
 80113c6:	68db      	ldr	r3, [r3, #12]
 80113c8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80113ca:	3410      	adds	r4, #16
 80113cc:	3610      	adds	r6, #16
 80113ce:	42bc      	cmp	r4, r7
 80113d0:	d1f4      	bne.n	80113bc <Hash_gen.lto_priv.479+0x3c>
 80113d2:	4633      	mov	r3, r6
 80113d4:	4622      	mov	r2, r4
 80113d6:	6810      	ldr	r0, [r2, #0]
 80113d8:	6018      	str	r0, [r3, #0]
 80113da:	8891      	ldrh	r1, [r2, #4]
 80113dc:	7992      	ldrb	r2, [r2, #6]
 80113de:	8099      	strh	r1, [r3, #4]
 80113e0:	719a      	strb	r2, [r3, #6]
    for (i = 0; i < len; i++) {
 80113e2:	2300      	movs	r3, #0
 80113e4:	9338      	str	r3, [sp, #224]	; 0xe0
 80113e6:	e071      	b.n	80114cc <Hash_gen.lto_priv.479+0x14c>
        ret = wc_InitSha256(&sha);
 80113e8:	ab0c      	add	r3, sp, #48	; 0x30
 80113ea:	4618      	mov	r0, r3
 80113ec:	f7f5 f958 	bl	80066a0 <wc_InitSha256>
 80113f0:	9039      	str	r0, [sp, #228]	; 0xe4
        if (ret == 0)
 80113f2:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 80113f4:	2b00      	cmp	r3, #0
 80113f6:	d106      	bne.n	8011406 <Hash_gen.lto_priv.479+0x86>
            ret = wc_Sha256Update(&sha, data, sizeof(data));
 80113f8:	a929      	add	r1, sp, #164	; 0xa4
 80113fa:	ab0c      	add	r3, sp, #48	; 0x30
 80113fc:	2237      	movs	r2, #55	; 0x37
 80113fe:	4618      	mov	r0, r3
 8011400:	f7f4 ffce 	bl	80063a0 <wc_Sha256Update>
 8011404:	9039      	str	r0, [sp, #228]	; 0xe4
        if (ret == 0)
 8011406:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 8011408:	2b00      	cmp	r3, #0
 801140a:	d106      	bne.n	801141a <Hash_gen.lto_priv.479+0x9a>
            ret = wc_Sha256Final(&sha, digest);
 801140c:	aa04      	add	r2, sp, #16
 801140e:	ab0c      	add	r3, sp, #48	; 0x30
 8011410:	4611      	mov	r1, r2
 8011412:	4618      	mov	r0, r3
 8011414:	f7f5 f854 	bl	80064c0 <wc_Sha256Final>
 8011418:	9039      	str	r0, [sp, #228]	; 0xe4
        wc_Sha256Free(&sha);
 801141a:	ab0c      	add	r3, sp, #48	; 0x30
 801141c:	4618      	mov	r0, r3
 801141e:	f7f5 f94f 	bl	80066c0 <wc_Sha256Free>
        if (ret == 0) {
 8011422:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 8011424:	2b00      	cmp	r3, #0
 8011426:	d14e      	bne.n	80114c6 <Hash_gen.lto_priv.479+0x146>
            XMEMCPY(&checkBlock, digest, sizeof(word32));
 8011428:	9b04      	ldr	r3, [sp, #16]
 801142a:	9328      	str	r3, [sp, #160]	; 0xa0
            if (drbg->reseedCtr > 1 && checkBlock == drbg->lastBlock) {
 801142c:	9b03      	ldr	r3, [sp, #12]
 801142e:	681b      	ldr	r3, [r3, #0]
 8011430:	2b01      	cmp	r3, #1
 8011432:	d917      	bls.n	8011464 <Hash_gen.lto_priv.479+0xe4>
 8011434:	9b03      	ldr	r3, [sp, #12]
 8011436:	685a      	ldr	r2, [r3, #4]
 8011438:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 801143a:	429a      	cmp	r2, r3
 801143c:	d112      	bne.n	8011464 <Hash_gen.lto_priv.479+0xe4>
                if (drbg->matchCount == 1) {
 801143e:	9b03      	ldr	r3, [sp, #12]
 8011440:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
 8011444:	2b01      	cmp	r3, #1
 8011446:	d101      	bne.n	801144c <Hash_gen.lto_priv.479+0xcc>
                    return DRBG_CONT_FAILURE;
 8011448:	2304      	movs	r3, #4
 801144a:	e04e      	b.n	80114ea <Hash_gen.lto_priv.479+0x16a>
                    if (i == len) {
 801144c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
 801144e:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8011450:	429a      	cmp	r2, r3
 8011452:	d102      	bne.n	801145a <Hash_gen.lto_priv.479+0xda>
                        len++;
 8011454:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8011456:	3301      	adds	r3, #1
 8011458:	9337      	str	r3, [sp, #220]	; 0xdc
                    drbg->matchCount = 1;
 801145a:	9b03      	ldr	r3, [sp, #12]
 801145c:	2201      	movs	r2, #1
 801145e:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
 8011462:	e006      	b.n	8011472 <Hash_gen.lto_priv.479+0xf2>
                drbg->matchCount = 0;
 8011464:	9b03      	ldr	r3, [sp, #12]
 8011466:	2200      	movs	r2, #0
 8011468:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
                drbg->lastBlock = checkBlock;
 801146c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 801146e:	9b03      	ldr	r3, [sp, #12]
 8011470:	605a      	str	r2, [r3, #4]
            if (out != NULL && outSz != 0) {
 8011472:	9b02      	ldr	r3, [sp, #8]
 8011474:	2b00      	cmp	r3, #0
 8011476:	d026      	beq.n	80114c6 <Hash_gen.lto_priv.479+0x146>
 8011478:	9b01      	ldr	r3, [sp, #4]
 801147a:	2b00      	cmp	r3, #0
 801147c:	d023      	beq.n	80114c6 <Hash_gen.lto_priv.479+0x146>
                if (outSz >= OUTPUT_BLOCK_LEN) {
 801147e:	9b01      	ldr	r3, [sp, #4]
 8011480:	2b1f      	cmp	r3, #31
 8011482:	d918      	bls.n	80114b6 <Hash_gen.lto_priv.479+0x136>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 8011484:	9b02      	ldr	r3, [sp, #8]
 8011486:	461d      	mov	r5, r3
 8011488:	ac04      	add	r4, sp, #16
 801148a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801148c:	6028      	str	r0, [r5, #0]
 801148e:	6069      	str	r1, [r5, #4]
 8011490:	60aa      	str	r2, [r5, #8]
 8011492:	60eb      	str	r3, [r5, #12]
 8011494:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8011496:	6128      	str	r0, [r5, #16]
 8011498:	6169      	str	r1, [r5, #20]
 801149a:	61aa      	str	r2, [r5, #24]
 801149c:	61eb      	str	r3, [r5, #28]
                    outSz -= OUTPUT_BLOCK_LEN;
 801149e:	9b01      	ldr	r3, [sp, #4]
 80114a0:	3b20      	subs	r3, #32
 80114a2:	9301      	str	r3, [sp, #4]
                    out += OUTPUT_BLOCK_LEN;
 80114a4:	9b02      	ldr	r3, [sp, #8]
 80114a6:	3320      	adds	r3, #32
 80114a8:	9302      	str	r3, [sp, #8]
                    array_add_one(data, DRBG_SEED_LEN);
 80114aa:	ab29      	add	r3, sp, #164	; 0xa4
 80114ac:	2137      	movs	r1, #55	; 0x37
 80114ae:	4618      	mov	r0, r3
 80114b0:	f7ff ff46 	bl	8011340 <array_add_one>
 80114b4:	e007      	b.n	80114c6 <Hash_gen.lto_priv.479+0x146>
                    XMEMCPY(out, digest, outSz);
 80114b6:	ab04      	add	r3, sp, #16
 80114b8:	9a01      	ldr	r2, [sp, #4]
 80114ba:	4619      	mov	r1, r3
 80114bc:	9802      	ldr	r0, [sp, #8]
 80114be:	f7f3 f92d 	bl	800471c <memcpy>
                    outSz = 0;
 80114c2:	2300      	movs	r3, #0
 80114c4:	9301      	str	r3, [sp, #4]
    for (i = 0; i < len; i++) {
 80114c6:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80114c8:	3301      	adds	r3, #1
 80114ca:	9338      	str	r3, [sp, #224]	; 0xe0
 80114cc:	9a38      	ldr	r2, [sp, #224]	; 0xe0
 80114ce:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 80114d0:	429a      	cmp	r2, r3
 80114d2:	db89      	blt.n	80113e8 <Hash_gen.lto_priv.479+0x68>
    ForceZero(data, sizeof(data));
 80114d4:	ab29      	add	r3, sp, #164	; 0xa4
 80114d6:	2137      	movs	r1, #55	; 0x37
 80114d8:	4618      	mov	r0, r3
 80114da:	f7ff fdd9 	bl	8011090 <ForceZero.lto_priv.475>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 80114de:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 80114e0:	2b00      	cmp	r3, #0
 80114e2:	d101      	bne.n	80114e8 <Hash_gen.lto_priv.479+0x168>
 80114e4:	2300      	movs	r3, #0
 80114e6:	e000      	b.n	80114ea <Hash_gen.lto_priv.479+0x16a>
 80114e8:	2302      	movs	r3, #2
}
 80114ea:	4618      	mov	r0, r3
 80114ec:	b03b      	add	sp, #236	; 0xec
 80114ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080114f0 <array_add.lto_priv.477>:
{
 80114f0:	b088      	sub	sp, #32
 80114f2:	9003      	str	r0, [sp, #12]
 80114f4:	9102      	str	r1, [sp, #8]
 80114f6:	9201      	str	r2, [sp, #4]
 80114f8:	9300      	str	r3, [sp, #0]
    word16 carry = 0;
 80114fa:	2300      	movs	r3, #0
 80114fc:	f8ad 301e 	strh.w	r3, [sp, #30]
    if (dLen > 0 && sLen > 0 && dLen >= sLen) {
 8011500:	9b02      	ldr	r3, [sp, #8]
 8011502:	2b00      	cmp	r3, #0
 8011504:	d054      	beq.n	80115b0 <array_add.lto_priv.477+0xc0>
 8011506:	9b00      	ldr	r3, [sp, #0]
 8011508:	2b00      	cmp	r3, #0
 801150a:	d051      	beq.n	80115b0 <array_add.lto_priv.477+0xc0>
 801150c:	9a02      	ldr	r2, [sp, #8]
 801150e:	9b00      	ldr	r3, [sp, #0]
 8011510:	429a      	cmp	r2, r3
 8011512:	d34d      	bcc.n	80115b0 <array_add.lto_priv.477+0xc0>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--)
 8011514:	9b00      	ldr	r3, [sp, #0]
 8011516:	3b01      	subs	r3, #1
 8011518:	9306      	str	r3, [sp, #24]
 801151a:	9b02      	ldr	r3, [sp, #8]
 801151c:	3b01      	subs	r3, #1
 801151e:	9305      	str	r3, [sp, #20]
 8011520:	e022      	b.n	8011568 <array_add.lto_priv.477+0x78>
            carry += d[dIdx] + s[sIdx];
 8011522:	9b05      	ldr	r3, [sp, #20]
 8011524:	9a03      	ldr	r2, [sp, #12]
 8011526:	4413      	add	r3, r2
 8011528:	781b      	ldrb	r3, [r3, #0]
 801152a:	b29a      	uxth	r2, r3
 801152c:	9b06      	ldr	r3, [sp, #24]
 801152e:	9901      	ldr	r1, [sp, #4]
 8011530:	440b      	add	r3, r1
 8011532:	781b      	ldrb	r3, [r3, #0]
 8011534:	b29b      	uxth	r3, r3
 8011536:	4413      	add	r3, r2
 8011538:	b29a      	uxth	r2, r3
 801153a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 801153e:	4413      	add	r3, r2
 8011540:	f8ad 301e 	strh.w	r3, [sp, #30]
            d[dIdx] = (byte)carry;
 8011544:	9b05      	ldr	r3, [sp, #20]
 8011546:	9a03      	ldr	r2, [sp, #12]
 8011548:	4413      	add	r3, r2
 801154a:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 801154e:	b2d2      	uxtb	r2, r2
 8011550:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 8011552:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8011556:	0a1b      	lsrs	r3, r3, #8
 8011558:	f8ad 301e 	strh.w	r3, [sp, #30]
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--)
 801155c:	9b05      	ldr	r3, [sp, #20]
 801155e:	3b01      	subs	r3, #1
 8011560:	9305      	str	r3, [sp, #20]
 8011562:	9b06      	ldr	r3, [sp, #24]
 8011564:	3b01      	subs	r3, #1
 8011566:	9306      	str	r3, [sp, #24]
 8011568:	9b06      	ldr	r3, [sp, #24]
 801156a:	2b00      	cmp	r3, #0
 801156c:	dad9      	bge.n	8011522 <array_add.lto_priv.477+0x32>
 801156e:	e018      	b.n	80115a2 <array_add.lto_priv.477+0xb2>
            carry += d[dIdx];
 8011570:	9b05      	ldr	r3, [sp, #20]
 8011572:	9a03      	ldr	r2, [sp, #12]
 8011574:	4413      	add	r3, r2
 8011576:	781b      	ldrb	r3, [r3, #0]
 8011578:	b29a      	uxth	r2, r3
 801157a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 801157e:	4413      	add	r3, r2
 8011580:	f8ad 301e 	strh.w	r3, [sp, #30]
            d[dIdx] = (byte)carry;
 8011584:	9b05      	ldr	r3, [sp, #20]
 8011586:	9a03      	ldr	r2, [sp, #12]
 8011588:	4413      	add	r3, r2
 801158a:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 801158e:	b2d2      	uxtb	r2, r2
 8011590:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 8011592:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8011596:	0a1b      	lsrs	r3, r3, #8
 8011598:	f8ad 301e 	strh.w	r3, [sp, #30]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
 801159c:	9b05      	ldr	r3, [sp, #20]
 801159e:	3b01      	subs	r3, #1
 80115a0:	9305      	str	r3, [sp, #20]
 80115a2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80115a6:	2b00      	cmp	r3, #0
 80115a8:	d002      	beq.n	80115b0 <array_add.lto_priv.477+0xc0>
 80115aa:	9b05      	ldr	r3, [sp, #20]
 80115ac:	2b00      	cmp	r3, #0
 80115ae:	dadf      	bge.n	8011570 <array_add.lto_priv.477+0x80>
}
 80115b0:	b008      	add	sp, #32
 80115b2:	4770      	bx	lr
	...

080115c0 <wc_InitSha_ex>:
    }
#endif /* !USE_CUSTOM_SHA_TRANSFORM */


int wc_InitSha_ex(wc_Sha* sha, void* heap, int devId)
{
 80115c0:	b500      	push	{lr}
 80115c2:	b087      	sub	sp, #28
 80115c4:	9003      	str	r0, [sp, #12]
 80115c6:	9102      	str	r1, [sp, #8]
 80115c8:	9201      	str	r2, [sp, #4]
    int ret = 0;
 80115ca:	2300      	movs	r3, #0
 80115cc:	9305      	str	r3, [sp, #20]

    if (sha == NULL)
 80115ce:	9b03      	ldr	r3, [sp, #12]
 80115d0:	2b00      	cmp	r3, #0
 80115d2:	d102      	bne.n	80115da <wc_InitSha_ex+0x1a>
        return BAD_FUNC_ARG;
 80115d4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80115d8:	e00c      	b.n	80115f4 <wc_InitSha_ex+0x34>

    sha->heap = heap;
 80115da:	9b03      	ldr	r3, [sp, #12]
 80115dc:	9a02      	ldr	r2, [sp, #8]
 80115de:	661a      	str	r2, [r3, #96]	; 0x60

    ret = InitSha(sha);
 80115e0:	9803      	ldr	r0, [sp, #12]
 80115e2:	f000 f945 	bl	8011870 <InitSha.lto_priv.486>
 80115e6:	9005      	str	r0, [sp, #20]
    if (ret != 0)
 80115e8:	9b05      	ldr	r3, [sp, #20]
 80115ea:	2b00      	cmp	r3, #0
 80115ec:	d001      	beq.n	80115f2 <wc_InitSha_ex+0x32>
        return ret;
 80115ee:	9b05      	ldr	r3, [sp, #20]
 80115f0:	e000      	b.n	80115f4 <wc_InitSha_ex+0x34>
                                                            sha->heap, devId);
#else
    (void)devId;
#endif /* WOLFSSL_ASYNC_CRYPT */

    return ret;
 80115f2:	9b05      	ldr	r3, [sp, #20]
}
 80115f4:	4618      	mov	r0, r3
 80115f6:	b007      	add	sp, #28
 80115f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80115fc:	0000      	movs	r0, r0
	...

08011600 <wc_ShaUpdate>:

int wc_ShaUpdate(wc_Sha* sha, const byte* data, word32 len)
{
 8011600:	b500      	push	{lr}
 8011602:	b087      	sub	sp, #28
 8011604:	9003      	str	r0, [sp, #12]
 8011606:	9102      	str	r1, [sp, #8]
 8011608:	9201      	str	r2, [sp, #4]
    byte* local;

    if (sha == NULL ||(data == NULL && len > 0)) {
 801160a:	9b03      	ldr	r3, [sp, #12]
 801160c:	2b00      	cmp	r3, #0
 801160e:	d005      	beq.n	801161c <wc_ShaUpdate+0x1c>
 8011610:	9b02      	ldr	r3, [sp, #8]
 8011612:	2b00      	cmp	r3, #0
 8011614:	d105      	bne.n	8011622 <wc_ShaUpdate+0x22>
 8011616:	9b01      	ldr	r3, [sp, #4]
 8011618:	2b00      	cmp	r3, #0
 801161a:	d002      	beq.n	8011622 <wc_ShaUpdate+0x22>
        return BAD_FUNC_ARG;
 801161c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 8011620:	e045      	b.n	80116ae <wc_ShaUpdate+0xae>
    }

    /* do block size increments */
    local = (byte*)sha->buffer;
 8011622:	9b03      	ldr	r3, [sp, #12]
 8011624:	330c      	adds	r3, #12
 8011626:	9305      	str	r3, [sp, #20]
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* check that internal buffLen is valid */
    if (sha->buffLen >= WC_SHA_BLOCK_SIZE)
 8011628:	9b03      	ldr	r3, [sp, #12]
 801162a:	681b      	ldr	r3, [r3, #0]
 801162c:	2b3f      	cmp	r3, #63	; 0x3f
 801162e:	d93a      	bls.n	80116a6 <wc_ShaUpdate+0xa6>
        return BUFFER_E;
 8011630:	f06f 0383 	mvn.w	r3, #131	; 0x83
 8011634:	e03b      	b.n	80116ae <wc_ShaUpdate+0xae>

    while (len) {
        word32 add = min(len, WC_SHA_BLOCK_SIZE - sha->buffLen);
 8011636:	9b03      	ldr	r3, [sp, #12]
 8011638:	681b      	ldr	r3, [r3, #0]
 801163a:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 801163e:	4619      	mov	r1, r3
 8011640:	9801      	ldr	r0, [sp, #4]
 8011642:	f000 f905 	bl	8011850 <min.lto_priv.490>
 8011646:	9004      	str	r0, [sp, #16]
        XMEMCPY(&local[sha->buffLen], data, add);
 8011648:	9b03      	ldr	r3, [sp, #12]
 801164a:	681b      	ldr	r3, [r3, #0]
 801164c:	9a05      	ldr	r2, [sp, #20]
 801164e:	4413      	add	r3, r2
 8011650:	9a04      	ldr	r2, [sp, #16]
 8011652:	9902      	ldr	r1, [sp, #8]
 8011654:	4618      	mov	r0, r3
 8011656:	f7f3 f861 	bl	800471c <memcpy>

        sha->buffLen += add;
 801165a:	9b03      	ldr	r3, [sp, #12]
 801165c:	681a      	ldr	r2, [r3, #0]
 801165e:	9b04      	ldr	r3, [sp, #16]
 8011660:	441a      	add	r2, r3
 8011662:	9b03      	ldr	r3, [sp, #12]
 8011664:	601a      	str	r2, [r3, #0]
        data         += add;
 8011666:	9a02      	ldr	r2, [sp, #8]
 8011668:	9b04      	ldr	r3, [sp, #16]
 801166a:	4413      	add	r3, r2
 801166c:	9302      	str	r3, [sp, #8]
        len          -= add;
 801166e:	9a01      	ldr	r2, [sp, #4]
 8011670:	9b04      	ldr	r3, [sp, #16]
 8011672:	1ad3      	subs	r3, r2, r3
 8011674:	9301      	str	r3, [sp, #4]

        if (sha->buffLen == WC_SHA_BLOCK_SIZE) {
 8011676:	9b03      	ldr	r3, [sp, #12]
 8011678:	681b      	ldr	r3, [r3, #0]
 801167a:	2b40      	cmp	r3, #64	; 0x40
 801167c:	d113      	bne.n	80116a6 <wc_ShaUpdate+0xa6>
#if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
            ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
 801167e:	9b03      	ldr	r3, [sp, #12]
 8011680:	f103 000c 	add.w	r0, r3, #12
 8011684:	9b03      	ldr	r3, [sp, #12]
 8011686:	330c      	adds	r3, #12
 8011688:	2240      	movs	r2, #64	; 0x40
 801168a:	4619      	mov	r1, r3
 801168c:	f000 f8b8 	bl	8011800 <ByteReverseWords.lto_priv.487>
#endif
            XTRANSFORM(sha, local);
 8011690:	9905      	ldr	r1, [sp, #20]
 8011692:	9803      	ldr	r0, [sp, #12]
 8011694:	f000 f934 	bl	8011900 <Transform.lto_priv.488>
            AddLength(sha, WC_SHA_BLOCK_SIZE);
 8011698:	2140      	movs	r1, #64	; 0x40
 801169a:	9803      	ldr	r0, [sp, #12]
 801169c:	f000 f918 	bl	80118d0 <AddLength.lto_priv.489>
            sha->buffLen = 0;
 80116a0:	9b03      	ldr	r3, [sp, #12]
 80116a2:	2200      	movs	r2, #0
 80116a4:	601a      	str	r2, [r3, #0]
    while (len) {
 80116a6:	9b01      	ldr	r3, [sp, #4]
 80116a8:	2b00      	cmp	r3, #0
 80116aa:	d1c4      	bne.n	8011636 <wc_ShaUpdate+0x36>
        }
    }

    return 0;
 80116ac:	2300      	movs	r3, #0
}
 80116ae:	4618      	mov	r0, r3
 80116b0:	b007      	add	sp, #28
 80116b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80116b6:	bf00      	nop
	...

080116c0 <wc_ShaFinal>:

int wc_ShaFinal(wc_Sha* sha, byte* hash)
{
 80116c0:	b500      	push	{lr}
 80116c2:	b085      	sub	sp, #20
 80116c4:	9001      	str	r0, [sp, #4]
 80116c6:	9100      	str	r1, [sp, #0]
    byte* local;

    if (sha == NULL || hash == NULL) {
 80116c8:	9b01      	ldr	r3, [sp, #4]
 80116ca:	2b00      	cmp	r3, #0
 80116cc:	d002      	beq.n	80116d4 <wc_ShaFinal+0x14>
 80116ce:	9b00      	ldr	r3, [sp, #0]
 80116d0:	2b00      	cmp	r3, #0
 80116d2:	d102      	bne.n	80116da <wc_ShaFinal+0x1a>
        return BAD_FUNC_ARG;
 80116d4:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 80116d8:	e07b      	b.n	80117d2 <wc_ShaFinal+0x112>
    }

    local = (byte*)sha->buffer;
 80116da:	9b01      	ldr	r3, [sp, #4]
 80116dc:	330c      	adds	r3, #12
 80116de:	9303      	str	r3, [sp, #12]
        return IntelQaSymSha(&sha->asyncDev, hash, NULL, WC_SHA_DIGEST_SIZE);
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    AddLength(sha, sha->buffLen);  /* before adding pads */
 80116e0:	9b01      	ldr	r3, [sp, #4]
 80116e2:	681b      	ldr	r3, [r3, #0]
 80116e4:	4619      	mov	r1, r3
 80116e6:	9801      	ldr	r0, [sp, #4]
 80116e8:	f000 f8f2 	bl	80118d0 <AddLength.lto_priv.489>

    local[sha->buffLen++] = 0x80;  /* add 1 */
 80116ec:	9b01      	ldr	r3, [sp, #4]
 80116ee:	681b      	ldr	r3, [r3, #0]
 80116f0:	1c59      	adds	r1, r3, #1
 80116f2:	9a01      	ldr	r2, [sp, #4]
 80116f4:	6011      	str	r1, [r2, #0]
 80116f6:	9a03      	ldr	r2, [sp, #12]
 80116f8:	4413      	add	r3, r2
 80116fa:	2280      	movs	r2, #128	; 0x80
 80116fc:	701a      	strb	r2, [r3, #0]

    /* pad with zeros */
    if (sha->buffLen > WC_SHA_PAD_SIZE) {
 80116fe:	9b01      	ldr	r3, [sp, #4]
 8011700:	681b      	ldr	r3, [r3, #0]
 8011702:	2b38      	cmp	r3, #56	; 0x38
 8011704:	d91e      	bls.n	8011744 <wc_ShaFinal+0x84>
        XMEMSET(&local[sha->buffLen], 0, WC_SHA_BLOCK_SIZE - sha->buffLen);
 8011706:	9b01      	ldr	r3, [sp, #4]
 8011708:	681b      	ldr	r3, [r3, #0]
 801170a:	9a03      	ldr	r2, [sp, #12]
 801170c:	18d0      	adds	r0, r2, r3
 801170e:	9b01      	ldr	r3, [sp, #4]
 8011710:	681b      	ldr	r3, [r3, #0]
 8011712:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8011716:	461a      	mov	r2, r3
 8011718:	2100      	movs	r1, #0
 801171a:	f00c f85b 	bl	801d7d4 <memset>
        sha->buffLen += WC_SHA_BLOCK_SIZE - sha->buffLen;
 801171e:	9b01      	ldr	r3, [sp, #4]
 8011720:	2240      	movs	r2, #64	; 0x40
 8011722:	601a      	str	r2, [r3, #0]

#if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
 8011724:	9b01      	ldr	r3, [sp, #4]
 8011726:	f103 000c 	add.w	r0, r3, #12
 801172a:	9b01      	ldr	r3, [sp, #4]
 801172c:	330c      	adds	r3, #12
 801172e:	2240      	movs	r2, #64	; 0x40
 8011730:	4619      	mov	r1, r3
 8011732:	f000 f865 	bl	8011800 <ByteReverseWords.lto_priv.487>
#endif
        XTRANSFORM(sha, local);
 8011736:	9903      	ldr	r1, [sp, #12]
 8011738:	9801      	ldr	r0, [sp, #4]
 801173a:	f000 f8e1 	bl	8011900 <Transform.lto_priv.488>
        sha->buffLen = 0;
 801173e:	9b01      	ldr	r3, [sp, #4]
 8011740:	2200      	movs	r2, #0
 8011742:	601a      	str	r2, [r3, #0]
    }
    XMEMSET(&local[sha->buffLen], 0, WC_SHA_PAD_SIZE - sha->buffLen);
 8011744:	9b01      	ldr	r3, [sp, #4]
 8011746:	681b      	ldr	r3, [r3, #0]
 8011748:	9a03      	ldr	r2, [sp, #12]
 801174a:	18d0      	adds	r0, r2, r3
 801174c:	9b01      	ldr	r3, [sp, #4]
 801174e:	681b      	ldr	r3, [r3, #0]
 8011750:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 8011754:	461a      	mov	r2, r3
 8011756:	2100      	movs	r1, #0
 8011758:	f00c f83c 	bl	801d7d4 <memset>

#if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
 801175c:	9b01      	ldr	r3, [sp, #4]
 801175e:	f103 000c 	add.w	r0, r3, #12
 8011762:	9b01      	ldr	r3, [sp, #4]
 8011764:	330c      	adds	r3, #12
 8011766:	2240      	movs	r2, #64	; 0x40
 8011768:	4619      	mov	r1, r3
 801176a:	f000 f849 	bl	8011800 <ByteReverseWords.lto_priv.487>
#endif

    /* store lengths */
    /* put lengths in bits */
    sha->hiLen = (sha->loLen >> (8*sizeof(sha->loLen) - 3)) + (sha->hiLen << 3);
 801176e:	9b01      	ldr	r3, [sp, #4]
 8011770:	685b      	ldr	r3, [r3, #4]
 8011772:	0f5a      	lsrs	r2, r3, #29
 8011774:	9b01      	ldr	r3, [sp, #4]
 8011776:	689b      	ldr	r3, [r3, #8]
 8011778:	00db      	lsls	r3, r3, #3
 801177a:	441a      	add	r2, r3
 801177c:	9b01      	ldr	r3, [sp, #4]
 801177e:	609a      	str	r2, [r3, #8]
    sha->loLen = sha->loLen << 3;
 8011780:	9b01      	ldr	r3, [sp, #4]
 8011782:	685b      	ldr	r3, [r3, #4]
 8011784:	00da      	lsls	r2, r3, #3
 8011786:	9b01      	ldr	r3, [sp, #4]
 8011788:	605a      	str	r2, [r3, #4]

    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_SHA_PAD_SIZE], &sha->hiLen, sizeof(word32));
 801178a:	9b03      	ldr	r3, [sp, #12]
 801178c:	3338      	adds	r3, #56	; 0x38
 801178e:	9a01      	ldr	r2, [sp, #4]
 8011790:	3208      	adds	r2, #8
 8011792:	6812      	ldr	r2, [r2, #0]
 8011794:	601a      	str	r2, [r3, #0]
    XMEMCPY(&local[WC_SHA_PAD_SIZE + sizeof(word32)], &sha->loLen, sizeof(word32));
 8011796:	9b03      	ldr	r3, [sp, #12]
 8011798:	333c      	adds	r3, #60	; 0x3c
 801179a:	9a01      	ldr	r2, [sp, #4]
 801179c:	3204      	adds	r2, #4
 801179e:	6812      	ldr	r2, [r2, #0]
 80117a0:	601a      	str	r2, [r3, #0]
    ByteReverseWords(&sha->buffer[WC_SHA_PAD_SIZE/sizeof(word32)],
                     &sha->buffer[WC_SHA_PAD_SIZE/sizeof(word32)],
                     2 * sizeof(word32));
#endif

    XTRANSFORM(sha, local);
 80117a2:	9903      	ldr	r1, [sp, #12]
 80117a4:	9801      	ldr	r0, [sp, #4]
 80117a6:	f000 f8ab 	bl	8011900 <Transform.lto_priv.488>
#ifdef LITTLE_ENDIAN_ORDER
    ByteReverseWords(sha->digest, sha->digest, WC_SHA_DIGEST_SIZE);
 80117aa:	9b01      	ldr	r3, [sp, #4]
 80117ac:	f103 004c 	add.w	r0, r3, #76	; 0x4c
 80117b0:	9b01      	ldr	r3, [sp, #4]
 80117b2:	334c      	adds	r3, #76	; 0x4c
 80117b4:	2214      	movs	r2, #20
 80117b6:	4619      	mov	r1, r3
 80117b8:	f000 f822 	bl	8011800 <ByteReverseWords.lto_priv.487>
#endif
    XMEMCPY(hash, sha->digest, WC_SHA_DIGEST_SIZE);
 80117bc:	9b01      	ldr	r3, [sp, #4]
 80117be:	334c      	adds	r3, #76	; 0x4c
 80117c0:	2214      	movs	r2, #20
 80117c2:	4619      	mov	r1, r3
 80117c4:	9800      	ldr	r0, [sp, #0]
 80117c6:	f7f2 ffa9 	bl	800471c <memcpy>

    return InitSha(sha); /* reset state */
 80117ca:	9801      	ldr	r0, [sp, #4]
 80117cc:	f000 f850 	bl	8011870 <InitSha.lto_priv.486>
 80117d0:	4603      	mov	r3, r0
}
 80117d2:	4618      	mov	r0, r3
 80117d4:	b005      	add	sp, #20
 80117d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80117da:	bf00      	nop
 80117dc:	0000      	movs	r0, r0
	...

080117e0 <wc_InitSha>:

#endif /* USE_SHA_SOFTWARE_IMPL */


int wc_InitSha(wc_Sha* sha)
{
 80117e0:	b500      	push	{lr}
 80117e2:	b083      	sub	sp, #12
 80117e4:	9001      	str	r0, [sp, #4]
    return wc_InitSha_ex(sha, NULL, INVALID_DEVID);
 80117e6:	f06f 0201 	mvn.w	r2, #1
 80117ea:	2100      	movs	r1, #0
 80117ec:	9801      	ldr	r0, [sp, #4]
 80117ee:	f7ff fee7 	bl	80115c0 <wc_InitSha_ex>
 80117f2:	4603      	mov	r3, r0
}
 80117f4:	4618      	mov	r0, r3
 80117f6:	b003      	add	sp, #12
 80117f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80117fc:	0000      	movs	r0, r0
	...

08011800 <ByteReverseWords.lto_priv.487>:
{
 8011800:	b510      	push	{r4, lr}
 8011802:	b086      	sub	sp, #24
 8011804:	9003      	str	r0, [sp, #12]
 8011806:	9102      	str	r1, [sp, #8]
 8011808:	9201      	str	r2, [sp, #4]
    word32 count = byteCount/(word32)sizeof(word32), i;
 801180a:	9b01      	ldr	r3, [sp, #4]
 801180c:	089b      	lsrs	r3, r3, #2
 801180e:	9304      	str	r3, [sp, #16]
    for (i = 0; i < count; i++)
 8011810:	2300      	movs	r3, #0
 8011812:	9305      	str	r3, [sp, #20]
 8011814:	e010      	b.n	8011838 <ByteReverseWords.lto_priv.487+0x38>
        out[i] = ByteReverseWord32(in[i]);
 8011816:	9b05      	ldr	r3, [sp, #20]
 8011818:	009b      	lsls	r3, r3, #2
 801181a:	9a03      	ldr	r2, [sp, #12]
 801181c:	18d4      	adds	r4, r2, r3
 801181e:	9b05      	ldr	r3, [sp, #20]
 8011820:	009b      	lsls	r3, r3, #2
 8011822:	9a02      	ldr	r2, [sp, #8]
 8011824:	4413      	add	r3, r2
 8011826:	681b      	ldr	r3, [r3, #0]
 8011828:	4618      	mov	r0, r3
 801182a:	f001 fc29 	bl	8013080 <ByteReverseWord32.lto_priv.492>
 801182e:	4603      	mov	r3, r0
 8011830:	6023      	str	r3, [r4, #0]
    for (i = 0; i < count; i++)
 8011832:	9b05      	ldr	r3, [sp, #20]
 8011834:	3301      	adds	r3, #1
 8011836:	9305      	str	r3, [sp, #20]
 8011838:	9a05      	ldr	r2, [sp, #20]
 801183a:	9b04      	ldr	r3, [sp, #16]
 801183c:	429a      	cmp	r2, r3
 801183e:	d3ea      	bcc.n	8011816 <ByteReverseWords.lto_priv.487+0x16>
}
 8011840:	b006      	add	sp, #24
 8011842:	bd10      	pop	{r4, pc}
	...

08011850 <min.lto_priv.490>:
    {
 8011850:	b082      	sub	sp, #8
 8011852:	9001      	str	r0, [sp, #4]
 8011854:	9100      	str	r1, [sp, #0]
        return a > b ? b : a;
 8011856:	9a01      	ldr	r2, [sp, #4]
 8011858:	9b00      	ldr	r3, [sp, #0]
 801185a:	4293      	cmp	r3, r2
 801185c:	bf28      	it	cs
 801185e:	4613      	movcs	r3, r2
    }
 8011860:	4618      	mov	r0, r3
 8011862:	b002      	add	sp, #8
 8011864:	4770      	bx	lr
 8011866:	bf00      	nop
	...

08011870 <InitSha.lto_priv.486>:
    {
 8011870:	b084      	sub	sp, #16
 8011872:	9001      	str	r0, [sp, #4]
        int ret = 0;
 8011874:	2300      	movs	r3, #0
 8011876:	9303      	str	r3, [sp, #12]
        sha->digest[0] = 0x67452301L;
 8011878:	9b01      	ldr	r3, [sp, #4]
 801187a:	4a0d      	ldr	r2, [pc, #52]	; (80118b0 <InitSha.lto_priv.486+0x40>)
 801187c:	64da      	str	r2, [r3, #76]	; 0x4c
        sha->digest[1] = 0xEFCDAB89L;
 801187e:	9b01      	ldr	r3, [sp, #4]
 8011880:	4a0c      	ldr	r2, [pc, #48]	; (80118b4 <InitSha.lto_priv.486+0x44>)
 8011882:	651a      	str	r2, [r3, #80]	; 0x50
        sha->digest[2] = 0x98BADCFEL;
 8011884:	9b01      	ldr	r3, [sp, #4]
 8011886:	4a0c      	ldr	r2, [pc, #48]	; (80118b8 <InitSha.lto_priv.486+0x48>)
 8011888:	655a      	str	r2, [r3, #84]	; 0x54
        sha->digest[3] = 0x10325476L;
 801188a:	9b01      	ldr	r3, [sp, #4]
 801188c:	4a0b      	ldr	r2, [pc, #44]	; (80118bc <InitSha.lto_priv.486+0x4c>)
 801188e:	659a      	str	r2, [r3, #88]	; 0x58
        sha->digest[4] = 0xC3D2E1F0L;
 8011890:	9b01      	ldr	r3, [sp, #4]
 8011892:	4a0b      	ldr	r2, [pc, #44]	; (80118c0 <InitSha.lto_priv.486+0x50>)
 8011894:	65da      	str	r2, [r3, #92]	; 0x5c
        sha->buffLen = 0;
 8011896:	9b01      	ldr	r3, [sp, #4]
 8011898:	2200      	movs	r2, #0
 801189a:	601a      	str	r2, [r3, #0]
        sha->loLen   = 0;
 801189c:	9b01      	ldr	r3, [sp, #4]
 801189e:	2200      	movs	r2, #0
 80118a0:	605a      	str	r2, [r3, #4]
        sha->hiLen   = 0;
 80118a2:	9b01      	ldr	r3, [sp, #4]
 80118a4:	2200      	movs	r2, #0
 80118a6:	609a      	str	r2, [r3, #8]
        return ret;
 80118a8:	9b03      	ldr	r3, [sp, #12]
    }
 80118aa:	4618      	mov	r0, r3
 80118ac:	b004      	add	sp, #16
 80118ae:	4770      	bx	lr
 80118b0:	67452301 	.word	0x67452301
 80118b4:	efcdab89 	.word	0xefcdab89
 80118b8:	98badcfe 	.word	0x98badcfe
 80118bc:	10325476 	.word	0x10325476
 80118c0:	c3d2e1f0 	.word	0xc3d2e1f0
	...

080118d0 <AddLength.lto_priv.489>:
{
 80118d0:	b084      	sub	sp, #16
 80118d2:	9001      	str	r0, [sp, #4]
 80118d4:	9100      	str	r1, [sp, #0]
    word32 tmp = sha->loLen;
 80118d6:	9b01      	ldr	r3, [sp, #4]
 80118d8:	685b      	ldr	r3, [r3, #4]
 80118da:	9303      	str	r3, [sp, #12]
    if ((sha->loLen += len) < tmp)
 80118dc:	9b01      	ldr	r3, [sp, #4]
 80118de:	685a      	ldr	r2, [r3, #4]
 80118e0:	9b00      	ldr	r3, [sp, #0]
 80118e2:	441a      	add	r2, r3
 80118e4:	9b01      	ldr	r3, [sp, #4]
 80118e6:	605a      	str	r2, [r3, #4]
 80118e8:	9b01      	ldr	r3, [sp, #4]
 80118ea:	685a      	ldr	r2, [r3, #4]
 80118ec:	9b03      	ldr	r3, [sp, #12]
 80118ee:	429a      	cmp	r2, r3
 80118f0:	d204      	bcs.n	80118fc <AddLength.lto_priv.489+0x2c>
        sha->hiLen++;                       /* carry low to high */
 80118f2:	9b01      	ldr	r3, [sp, #4]
 80118f4:	689b      	ldr	r3, [r3, #8]
 80118f6:	1c5a      	adds	r2, r3, #1
 80118f8:	9b01      	ldr	r3, [sp, #4]
 80118fa:	609a      	str	r2, [r3, #8]
}
 80118fc:	b004      	add	sp, #16
 80118fe:	4770      	bx	lr

08011900 <Transform.lto_priv.488>:
    {
 8011900:	b510      	push	{r4, lr}
 8011902:	b098      	sub	sp, #96	; 0x60
 8011904:	9001      	str	r0, [sp, #4]
 8011906:	9100      	str	r1, [sp, #0]
        word32 a = sha->digest[0];
 8011908:	9b01      	ldr	r3, [sp, #4]
 801190a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801190c:	9317      	str	r3, [sp, #92]	; 0x5c
        word32 b = sha->digest[1];
 801190e:	9b01      	ldr	r3, [sp, #4]
 8011910:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011912:	9316      	str	r3, [sp, #88]	; 0x58
        word32 c = sha->digest[2];
 8011914:	9b01      	ldr	r3, [sp, #4]
 8011916:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011918:	9315      	str	r3, [sp, #84]	; 0x54
        word32 d = sha->digest[3];
 801191a:	9b01      	ldr	r3, [sp, #4]
 801191c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801191e:	9314      	str	r3, [sp, #80]	; 0x50
        word32 e = sha->digest[4];
 8011920:	9b01      	ldr	r3, [sp, #4]
 8011922:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8011924:	9313      	str	r3, [sp, #76]	; 0x4c
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
 8011926:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011928:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801192a:	405a      	eors	r2, r3
 801192c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801192e:	401a      	ands	r2, r3
 8011930:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011932:	405a      	eors	r2, r3
 8011934:	9b01      	ldr	r3, [sp, #4]
 8011936:	68db      	ldr	r3, [r3, #12]
 8011938:	9303      	str	r3, [sp, #12]
 801193a:	9b03      	ldr	r3, [sp, #12]
 801193c:	18d4      	adds	r4, r2, r3
 801193e:	2105      	movs	r1, #5
 8011940:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011942:	f001 fb8d 	bl	8013060 <rotlFixed.lto_priv.491>
 8011946:	4603      	mov	r3, r0
 8011948:	18e2      	adds	r2, r4, r3
 801194a:	4ba9      	ldr	r3, [pc, #676]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 801194c:	4413      	add	r3, r2
 801194e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011950:	4413      	add	r3, r2
 8011952:	9313      	str	r3, [sp, #76]	; 0x4c
 8011954:	211e      	movs	r1, #30
 8011956:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011958:	f001 fb82 	bl	8013060 <rotlFixed.lto_priv.491>
 801195c:	9016      	str	r0, [sp, #88]	; 0x58
 801195e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011960:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011962:	405a      	eors	r2, r3
 8011964:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011966:	401a      	ands	r2, r3
 8011968:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801196a:	405a      	eors	r2, r3
 801196c:	9b01      	ldr	r3, [sp, #4]
 801196e:	691b      	ldr	r3, [r3, #16]
 8011970:	9304      	str	r3, [sp, #16]
 8011972:	9b04      	ldr	r3, [sp, #16]
 8011974:	18d4      	adds	r4, r2, r3
 8011976:	2105      	movs	r1, #5
 8011978:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801197a:	f001 fb71 	bl	8013060 <rotlFixed.lto_priv.491>
 801197e:	4603      	mov	r3, r0
 8011980:	18e2      	adds	r2, r4, r3
 8011982:	4b9b      	ldr	r3, [pc, #620]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011984:	4413      	add	r3, r2
 8011986:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011988:	4413      	add	r3, r2
 801198a:	9314      	str	r3, [sp, #80]	; 0x50
 801198c:	211e      	movs	r1, #30
 801198e:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011990:	f001 fb66 	bl	8013060 <rotlFixed.lto_priv.491>
 8011994:	9017      	str	r0, [sp, #92]	; 0x5c
 8011996:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011998:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801199a:	405a      	eors	r2, r3
 801199c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801199e:	401a      	ands	r2, r3
 80119a0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80119a2:	405a      	eors	r2, r3
 80119a4:	9b01      	ldr	r3, [sp, #4]
 80119a6:	695b      	ldr	r3, [r3, #20]
 80119a8:	9305      	str	r3, [sp, #20]
 80119aa:	9b05      	ldr	r3, [sp, #20]
 80119ac:	18d4      	adds	r4, r2, r3
 80119ae:	2105      	movs	r1, #5
 80119b0:	9814      	ldr	r0, [sp, #80]	; 0x50
 80119b2:	f001 fb55 	bl	8013060 <rotlFixed.lto_priv.491>
 80119b6:	4603      	mov	r3, r0
 80119b8:	18e2      	adds	r2, r4, r3
 80119ba:	4b8d      	ldr	r3, [pc, #564]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 80119bc:	4413      	add	r3, r2
 80119be:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80119c0:	4413      	add	r3, r2
 80119c2:	9315      	str	r3, [sp, #84]	; 0x54
 80119c4:	211e      	movs	r1, #30
 80119c6:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80119c8:	f001 fb4a 	bl	8013060 <rotlFixed.lto_priv.491>
 80119cc:	9013      	str	r0, [sp, #76]	; 0x4c
 80119ce:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80119d0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80119d2:	405a      	eors	r2, r3
 80119d4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80119d6:	401a      	ands	r2, r3
 80119d8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80119da:	405a      	eors	r2, r3
 80119dc:	9b01      	ldr	r3, [sp, #4]
 80119de:	699b      	ldr	r3, [r3, #24]
 80119e0:	9306      	str	r3, [sp, #24]
 80119e2:	9b06      	ldr	r3, [sp, #24]
 80119e4:	18d4      	adds	r4, r2, r3
 80119e6:	2105      	movs	r1, #5
 80119e8:	9815      	ldr	r0, [sp, #84]	; 0x54
 80119ea:	f001 fb39 	bl	8013060 <rotlFixed.lto_priv.491>
 80119ee:	4603      	mov	r3, r0
 80119f0:	18e2      	adds	r2, r4, r3
 80119f2:	4b7f      	ldr	r3, [pc, #508]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 80119f4:	4413      	add	r3, r2
 80119f6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80119f8:	4413      	add	r3, r2
 80119fa:	9316      	str	r3, [sp, #88]	; 0x58
 80119fc:	211e      	movs	r1, #30
 80119fe:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011a00:	f001 fb2e 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a04:	9014      	str	r0, [sp, #80]	; 0x50
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
 8011a06:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011a08:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011a0a:	405a      	eors	r2, r3
 8011a0c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011a0e:	401a      	ands	r2, r3
 8011a10:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011a12:	405a      	eors	r2, r3
 8011a14:	9b01      	ldr	r3, [sp, #4]
 8011a16:	69db      	ldr	r3, [r3, #28]
 8011a18:	9307      	str	r3, [sp, #28]
 8011a1a:	9b07      	ldr	r3, [sp, #28]
 8011a1c:	18d4      	adds	r4, r2, r3
 8011a1e:	2105      	movs	r1, #5
 8011a20:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011a22:	f001 fb1d 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a26:	4603      	mov	r3, r0
 8011a28:	18e2      	adds	r2, r4, r3
 8011a2a:	4b71      	ldr	r3, [pc, #452]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011a2c:	4413      	add	r3, r2
 8011a2e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011a30:	4413      	add	r3, r2
 8011a32:	9317      	str	r3, [sp, #92]	; 0x5c
 8011a34:	211e      	movs	r1, #30
 8011a36:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011a38:	f001 fb12 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a3c:	9015      	str	r0, [sp, #84]	; 0x54
 8011a3e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011a40:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011a42:	405a      	eors	r2, r3
 8011a44:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011a46:	401a      	ands	r2, r3
 8011a48:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011a4a:	405a      	eors	r2, r3
 8011a4c:	9b01      	ldr	r3, [sp, #4]
 8011a4e:	6a1b      	ldr	r3, [r3, #32]
 8011a50:	9308      	str	r3, [sp, #32]
 8011a52:	9b08      	ldr	r3, [sp, #32]
 8011a54:	18d4      	adds	r4, r2, r3
 8011a56:	2105      	movs	r1, #5
 8011a58:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011a5a:	f001 fb01 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a5e:	4603      	mov	r3, r0
 8011a60:	18e2      	adds	r2, r4, r3
 8011a62:	4b63      	ldr	r3, [pc, #396]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011a64:	4413      	add	r3, r2
 8011a66:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011a68:	4413      	add	r3, r2
 8011a6a:	9313      	str	r3, [sp, #76]	; 0x4c
 8011a6c:	211e      	movs	r1, #30
 8011a6e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011a70:	f001 faf6 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a74:	9016      	str	r0, [sp, #88]	; 0x58
 8011a76:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011a78:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011a7a:	405a      	eors	r2, r3
 8011a7c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011a7e:	401a      	ands	r2, r3
 8011a80:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011a82:	405a      	eors	r2, r3
 8011a84:	9b01      	ldr	r3, [sp, #4]
 8011a86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011a88:	9309      	str	r3, [sp, #36]	; 0x24
 8011a8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011a8c:	18d4      	adds	r4, r2, r3
 8011a8e:	2105      	movs	r1, #5
 8011a90:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011a92:	f001 fae5 	bl	8013060 <rotlFixed.lto_priv.491>
 8011a96:	4603      	mov	r3, r0
 8011a98:	18e2      	adds	r2, r4, r3
 8011a9a:	4b55      	ldr	r3, [pc, #340]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011a9c:	4413      	add	r3, r2
 8011a9e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011aa0:	4413      	add	r3, r2
 8011aa2:	9314      	str	r3, [sp, #80]	; 0x50
 8011aa4:	211e      	movs	r1, #30
 8011aa6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011aa8:	f001 fada 	bl	8013060 <rotlFixed.lto_priv.491>
 8011aac:	9017      	str	r0, [sp, #92]	; 0x5c
 8011aae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011ab0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011ab2:	405a      	eors	r2, r3
 8011ab4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011ab6:	401a      	ands	r2, r3
 8011ab8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011aba:	405a      	eors	r2, r3
 8011abc:	9b01      	ldr	r3, [sp, #4]
 8011abe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011ac0:	930a      	str	r3, [sp, #40]	; 0x28
 8011ac2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011ac4:	18d4      	adds	r4, r2, r3
 8011ac6:	2105      	movs	r1, #5
 8011ac8:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011aca:	f001 fac9 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ace:	4603      	mov	r3, r0
 8011ad0:	18e2      	adds	r2, r4, r3
 8011ad2:	4b47      	ldr	r3, [pc, #284]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011ad4:	4413      	add	r3, r2
 8011ad6:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011ad8:	4413      	add	r3, r2
 8011ada:	9315      	str	r3, [sp, #84]	; 0x54
 8011adc:	211e      	movs	r1, #30
 8011ade:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011ae0:	f001 fabe 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ae4:	9013      	str	r0, [sp, #76]	; 0x4c
        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
 8011ae6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011ae8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011aea:	405a      	eors	r2, r3
 8011aec:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011aee:	401a      	ands	r2, r3
 8011af0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011af2:	405a      	eors	r2, r3
 8011af4:	9b01      	ldr	r3, [sp, #4]
 8011af6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011af8:	930b      	str	r3, [sp, #44]	; 0x2c
 8011afa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011afc:	18d4      	adds	r4, r2, r3
 8011afe:	2105      	movs	r1, #5
 8011b00:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011b02:	f001 faad 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b06:	4603      	mov	r3, r0
 8011b08:	18e2      	adds	r2, r4, r3
 8011b0a:	4b39      	ldr	r3, [pc, #228]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011b0c:	4413      	add	r3, r2
 8011b0e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011b10:	4413      	add	r3, r2
 8011b12:	9316      	str	r3, [sp, #88]	; 0x58
 8011b14:	211e      	movs	r1, #30
 8011b16:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011b18:	f001 faa2 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b1c:	9014      	str	r0, [sp, #80]	; 0x50
 8011b1e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011b20:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011b22:	405a      	eors	r2, r3
 8011b24:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011b26:	401a      	ands	r2, r3
 8011b28:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011b2a:	405a      	eors	r2, r3
 8011b2c:	9b01      	ldr	r3, [sp, #4]
 8011b2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011b30:	930c      	str	r3, [sp, #48]	; 0x30
 8011b32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011b34:	18d4      	adds	r4, r2, r3
 8011b36:	2105      	movs	r1, #5
 8011b38:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011b3a:	f001 fa91 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b3e:	4603      	mov	r3, r0
 8011b40:	18e2      	adds	r2, r4, r3
 8011b42:	4b2b      	ldr	r3, [pc, #172]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011b44:	4413      	add	r3, r2
 8011b46:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011b48:	4413      	add	r3, r2
 8011b4a:	9317      	str	r3, [sp, #92]	; 0x5c
 8011b4c:	211e      	movs	r1, #30
 8011b4e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011b50:	f001 fa86 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b54:	9015      	str	r0, [sp, #84]	; 0x54
 8011b56:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011b58:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011b5a:	405a      	eors	r2, r3
 8011b5c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011b5e:	401a      	ands	r2, r3
 8011b60:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011b62:	405a      	eors	r2, r3
 8011b64:	9b01      	ldr	r3, [sp, #4]
 8011b66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011b68:	930d      	str	r3, [sp, #52]	; 0x34
 8011b6a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011b6c:	18d4      	adds	r4, r2, r3
 8011b6e:	2105      	movs	r1, #5
 8011b70:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011b72:	f001 fa75 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b76:	4603      	mov	r3, r0
 8011b78:	18e2      	adds	r2, r4, r3
 8011b7a:	4b1d      	ldr	r3, [pc, #116]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011b7c:	4413      	add	r3, r2
 8011b7e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011b80:	4413      	add	r3, r2
 8011b82:	9313      	str	r3, [sp, #76]	; 0x4c
 8011b84:	211e      	movs	r1, #30
 8011b86:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011b88:	f001 fa6a 	bl	8013060 <rotlFixed.lto_priv.491>
 8011b8c:	9016      	str	r0, [sp, #88]	; 0x58
 8011b8e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011b90:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011b92:	405a      	eors	r2, r3
 8011b94:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011b96:	401a      	ands	r2, r3
 8011b98:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011b9a:	405a      	eors	r2, r3
 8011b9c:	9b01      	ldr	r3, [sp, #4]
 8011b9e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011ba0:	930e      	str	r3, [sp, #56]	; 0x38
 8011ba2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011ba4:	18d4      	adds	r4, r2, r3
 8011ba6:	2105      	movs	r1, #5
 8011ba8:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011baa:	f001 fa59 	bl	8013060 <rotlFixed.lto_priv.491>
 8011bae:	4603      	mov	r3, r0
 8011bb0:	18e2      	adds	r2, r4, r3
 8011bb2:	4b0f      	ldr	r3, [pc, #60]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011bb4:	4413      	add	r3, r2
 8011bb6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011bb8:	4413      	add	r3, r2
 8011bba:	9314      	str	r3, [sp, #80]	; 0x50
 8011bbc:	211e      	movs	r1, #30
 8011bbe:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011bc0:	f001 fa4e 	bl	8013060 <rotlFixed.lto_priv.491>
 8011bc4:	9017      	str	r0, [sp, #92]	; 0x5c
        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
 8011bc6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011bc8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011bca:	405a      	eors	r2, r3
 8011bcc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011bce:	401a      	ands	r2, r3
 8011bd0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011bd2:	405a      	eors	r2, r3
 8011bd4:	9b01      	ldr	r3, [sp, #4]
 8011bd6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011bd8:	930f      	str	r3, [sp, #60]	; 0x3c
 8011bda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011bdc:	18d4      	adds	r4, r2, r3
 8011bde:	2105      	movs	r1, #5
 8011be0:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011be2:	f001 fa3d 	bl	8013060 <rotlFixed.lto_priv.491>
 8011be6:	4603      	mov	r3, r0
 8011be8:	18e2      	adds	r2, r4, r3
 8011bea:	4b01      	ldr	r3, [pc, #4]	; (8011bf0 <Transform.lto_priv.488+0x2f0>)
 8011bec:	4413      	add	r3, r2
 8011bee:	e001      	b.n	8011bf4 <Transform.lto_priv.488+0x2f4>
 8011bf0:	5a827999 	.word	0x5a827999
 8011bf4:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011bf6:	4413      	add	r3, r2
 8011bf8:	9315      	str	r3, [sp, #84]	; 0x54
 8011bfa:	211e      	movs	r1, #30
 8011bfc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011bfe:	f001 fa2f 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c02:	9013      	str	r0, [sp, #76]	; 0x4c
 8011c04:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011c06:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011c08:	405a      	eors	r2, r3
 8011c0a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011c0c:	401a      	ands	r2, r3
 8011c0e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011c10:	405a      	eors	r2, r3
 8011c12:	9b01      	ldr	r3, [sp, #4]
 8011c14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011c16:	9310      	str	r3, [sp, #64]	; 0x40
 8011c18:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011c1a:	18d4      	adds	r4, r2, r3
 8011c1c:	2105      	movs	r1, #5
 8011c1e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011c20:	f001 fa1e 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c24:	4603      	mov	r3, r0
 8011c26:	18e2      	adds	r2, r4, r3
 8011c28:	4bb2      	ldr	r3, [pc, #712]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011c2a:	4413      	add	r3, r2
 8011c2c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011c2e:	4413      	add	r3, r2
 8011c30:	9316      	str	r3, [sp, #88]	; 0x58
 8011c32:	211e      	movs	r1, #30
 8011c34:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011c36:	f001 fa13 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c3a:	9014      	str	r0, [sp, #80]	; 0x50
 8011c3c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011c3e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011c40:	405a      	eors	r2, r3
 8011c42:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011c44:	401a      	ands	r2, r3
 8011c46:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011c48:	405a      	eors	r2, r3
 8011c4a:	9b01      	ldr	r3, [sp, #4]
 8011c4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011c4e:	9311      	str	r3, [sp, #68]	; 0x44
 8011c50:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8011c52:	18d4      	adds	r4, r2, r3
 8011c54:	2105      	movs	r1, #5
 8011c56:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011c58:	f001 fa02 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c5c:	4603      	mov	r3, r0
 8011c5e:	18e2      	adds	r2, r4, r3
 8011c60:	4ba4      	ldr	r3, [pc, #656]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011c62:	4413      	add	r3, r2
 8011c64:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011c66:	4413      	add	r3, r2
 8011c68:	9317      	str	r3, [sp, #92]	; 0x5c
 8011c6a:	211e      	movs	r1, #30
 8011c6c:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011c6e:	f001 f9f7 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c72:	9015      	str	r0, [sp, #84]	; 0x54
 8011c74:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011c76:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011c78:	405a      	eors	r2, r3
 8011c7a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011c7c:	401a      	ands	r2, r3
 8011c7e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011c80:	405a      	eors	r2, r3
 8011c82:	9b01      	ldr	r3, [sp, #4]
 8011c84:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011c86:	9312      	str	r3, [sp, #72]	; 0x48
 8011c88:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8011c8a:	18d4      	adds	r4, r2, r3
 8011c8c:	2105      	movs	r1, #5
 8011c8e:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011c90:	f001 f9e6 	bl	8013060 <rotlFixed.lto_priv.491>
 8011c94:	4603      	mov	r3, r0
 8011c96:	18e2      	adds	r2, r4, r3
 8011c98:	4b96      	ldr	r3, [pc, #600]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011c9a:	4413      	add	r3, r2
 8011c9c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011c9e:	4413      	add	r3, r2
 8011ca0:	9313      	str	r3, [sp, #76]	; 0x4c
 8011ca2:	211e      	movs	r1, #30
 8011ca4:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011ca6:	f001 f9db 	bl	8013060 <rotlFixed.lto_priv.491>
 8011caa:	9016      	str	r0, [sp, #88]	; 0x58
        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 8011cac:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011cae:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011cb0:	405a      	eors	r2, r3
 8011cb2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011cb4:	401a      	ands	r2, r3
 8011cb6:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011cb8:	ea82 0403 	eor.w	r4, r2, r3
 8011cbc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8011cbe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011cc0:	405a      	eors	r2, r3
 8011cc2:	9b05      	ldr	r3, [sp, #20]
 8011cc4:	405a      	eors	r2, r3
 8011cc6:	9b03      	ldr	r3, [sp, #12]
 8011cc8:	4053      	eors	r3, r2
 8011cca:	2101      	movs	r1, #1
 8011ccc:	4618      	mov	r0, r3
 8011cce:	f001 f9c7 	bl	8013060 <rotlFixed.lto_priv.491>
 8011cd2:	4603      	mov	r3, r0
 8011cd4:	9303      	str	r3, [sp, #12]
 8011cd6:	9b03      	ldr	r3, [sp, #12]
 8011cd8:	441c      	add	r4, r3
 8011cda:	2105      	movs	r1, #5
 8011cdc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011cde:	f001 f9bf 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ce2:	4603      	mov	r3, r0
 8011ce4:	18e2      	adds	r2, r4, r3
 8011ce6:	4b83      	ldr	r3, [pc, #524]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011ce8:	4413      	add	r3, r2
 8011cea:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011cec:	4413      	add	r3, r2
 8011cee:	9314      	str	r3, [sp, #80]	; 0x50
 8011cf0:	211e      	movs	r1, #30
 8011cf2:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011cf4:	f001 f9b4 	bl	8013060 <rotlFixed.lto_priv.491>
 8011cf8:	9017      	str	r0, [sp, #92]	; 0x5c
 8011cfa:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011cfc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011cfe:	405a      	eors	r2, r3
 8011d00:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011d02:	401a      	ands	r2, r3
 8011d04:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011d06:	ea82 0403 	eor.w	r4, r2, r3
 8011d0a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8011d0c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011d0e:	405a      	eors	r2, r3
 8011d10:	9b06      	ldr	r3, [sp, #24]
 8011d12:	405a      	eors	r2, r3
 8011d14:	9b04      	ldr	r3, [sp, #16]
 8011d16:	4053      	eors	r3, r2
 8011d18:	2101      	movs	r1, #1
 8011d1a:	4618      	mov	r0, r3
 8011d1c:	f001 f9a0 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d20:	4603      	mov	r3, r0
 8011d22:	9304      	str	r3, [sp, #16]
 8011d24:	9b04      	ldr	r3, [sp, #16]
 8011d26:	441c      	add	r4, r3
 8011d28:	2105      	movs	r1, #5
 8011d2a:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011d2c:	f001 f998 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d30:	4603      	mov	r3, r0
 8011d32:	18e2      	adds	r2, r4, r3
 8011d34:	4b6f      	ldr	r3, [pc, #444]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011d36:	4413      	add	r3, r2
 8011d38:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011d3a:	4413      	add	r3, r2
 8011d3c:	9315      	str	r3, [sp, #84]	; 0x54
 8011d3e:	211e      	movs	r1, #30
 8011d40:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011d42:	f001 f98d 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d46:	9013      	str	r0, [sp, #76]	; 0x4c
 8011d48:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011d4a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011d4c:	405a      	eors	r2, r3
 8011d4e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011d50:	401a      	ands	r2, r3
 8011d52:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011d54:	ea82 0403 	eor.w	r4, r2, r3
 8011d58:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8011d5a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011d5c:	405a      	eors	r2, r3
 8011d5e:	9b07      	ldr	r3, [sp, #28]
 8011d60:	405a      	eors	r2, r3
 8011d62:	9b05      	ldr	r3, [sp, #20]
 8011d64:	4053      	eors	r3, r2
 8011d66:	2101      	movs	r1, #1
 8011d68:	4618      	mov	r0, r3
 8011d6a:	f001 f979 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d6e:	4603      	mov	r3, r0
 8011d70:	9305      	str	r3, [sp, #20]
 8011d72:	9b05      	ldr	r3, [sp, #20]
 8011d74:	441c      	add	r4, r3
 8011d76:	2105      	movs	r1, #5
 8011d78:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011d7a:	f001 f971 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d7e:	4603      	mov	r3, r0
 8011d80:	18e2      	adds	r2, r4, r3
 8011d82:	4b5c      	ldr	r3, [pc, #368]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011d84:	4413      	add	r3, r2
 8011d86:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011d88:	4413      	add	r3, r2
 8011d8a:	9316      	str	r3, [sp, #88]	; 0x58
 8011d8c:	211e      	movs	r1, #30
 8011d8e:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011d90:	f001 f966 	bl	8013060 <rotlFixed.lto_priv.491>
 8011d94:	9014      	str	r0, [sp, #80]	; 0x50
 8011d96:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011d98:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011d9a:	405a      	eors	r2, r3
 8011d9c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011d9e:	401a      	ands	r2, r3
 8011da0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011da2:	ea82 0403 	eor.w	r4, r2, r3
 8011da6:	9a03      	ldr	r2, [sp, #12]
 8011da8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011daa:	405a      	eors	r2, r3
 8011dac:	9b08      	ldr	r3, [sp, #32]
 8011dae:	405a      	eors	r2, r3
 8011db0:	9b06      	ldr	r3, [sp, #24]
 8011db2:	4053      	eors	r3, r2
 8011db4:	2101      	movs	r1, #1
 8011db6:	4618      	mov	r0, r3
 8011db8:	f001 f952 	bl	8013060 <rotlFixed.lto_priv.491>
 8011dbc:	4603      	mov	r3, r0
 8011dbe:	9306      	str	r3, [sp, #24]
 8011dc0:	9b06      	ldr	r3, [sp, #24]
 8011dc2:	441c      	add	r4, r3
 8011dc4:	2105      	movs	r1, #5
 8011dc6:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011dc8:	f001 f94a 	bl	8013060 <rotlFixed.lto_priv.491>
 8011dcc:	4603      	mov	r3, r0
 8011dce:	18e2      	adds	r2, r4, r3
 8011dd0:	4b48      	ldr	r3, [pc, #288]	; (8011ef4 <Transform.lto_priv.488+0x5f4>)
 8011dd2:	4413      	add	r3, r2
 8011dd4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011dd6:	4413      	add	r3, r2
 8011dd8:	9317      	str	r3, [sp, #92]	; 0x5c
 8011dda:	211e      	movs	r1, #30
 8011ddc:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011dde:	f001 f93f 	bl	8013060 <rotlFixed.lto_priv.491>
 8011de2:	9015      	str	r0, [sp, #84]	; 0x54
        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 8011de4:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011de6:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011de8:	405a      	eors	r2, r3
 8011dea:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011dec:	ea82 0403 	eor.w	r4, r2, r3
 8011df0:	9a04      	ldr	r2, [sp, #16]
 8011df2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011df4:	405a      	eors	r2, r3
 8011df6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011df8:	405a      	eors	r2, r3
 8011dfa:	9b07      	ldr	r3, [sp, #28]
 8011dfc:	4053      	eors	r3, r2
 8011dfe:	2101      	movs	r1, #1
 8011e00:	4618      	mov	r0, r3
 8011e02:	f001 f92d 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e06:	4603      	mov	r3, r0
 8011e08:	9307      	str	r3, [sp, #28]
 8011e0a:	9b07      	ldr	r3, [sp, #28]
 8011e0c:	441c      	add	r4, r3
 8011e0e:	2105      	movs	r1, #5
 8011e10:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011e12:	f001 f925 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e16:	4603      	mov	r3, r0
 8011e18:	18e2      	adds	r2, r4, r3
 8011e1a:	4b37      	ldr	r3, [pc, #220]	; (8011ef8 <Transform.lto_priv.488+0x5f8>)
 8011e1c:	4413      	add	r3, r2
 8011e1e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011e20:	4413      	add	r3, r2
 8011e22:	9313      	str	r3, [sp, #76]	; 0x4c
 8011e24:	211e      	movs	r1, #30
 8011e26:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011e28:	f001 f91a 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e2c:	9016      	str	r0, [sp, #88]	; 0x58
 8011e2e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011e30:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011e32:	405a      	eors	r2, r3
 8011e34:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011e36:	ea82 0403 	eor.w	r4, r2, r3
 8011e3a:	9a05      	ldr	r2, [sp, #20]
 8011e3c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011e3e:	405a      	eors	r2, r3
 8011e40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011e42:	405a      	eors	r2, r3
 8011e44:	9b08      	ldr	r3, [sp, #32]
 8011e46:	4053      	eors	r3, r2
 8011e48:	2101      	movs	r1, #1
 8011e4a:	4618      	mov	r0, r3
 8011e4c:	f001 f908 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e50:	4603      	mov	r3, r0
 8011e52:	9308      	str	r3, [sp, #32]
 8011e54:	9b08      	ldr	r3, [sp, #32]
 8011e56:	441c      	add	r4, r3
 8011e58:	2105      	movs	r1, #5
 8011e5a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011e5c:	f001 f900 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e60:	4603      	mov	r3, r0
 8011e62:	18e2      	adds	r2, r4, r3
 8011e64:	4b24      	ldr	r3, [pc, #144]	; (8011ef8 <Transform.lto_priv.488+0x5f8>)
 8011e66:	4413      	add	r3, r2
 8011e68:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011e6a:	4413      	add	r3, r2
 8011e6c:	9314      	str	r3, [sp, #80]	; 0x50
 8011e6e:	211e      	movs	r1, #30
 8011e70:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011e72:	f001 f8f5 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e76:	9017      	str	r0, [sp, #92]	; 0x5c
 8011e78:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011e7a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011e7c:	405a      	eors	r2, r3
 8011e7e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011e80:	ea82 0403 	eor.w	r4, r2, r3
 8011e84:	9a06      	ldr	r2, [sp, #24]
 8011e86:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8011e88:	405a      	eors	r2, r3
 8011e8a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011e8c:	405a      	eors	r2, r3
 8011e8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011e90:	4053      	eors	r3, r2
 8011e92:	2101      	movs	r1, #1
 8011e94:	4618      	mov	r0, r3
 8011e96:	f001 f8e3 	bl	8013060 <rotlFixed.lto_priv.491>
 8011e9a:	4603      	mov	r3, r0
 8011e9c:	9309      	str	r3, [sp, #36]	; 0x24
 8011e9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011ea0:	441c      	add	r4, r3
 8011ea2:	2105      	movs	r1, #5
 8011ea4:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011ea6:	f001 f8db 	bl	8013060 <rotlFixed.lto_priv.491>
 8011eaa:	4603      	mov	r3, r0
 8011eac:	18e2      	adds	r2, r4, r3
 8011eae:	4b12      	ldr	r3, [pc, #72]	; (8011ef8 <Transform.lto_priv.488+0x5f8>)
 8011eb0:	4413      	add	r3, r2
 8011eb2:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011eb4:	4413      	add	r3, r2
 8011eb6:	9315      	str	r3, [sp, #84]	; 0x54
 8011eb8:	211e      	movs	r1, #30
 8011eba:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011ebc:	f001 f8d0 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ec0:	9013      	str	r0, [sp, #76]	; 0x4c
 8011ec2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011ec4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011ec6:	405a      	eors	r2, r3
 8011ec8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011eca:	ea82 0403 	eor.w	r4, r2, r3
 8011ece:	9a07      	ldr	r2, [sp, #28]
 8011ed0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8011ed2:	405a      	eors	r2, r3
 8011ed4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011ed6:	405a      	eors	r2, r3
 8011ed8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011eda:	4053      	eors	r3, r2
 8011edc:	2101      	movs	r1, #1
 8011ede:	4618      	mov	r0, r3
 8011ee0:	f001 f8be 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ee4:	4603      	mov	r3, r0
 8011ee6:	930a      	str	r3, [sp, #40]	; 0x28
 8011ee8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011eea:	441c      	add	r4, r3
 8011eec:	2105      	movs	r1, #5
 8011eee:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011ef0:	e004      	b.n	8011efc <Transform.lto_priv.488+0x5fc>
 8011ef2:	bf00      	nop
 8011ef4:	5a827999 	.word	0x5a827999
 8011ef8:	6ed9eba1 	.word	0x6ed9eba1
 8011efc:	f001 f8b0 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f00:	4603      	mov	r3, r0
 8011f02:	18e2      	adds	r2, r4, r3
 8011f04:	4bb4      	ldr	r3, [pc, #720]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8011f06:	4413      	add	r3, r2
 8011f08:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011f0a:	4413      	add	r3, r2
 8011f0c:	9316      	str	r3, [sp, #88]	; 0x58
 8011f0e:	211e      	movs	r1, #30
 8011f10:	9814      	ldr	r0, [sp, #80]	; 0x50
 8011f12:	f001 f8a5 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f16:	9014      	str	r0, [sp, #80]	; 0x50
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 8011f18:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011f1a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011f1c:	405a      	eors	r2, r3
 8011f1e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011f20:	ea82 0403 	eor.w	r4, r2, r3
 8011f24:	9a08      	ldr	r2, [sp, #32]
 8011f26:	9b03      	ldr	r3, [sp, #12]
 8011f28:	405a      	eors	r2, r3
 8011f2a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011f2c:	405a      	eors	r2, r3
 8011f2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011f30:	4053      	eors	r3, r2
 8011f32:	2101      	movs	r1, #1
 8011f34:	4618      	mov	r0, r3
 8011f36:	f001 f893 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f3a:	4603      	mov	r3, r0
 8011f3c:	930b      	str	r3, [sp, #44]	; 0x2c
 8011f3e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011f40:	441c      	add	r4, r3
 8011f42:	2105      	movs	r1, #5
 8011f44:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011f46:	f001 f88b 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f4a:	4603      	mov	r3, r0
 8011f4c:	18e2      	adds	r2, r4, r3
 8011f4e:	4ba2      	ldr	r3, [pc, #648]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8011f50:	4413      	add	r3, r2
 8011f52:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011f54:	4413      	add	r3, r2
 8011f56:	9317      	str	r3, [sp, #92]	; 0x5c
 8011f58:	211e      	movs	r1, #30
 8011f5a:	9815      	ldr	r0, [sp, #84]	; 0x54
 8011f5c:	f001 f880 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f60:	9015      	str	r0, [sp, #84]	; 0x54
 8011f62:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011f64:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011f66:	405a      	eors	r2, r3
 8011f68:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011f6a:	ea82 0403 	eor.w	r4, r2, r3
 8011f6e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011f70:	9b04      	ldr	r3, [sp, #16]
 8011f72:	405a      	eors	r2, r3
 8011f74:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011f76:	405a      	eors	r2, r3
 8011f78:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011f7a:	4053      	eors	r3, r2
 8011f7c:	2101      	movs	r1, #1
 8011f7e:	4618      	mov	r0, r3
 8011f80:	f001 f86e 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f84:	4603      	mov	r3, r0
 8011f86:	930c      	str	r3, [sp, #48]	; 0x30
 8011f88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011f8a:	441c      	add	r4, r3
 8011f8c:	2105      	movs	r1, #5
 8011f8e:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011f90:	f001 f866 	bl	8013060 <rotlFixed.lto_priv.491>
 8011f94:	4603      	mov	r3, r0
 8011f96:	18e2      	adds	r2, r4, r3
 8011f98:	4b8f      	ldr	r3, [pc, #572]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8011f9a:	4413      	add	r3, r2
 8011f9c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011f9e:	4413      	add	r3, r2
 8011fa0:	9313      	str	r3, [sp, #76]	; 0x4c
 8011fa2:	211e      	movs	r1, #30
 8011fa4:	9816      	ldr	r0, [sp, #88]	; 0x58
 8011fa6:	f001 f85b 	bl	8013060 <rotlFixed.lto_priv.491>
 8011faa:	9016      	str	r0, [sp, #88]	; 0x58
 8011fac:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8011fae:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011fb0:	405a      	eors	r2, r3
 8011fb2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011fb4:	ea82 0403 	eor.w	r4, r2, r3
 8011fb8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011fba:	9b05      	ldr	r3, [sp, #20]
 8011fbc:	405a      	eors	r2, r3
 8011fbe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011fc0:	405a      	eors	r2, r3
 8011fc2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011fc4:	4053      	eors	r3, r2
 8011fc6:	2101      	movs	r1, #1
 8011fc8:	4618      	mov	r0, r3
 8011fca:	f001 f849 	bl	8013060 <rotlFixed.lto_priv.491>
 8011fce:	4603      	mov	r3, r0
 8011fd0:	930d      	str	r3, [sp, #52]	; 0x34
 8011fd2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011fd4:	441c      	add	r4, r3
 8011fd6:	2105      	movs	r1, #5
 8011fd8:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8011fda:	f001 f841 	bl	8013060 <rotlFixed.lto_priv.491>
 8011fde:	4603      	mov	r3, r0
 8011fe0:	18e2      	adds	r2, r4, r3
 8011fe2:	4b7d      	ldr	r3, [pc, #500]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8011fe4:	4413      	add	r3, r2
 8011fe6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011fe8:	4413      	add	r3, r2
 8011fea:	9314      	str	r3, [sp, #80]	; 0x50
 8011fec:	211e      	movs	r1, #30
 8011fee:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8011ff0:	f001 f836 	bl	8013060 <rotlFixed.lto_priv.491>
 8011ff4:	9017      	str	r0, [sp, #92]	; 0x5c
 8011ff6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011ff8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011ffa:	405a      	eors	r2, r3
 8011ffc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011ffe:	ea82 0403 	eor.w	r4, r2, r3
 8012002:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012004:	9b06      	ldr	r3, [sp, #24]
 8012006:	405a      	eors	r2, r3
 8012008:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801200a:	405a      	eors	r2, r3
 801200c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801200e:	4053      	eors	r3, r2
 8012010:	2101      	movs	r1, #1
 8012012:	4618      	mov	r0, r3
 8012014:	f001 f824 	bl	8013060 <rotlFixed.lto_priv.491>
 8012018:	4603      	mov	r3, r0
 801201a:	930e      	str	r3, [sp, #56]	; 0x38
 801201c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801201e:	441c      	add	r4, r3
 8012020:	2105      	movs	r1, #5
 8012022:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012024:	f001 f81c 	bl	8013060 <rotlFixed.lto_priv.491>
 8012028:	4603      	mov	r3, r0
 801202a:	18e2      	adds	r2, r4, r3
 801202c:	4b6a      	ldr	r3, [pc, #424]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 801202e:	4413      	add	r3, r2
 8012030:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012032:	4413      	add	r3, r2
 8012034:	9315      	str	r3, [sp, #84]	; 0x54
 8012036:	211e      	movs	r1, #30
 8012038:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801203a:	f001 f811 	bl	8013060 <rotlFixed.lto_priv.491>
 801203e:	9013      	str	r0, [sp, #76]	; 0x4c
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 8012040:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012042:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012044:	405a      	eors	r2, r3
 8012046:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012048:	ea82 0403 	eor.w	r4, r2, r3
 801204c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801204e:	9b07      	ldr	r3, [sp, #28]
 8012050:	405a      	eors	r2, r3
 8012052:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012054:	405a      	eors	r2, r3
 8012056:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012058:	4053      	eors	r3, r2
 801205a:	2101      	movs	r1, #1
 801205c:	4618      	mov	r0, r3
 801205e:	f000 ffff 	bl	8013060 <rotlFixed.lto_priv.491>
 8012062:	4603      	mov	r3, r0
 8012064:	930f      	str	r3, [sp, #60]	; 0x3c
 8012066:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012068:	441c      	add	r4, r3
 801206a:	2105      	movs	r1, #5
 801206c:	9815      	ldr	r0, [sp, #84]	; 0x54
 801206e:	f000 fff7 	bl	8013060 <rotlFixed.lto_priv.491>
 8012072:	4603      	mov	r3, r0
 8012074:	18e2      	adds	r2, r4, r3
 8012076:	4b58      	ldr	r3, [pc, #352]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8012078:	4413      	add	r3, r2
 801207a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801207c:	4413      	add	r3, r2
 801207e:	9316      	str	r3, [sp, #88]	; 0x58
 8012080:	211e      	movs	r1, #30
 8012082:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012084:	f000 ffec 	bl	8013060 <rotlFixed.lto_priv.491>
 8012088:	9014      	str	r0, [sp, #80]	; 0x50
 801208a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801208c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801208e:	405a      	eors	r2, r3
 8012090:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012092:	ea82 0403 	eor.w	r4, r2, r3
 8012096:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012098:	9b08      	ldr	r3, [sp, #32]
 801209a:	405a      	eors	r2, r3
 801209c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801209e:	405a      	eors	r2, r3
 80120a0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80120a2:	4053      	eors	r3, r2
 80120a4:	2101      	movs	r1, #1
 80120a6:	4618      	mov	r0, r3
 80120a8:	f000 ffda 	bl	8013060 <rotlFixed.lto_priv.491>
 80120ac:	4603      	mov	r3, r0
 80120ae:	9310      	str	r3, [sp, #64]	; 0x40
 80120b0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80120b2:	441c      	add	r4, r3
 80120b4:	2105      	movs	r1, #5
 80120b6:	9816      	ldr	r0, [sp, #88]	; 0x58
 80120b8:	f000 ffd2 	bl	8013060 <rotlFixed.lto_priv.491>
 80120bc:	4603      	mov	r3, r0
 80120be:	18e2      	adds	r2, r4, r3
 80120c0:	4b45      	ldr	r3, [pc, #276]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 80120c2:	4413      	add	r3, r2
 80120c4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80120c6:	4413      	add	r3, r2
 80120c8:	9317      	str	r3, [sp, #92]	; 0x5c
 80120ca:	211e      	movs	r1, #30
 80120cc:	9815      	ldr	r0, [sp, #84]	; 0x54
 80120ce:	f000 ffc7 	bl	8013060 <rotlFixed.lto_priv.491>
 80120d2:	9015      	str	r0, [sp, #84]	; 0x54
 80120d4:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80120d6:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80120d8:	405a      	eors	r2, r3
 80120da:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80120dc:	ea82 0403 	eor.w	r4, r2, r3
 80120e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80120e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80120e4:	405a      	eors	r2, r3
 80120e6:	9b03      	ldr	r3, [sp, #12]
 80120e8:	405a      	eors	r2, r3
 80120ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80120ec:	4053      	eors	r3, r2
 80120ee:	2101      	movs	r1, #1
 80120f0:	4618      	mov	r0, r3
 80120f2:	f000 ffb5 	bl	8013060 <rotlFixed.lto_priv.491>
 80120f6:	4603      	mov	r3, r0
 80120f8:	9311      	str	r3, [sp, #68]	; 0x44
 80120fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80120fc:	441c      	add	r4, r3
 80120fe:	2105      	movs	r1, #5
 8012100:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012102:	f000 ffad 	bl	8013060 <rotlFixed.lto_priv.491>
 8012106:	4603      	mov	r3, r0
 8012108:	18e2      	adds	r2, r4, r3
 801210a:	4b33      	ldr	r3, [pc, #204]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 801210c:	4413      	add	r3, r2
 801210e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012110:	4413      	add	r3, r2
 8012112:	9313      	str	r3, [sp, #76]	; 0x4c
 8012114:	211e      	movs	r1, #30
 8012116:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012118:	f000 ffa2 	bl	8013060 <rotlFixed.lto_priv.491>
 801211c:	9016      	str	r0, [sp, #88]	; 0x58
 801211e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012120:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012122:	405a      	eors	r2, r3
 8012124:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012126:	ea82 0403 	eor.w	r4, r2, r3
 801212a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801212c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801212e:	405a      	eors	r2, r3
 8012130:	9b04      	ldr	r3, [sp, #16]
 8012132:	405a      	eors	r2, r3
 8012134:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012136:	4053      	eors	r3, r2
 8012138:	2101      	movs	r1, #1
 801213a:	4618      	mov	r0, r3
 801213c:	f000 ff90 	bl	8013060 <rotlFixed.lto_priv.491>
 8012140:	4603      	mov	r3, r0
 8012142:	9312      	str	r3, [sp, #72]	; 0x48
 8012144:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012146:	441c      	add	r4, r3
 8012148:	2105      	movs	r1, #5
 801214a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801214c:	f000 ff88 	bl	8013060 <rotlFixed.lto_priv.491>
 8012150:	4603      	mov	r3, r0
 8012152:	18e2      	adds	r2, r4, r3
 8012154:	4b20      	ldr	r3, [pc, #128]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 8012156:	4413      	add	r3, r2
 8012158:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801215a:	4413      	add	r3, r2
 801215c:	9314      	str	r3, [sp, #80]	; 0x50
 801215e:	211e      	movs	r1, #30
 8012160:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012162:	f000 ff7d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012166:	9017      	str	r0, [sp, #92]	; 0x5c
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 8012168:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801216a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801216c:	405a      	eors	r2, r3
 801216e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012170:	ea82 0403 	eor.w	r4, r2, r3
 8012174:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8012176:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012178:	405a      	eors	r2, r3
 801217a:	9b05      	ldr	r3, [sp, #20]
 801217c:	405a      	eors	r2, r3
 801217e:	9b03      	ldr	r3, [sp, #12]
 8012180:	4053      	eors	r3, r2
 8012182:	2101      	movs	r1, #1
 8012184:	4618      	mov	r0, r3
 8012186:	f000 ff6b 	bl	8013060 <rotlFixed.lto_priv.491>
 801218a:	4603      	mov	r3, r0
 801218c:	9303      	str	r3, [sp, #12]
 801218e:	9b03      	ldr	r3, [sp, #12]
 8012190:	441c      	add	r4, r3
 8012192:	2105      	movs	r1, #5
 8012194:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012196:	f000 ff63 	bl	8013060 <rotlFixed.lto_priv.491>
 801219a:	4603      	mov	r3, r0
 801219c:	18e2      	adds	r2, r4, r3
 801219e:	4b0e      	ldr	r3, [pc, #56]	; (80121d8 <Transform.lto_priv.488+0x8d8>)
 80121a0:	4413      	add	r3, r2
 80121a2:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80121a4:	4413      	add	r3, r2
 80121a6:	9315      	str	r3, [sp, #84]	; 0x54
 80121a8:	211e      	movs	r1, #30
 80121aa:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80121ac:	f000 ff58 	bl	8013060 <rotlFixed.lto_priv.491>
 80121b0:	9013      	str	r0, [sp, #76]	; 0x4c
 80121b2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80121b4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80121b6:	405a      	eors	r2, r3
 80121b8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80121ba:	ea82 0403 	eor.w	r4, r2, r3
 80121be:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80121c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80121c2:	405a      	eors	r2, r3
 80121c4:	9b06      	ldr	r3, [sp, #24]
 80121c6:	405a      	eors	r2, r3
 80121c8:	9b04      	ldr	r3, [sp, #16]
 80121ca:	4053      	eors	r3, r2
 80121cc:	2101      	movs	r1, #1
 80121ce:	4618      	mov	r0, r3
 80121d0:	f000 ff46 	bl	8013060 <rotlFixed.lto_priv.491>
 80121d4:	4603      	mov	r3, r0
 80121d6:	e001      	b.n	80121dc <Transform.lto_priv.488+0x8dc>
 80121d8:	6ed9eba1 	.word	0x6ed9eba1
 80121dc:	9304      	str	r3, [sp, #16]
 80121de:	9b04      	ldr	r3, [sp, #16]
 80121e0:	441c      	add	r4, r3
 80121e2:	2105      	movs	r1, #5
 80121e4:	9815      	ldr	r0, [sp, #84]	; 0x54
 80121e6:	f000 ff3b 	bl	8013060 <rotlFixed.lto_priv.491>
 80121ea:	4603      	mov	r3, r0
 80121ec:	18e2      	adds	r2, r4, r3
 80121ee:	4bb4      	ldr	r3, [pc, #720]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 80121f0:	4413      	add	r3, r2
 80121f2:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80121f4:	4413      	add	r3, r2
 80121f6:	9316      	str	r3, [sp, #88]	; 0x58
 80121f8:	211e      	movs	r1, #30
 80121fa:	9814      	ldr	r0, [sp, #80]	; 0x50
 80121fc:	f000 ff30 	bl	8013060 <rotlFixed.lto_priv.491>
 8012200:	9014      	str	r0, [sp, #80]	; 0x50
 8012202:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012204:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012206:	405a      	eors	r2, r3
 8012208:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801220a:	ea82 0403 	eor.w	r4, r2, r3
 801220e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8012210:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012212:	405a      	eors	r2, r3
 8012214:	9b07      	ldr	r3, [sp, #28]
 8012216:	405a      	eors	r2, r3
 8012218:	9b05      	ldr	r3, [sp, #20]
 801221a:	4053      	eors	r3, r2
 801221c:	2101      	movs	r1, #1
 801221e:	4618      	mov	r0, r3
 8012220:	f000 ff1e 	bl	8013060 <rotlFixed.lto_priv.491>
 8012224:	4603      	mov	r3, r0
 8012226:	9305      	str	r3, [sp, #20]
 8012228:	9b05      	ldr	r3, [sp, #20]
 801222a:	441c      	add	r4, r3
 801222c:	2105      	movs	r1, #5
 801222e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012230:	f000 ff16 	bl	8013060 <rotlFixed.lto_priv.491>
 8012234:	4603      	mov	r3, r0
 8012236:	18e2      	adds	r2, r4, r3
 8012238:	4ba1      	ldr	r3, [pc, #644]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 801223a:	4413      	add	r3, r2
 801223c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801223e:	4413      	add	r3, r2
 8012240:	9317      	str	r3, [sp, #92]	; 0x5c
 8012242:	211e      	movs	r1, #30
 8012244:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012246:	f000 ff0b 	bl	8013060 <rotlFixed.lto_priv.491>
 801224a:	9015      	str	r0, [sp, #84]	; 0x54
 801224c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801224e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012250:	405a      	eors	r2, r3
 8012252:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012254:	ea82 0403 	eor.w	r4, r2, r3
 8012258:	9a03      	ldr	r2, [sp, #12]
 801225a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801225c:	405a      	eors	r2, r3
 801225e:	9b08      	ldr	r3, [sp, #32]
 8012260:	405a      	eors	r2, r3
 8012262:	9b06      	ldr	r3, [sp, #24]
 8012264:	4053      	eors	r3, r2
 8012266:	2101      	movs	r1, #1
 8012268:	4618      	mov	r0, r3
 801226a:	f000 fef9 	bl	8013060 <rotlFixed.lto_priv.491>
 801226e:	4603      	mov	r3, r0
 8012270:	9306      	str	r3, [sp, #24]
 8012272:	9b06      	ldr	r3, [sp, #24]
 8012274:	441c      	add	r4, r3
 8012276:	2105      	movs	r1, #5
 8012278:	9817      	ldr	r0, [sp, #92]	; 0x5c
 801227a:	f000 fef1 	bl	8013060 <rotlFixed.lto_priv.491>
 801227e:	4603      	mov	r3, r0
 8012280:	18e2      	adds	r2, r4, r3
 8012282:	4b8f      	ldr	r3, [pc, #572]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 8012284:	4413      	add	r3, r2
 8012286:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012288:	4413      	add	r3, r2
 801228a:	9313      	str	r3, [sp, #76]	; 0x4c
 801228c:	211e      	movs	r1, #30
 801228e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012290:	f000 fee6 	bl	8013060 <rotlFixed.lto_priv.491>
 8012294:	9016      	str	r0, [sp, #88]	; 0x58
        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
 8012296:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012298:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801229a:	405a      	eors	r2, r3
 801229c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801229e:	ea82 0403 	eor.w	r4, r2, r3
 80122a2:	9a04      	ldr	r2, [sp, #16]
 80122a4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80122a6:	405a      	eors	r2, r3
 80122a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80122aa:	405a      	eors	r2, r3
 80122ac:	9b07      	ldr	r3, [sp, #28]
 80122ae:	4053      	eors	r3, r2
 80122b0:	2101      	movs	r1, #1
 80122b2:	4618      	mov	r0, r3
 80122b4:	f000 fed4 	bl	8013060 <rotlFixed.lto_priv.491>
 80122b8:	4603      	mov	r3, r0
 80122ba:	9307      	str	r3, [sp, #28]
 80122bc:	9b07      	ldr	r3, [sp, #28]
 80122be:	441c      	add	r4, r3
 80122c0:	2105      	movs	r1, #5
 80122c2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80122c4:	f000 fecc 	bl	8013060 <rotlFixed.lto_priv.491>
 80122c8:	4603      	mov	r3, r0
 80122ca:	18e2      	adds	r2, r4, r3
 80122cc:	4b7c      	ldr	r3, [pc, #496]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 80122ce:	4413      	add	r3, r2
 80122d0:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80122d2:	4413      	add	r3, r2
 80122d4:	9314      	str	r3, [sp, #80]	; 0x50
 80122d6:	211e      	movs	r1, #30
 80122d8:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80122da:	f000 fec1 	bl	8013060 <rotlFixed.lto_priv.491>
 80122de:	9017      	str	r0, [sp, #92]	; 0x5c
 80122e0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80122e2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80122e4:	405a      	eors	r2, r3
 80122e6:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80122e8:	ea82 0403 	eor.w	r4, r2, r3
 80122ec:	9a05      	ldr	r2, [sp, #20]
 80122ee:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80122f0:	405a      	eors	r2, r3
 80122f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80122f4:	405a      	eors	r2, r3
 80122f6:	9b08      	ldr	r3, [sp, #32]
 80122f8:	4053      	eors	r3, r2
 80122fa:	2101      	movs	r1, #1
 80122fc:	4618      	mov	r0, r3
 80122fe:	f000 feaf 	bl	8013060 <rotlFixed.lto_priv.491>
 8012302:	4603      	mov	r3, r0
 8012304:	9308      	str	r3, [sp, #32]
 8012306:	9b08      	ldr	r3, [sp, #32]
 8012308:	441c      	add	r4, r3
 801230a:	2105      	movs	r1, #5
 801230c:	9814      	ldr	r0, [sp, #80]	; 0x50
 801230e:	f000 fea7 	bl	8013060 <rotlFixed.lto_priv.491>
 8012312:	4603      	mov	r3, r0
 8012314:	18e2      	adds	r2, r4, r3
 8012316:	4b6a      	ldr	r3, [pc, #424]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 8012318:	4413      	add	r3, r2
 801231a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801231c:	4413      	add	r3, r2
 801231e:	9315      	str	r3, [sp, #84]	; 0x54
 8012320:	211e      	movs	r1, #30
 8012322:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012324:	f000 fe9c 	bl	8013060 <rotlFixed.lto_priv.491>
 8012328:	9013      	str	r0, [sp, #76]	; 0x4c
 801232a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801232c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801232e:	405a      	eors	r2, r3
 8012330:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012332:	ea82 0403 	eor.w	r4, r2, r3
 8012336:	9a06      	ldr	r2, [sp, #24]
 8012338:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801233a:	405a      	eors	r2, r3
 801233c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801233e:	405a      	eors	r2, r3
 8012340:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012342:	4053      	eors	r3, r2
 8012344:	2101      	movs	r1, #1
 8012346:	4618      	mov	r0, r3
 8012348:	f000 fe8a 	bl	8013060 <rotlFixed.lto_priv.491>
 801234c:	4603      	mov	r3, r0
 801234e:	9309      	str	r3, [sp, #36]	; 0x24
 8012350:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012352:	441c      	add	r4, r3
 8012354:	2105      	movs	r1, #5
 8012356:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012358:	f000 fe82 	bl	8013060 <rotlFixed.lto_priv.491>
 801235c:	4603      	mov	r3, r0
 801235e:	18e2      	adds	r2, r4, r3
 8012360:	4b57      	ldr	r3, [pc, #348]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 8012362:	4413      	add	r3, r2
 8012364:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012366:	4413      	add	r3, r2
 8012368:	9316      	str	r3, [sp, #88]	; 0x58
 801236a:	211e      	movs	r1, #30
 801236c:	9814      	ldr	r0, [sp, #80]	; 0x50
 801236e:	f000 fe77 	bl	8013060 <rotlFixed.lto_priv.491>
 8012372:	9014      	str	r0, [sp, #80]	; 0x50
 8012374:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012376:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012378:	405a      	eors	r2, r3
 801237a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801237c:	ea82 0403 	eor.w	r4, r2, r3
 8012380:	9a07      	ldr	r2, [sp, #28]
 8012382:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012384:	405a      	eors	r2, r3
 8012386:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012388:	405a      	eors	r2, r3
 801238a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801238c:	4053      	eors	r3, r2
 801238e:	2101      	movs	r1, #1
 8012390:	4618      	mov	r0, r3
 8012392:	f000 fe65 	bl	8013060 <rotlFixed.lto_priv.491>
 8012396:	4603      	mov	r3, r0
 8012398:	930a      	str	r3, [sp, #40]	; 0x28
 801239a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801239c:	441c      	add	r4, r3
 801239e:	2105      	movs	r1, #5
 80123a0:	9816      	ldr	r0, [sp, #88]	; 0x58
 80123a2:	f000 fe5d 	bl	8013060 <rotlFixed.lto_priv.491>
 80123a6:	4603      	mov	r3, r0
 80123a8:	18e2      	adds	r2, r4, r3
 80123aa:	4b45      	ldr	r3, [pc, #276]	; (80124c0 <Transform.lto_priv.488+0xbc0>)
 80123ac:	4413      	add	r3, r2
 80123ae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80123b0:	4413      	add	r3, r2
 80123b2:	9317      	str	r3, [sp, #92]	; 0x5c
 80123b4:	211e      	movs	r1, #30
 80123b6:	9815      	ldr	r0, [sp, #84]	; 0x54
 80123b8:	f000 fe52 	bl	8013060 <rotlFixed.lto_priv.491>
 80123bc:	9015      	str	r0, [sp, #84]	; 0x54
        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 80123be:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80123c0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80123c2:	401a      	ands	r2, r3
 80123c4:	9916      	ldr	r1, [sp, #88]	; 0x58
 80123c6:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80123c8:	4319      	orrs	r1, r3
 80123ca:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80123cc:	400b      	ands	r3, r1
 80123ce:	ea42 0403 	orr.w	r4, r2, r3
 80123d2:	9a08      	ldr	r2, [sp, #32]
 80123d4:	9b03      	ldr	r3, [sp, #12]
 80123d6:	405a      	eors	r2, r3
 80123d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80123da:	405a      	eors	r2, r3
 80123dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80123de:	4053      	eors	r3, r2
 80123e0:	2101      	movs	r1, #1
 80123e2:	4618      	mov	r0, r3
 80123e4:	f000 fe3c 	bl	8013060 <rotlFixed.lto_priv.491>
 80123e8:	4603      	mov	r3, r0
 80123ea:	930b      	str	r3, [sp, #44]	; 0x2c
 80123ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80123ee:	441c      	add	r4, r3
 80123f0:	2105      	movs	r1, #5
 80123f2:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80123f4:	f000 fe34 	bl	8013060 <rotlFixed.lto_priv.491>
 80123f8:	4603      	mov	r3, r0
 80123fa:	18e2      	adds	r2, r4, r3
 80123fc:	4b31      	ldr	r3, [pc, #196]	; (80124c4 <Transform.lto_priv.488+0xbc4>)
 80123fe:	4413      	add	r3, r2
 8012400:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012402:	4413      	add	r3, r2
 8012404:	9313      	str	r3, [sp, #76]	; 0x4c
 8012406:	211e      	movs	r1, #30
 8012408:	9816      	ldr	r0, [sp, #88]	; 0x58
 801240a:	f000 fe29 	bl	8013060 <rotlFixed.lto_priv.491>
 801240e:	9016      	str	r0, [sp, #88]	; 0x58
 8012410:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012412:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012414:	401a      	ands	r2, r3
 8012416:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8012418:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801241a:	4319      	orrs	r1, r3
 801241c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801241e:	400b      	ands	r3, r1
 8012420:	ea42 0403 	orr.w	r4, r2, r3
 8012424:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8012426:	9b04      	ldr	r3, [sp, #16]
 8012428:	405a      	eors	r2, r3
 801242a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801242c:	405a      	eors	r2, r3
 801242e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012430:	4053      	eors	r3, r2
 8012432:	2101      	movs	r1, #1
 8012434:	4618      	mov	r0, r3
 8012436:	f000 fe13 	bl	8013060 <rotlFixed.lto_priv.491>
 801243a:	4603      	mov	r3, r0
 801243c:	930c      	str	r3, [sp, #48]	; 0x30
 801243e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012440:	441c      	add	r4, r3
 8012442:	2105      	movs	r1, #5
 8012444:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012446:	f000 fe0b 	bl	8013060 <rotlFixed.lto_priv.491>
 801244a:	4603      	mov	r3, r0
 801244c:	18e2      	adds	r2, r4, r3
 801244e:	4b1d      	ldr	r3, [pc, #116]	; (80124c4 <Transform.lto_priv.488+0xbc4>)
 8012450:	4413      	add	r3, r2
 8012452:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012454:	4413      	add	r3, r2
 8012456:	9314      	str	r3, [sp, #80]	; 0x50
 8012458:	211e      	movs	r1, #30
 801245a:	9817      	ldr	r0, [sp, #92]	; 0x5c
 801245c:	f000 fe00 	bl	8013060 <rotlFixed.lto_priv.491>
 8012460:	9017      	str	r0, [sp, #92]	; 0x5c
 8012462:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012464:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012466:	401a      	ands	r2, r3
 8012468:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801246a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801246c:	4319      	orrs	r1, r3
 801246e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012470:	400b      	ands	r3, r1
 8012472:	ea42 0403 	orr.w	r4, r2, r3
 8012476:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012478:	9b05      	ldr	r3, [sp, #20]
 801247a:	405a      	eors	r2, r3
 801247c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801247e:	405a      	eors	r2, r3
 8012480:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012482:	4053      	eors	r3, r2
 8012484:	2101      	movs	r1, #1
 8012486:	4618      	mov	r0, r3
 8012488:	f000 fdea 	bl	8013060 <rotlFixed.lto_priv.491>
 801248c:	4603      	mov	r3, r0
 801248e:	930d      	str	r3, [sp, #52]	; 0x34
 8012490:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012492:	441c      	add	r4, r3
 8012494:	2105      	movs	r1, #5
 8012496:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012498:	f000 fde2 	bl	8013060 <rotlFixed.lto_priv.491>
 801249c:	4603      	mov	r3, r0
 801249e:	18e2      	adds	r2, r4, r3
 80124a0:	4b08      	ldr	r3, [pc, #32]	; (80124c4 <Transform.lto_priv.488+0xbc4>)
 80124a2:	4413      	add	r3, r2
 80124a4:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80124a6:	4413      	add	r3, r2
 80124a8:	9315      	str	r3, [sp, #84]	; 0x54
 80124aa:	211e      	movs	r1, #30
 80124ac:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80124ae:	f000 fdd7 	bl	8013060 <rotlFixed.lto_priv.491>
 80124b2:	9013      	str	r0, [sp, #76]	; 0x4c
 80124b4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80124b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80124b8:	401a      	ands	r2, r3
 80124ba:	9914      	ldr	r1, [sp, #80]	; 0x50
 80124bc:	e004      	b.n	80124c8 <Transform.lto_priv.488+0xbc8>
 80124be:	bf00      	nop
 80124c0:	6ed9eba1 	.word	0x6ed9eba1
 80124c4:	8f1bbcdc 	.word	0x8f1bbcdc
 80124c8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80124ca:	4319      	orrs	r1, r3
 80124cc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80124ce:	400b      	ands	r3, r1
 80124d0:	ea42 0403 	orr.w	r4, r2, r3
 80124d4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80124d6:	9b06      	ldr	r3, [sp, #24]
 80124d8:	405a      	eors	r2, r3
 80124da:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80124dc:	405a      	eors	r2, r3
 80124de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80124e0:	4053      	eors	r3, r2
 80124e2:	2101      	movs	r1, #1
 80124e4:	4618      	mov	r0, r3
 80124e6:	f000 fdbb 	bl	8013060 <rotlFixed.lto_priv.491>
 80124ea:	4603      	mov	r3, r0
 80124ec:	930e      	str	r3, [sp, #56]	; 0x38
 80124ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80124f0:	441c      	add	r4, r3
 80124f2:	2105      	movs	r1, #5
 80124f4:	9815      	ldr	r0, [sp, #84]	; 0x54
 80124f6:	f000 fdb3 	bl	8013060 <rotlFixed.lto_priv.491>
 80124fa:	4603      	mov	r3, r0
 80124fc:	18e2      	adds	r2, r4, r3
 80124fe:	4bb3      	ldr	r3, [pc, #716]	; (80127cc <Transform.lto_priv.488+0xecc>)
 8012500:	4413      	add	r3, r2
 8012502:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012504:	4413      	add	r3, r2
 8012506:	9316      	str	r3, [sp, #88]	; 0x58
 8012508:	211e      	movs	r1, #30
 801250a:	9814      	ldr	r0, [sp, #80]	; 0x50
 801250c:	f000 fda8 	bl	8013060 <rotlFixed.lto_priv.491>
 8012510:	9014      	str	r0, [sp, #80]	; 0x50
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 8012512:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012514:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012516:	401a      	ands	r2, r3
 8012518:	9915      	ldr	r1, [sp, #84]	; 0x54
 801251a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801251c:	4319      	orrs	r1, r3
 801251e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012520:	400b      	ands	r3, r1
 8012522:	ea42 0403 	orr.w	r4, r2, r3
 8012526:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8012528:	9b07      	ldr	r3, [sp, #28]
 801252a:	405a      	eors	r2, r3
 801252c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801252e:	405a      	eors	r2, r3
 8012530:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012532:	4053      	eors	r3, r2
 8012534:	2101      	movs	r1, #1
 8012536:	4618      	mov	r0, r3
 8012538:	f000 fd92 	bl	8013060 <rotlFixed.lto_priv.491>
 801253c:	4603      	mov	r3, r0
 801253e:	930f      	str	r3, [sp, #60]	; 0x3c
 8012540:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012542:	441c      	add	r4, r3
 8012544:	2105      	movs	r1, #5
 8012546:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012548:	f000 fd8a 	bl	8013060 <rotlFixed.lto_priv.491>
 801254c:	4603      	mov	r3, r0
 801254e:	18e2      	adds	r2, r4, r3
 8012550:	4b9e      	ldr	r3, [pc, #632]	; (80127cc <Transform.lto_priv.488+0xecc>)
 8012552:	4413      	add	r3, r2
 8012554:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012556:	4413      	add	r3, r2
 8012558:	9317      	str	r3, [sp, #92]	; 0x5c
 801255a:	211e      	movs	r1, #30
 801255c:	9815      	ldr	r0, [sp, #84]	; 0x54
 801255e:	f000 fd7f 	bl	8013060 <rotlFixed.lto_priv.491>
 8012562:	9015      	str	r0, [sp, #84]	; 0x54
 8012564:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012566:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012568:	401a      	ands	r2, r3
 801256a:	9916      	ldr	r1, [sp, #88]	; 0x58
 801256c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801256e:	4319      	orrs	r1, r3
 8012570:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012572:	400b      	ands	r3, r1
 8012574:	ea42 0403 	orr.w	r4, r2, r3
 8012578:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801257a:	9b08      	ldr	r3, [sp, #32]
 801257c:	405a      	eors	r2, r3
 801257e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012580:	405a      	eors	r2, r3
 8012582:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012584:	4053      	eors	r3, r2
 8012586:	2101      	movs	r1, #1
 8012588:	4618      	mov	r0, r3
 801258a:	f000 fd69 	bl	8013060 <rotlFixed.lto_priv.491>
 801258e:	4603      	mov	r3, r0
 8012590:	9310      	str	r3, [sp, #64]	; 0x40
 8012592:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012594:	441c      	add	r4, r3
 8012596:	2105      	movs	r1, #5
 8012598:	9817      	ldr	r0, [sp, #92]	; 0x5c
 801259a:	f000 fd61 	bl	8013060 <rotlFixed.lto_priv.491>
 801259e:	4603      	mov	r3, r0
 80125a0:	18e2      	adds	r2, r4, r3
 80125a2:	4b8a      	ldr	r3, [pc, #552]	; (80127cc <Transform.lto_priv.488+0xecc>)
 80125a4:	4413      	add	r3, r2
 80125a6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80125a8:	4413      	add	r3, r2
 80125aa:	9313      	str	r3, [sp, #76]	; 0x4c
 80125ac:	211e      	movs	r1, #30
 80125ae:	9816      	ldr	r0, [sp, #88]	; 0x58
 80125b0:	f000 fd56 	bl	8013060 <rotlFixed.lto_priv.491>
 80125b4:	9016      	str	r0, [sp, #88]	; 0x58
 80125b6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80125b8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80125ba:	401a      	ands	r2, r3
 80125bc:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80125be:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80125c0:	4319      	orrs	r1, r3
 80125c2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80125c4:	400b      	ands	r3, r1
 80125c6:	ea42 0403 	orr.w	r4, r2, r3
 80125ca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80125cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80125ce:	405a      	eors	r2, r3
 80125d0:	9b03      	ldr	r3, [sp, #12]
 80125d2:	405a      	eors	r2, r3
 80125d4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80125d6:	4053      	eors	r3, r2
 80125d8:	2101      	movs	r1, #1
 80125da:	4618      	mov	r0, r3
 80125dc:	f000 fd40 	bl	8013060 <rotlFixed.lto_priv.491>
 80125e0:	4603      	mov	r3, r0
 80125e2:	9311      	str	r3, [sp, #68]	; 0x44
 80125e4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80125e6:	441c      	add	r4, r3
 80125e8:	2105      	movs	r1, #5
 80125ea:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80125ec:	f000 fd38 	bl	8013060 <rotlFixed.lto_priv.491>
 80125f0:	4603      	mov	r3, r0
 80125f2:	18e2      	adds	r2, r4, r3
 80125f4:	4b75      	ldr	r3, [pc, #468]	; (80127cc <Transform.lto_priv.488+0xecc>)
 80125f6:	4413      	add	r3, r2
 80125f8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80125fa:	4413      	add	r3, r2
 80125fc:	9314      	str	r3, [sp, #80]	; 0x50
 80125fe:	211e      	movs	r1, #30
 8012600:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012602:	f000 fd2d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012606:	9017      	str	r0, [sp, #92]	; 0x5c
 8012608:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801260a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801260c:	401a      	ands	r2, r3
 801260e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8012610:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012612:	4319      	orrs	r1, r3
 8012614:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012616:	400b      	ands	r3, r1
 8012618:	ea42 0403 	orr.w	r4, r2, r3
 801261c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801261e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012620:	405a      	eors	r2, r3
 8012622:	9b04      	ldr	r3, [sp, #16]
 8012624:	405a      	eors	r2, r3
 8012626:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012628:	4053      	eors	r3, r2
 801262a:	2101      	movs	r1, #1
 801262c:	4618      	mov	r0, r3
 801262e:	f000 fd17 	bl	8013060 <rotlFixed.lto_priv.491>
 8012632:	4603      	mov	r3, r0
 8012634:	9312      	str	r3, [sp, #72]	; 0x48
 8012636:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012638:	441c      	add	r4, r3
 801263a:	2105      	movs	r1, #5
 801263c:	9814      	ldr	r0, [sp, #80]	; 0x50
 801263e:	f000 fd0f 	bl	8013060 <rotlFixed.lto_priv.491>
 8012642:	4603      	mov	r3, r0
 8012644:	18e2      	adds	r2, r4, r3
 8012646:	4b61      	ldr	r3, [pc, #388]	; (80127cc <Transform.lto_priv.488+0xecc>)
 8012648:	4413      	add	r3, r2
 801264a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801264c:	4413      	add	r3, r2
 801264e:	9315      	str	r3, [sp, #84]	; 0x54
 8012650:	211e      	movs	r1, #30
 8012652:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012654:	f000 fd04 	bl	8013060 <rotlFixed.lto_priv.491>
 8012658:	9013      	str	r0, [sp, #76]	; 0x4c
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 801265a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801265c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801265e:	401a      	ands	r2, r3
 8012660:	9914      	ldr	r1, [sp, #80]	; 0x50
 8012662:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012664:	4319      	orrs	r1, r3
 8012666:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012668:	400b      	ands	r3, r1
 801266a:	ea42 0403 	orr.w	r4, r2, r3
 801266e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8012670:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012672:	405a      	eors	r2, r3
 8012674:	9b05      	ldr	r3, [sp, #20]
 8012676:	405a      	eors	r2, r3
 8012678:	9b03      	ldr	r3, [sp, #12]
 801267a:	4053      	eors	r3, r2
 801267c:	2101      	movs	r1, #1
 801267e:	4618      	mov	r0, r3
 8012680:	f000 fcee 	bl	8013060 <rotlFixed.lto_priv.491>
 8012684:	4603      	mov	r3, r0
 8012686:	9303      	str	r3, [sp, #12]
 8012688:	9b03      	ldr	r3, [sp, #12]
 801268a:	441c      	add	r4, r3
 801268c:	2105      	movs	r1, #5
 801268e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012690:	f000 fce6 	bl	8013060 <rotlFixed.lto_priv.491>
 8012694:	4603      	mov	r3, r0
 8012696:	18e2      	adds	r2, r4, r3
 8012698:	4b4c      	ldr	r3, [pc, #304]	; (80127cc <Transform.lto_priv.488+0xecc>)
 801269a:	4413      	add	r3, r2
 801269c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801269e:	4413      	add	r3, r2
 80126a0:	9316      	str	r3, [sp, #88]	; 0x58
 80126a2:	211e      	movs	r1, #30
 80126a4:	9814      	ldr	r0, [sp, #80]	; 0x50
 80126a6:	f000 fcdb 	bl	8013060 <rotlFixed.lto_priv.491>
 80126aa:	9014      	str	r0, [sp, #80]	; 0x50
 80126ac:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80126ae:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80126b0:	401a      	ands	r2, r3
 80126b2:	9915      	ldr	r1, [sp, #84]	; 0x54
 80126b4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80126b6:	4319      	orrs	r1, r3
 80126b8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80126ba:	400b      	ands	r3, r1
 80126bc:	ea42 0403 	orr.w	r4, r2, r3
 80126c0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80126c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80126c4:	405a      	eors	r2, r3
 80126c6:	9b06      	ldr	r3, [sp, #24]
 80126c8:	405a      	eors	r2, r3
 80126ca:	9b04      	ldr	r3, [sp, #16]
 80126cc:	4053      	eors	r3, r2
 80126ce:	2101      	movs	r1, #1
 80126d0:	4618      	mov	r0, r3
 80126d2:	f000 fcc5 	bl	8013060 <rotlFixed.lto_priv.491>
 80126d6:	4603      	mov	r3, r0
 80126d8:	9304      	str	r3, [sp, #16]
 80126da:	9b04      	ldr	r3, [sp, #16]
 80126dc:	441c      	add	r4, r3
 80126de:	2105      	movs	r1, #5
 80126e0:	9816      	ldr	r0, [sp, #88]	; 0x58
 80126e2:	f000 fcbd 	bl	8013060 <rotlFixed.lto_priv.491>
 80126e6:	4603      	mov	r3, r0
 80126e8:	18e2      	adds	r2, r4, r3
 80126ea:	4b38      	ldr	r3, [pc, #224]	; (80127cc <Transform.lto_priv.488+0xecc>)
 80126ec:	4413      	add	r3, r2
 80126ee:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80126f0:	4413      	add	r3, r2
 80126f2:	9317      	str	r3, [sp, #92]	; 0x5c
 80126f4:	211e      	movs	r1, #30
 80126f6:	9815      	ldr	r0, [sp, #84]	; 0x54
 80126f8:	f000 fcb2 	bl	8013060 <rotlFixed.lto_priv.491>
 80126fc:	9015      	str	r0, [sp, #84]	; 0x54
 80126fe:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012700:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012702:	401a      	ands	r2, r3
 8012704:	9916      	ldr	r1, [sp, #88]	; 0x58
 8012706:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012708:	4319      	orrs	r1, r3
 801270a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801270c:	400b      	ands	r3, r1
 801270e:	ea42 0403 	orr.w	r4, r2, r3
 8012712:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8012714:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012716:	405a      	eors	r2, r3
 8012718:	9b07      	ldr	r3, [sp, #28]
 801271a:	405a      	eors	r2, r3
 801271c:	9b05      	ldr	r3, [sp, #20]
 801271e:	4053      	eors	r3, r2
 8012720:	2101      	movs	r1, #1
 8012722:	4618      	mov	r0, r3
 8012724:	f000 fc9c 	bl	8013060 <rotlFixed.lto_priv.491>
 8012728:	4603      	mov	r3, r0
 801272a:	9305      	str	r3, [sp, #20]
 801272c:	9b05      	ldr	r3, [sp, #20]
 801272e:	441c      	add	r4, r3
 8012730:	2105      	movs	r1, #5
 8012732:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012734:	f000 fc94 	bl	8013060 <rotlFixed.lto_priv.491>
 8012738:	4603      	mov	r3, r0
 801273a:	18e2      	adds	r2, r4, r3
 801273c:	4b23      	ldr	r3, [pc, #140]	; (80127cc <Transform.lto_priv.488+0xecc>)
 801273e:	4413      	add	r3, r2
 8012740:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012742:	4413      	add	r3, r2
 8012744:	9313      	str	r3, [sp, #76]	; 0x4c
 8012746:	211e      	movs	r1, #30
 8012748:	9816      	ldr	r0, [sp, #88]	; 0x58
 801274a:	f000 fc89 	bl	8013060 <rotlFixed.lto_priv.491>
 801274e:	9016      	str	r0, [sp, #88]	; 0x58
 8012750:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012752:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012754:	401a      	ands	r2, r3
 8012756:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8012758:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801275a:	4319      	orrs	r1, r3
 801275c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801275e:	400b      	ands	r3, r1
 8012760:	ea42 0403 	orr.w	r4, r2, r3
 8012764:	9a03      	ldr	r2, [sp, #12]
 8012766:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012768:	405a      	eors	r2, r3
 801276a:	9b08      	ldr	r3, [sp, #32]
 801276c:	405a      	eors	r2, r3
 801276e:	9b06      	ldr	r3, [sp, #24]
 8012770:	4053      	eors	r3, r2
 8012772:	2101      	movs	r1, #1
 8012774:	4618      	mov	r0, r3
 8012776:	f000 fc73 	bl	8013060 <rotlFixed.lto_priv.491>
 801277a:	4603      	mov	r3, r0
 801277c:	9306      	str	r3, [sp, #24]
 801277e:	9b06      	ldr	r3, [sp, #24]
 8012780:	441c      	add	r4, r3
 8012782:	2105      	movs	r1, #5
 8012784:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012786:	f000 fc6b 	bl	8013060 <rotlFixed.lto_priv.491>
 801278a:	4603      	mov	r3, r0
 801278c:	18e2      	adds	r2, r4, r3
 801278e:	4b0f      	ldr	r3, [pc, #60]	; (80127cc <Transform.lto_priv.488+0xecc>)
 8012790:	4413      	add	r3, r2
 8012792:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012794:	4413      	add	r3, r2
 8012796:	9314      	str	r3, [sp, #80]	; 0x50
 8012798:	211e      	movs	r1, #30
 801279a:	9817      	ldr	r0, [sp, #92]	; 0x5c
 801279c:	f000 fc60 	bl	8013060 <rotlFixed.lto_priv.491>
 80127a0:	9017      	str	r0, [sp, #92]	; 0x5c
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 80127a2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80127a4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80127a6:	401a      	ands	r2, r3
 80127a8:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80127aa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80127ac:	4319      	orrs	r1, r3
 80127ae:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80127b0:	400b      	ands	r3, r1
 80127b2:	ea42 0403 	orr.w	r4, r2, r3
 80127b6:	9a04      	ldr	r2, [sp, #16]
 80127b8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80127ba:	405a      	eors	r2, r3
 80127bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80127be:	405a      	eors	r2, r3
 80127c0:	9b07      	ldr	r3, [sp, #28]
 80127c2:	4053      	eors	r3, r2
 80127c4:	2101      	movs	r1, #1
 80127c6:	4618      	mov	r0, r3
 80127c8:	e002      	b.n	80127d0 <Transform.lto_priv.488+0xed0>
 80127ca:	bf00      	nop
 80127cc:	8f1bbcdc 	.word	0x8f1bbcdc
 80127d0:	f000 fc46 	bl	8013060 <rotlFixed.lto_priv.491>
 80127d4:	4603      	mov	r3, r0
 80127d6:	9307      	str	r3, [sp, #28]
 80127d8:	9b07      	ldr	r3, [sp, #28]
 80127da:	441c      	add	r4, r3
 80127dc:	2105      	movs	r1, #5
 80127de:	9814      	ldr	r0, [sp, #80]	; 0x50
 80127e0:	f000 fc3e 	bl	8013060 <rotlFixed.lto_priv.491>
 80127e4:	4603      	mov	r3, r0
 80127e6:	18e2      	adds	r2, r4, r3
 80127e8:	4bb3      	ldr	r3, [pc, #716]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 80127ea:	4413      	add	r3, r2
 80127ec:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80127ee:	4413      	add	r3, r2
 80127f0:	9315      	str	r3, [sp, #84]	; 0x54
 80127f2:	211e      	movs	r1, #30
 80127f4:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80127f6:	f000 fc33 	bl	8013060 <rotlFixed.lto_priv.491>
 80127fa:	9013      	str	r0, [sp, #76]	; 0x4c
 80127fc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80127fe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012800:	401a      	ands	r2, r3
 8012802:	9914      	ldr	r1, [sp, #80]	; 0x50
 8012804:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012806:	4319      	orrs	r1, r3
 8012808:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801280a:	400b      	ands	r3, r1
 801280c:	ea42 0403 	orr.w	r4, r2, r3
 8012810:	9a05      	ldr	r2, [sp, #20]
 8012812:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012814:	405a      	eors	r2, r3
 8012816:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012818:	405a      	eors	r2, r3
 801281a:	9b08      	ldr	r3, [sp, #32]
 801281c:	4053      	eors	r3, r2
 801281e:	2101      	movs	r1, #1
 8012820:	4618      	mov	r0, r3
 8012822:	f000 fc1d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012826:	4603      	mov	r3, r0
 8012828:	9308      	str	r3, [sp, #32]
 801282a:	9b08      	ldr	r3, [sp, #32]
 801282c:	441c      	add	r4, r3
 801282e:	2105      	movs	r1, #5
 8012830:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012832:	f000 fc15 	bl	8013060 <rotlFixed.lto_priv.491>
 8012836:	4603      	mov	r3, r0
 8012838:	18e2      	adds	r2, r4, r3
 801283a:	4b9f      	ldr	r3, [pc, #636]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 801283c:	4413      	add	r3, r2
 801283e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012840:	4413      	add	r3, r2
 8012842:	9316      	str	r3, [sp, #88]	; 0x58
 8012844:	211e      	movs	r1, #30
 8012846:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012848:	f000 fc0a 	bl	8013060 <rotlFixed.lto_priv.491>
 801284c:	9014      	str	r0, [sp, #80]	; 0x50
 801284e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012850:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012852:	401a      	ands	r2, r3
 8012854:	9915      	ldr	r1, [sp, #84]	; 0x54
 8012856:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012858:	4319      	orrs	r1, r3
 801285a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801285c:	400b      	ands	r3, r1
 801285e:	ea42 0403 	orr.w	r4, r2, r3
 8012862:	9a06      	ldr	r2, [sp, #24]
 8012864:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012866:	405a      	eors	r2, r3
 8012868:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801286a:	405a      	eors	r2, r3
 801286c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801286e:	4053      	eors	r3, r2
 8012870:	2101      	movs	r1, #1
 8012872:	4618      	mov	r0, r3
 8012874:	f000 fbf4 	bl	8013060 <rotlFixed.lto_priv.491>
 8012878:	4603      	mov	r3, r0
 801287a:	9309      	str	r3, [sp, #36]	; 0x24
 801287c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801287e:	441c      	add	r4, r3
 8012880:	2105      	movs	r1, #5
 8012882:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012884:	f000 fbec 	bl	8013060 <rotlFixed.lto_priv.491>
 8012888:	4603      	mov	r3, r0
 801288a:	18e2      	adds	r2, r4, r3
 801288c:	4b8a      	ldr	r3, [pc, #552]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 801288e:	4413      	add	r3, r2
 8012890:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012892:	4413      	add	r3, r2
 8012894:	9317      	str	r3, [sp, #92]	; 0x5c
 8012896:	211e      	movs	r1, #30
 8012898:	9815      	ldr	r0, [sp, #84]	; 0x54
 801289a:	f000 fbe1 	bl	8013060 <rotlFixed.lto_priv.491>
 801289e:	9015      	str	r0, [sp, #84]	; 0x54
 80128a0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80128a2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80128a4:	401a      	ands	r2, r3
 80128a6:	9916      	ldr	r1, [sp, #88]	; 0x58
 80128a8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80128aa:	4319      	orrs	r1, r3
 80128ac:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80128ae:	400b      	ands	r3, r1
 80128b0:	ea42 0403 	orr.w	r4, r2, r3
 80128b4:	9a07      	ldr	r2, [sp, #28]
 80128b6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80128b8:	405a      	eors	r2, r3
 80128ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80128bc:	405a      	eors	r2, r3
 80128be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80128c0:	4053      	eors	r3, r2
 80128c2:	2101      	movs	r1, #1
 80128c4:	4618      	mov	r0, r3
 80128c6:	f000 fbcb 	bl	8013060 <rotlFixed.lto_priv.491>
 80128ca:	4603      	mov	r3, r0
 80128cc:	930a      	str	r3, [sp, #40]	; 0x28
 80128ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80128d0:	441c      	add	r4, r3
 80128d2:	2105      	movs	r1, #5
 80128d4:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80128d6:	f000 fbc3 	bl	8013060 <rotlFixed.lto_priv.491>
 80128da:	4603      	mov	r3, r0
 80128dc:	18e2      	adds	r2, r4, r3
 80128de:	4b76      	ldr	r3, [pc, #472]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 80128e0:	4413      	add	r3, r2
 80128e2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80128e4:	4413      	add	r3, r2
 80128e6:	9313      	str	r3, [sp, #76]	; 0x4c
 80128e8:	211e      	movs	r1, #30
 80128ea:	9816      	ldr	r0, [sp, #88]	; 0x58
 80128ec:	f000 fbb8 	bl	8013060 <rotlFixed.lto_priv.491>
 80128f0:	9016      	str	r0, [sp, #88]	; 0x58
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 80128f2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80128f4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80128f6:	401a      	ands	r2, r3
 80128f8:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80128fa:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80128fc:	4319      	orrs	r1, r3
 80128fe:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012900:	400b      	ands	r3, r1
 8012902:	ea42 0403 	orr.w	r4, r2, r3
 8012906:	9a08      	ldr	r2, [sp, #32]
 8012908:	9b03      	ldr	r3, [sp, #12]
 801290a:	405a      	eors	r2, r3
 801290c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801290e:	405a      	eors	r2, r3
 8012910:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012912:	4053      	eors	r3, r2
 8012914:	2101      	movs	r1, #1
 8012916:	4618      	mov	r0, r3
 8012918:	f000 fba2 	bl	8013060 <rotlFixed.lto_priv.491>
 801291c:	4603      	mov	r3, r0
 801291e:	930b      	str	r3, [sp, #44]	; 0x2c
 8012920:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012922:	441c      	add	r4, r3
 8012924:	2105      	movs	r1, #5
 8012926:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012928:	f000 fb9a 	bl	8013060 <rotlFixed.lto_priv.491>
 801292c:	4603      	mov	r3, r0
 801292e:	18e2      	adds	r2, r4, r3
 8012930:	4b61      	ldr	r3, [pc, #388]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 8012932:	4413      	add	r3, r2
 8012934:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012936:	4413      	add	r3, r2
 8012938:	9314      	str	r3, [sp, #80]	; 0x50
 801293a:	211e      	movs	r1, #30
 801293c:	9817      	ldr	r0, [sp, #92]	; 0x5c
 801293e:	f000 fb8f 	bl	8013060 <rotlFixed.lto_priv.491>
 8012942:	9017      	str	r0, [sp, #92]	; 0x5c
 8012944:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012946:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012948:	401a      	ands	r2, r3
 801294a:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801294c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801294e:	4319      	orrs	r1, r3
 8012950:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012952:	400b      	ands	r3, r1
 8012954:	ea42 0403 	orr.w	r4, r2, r3
 8012958:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801295a:	9b04      	ldr	r3, [sp, #16]
 801295c:	405a      	eors	r2, r3
 801295e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012960:	405a      	eors	r2, r3
 8012962:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012964:	4053      	eors	r3, r2
 8012966:	2101      	movs	r1, #1
 8012968:	4618      	mov	r0, r3
 801296a:	f000 fb79 	bl	8013060 <rotlFixed.lto_priv.491>
 801296e:	4603      	mov	r3, r0
 8012970:	930c      	str	r3, [sp, #48]	; 0x30
 8012972:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012974:	441c      	add	r4, r3
 8012976:	2105      	movs	r1, #5
 8012978:	9814      	ldr	r0, [sp, #80]	; 0x50
 801297a:	f000 fb71 	bl	8013060 <rotlFixed.lto_priv.491>
 801297e:	4603      	mov	r3, r0
 8012980:	18e2      	adds	r2, r4, r3
 8012982:	4b4d      	ldr	r3, [pc, #308]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 8012984:	4413      	add	r3, r2
 8012986:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012988:	4413      	add	r3, r2
 801298a:	9315      	str	r3, [sp, #84]	; 0x54
 801298c:	211e      	movs	r1, #30
 801298e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012990:	f000 fb66 	bl	8013060 <rotlFixed.lto_priv.491>
 8012994:	9013      	str	r0, [sp, #76]	; 0x4c
 8012996:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012998:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801299a:	401a      	ands	r2, r3
 801299c:	9914      	ldr	r1, [sp, #80]	; 0x50
 801299e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80129a0:	4319      	orrs	r1, r3
 80129a2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80129a4:	400b      	ands	r3, r1
 80129a6:	ea42 0403 	orr.w	r4, r2, r3
 80129aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80129ac:	9b05      	ldr	r3, [sp, #20]
 80129ae:	405a      	eors	r2, r3
 80129b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80129b2:	405a      	eors	r2, r3
 80129b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80129b6:	4053      	eors	r3, r2
 80129b8:	2101      	movs	r1, #1
 80129ba:	4618      	mov	r0, r3
 80129bc:	f000 fb50 	bl	8013060 <rotlFixed.lto_priv.491>
 80129c0:	4603      	mov	r3, r0
 80129c2:	930d      	str	r3, [sp, #52]	; 0x34
 80129c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80129c6:	441c      	add	r4, r3
 80129c8:	2105      	movs	r1, #5
 80129ca:	9815      	ldr	r0, [sp, #84]	; 0x54
 80129cc:	f000 fb48 	bl	8013060 <rotlFixed.lto_priv.491>
 80129d0:	4603      	mov	r3, r0
 80129d2:	18e2      	adds	r2, r4, r3
 80129d4:	4b38      	ldr	r3, [pc, #224]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 80129d6:	4413      	add	r3, r2
 80129d8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80129da:	4413      	add	r3, r2
 80129dc:	9316      	str	r3, [sp, #88]	; 0x58
 80129de:	211e      	movs	r1, #30
 80129e0:	9814      	ldr	r0, [sp, #80]	; 0x50
 80129e2:	f000 fb3d 	bl	8013060 <rotlFixed.lto_priv.491>
 80129e6:	9014      	str	r0, [sp, #80]	; 0x50
 80129e8:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80129ea:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80129ec:	401a      	ands	r2, r3
 80129ee:	9915      	ldr	r1, [sp, #84]	; 0x54
 80129f0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80129f2:	4319      	orrs	r1, r3
 80129f4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80129f6:	400b      	ands	r3, r1
 80129f8:	ea42 0403 	orr.w	r4, r2, r3
 80129fc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80129fe:	9b06      	ldr	r3, [sp, #24]
 8012a00:	405a      	eors	r2, r3
 8012a02:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012a04:	405a      	eors	r2, r3
 8012a06:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012a08:	4053      	eors	r3, r2
 8012a0a:	2101      	movs	r1, #1
 8012a0c:	4618      	mov	r0, r3
 8012a0e:	f000 fb27 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a12:	4603      	mov	r3, r0
 8012a14:	930e      	str	r3, [sp, #56]	; 0x38
 8012a16:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012a18:	441c      	add	r4, r3
 8012a1a:	2105      	movs	r1, #5
 8012a1c:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012a1e:	f000 fb1f 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a22:	4603      	mov	r3, r0
 8012a24:	18e2      	adds	r2, r4, r3
 8012a26:	4b24      	ldr	r3, [pc, #144]	; (8012ab8 <Transform.lto_priv.488+0x11b8>)
 8012a28:	4413      	add	r3, r2
 8012a2a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012a2c:	4413      	add	r3, r2
 8012a2e:	9317      	str	r3, [sp, #92]	; 0x5c
 8012a30:	211e      	movs	r1, #30
 8012a32:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012a34:	f000 fb14 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a38:	9015      	str	r0, [sp, #84]	; 0x54
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 8012a3a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012a3c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012a3e:	405a      	eors	r2, r3
 8012a40:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012a42:	ea82 0403 	eor.w	r4, r2, r3
 8012a46:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8012a48:	9b07      	ldr	r3, [sp, #28]
 8012a4a:	405a      	eors	r2, r3
 8012a4c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012a4e:	405a      	eors	r2, r3
 8012a50:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012a52:	4053      	eors	r3, r2
 8012a54:	2101      	movs	r1, #1
 8012a56:	4618      	mov	r0, r3
 8012a58:	f000 fb02 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a5c:	4603      	mov	r3, r0
 8012a5e:	930f      	str	r3, [sp, #60]	; 0x3c
 8012a60:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012a62:	441c      	add	r4, r3
 8012a64:	2105      	movs	r1, #5
 8012a66:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012a68:	f000 fafa 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a6c:	4603      	mov	r3, r0
 8012a6e:	18e2      	adds	r2, r4, r3
 8012a70:	4b12      	ldr	r3, [pc, #72]	; (8012abc <Transform.lto_priv.488+0x11bc>)
 8012a72:	4413      	add	r3, r2
 8012a74:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012a76:	4413      	add	r3, r2
 8012a78:	9313      	str	r3, [sp, #76]	; 0x4c
 8012a7a:	211e      	movs	r1, #30
 8012a7c:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012a7e:	f000 faef 	bl	8013060 <rotlFixed.lto_priv.491>
 8012a82:	9016      	str	r0, [sp, #88]	; 0x58
 8012a84:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012a86:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012a88:	405a      	eors	r2, r3
 8012a8a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012a8c:	ea82 0403 	eor.w	r4, r2, r3
 8012a90:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012a92:	9b08      	ldr	r3, [sp, #32]
 8012a94:	405a      	eors	r2, r3
 8012a96:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012a98:	405a      	eors	r2, r3
 8012a9a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012a9c:	4053      	eors	r3, r2
 8012a9e:	2101      	movs	r1, #1
 8012aa0:	4618      	mov	r0, r3
 8012aa2:	f000 fadd 	bl	8013060 <rotlFixed.lto_priv.491>
 8012aa6:	4603      	mov	r3, r0
 8012aa8:	9310      	str	r3, [sp, #64]	; 0x40
 8012aaa:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012aac:	441c      	add	r4, r3
 8012aae:	2105      	movs	r1, #5
 8012ab0:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012ab2:	f000 fad5 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ab6:	e003      	b.n	8012ac0 <Transform.lto_priv.488+0x11c0>
 8012ab8:	8f1bbcdc 	.word	0x8f1bbcdc
 8012abc:	ca62c1d6 	.word	0xca62c1d6
 8012ac0:	4603      	mov	r3, r0
 8012ac2:	18e2      	adds	r2, r4, r3
 8012ac4:	4bb4      	ldr	r3, [pc, #720]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012ac6:	4413      	add	r3, r2
 8012ac8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012aca:	4413      	add	r3, r2
 8012acc:	9314      	str	r3, [sp, #80]	; 0x50
 8012ace:	211e      	movs	r1, #30
 8012ad0:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012ad2:	f000 fac5 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ad6:	9017      	str	r0, [sp, #92]	; 0x5c
 8012ad8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012ada:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012adc:	405a      	eors	r2, r3
 8012ade:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012ae0:	ea82 0403 	eor.w	r4, r2, r3
 8012ae4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8012ae6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012ae8:	405a      	eors	r2, r3
 8012aea:	9b03      	ldr	r3, [sp, #12]
 8012aec:	405a      	eors	r2, r3
 8012aee:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012af0:	4053      	eors	r3, r2
 8012af2:	2101      	movs	r1, #1
 8012af4:	4618      	mov	r0, r3
 8012af6:	f000 fab3 	bl	8013060 <rotlFixed.lto_priv.491>
 8012afa:	4603      	mov	r3, r0
 8012afc:	9311      	str	r3, [sp, #68]	; 0x44
 8012afe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012b00:	441c      	add	r4, r3
 8012b02:	2105      	movs	r1, #5
 8012b04:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012b06:	f000 faab 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b0a:	4603      	mov	r3, r0
 8012b0c:	18e2      	adds	r2, r4, r3
 8012b0e:	4ba2      	ldr	r3, [pc, #648]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012b10:	4413      	add	r3, r2
 8012b12:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012b14:	4413      	add	r3, r2
 8012b16:	9315      	str	r3, [sp, #84]	; 0x54
 8012b18:	211e      	movs	r1, #30
 8012b1a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012b1c:	f000 faa0 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b20:	9013      	str	r0, [sp, #76]	; 0x4c
 8012b22:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012b24:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012b26:	405a      	eors	r2, r3
 8012b28:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012b2a:	ea82 0403 	eor.w	r4, r2, r3
 8012b2e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8012b30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012b32:	405a      	eors	r2, r3
 8012b34:	9b04      	ldr	r3, [sp, #16]
 8012b36:	405a      	eors	r2, r3
 8012b38:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012b3a:	4053      	eors	r3, r2
 8012b3c:	2101      	movs	r1, #1
 8012b3e:	4618      	mov	r0, r3
 8012b40:	f000 fa8e 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b44:	4603      	mov	r3, r0
 8012b46:	9312      	str	r3, [sp, #72]	; 0x48
 8012b48:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012b4a:	441c      	add	r4, r3
 8012b4c:	2105      	movs	r1, #5
 8012b4e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012b50:	f000 fa86 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b54:	4603      	mov	r3, r0
 8012b56:	18e2      	adds	r2, r4, r3
 8012b58:	4b8f      	ldr	r3, [pc, #572]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012b5a:	4413      	add	r3, r2
 8012b5c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012b5e:	4413      	add	r3, r2
 8012b60:	9316      	str	r3, [sp, #88]	; 0x58
 8012b62:	211e      	movs	r1, #30
 8012b64:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012b66:	f000 fa7b 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b6a:	9014      	str	r0, [sp, #80]	; 0x50
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 8012b6c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012b6e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012b70:	405a      	eors	r2, r3
 8012b72:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012b74:	ea82 0403 	eor.w	r4, r2, r3
 8012b78:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8012b7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012b7c:	405a      	eors	r2, r3
 8012b7e:	9b05      	ldr	r3, [sp, #20]
 8012b80:	405a      	eors	r2, r3
 8012b82:	9b03      	ldr	r3, [sp, #12]
 8012b84:	4053      	eors	r3, r2
 8012b86:	2101      	movs	r1, #1
 8012b88:	4618      	mov	r0, r3
 8012b8a:	f000 fa69 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b8e:	4603      	mov	r3, r0
 8012b90:	9303      	str	r3, [sp, #12]
 8012b92:	9b03      	ldr	r3, [sp, #12]
 8012b94:	441c      	add	r4, r3
 8012b96:	2105      	movs	r1, #5
 8012b98:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012b9a:	f000 fa61 	bl	8013060 <rotlFixed.lto_priv.491>
 8012b9e:	4603      	mov	r3, r0
 8012ba0:	18e2      	adds	r2, r4, r3
 8012ba2:	4b7d      	ldr	r3, [pc, #500]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012ba4:	4413      	add	r3, r2
 8012ba6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012ba8:	4413      	add	r3, r2
 8012baa:	9317      	str	r3, [sp, #92]	; 0x5c
 8012bac:	211e      	movs	r1, #30
 8012bae:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012bb0:	f000 fa56 	bl	8013060 <rotlFixed.lto_priv.491>
 8012bb4:	9015      	str	r0, [sp, #84]	; 0x54
 8012bb6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012bb8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012bba:	405a      	eors	r2, r3
 8012bbc:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012bbe:	ea82 0403 	eor.w	r4, r2, r3
 8012bc2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8012bc4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012bc6:	405a      	eors	r2, r3
 8012bc8:	9b06      	ldr	r3, [sp, #24]
 8012bca:	405a      	eors	r2, r3
 8012bcc:	9b04      	ldr	r3, [sp, #16]
 8012bce:	4053      	eors	r3, r2
 8012bd0:	2101      	movs	r1, #1
 8012bd2:	4618      	mov	r0, r3
 8012bd4:	f000 fa44 	bl	8013060 <rotlFixed.lto_priv.491>
 8012bd8:	4603      	mov	r3, r0
 8012bda:	9304      	str	r3, [sp, #16]
 8012bdc:	9b04      	ldr	r3, [sp, #16]
 8012bde:	441c      	add	r4, r3
 8012be0:	2105      	movs	r1, #5
 8012be2:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012be4:	f000 fa3c 	bl	8013060 <rotlFixed.lto_priv.491>
 8012be8:	4603      	mov	r3, r0
 8012bea:	18e2      	adds	r2, r4, r3
 8012bec:	4b6a      	ldr	r3, [pc, #424]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012bee:	4413      	add	r3, r2
 8012bf0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012bf2:	4413      	add	r3, r2
 8012bf4:	9313      	str	r3, [sp, #76]	; 0x4c
 8012bf6:	211e      	movs	r1, #30
 8012bf8:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012bfa:	f000 fa31 	bl	8013060 <rotlFixed.lto_priv.491>
 8012bfe:	9016      	str	r0, [sp, #88]	; 0x58
 8012c00:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012c02:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012c04:	405a      	eors	r2, r3
 8012c06:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012c08:	ea82 0403 	eor.w	r4, r2, r3
 8012c0c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8012c0e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012c10:	405a      	eors	r2, r3
 8012c12:	9b07      	ldr	r3, [sp, #28]
 8012c14:	405a      	eors	r2, r3
 8012c16:	9b05      	ldr	r3, [sp, #20]
 8012c18:	4053      	eors	r3, r2
 8012c1a:	2101      	movs	r1, #1
 8012c1c:	4618      	mov	r0, r3
 8012c1e:	f000 fa1f 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c22:	4603      	mov	r3, r0
 8012c24:	9305      	str	r3, [sp, #20]
 8012c26:	9b05      	ldr	r3, [sp, #20]
 8012c28:	441c      	add	r4, r3
 8012c2a:	2105      	movs	r1, #5
 8012c2c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012c2e:	f000 fa17 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c32:	4603      	mov	r3, r0
 8012c34:	18e2      	adds	r2, r4, r3
 8012c36:	4b58      	ldr	r3, [pc, #352]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012c38:	4413      	add	r3, r2
 8012c3a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012c3c:	4413      	add	r3, r2
 8012c3e:	9314      	str	r3, [sp, #80]	; 0x50
 8012c40:	211e      	movs	r1, #30
 8012c42:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012c44:	f000 fa0c 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c48:	9017      	str	r0, [sp, #92]	; 0x5c
 8012c4a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012c4c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012c4e:	405a      	eors	r2, r3
 8012c50:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012c52:	ea82 0403 	eor.w	r4, r2, r3
 8012c56:	9a03      	ldr	r2, [sp, #12]
 8012c58:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012c5a:	405a      	eors	r2, r3
 8012c5c:	9b08      	ldr	r3, [sp, #32]
 8012c5e:	405a      	eors	r2, r3
 8012c60:	9b06      	ldr	r3, [sp, #24]
 8012c62:	4053      	eors	r3, r2
 8012c64:	2101      	movs	r1, #1
 8012c66:	4618      	mov	r0, r3
 8012c68:	f000 f9fa 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c6c:	4603      	mov	r3, r0
 8012c6e:	9306      	str	r3, [sp, #24]
 8012c70:	9b06      	ldr	r3, [sp, #24]
 8012c72:	441c      	add	r4, r3
 8012c74:	2105      	movs	r1, #5
 8012c76:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012c78:	f000 f9f2 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c7c:	4603      	mov	r3, r0
 8012c7e:	18e2      	adds	r2, r4, r3
 8012c80:	4b45      	ldr	r3, [pc, #276]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012c82:	4413      	add	r3, r2
 8012c84:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012c86:	4413      	add	r3, r2
 8012c88:	9315      	str	r3, [sp, #84]	; 0x54
 8012c8a:	211e      	movs	r1, #30
 8012c8c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012c8e:	f000 f9e7 	bl	8013060 <rotlFixed.lto_priv.491>
 8012c92:	9013      	str	r0, [sp, #76]	; 0x4c
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 8012c94:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012c96:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012c98:	405a      	eors	r2, r3
 8012c9a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012c9c:	ea82 0403 	eor.w	r4, r2, r3
 8012ca0:	9a04      	ldr	r2, [sp, #16]
 8012ca2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012ca4:	405a      	eors	r2, r3
 8012ca6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012ca8:	405a      	eors	r2, r3
 8012caa:	9b07      	ldr	r3, [sp, #28]
 8012cac:	4053      	eors	r3, r2
 8012cae:	2101      	movs	r1, #1
 8012cb0:	4618      	mov	r0, r3
 8012cb2:	f000 f9d5 	bl	8013060 <rotlFixed.lto_priv.491>
 8012cb6:	4603      	mov	r3, r0
 8012cb8:	9307      	str	r3, [sp, #28]
 8012cba:	9b07      	ldr	r3, [sp, #28]
 8012cbc:	441c      	add	r4, r3
 8012cbe:	2105      	movs	r1, #5
 8012cc0:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012cc2:	f000 f9cd 	bl	8013060 <rotlFixed.lto_priv.491>
 8012cc6:	4603      	mov	r3, r0
 8012cc8:	18e2      	adds	r2, r4, r3
 8012cca:	4b33      	ldr	r3, [pc, #204]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012ccc:	4413      	add	r3, r2
 8012cce:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012cd0:	4413      	add	r3, r2
 8012cd2:	9316      	str	r3, [sp, #88]	; 0x58
 8012cd4:	211e      	movs	r1, #30
 8012cd6:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012cd8:	f000 f9c2 	bl	8013060 <rotlFixed.lto_priv.491>
 8012cdc:	9014      	str	r0, [sp, #80]	; 0x50
 8012cde:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012ce0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012ce2:	405a      	eors	r2, r3
 8012ce4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012ce6:	ea82 0403 	eor.w	r4, r2, r3
 8012cea:	9a05      	ldr	r2, [sp, #20]
 8012cec:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012cee:	405a      	eors	r2, r3
 8012cf0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012cf2:	405a      	eors	r2, r3
 8012cf4:	9b08      	ldr	r3, [sp, #32]
 8012cf6:	4053      	eors	r3, r2
 8012cf8:	2101      	movs	r1, #1
 8012cfa:	4618      	mov	r0, r3
 8012cfc:	f000 f9b0 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d00:	4603      	mov	r3, r0
 8012d02:	9308      	str	r3, [sp, #32]
 8012d04:	9b08      	ldr	r3, [sp, #32]
 8012d06:	441c      	add	r4, r3
 8012d08:	2105      	movs	r1, #5
 8012d0a:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012d0c:	f000 f9a8 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d10:	4603      	mov	r3, r0
 8012d12:	18e2      	adds	r2, r4, r3
 8012d14:	4b20      	ldr	r3, [pc, #128]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012d16:	4413      	add	r3, r2
 8012d18:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012d1a:	4413      	add	r3, r2
 8012d1c:	9317      	str	r3, [sp, #92]	; 0x5c
 8012d1e:	211e      	movs	r1, #30
 8012d20:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012d22:	f000 f99d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d26:	9015      	str	r0, [sp, #84]	; 0x54
 8012d28:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012d2a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012d2c:	405a      	eors	r2, r3
 8012d2e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012d30:	ea82 0403 	eor.w	r4, r2, r3
 8012d34:	9a06      	ldr	r2, [sp, #24]
 8012d36:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012d38:	405a      	eors	r2, r3
 8012d3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012d3c:	405a      	eors	r2, r3
 8012d3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012d40:	4053      	eors	r3, r2
 8012d42:	2101      	movs	r1, #1
 8012d44:	4618      	mov	r0, r3
 8012d46:	f000 f98b 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d4a:	4603      	mov	r3, r0
 8012d4c:	9309      	str	r3, [sp, #36]	; 0x24
 8012d4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012d50:	441c      	add	r4, r3
 8012d52:	2105      	movs	r1, #5
 8012d54:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012d56:	f000 f983 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d5a:	4603      	mov	r3, r0
 8012d5c:	18e2      	adds	r2, r4, r3
 8012d5e:	4b0e      	ldr	r3, [pc, #56]	; (8012d98 <Transform.lto_priv.488+0x1498>)
 8012d60:	4413      	add	r3, r2
 8012d62:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012d64:	4413      	add	r3, r2
 8012d66:	9313      	str	r3, [sp, #76]	; 0x4c
 8012d68:	211e      	movs	r1, #30
 8012d6a:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012d6c:	f000 f978 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d70:	9016      	str	r0, [sp, #88]	; 0x58
 8012d72:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012d74:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012d76:	405a      	eors	r2, r3
 8012d78:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012d7a:	ea82 0403 	eor.w	r4, r2, r3
 8012d7e:	9a07      	ldr	r2, [sp, #28]
 8012d80:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012d82:	405a      	eors	r2, r3
 8012d84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012d86:	405a      	eors	r2, r3
 8012d88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012d8a:	4053      	eors	r3, r2
 8012d8c:	2101      	movs	r1, #1
 8012d8e:	4618      	mov	r0, r3
 8012d90:	f000 f966 	bl	8013060 <rotlFixed.lto_priv.491>
 8012d94:	4603      	mov	r3, r0
 8012d96:	e001      	b.n	8012d9c <Transform.lto_priv.488+0x149c>
 8012d98:	ca62c1d6 	.word	0xca62c1d6
 8012d9c:	930a      	str	r3, [sp, #40]	; 0x28
 8012d9e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012da0:	441c      	add	r4, r3
 8012da2:	2105      	movs	r1, #5
 8012da4:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012da6:	f000 f95b 	bl	8013060 <rotlFixed.lto_priv.491>
 8012daa:	4603      	mov	r3, r0
 8012dac:	18e2      	adds	r2, r4, r3
 8012dae:	4ba9      	ldr	r3, [pc, #676]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012db0:	4413      	add	r3, r2
 8012db2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012db4:	4413      	add	r3, r2
 8012db6:	9314      	str	r3, [sp, #80]	; 0x50
 8012db8:	211e      	movs	r1, #30
 8012dba:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012dbc:	f000 f950 	bl	8013060 <rotlFixed.lto_priv.491>
 8012dc0:	9017      	str	r0, [sp, #92]	; 0x5c
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 8012dc2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012dc4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012dc6:	405a      	eors	r2, r3
 8012dc8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012dca:	ea82 0403 	eor.w	r4, r2, r3
 8012dce:	9a08      	ldr	r2, [sp, #32]
 8012dd0:	9b03      	ldr	r3, [sp, #12]
 8012dd2:	405a      	eors	r2, r3
 8012dd4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012dd6:	405a      	eors	r2, r3
 8012dd8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012dda:	4053      	eors	r3, r2
 8012ddc:	2101      	movs	r1, #1
 8012dde:	4618      	mov	r0, r3
 8012de0:	f000 f93e 	bl	8013060 <rotlFixed.lto_priv.491>
 8012de4:	4603      	mov	r3, r0
 8012de6:	930b      	str	r3, [sp, #44]	; 0x2c
 8012de8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012dea:	441c      	add	r4, r3
 8012dec:	2105      	movs	r1, #5
 8012dee:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012df0:	f000 f936 	bl	8013060 <rotlFixed.lto_priv.491>
 8012df4:	4603      	mov	r3, r0
 8012df6:	18e2      	adds	r2, r4, r3
 8012df8:	4b96      	ldr	r3, [pc, #600]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012dfa:	4413      	add	r3, r2
 8012dfc:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012dfe:	4413      	add	r3, r2
 8012e00:	9315      	str	r3, [sp, #84]	; 0x54
 8012e02:	211e      	movs	r1, #30
 8012e04:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012e06:	f000 f92b 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e0a:	9013      	str	r0, [sp, #76]	; 0x4c
 8012e0c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012e0e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012e10:	405a      	eors	r2, r3
 8012e12:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012e14:	ea82 0403 	eor.w	r4, r2, r3
 8012e18:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8012e1a:	9b04      	ldr	r3, [sp, #16]
 8012e1c:	405a      	eors	r2, r3
 8012e1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012e20:	405a      	eors	r2, r3
 8012e22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012e24:	4053      	eors	r3, r2
 8012e26:	2101      	movs	r1, #1
 8012e28:	4618      	mov	r0, r3
 8012e2a:	f000 f919 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e2e:	4603      	mov	r3, r0
 8012e30:	930c      	str	r3, [sp, #48]	; 0x30
 8012e32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012e34:	441c      	add	r4, r3
 8012e36:	2105      	movs	r1, #5
 8012e38:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012e3a:	f000 f911 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e3e:	4603      	mov	r3, r0
 8012e40:	18e2      	adds	r2, r4, r3
 8012e42:	4b84      	ldr	r3, [pc, #528]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012e44:	4413      	add	r3, r2
 8012e46:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012e48:	4413      	add	r3, r2
 8012e4a:	9316      	str	r3, [sp, #88]	; 0x58
 8012e4c:	211e      	movs	r1, #30
 8012e4e:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012e50:	f000 f906 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e54:	9014      	str	r0, [sp, #80]	; 0x50
 8012e56:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012e58:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012e5a:	405a      	eors	r2, r3
 8012e5c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012e5e:	ea82 0403 	eor.w	r4, r2, r3
 8012e62:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012e64:	9b05      	ldr	r3, [sp, #20]
 8012e66:	405a      	eors	r2, r3
 8012e68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012e6a:	405a      	eors	r2, r3
 8012e6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012e6e:	4053      	eors	r3, r2
 8012e70:	2101      	movs	r1, #1
 8012e72:	4618      	mov	r0, r3
 8012e74:	f000 f8f4 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e78:	4603      	mov	r3, r0
 8012e7a:	930d      	str	r3, [sp, #52]	; 0x34
 8012e7c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8012e7e:	441c      	add	r4, r3
 8012e80:	2105      	movs	r1, #5
 8012e82:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012e84:	f000 f8ec 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e88:	4603      	mov	r3, r0
 8012e8a:	18e2      	adds	r2, r4, r3
 8012e8c:	4b71      	ldr	r3, [pc, #452]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012e8e:	4413      	add	r3, r2
 8012e90:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012e92:	4413      	add	r3, r2
 8012e94:	9317      	str	r3, [sp, #92]	; 0x5c
 8012e96:	211e      	movs	r1, #30
 8012e98:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012e9a:	f000 f8e1 	bl	8013060 <rotlFixed.lto_priv.491>
 8012e9e:	9015      	str	r0, [sp, #84]	; 0x54
 8012ea0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012ea2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012ea4:	405a      	eors	r2, r3
 8012ea6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012ea8:	ea82 0403 	eor.w	r4, r2, r3
 8012eac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012eae:	9b06      	ldr	r3, [sp, #24]
 8012eb0:	405a      	eors	r2, r3
 8012eb2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012eb4:	405a      	eors	r2, r3
 8012eb6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012eb8:	4053      	eors	r3, r2
 8012eba:	2101      	movs	r1, #1
 8012ebc:	4618      	mov	r0, r3
 8012ebe:	f000 f8cf 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ec2:	4603      	mov	r3, r0
 8012ec4:	930e      	str	r3, [sp, #56]	; 0x38
 8012ec6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012ec8:	441c      	add	r4, r3
 8012eca:	2105      	movs	r1, #5
 8012ecc:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012ece:	f000 f8c7 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ed2:	4603      	mov	r3, r0
 8012ed4:	18e2      	adds	r2, r4, r3
 8012ed6:	4b5f      	ldr	r3, [pc, #380]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012ed8:	4413      	add	r3, r2
 8012eda:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012edc:	4413      	add	r3, r2
 8012ede:	9313      	str	r3, [sp, #76]	; 0x4c
 8012ee0:	211e      	movs	r1, #30
 8012ee2:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012ee4:	f000 f8bc 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ee8:	9016      	str	r0, [sp, #88]	; 0x58
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 8012eea:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8012eec:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012eee:	405a      	eors	r2, r3
 8012ef0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8012ef2:	ea82 0403 	eor.w	r4, r2, r3
 8012ef6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8012ef8:	9b07      	ldr	r3, [sp, #28]
 8012efa:	405a      	eors	r2, r3
 8012efc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012efe:	405a      	eors	r2, r3
 8012f00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012f02:	4053      	eors	r3, r2
 8012f04:	2101      	movs	r1, #1
 8012f06:	4618      	mov	r0, r3
 8012f08:	f000 f8aa 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f0c:	4603      	mov	r3, r0
 8012f0e:	930f      	str	r3, [sp, #60]	; 0x3c
 8012f10:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012f12:	441c      	add	r4, r3
 8012f14:	2105      	movs	r1, #5
 8012f16:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012f18:	f000 f8a2 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f1c:	4603      	mov	r3, r0
 8012f1e:	18e2      	adds	r2, r4, r3
 8012f20:	4b4c      	ldr	r3, [pc, #304]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012f22:	4413      	add	r3, r2
 8012f24:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012f26:	4413      	add	r3, r2
 8012f28:	9314      	str	r3, [sp, #80]	; 0x50
 8012f2a:	211e      	movs	r1, #30
 8012f2c:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8012f2e:	f000 f897 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f32:	9017      	str	r0, [sp, #92]	; 0x5c
 8012f34:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012f36:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012f38:	405a      	eors	r2, r3
 8012f3a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012f3c:	ea82 0403 	eor.w	r4, r2, r3
 8012f40:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012f42:	9b08      	ldr	r3, [sp, #32]
 8012f44:	405a      	eors	r2, r3
 8012f46:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012f48:	405a      	eors	r2, r3
 8012f4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012f4c:	4053      	eors	r3, r2
 8012f4e:	2101      	movs	r1, #1
 8012f50:	4618      	mov	r0, r3
 8012f52:	f000 f885 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f56:	4603      	mov	r3, r0
 8012f58:	9310      	str	r3, [sp, #64]	; 0x40
 8012f5a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012f5c:	441c      	add	r4, r3
 8012f5e:	2105      	movs	r1, #5
 8012f60:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012f62:	f000 f87d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f66:	4603      	mov	r3, r0
 8012f68:	18e2      	adds	r2, r4, r3
 8012f6a:	4b3a      	ldr	r3, [pc, #232]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012f6c:	4413      	add	r3, r2
 8012f6e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012f70:	4413      	add	r3, r2
 8012f72:	9315      	str	r3, [sp, #84]	; 0x54
 8012f74:	211e      	movs	r1, #30
 8012f76:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8012f78:	f000 f872 	bl	8013060 <rotlFixed.lto_priv.491>
 8012f7c:	9013      	str	r0, [sp, #76]	; 0x4c
 8012f7e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012f80:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012f82:	405a      	eors	r2, r3
 8012f84:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012f86:	ea82 0403 	eor.w	r4, r2, r3
 8012f8a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8012f8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012f8e:	405a      	eors	r2, r3
 8012f90:	9b03      	ldr	r3, [sp, #12]
 8012f92:	405a      	eors	r2, r3
 8012f94:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012f96:	4053      	eors	r3, r2
 8012f98:	2101      	movs	r1, #1
 8012f9a:	4618      	mov	r0, r3
 8012f9c:	f000 f860 	bl	8013060 <rotlFixed.lto_priv.491>
 8012fa0:	4603      	mov	r3, r0
 8012fa2:	9311      	str	r3, [sp, #68]	; 0x44
 8012fa4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012fa6:	441c      	add	r4, r3
 8012fa8:	2105      	movs	r1, #5
 8012faa:	9815      	ldr	r0, [sp, #84]	; 0x54
 8012fac:	f000 f858 	bl	8013060 <rotlFixed.lto_priv.491>
 8012fb0:	4603      	mov	r3, r0
 8012fb2:	18e2      	adds	r2, r4, r3
 8012fb4:	4b27      	ldr	r3, [pc, #156]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8012fb6:	4413      	add	r3, r2
 8012fb8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012fba:	4413      	add	r3, r2
 8012fbc:	9316      	str	r3, [sp, #88]	; 0x58
 8012fbe:	211e      	movs	r1, #30
 8012fc0:	9814      	ldr	r0, [sp, #80]	; 0x50
 8012fc2:	f000 f84d 	bl	8013060 <rotlFixed.lto_priv.491>
 8012fc6:	9014      	str	r0, [sp, #80]	; 0x50
 8012fc8:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8012fca:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012fcc:	405a      	eors	r2, r3
 8012fce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012fd0:	ea82 0403 	eor.w	r4, r2, r3
 8012fd4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8012fd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012fd8:	405a      	eors	r2, r3
 8012fda:	9b04      	ldr	r3, [sp, #16]
 8012fdc:	405a      	eors	r2, r3
 8012fde:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012fe0:	4053      	eors	r3, r2
 8012fe2:	2101      	movs	r1, #1
 8012fe4:	4618      	mov	r0, r3
 8012fe6:	f000 f83b 	bl	8013060 <rotlFixed.lto_priv.491>
 8012fea:	4603      	mov	r3, r0
 8012fec:	9312      	str	r3, [sp, #72]	; 0x48
 8012fee:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8012ff0:	441c      	add	r4, r3
 8012ff2:	2105      	movs	r1, #5
 8012ff4:	9816      	ldr	r0, [sp, #88]	; 0x58
 8012ff6:	f000 f833 	bl	8013060 <rotlFixed.lto_priv.491>
 8012ffa:	4603      	mov	r3, r0
 8012ffc:	18e2      	adds	r2, r4, r3
 8012ffe:	4b15      	ldr	r3, [pc, #84]	; (8013054 <Transform.lto_priv.488+0x1754>)
 8013000:	4413      	add	r3, r2
 8013002:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8013004:	4413      	add	r3, r2
 8013006:	9317      	str	r3, [sp, #92]	; 0x5c
 8013008:	211e      	movs	r1, #30
 801300a:	9815      	ldr	r0, [sp, #84]	; 0x54
 801300c:	f000 f828 	bl	8013060 <rotlFixed.lto_priv.491>
 8013010:	9015      	str	r0, [sp, #84]	; 0x54
        sha->digest[0] += a;
 8013012:	9b01      	ldr	r3, [sp, #4]
 8013014:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013016:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8013018:	441a      	add	r2, r3
 801301a:	9b01      	ldr	r3, [sp, #4]
 801301c:	64da      	str	r2, [r3, #76]	; 0x4c
        sha->digest[1] += b;
 801301e:	9b01      	ldr	r3, [sp, #4]
 8013020:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8013022:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8013024:	441a      	add	r2, r3
 8013026:	9b01      	ldr	r3, [sp, #4]
 8013028:	651a      	str	r2, [r3, #80]	; 0x50
        sha->digest[2] += c;
 801302a:	9b01      	ldr	r3, [sp, #4]
 801302c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801302e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013030:	441a      	add	r2, r3
 8013032:	9b01      	ldr	r3, [sp, #4]
 8013034:	655a      	str	r2, [r3, #84]	; 0x54
        sha->digest[3] += d;
 8013036:	9b01      	ldr	r3, [sp, #4]
 8013038:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 801303a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801303c:	441a      	add	r2, r3
 801303e:	9b01      	ldr	r3, [sp, #4]
 8013040:	659a      	str	r2, [r3, #88]	; 0x58
        sha->digest[4] += e;
 8013042:	9b01      	ldr	r3, [sp, #4]
 8013044:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8013046:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8013048:	441a      	add	r2, r3
 801304a:	9b01      	ldr	r3, [sp, #4]
 801304c:	65da      	str	r2, [r3, #92]	; 0x5c
    }
 801304e:	b018      	add	sp, #96	; 0x60
 8013050:	bd10      	pop	{r4, pc}
 8013052:	bf00      	nop
 8013054:	ca62c1d6 	.word	0xca62c1d6
	...

08013060 <rotlFixed.lto_priv.491>:
    {
 8013060:	b082      	sub	sp, #8
 8013062:	9001      	str	r0, [sp, #4]
 8013064:	9100      	str	r1, [sp, #0]
        return (x << y) | (x >> (sizeof(y) * 8 - y));
 8013066:	9a01      	ldr	r2, [sp, #4]
 8013068:	9b00      	ldr	r3, [sp, #0]
 801306a:	f1c3 0320 	rsb	r3, r3, #32
 801306e:	fa62 f303 	ror.w	r3, r2, r3
    }
 8013072:	4618      	mov	r0, r3
 8013074:	b002      	add	sp, #8
 8013076:	4770      	bx	lr
	...

08013080 <ByteReverseWord32.lto_priv.492>:
{
 8013080:	b500      	push	{lr}
 8013082:	b083      	sub	sp, #12
 8013084:	9001      	str	r0, [sp, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 8013086:	9b01      	ldr	r3, [sp, #4]
 8013088:	0a1b      	lsrs	r3, r3, #8
 801308a:	f003 12ff 	and.w	r2, r3, #16711935	; 0xff00ff
 801308e:	9b01      	ldr	r3, [sp, #4]
 8013090:	021b      	lsls	r3, r3, #8
 8013092:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 8013096:	4313      	orrs	r3, r2
 8013098:	9301      	str	r3, [sp, #4]
    return rotlFixed(value, 16U);
 801309a:	2110      	movs	r1, #16
 801309c:	9801      	ldr	r0, [sp, #4]
 801309e:	f7ff ffdf 	bl	8013060 <rotlFixed.lto_priv.491>
 80130a2:	4603      	mov	r3, r0
}
 80130a4:	4618      	mov	r0, r3
 80130a6:	b003      	add	sp, #12
 80130a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80130ac:	0000      	movs	r0, r0
	...

080130b0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80130b0:	b500      	push	{lr}
 80130b2:	b085      	sub	sp, #20
 80130b4:	9001      	str	r0, [sp, #4]
 80130b6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80130b8:	9b01      	ldr	r3, [sp, #4]
 80130ba:	681b      	ldr	r3, [r3, #0]
 80130bc:	9303      	str	r3, [sp, #12]
 80130be:	e01a      	b.n	80130f6 <chEvtBroadcastFlagsI+0x46>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
 80130c0:	9b03      	ldr	r3, [sp, #12]
 80130c2:	68da      	ldr	r2, [r3, #12]
 80130c4:	9b00      	ldr	r3, [sp, #0]
 80130c6:	431a      	orrs	r2, r3
 80130c8:	9b03      	ldr	r3, [sp, #12]
 80130ca:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80130cc:	9b00      	ldr	r3, [sp, #0]
 80130ce:	2b00      	cmp	r3, #0
 80130d0:	d006      	beq.n	80130e0 <chEvtBroadcastFlagsI+0x30>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 80130d2:	9b03      	ldr	r3, [sp, #12]
 80130d4:	68da      	ldr	r2, [r3, #12]
 80130d6:	9b03      	ldr	r3, [sp, #12]
 80130d8:	691b      	ldr	r3, [r3, #16]
 80130da:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 80130dc:	2b00      	cmp	r3, #0
 80130de:	d007      	beq.n	80130f0 <chEvtBroadcastFlagsI+0x40>
      chEvtSignalI(elp->listener, elp->events);
 80130e0:	9b03      	ldr	r3, [sp, #12]
 80130e2:	685a      	ldr	r2, [r3, #4]
 80130e4:	9b03      	ldr	r3, [sp, #12]
 80130e6:	689b      	ldr	r3, [r3, #8]
 80130e8:	4619      	mov	r1, r3
 80130ea:	4610      	mov	r0, r2
 80130ec:	f000 f810 	bl	8013110 <chEvtSignalI>
    }
    elp = elp->next;
 80130f0:	9b03      	ldr	r3, [sp, #12]
 80130f2:	681b      	ldr	r3, [r3, #0]
 80130f4:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 80130f6:	9a03      	ldr	r2, [sp, #12]
 80130f8:	9b01      	ldr	r3, [sp, #4]
 80130fa:	429a      	cmp	r2, r3
 80130fc:	d1e0      	bne.n	80130c0 <chEvtBroadcastFlagsI+0x10>
  }
}
 80130fe:	b005      	add	sp, #20
 8013100:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08013110 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8013110:	b500      	push	{lr}
 8013112:	b083      	sub	sp, #12
 8013114:	9001      	str	r0, [sp, #4]
 8013116:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8013118:	9b01      	ldr	r3, [sp, #4]
 801311a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801311c:	9b00      	ldr	r3, [sp, #0]
 801311e:	431a      	orrs	r2, r3
 8013120:	9b01      	ldr	r3, [sp, #4]
 8013122:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8013124:	9b01      	ldr	r3, [sp, #4]
 8013126:	f893 3020 	ldrb.w	r3, [r3, #32]
 801312a:	2b0a      	cmp	r3, #10
 801312c:	d106      	bne.n	801313c <chEvtSignalI+0x2c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 801312e:	9b01      	ldr	r3, [sp, #4]
 8013130:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8013132:	9b01      	ldr	r3, [sp, #4]
 8013134:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013136:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8013138:	2b00      	cmp	r3, #0
 801313a:	d10d      	bne.n	8013158 <chEvtSignalI+0x48>
      ((tp->state == CH_STATE_WTANDEVT) &&
 801313c:	9b01      	ldr	r3, [sp, #4]
 801313e:	f893 3020 	ldrb.w	r3, [r3, #32]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8013142:	2b0b      	cmp	r3, #11
 8013144:	d10e      	bne.n	8013164 <chEvtSignalI+0x54>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8013146:	9b01      	ldr	r3, [sp, #4]
 8013148:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801314a:	9b01      	ldr	r3, [sp, #4]
 801314c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801314e:	401a      	ands	r2, r3
 8013150:	9b01      	ldr	r3, [sp, #4]
 8013152:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8013154:	429a      	cmp	r2, r3
 8013156:	d105      	bne.n	8013164 <chEvtSignalI+0x54>
    tp->u.rdymsg = MSG_OK;
 8013158:	9b01      	ldr	r3, [sp, #4]
 801315a:	2200      	movs	r2, #0
 801315c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 801315e:	9801      	ldr	r0, [sp, #4]
 8013160:	f001 f91e 	bl	80143a0 <chSchReadyI>
  }
}
 8013164:	b003      	add	sp, #12
 8013166:	f85d fb04 	ldr.w	pc, [sp], #4
 801316a:	bf00      	nop
 801316c:	0000      	movs	r0, r0
	...

08013170 <port_lock.lto_priv.621>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8013170:	b082      	sub	sp, #8
 8013172:	2320      	movs	r3, #32
 8013174:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013176:	9b01      	ldr	r3, [sp, #4]
 8013178:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801317c:	b002      	add	sp, #8
 801317e:	4770      	bx	lr

08013180 <port_unlock.lto_priv.630>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8013180:	b082      	sub	sp, #8
 8013182:	2300      	movs	r3, #0
 8013184:	9301      	str	r3, [sp, #4]
 8013186:	9b01      	ldr	r3, [sp, #4]
 8013188:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801318c:	b002      	add	sp, #8
 801318e:	4770      	bx	lr

08013190 <chSysLock.lto_priv.645>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8013190:	b508      	push	{r3, lr}

  port_lock();
 8013192:	f7ff ffed 	bl	8013170 <port_lock.lto_priv.621>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8013196:	bd08      	pop	{r3, pc}
	...

080131a0 <chSysUnlock.lto_priv.638>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80131a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80131a2:	f7ff ffed 	bl	8013180 <port_unlock.lto_priv.630>
}
 80131a6:	bd08      	pop	{r3, pc}
	...

080131b0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 80131b0:	4b03      	ldr	r3, [pc, #12]	; (80131c0 <_core_init+0x10>)
 80131b2:	4a04      	ldr	r2, [pc, #16]	; (80131c4 <_core_init+0x14>)
 80131b4:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 80131b6:	4b02      	ldr	r3, [pc, #8]	; (80131c0 <_core_init+0x10>)
 80131b8:	4a03      	ldr	r2, [pc, #12]	; (80131c8 <_core_init+0x18>)
 80131ba:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80131bc:	4770      	bx	lr
 80131be:	bf00      	nop
 80131c0:	20005d18 	.word	0x20005d18
 80131c4:	2000f258 	.word	0x2000f258
 80131c8:	20030000 	.word	0x20030000
 80131cc:	00000000 	.word	0x00000000

080131d0 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 80131d0:	b086      	sub	sp, #24
 80131d2:	9003      	str	r0, [sp, #12]
 80131d4:	9102      	str	r1, [sp, #8]
 80131d6:	9201      	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80131d8:	9a02      	ldr	r2, [sp, #8]
 80131da:	9b03      	ldr	r3, [sp, #12]
 80131dc:	4413      	add	r3, r2
 80131de:	1e5a      	subs	r2, r3, #1
 80131e0:	9b02      	ldr	r3, [sp, #8]
 80131e2:	425b      	negs	r3, r3
 80131e4:	4013      	ands	r3, r2
 80131e6:	9303      	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80131e8:	4b11      	ldr	r3, [pc, #68]	; (8013230 <chCoreAllocAlignedWithOffsetI+0x60>)
 80131ea:	681a      	ldr	r2, [r3, #0]
 80131ec:	9b01      	ldr	r3, [sp, #4]
 80131ee:	4413      	add	r3, r2
 80131f0:	461a      	mov	r2, r3
 80131f2:	9b02      	ldr	r3, [sp, #8]
 80131f4:	4413      	add	r3, r2
 80131f6:	1e5a      	subs	r2, r3, #1
 80131f8:	9b02      	ldr	r3, [sp, #8]
 80131fa:	425b      	negs	r3, r3
 80131fc:	4013      	ands	r3, r2
 80131fe:	9305      	str	r3, [sp, #20]
  next = p + size;
 8013200:	9a05      	ldr	r2, [sp, #20]
 8013202:	9b03      	ldr	r3, [sp, #12]
 8013204:	4413      	add	r3, r2
 8013206:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8013208:	4b09      	ldr	r3, [pc, #36]	; (8013230 <chCoreAllocAlignedWithOffsetI+0x60>)
 801320a:	685a      	ldr	r2, [r3, #4]
 801320c:	9b04      	ldr	r3, [sp, #16]
 801320e:	429a      	cmp	r2, r3
 8013210:	d304      	bcc.n	801321c <chCoreAllocAlignedWithOffsetI+0x4c>
 8013212:	4b07      	ldr	r3, [pc, #28]	; (8013230 <chCoreAllocAlignedWithOffsetI+0x60>)
 8013214:	681a      	ldr	r2, [r3, #0]
 8013216:	9b04      	ldr	r3, [sp, #16]
 8013218:	429a      	cmp	r2, r3
 801321a:	d901      	bls.n	8013220 <chCoreAllocAlignedWithOffsetI+0x50>
    return NULL;
 801321c:	2300      	movs	r3, #0
 801321e:	e003      	b.n	8013228 <chCoreAllocAlignedWithOffsetI+0x58>
  }

  ch_memcore.nextmem = next;
 8013220:	4a03      	ldr	r2, [pc, #12]	; (8013230 <chCoreAllocAlignedWithOffsetI+0x60>)
 8013222:	9b04      	ldr	r3, [sp, #16]
 8013224:	6013      	str	r3, [r2, #0]

  return p;
 8013226:	9b05      	ldr	r3, [sp, #20]
}
 8013228:	4618      	mov	r0, r3
 801322a:	b006      	add	sp, #24
 801322c:	4770      	bx	lr
 801322e:	bf00      	nop
 8013230:	20005d18 	.word	0x20005d18
	...

08013240 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8013240:	b500      	push	{lr}
 8013242:	b087      	sub	sp, #28
 8013244:	9003      	str	r0, [sp, #12]
 8013246:	9102      	str	r1, [sp, #8]
 8013248:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 801324a:	f7ff ffa1 	bl	8013190 <chSysLock.lto_priv.645>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 801324e:	9a01      	ldr	r2, [sp, #4]
 8013250:	9902      	ldr	r1, [sp, #8]
 8013252:	9803      	ldr	r0, [sp, #12]
 8013254:	f7ff ffbc 	bl	80131d0 <chCoreAllocAlignedWithOffsetI>
 8013258:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 801325a:	f7ff ffa1 	bl	80131a0 <chSysUnlock.lto_priv.638>

  return p;
 801325e:	9b05      	ldr	r3, [sp, #20]
}
 8013260:	4618      	mov	r0, r3
 8013262:	b007      	add	sp, #28
 8013264:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08013270 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8013270:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8013272:	4b06      	ldr	r3, [pc, #24]	; (801328c <_heap_init+0x1c>)
 8013274:	4a06      	ldr	r2, [pc, #24]	; (8013290 <_heap_init+0x20>)
 8013276:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8013278:	4b04      	ldr	r3, [pc, #16]	; (801328c <_heap_init+0x1c>)
 801327a:	2200      	movs	r2, #0
 801327c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 801327e:	4b03      	ldr	r3, [pc, #12]	; (801328c <_heap_init+0x1c>)
 8013280:	2200      	movs	r2, #0
 8013282:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8013284:	4803      	ldr	r0, [pc, #12]	; (8013294 <_heap_init+0x24>)
 8013286:	f001 fdc3 	bl	8014e10 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 801328a:	bd08      	pop	{r3, pc}
 801328c:	20005d20 	.word	0x20005d20
 8013290:	08013241 	.word	0x08013241
 8013294:	20005d2c 	.word	0x20005d2c
	...

080132a0 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80132a0:	b500      	push	{lr}
 80132a2:	b08d      	sub	sp, #52	; 0x34
 80132a4:	9003      	str	r0, [sp, #12]
 80132a6:	9102      	str	r1, [sp, #8]
 80132a8:	9201      	str	r2, [sp, #4]
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
 80132aa:	9b03      	ldr	r3, [sp, #12]
 80132ac:	2b00      	cmp	r3, #0
 80132ae:	d101      	bne.n	80132b4 <chHeapAllocAligned+0x14>
    heapp = &default_heap;
 80132b0:	4b65      	ldr	r3, [pc, #404]	; (8013448 <chHeapAllocAligned+0x1a8>)
 80132b2:	9303      	str	r3, [sp, #12]
  }

  /* Minimum alignment is constrained by the heap header structure size.*/
  if (align < CH_HEAP_ALIGNMENT) {
 80132b4:	9b01      	ldr	r3, [sp, #4]
 80132b6:	2b07      	cmp	r3, #7
 80132b8:	d801      	bhi.n	80132be <chHeapAllocAligned+0x1e>
    align = CH_HEAP_ALIGNMENT;
 80132ba:	2308      	movs	r3, #8
 80132bc:	9301      	str	r3, [sp, #4]
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80132be:	9b02      	ldr	r3, [sp, #8]
 80132c0:	3307      	adds	r3, #7
 80132c2:	08db      	lsrs	r3, r3, #3
 80132c4:	9309      	str	r3, [sp, #36]	; 0x24

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80132c6:	9b03      	ldr	r3, [sp, #12]
 80132c8:	330c      	adds	r3, #12
 80132ca:	4618      	mov	r0, r3
 80132cc:	f001 fdb0 	bl	8014e30 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 80132d0:	9b03      	ldr	r3, [sp, #12]
 80132d2:	3304      	adds	r3, #4
 80132d4:	930b      	str	r3, [sp, #44]	; 0x2c
 80132d6:	e08c      	b.n	80133f2 <chHeapAllocAligned+0x152>
  while (H_NEXT(qp) != NULL) {

    /* Next free block.*/
    hp = H_NEXT(qp);
 80132d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80132da:	681b      	ldr	r3, [r3, #0]
 80132dc:	930a      	str	r3, [sp, #40]	; 0x28

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80132de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80132e0:	3308      	adds	r3, #8
 80132e2:	461a      	mov	r2, r3
 80132e4:	9b01      	ldr	r3, [sp, #4]
 80132e6:	4413      	add	r3, r2
 80132e8:	1e5a      	subs	r2, r3, #1
 80132ea:	9b01      	ldr	r3, [sp, #4]
 80132ec:	425b      	negs	r3, r3
 80132ee:	4013      	ands	r3, r2
 80132f0:	3b08      	subs	r3, #8
 80132f2:	9308      	str	r3, [sp, #32]

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80132f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80132f6:	685b      	ldr	r3, [r3, #4]
 80132f8:	3301      	adds	r3, #1
 80132fa:	00db      	lsls	r3, r3, #3
 80132fc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80132fe:	441a      	add	r2, r3
 8013300:	9b08      	ldr	r3, [sp, #32]
 8013302:	429a      	cmp	r2, r3
 8013304:	d973      	bls.n	80133ee <chHeapAllocAligned+0x14e>
 8013306:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013308:	685b      	ldr	r3, [r3, #4]
 801330a:	3301      	adds	r3, #1
 801330c:	00db      	lsls	r3, r3, #3
 801330e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013310:	4413      	add	r3, r2
 8013312:	461a      	mov	r2, r3
 8013314:	9b08      	ldr	r3, [sp, #32]
 8013316:	3308      	adds	r3, #8
 8013318:	1ad3      	subs	r3, r2, r3
 801331a:	10db      	asrs	r3, r3, #3
 801331c:	461a      	mov	r2, r3
 801331e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013320:	429a      	cmp	r2, r3
 8013322:	d364      	bcc.n	80133ee <chHeapAllocAligned+0x14e>
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8013324:	9a08      	ldr	r2, [sp, #32]
 8013326:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013328:	429a      	cmp	r2, r3
 801332a:	d92d      	bls.n	8013388 <chHeapAllocAligned+0xe8>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
 801332c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801332e:	685b      	ldr	r3, [r3, #4]
 8013330:	3301      	adds	r3, #1
 8013332:	00db      	lsls	r3, r3, #3
 8013334:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013336:	4413      	add	r3, r2
 8013338:	461a      	mov	r2, r3
 801333a:	9b08      	ldr	r3, [sp, #32]
 801333c:	3308      	adds	r3, #8
 801333e:	1ad3      	subs	r3, r2, r3
 8013340:	10db      	asrs	r3, r3, #3
 8013342:	9307      	str	r3, [sp, #28]
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8013344:	9b08      	ldr	r3, [sp, #32]
 8013346:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013348:	3208      	adds	r2, #8
 801334a:	1a9b      	subs	r3, r3, r2
 801334c:	10db      	asrs	r3, r3, #3
 801334e:	461a      	mov	r2, r3
 8013350:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013352:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 8013354:	9a07      	ldr	r2, [sp, #28]
 8013356:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013358:	429a      	cmp	r2, r3
 801335a:	d912      	bls.n	8013382 <chHeapAllocAligned+0xe2>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 801335c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801335e:	3301      	adds	r3, #1
 8013360:	00db      	lsls	r3, r3, #3
 8013362:	9a08      	ldr	r2, [sp, #32]
 8013364:	4413      	add	r3, r2
 8013366:	9306      	str	r3, [sp, #24]
          H_PAGES(fp) = (bpages - pages) - 1U;
 8013368:	9a07      	ldr	r2, [sp, #28]
 801336a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801336c:	1ad3      	subs	r3, r2, r3
 801336e:	1e5a      	subs	r2, r3, #1
 8013370:	9b06      	ldr	r3, [sp, #24]
 8013372:	605a      	str	r2, [r3, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8013374:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013376:	681a      	ldr	r2, [r3, #0]
 8013378:	9b06      	ldr	r3, [sp, #24]
 801337a:	601a      	str	r2, [r3, #0]
          H_NEXT(hp) = fp;
 801337c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801337e:	9a06      	ldr	r2, [sp, #24]
 8013380:	601a      	str	r2, [r3, #0]
        }

        hp = ahp;
 8013382:	9b08      	ldr	r3, [sp, #32]
 8013384:	930a      	str	r3, [sp, #40]	; 0x28
 8013386:	e024      	b.n	80133d2 <chHeapAllocAligned+0x132>
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8013388:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801338a:	685a      	ldr	r2, [r3, #4]
 801338c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801338e:	429a      	cmp	r2, r3
 8013390:	d104      	bne.n	801339c <chHeapAllocAligned+0xfc>
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 8013392:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013394:	681a      	ldr	r2, [r3, #0]
 8013396:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013398:	601a      	str	r2, [r3, #0]
 801339a:	e01a      	b.n	80133d2 <chHeapAllocAligned+0x132>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 801339c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801339e:	3301      	adds	r3, #1
 80133a0:	00db      	lsls	r3, r3, #3
 80133a2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80133a4:	4413      	add	r3, r2
 80133a6:	9305      	str	r3, [sp, #20]
          H_NEXT(fp) = H_NEXT(hp);
 80133a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133aa:	681a      	ldr	r2, [r3, #0]
 80133ac:	9b05      	ldr	r3, [sp, #20]
 80133ae:	601a      	str	r2, [r3, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80133b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133b2:	685b      	ldr	r3, [r3, #4]
 80133b4:	3301      	adds	r3, #1
 80133b6:	00db      	lsls	r3, r3, #3
 80133b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80133ba:	4413      	add	r3, r2
 80133bc:	461a      	mov	r2, r3
 80133be:	9b05      	ldr	r3, [sp, #20]
 80133c0:	3308      	adds	r3, #8
 80133c2:	1ad3      	subs	r3, r2, r3
 80133c4:	10db      	asrs	r3, r3, #3
 80133c6:	461a      	mov	r2, r3
 80133c8:	9b05      	ldr	r3, [sp, #20]
 80133ca:	605a      	str	r2, [r3, #4]
          H_NEXT(qp) = fp;
 80133cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80133ce:	9a05      	ldr	r2, [sp, #20]
 80133d0:	601a      	str	r2, [r3, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 80133d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133d4:	9a02      	ldr	r2, [sp, #8]
 80133d6:	605a      	str	r2, [r3, #4]
      H_HEAP(hp) = heapp;
 80133d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133da:	9a03      	ldr	r2, [sp, #12]
 80133dc:	601a      	str	r2, [r3, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 80133de:	9b03      	ldr	r3, [sp, #12]
 80133e0:	330c      	adds	r3, #12
 80133e2:	4618      	mov	r0, r3
 80133e4:	f001 fd94 	bl	8014f10 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 80133e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133ea:	3308      	adds	r3, #8
 80133ec:	e027      	b.n	801343e <chHeapAllocAligned+0x19e>
      /*lint -restore*/
    }

    /* Next in the free blocks list.*/
    qp = hp;
 80133ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133f0:	930b      	str	r3, [sp, #44]	; 0x2c
  while (H_NEXT(qp) != NULL) {
 80133f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80133f4:	681b      	ldr	r3, [r3, #0]
 80133f6:	2b00      	cmp	r3, #0
 80133f8:	f47f af6e 	bne.w	80132d8 <chHeapAllocAligned+0x38>
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80133fc:	9b03      	ldr	r3, [sp, #12]
 80133fe:	330c      	adds	r3, #12
 8013400:	4618      	mov	r0, r3
 8013402:	f001 fd85 	bl	8014f10 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8013406:	9b03      	ldr	r3, [sp, #12]
 8013408:	681b      	ldr	r3, [r3, #0]
 801340a:	2b00      	cmp	r3, #0
 801340c:	d016      	beq.n	801343c <chHeapAllocAligned+0x19c>
    ahp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT,
 801340e:	9b03      	ldr	r3, [sp, #12]
 8013410:	681b      	ldr	r3, [r3, #0]
 8013412:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8013414:	3201      	adds	r2, #1
 8013416:	00d0      	lsls	r0, r2, #3
 8013418:	2208      	movs	r2, #8
 801341a:	9901      	ldr	r1, [sp, #4]
 801341c:	4798      	blx	r3
 801341e:	9008      	str	r0, [sp, #32]
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 8013420:	9b08      	ldr	r3, [sp, #32]
 8013422:	2b00      	cmp	r3, #0
 8013424:	d00a      	beq.n	801343c <chHeapAllocAligned+0x19c>
      hp = ahp - 1U;
 8013426:	9b08      	ldr	r3, [sp, #32]
 8013428:	3b08      	subs	r3, #8
 801342a:	930a      	str	r3, [sp, #40]	; 0x28
      H_HEAP(hp) = heapp;
 801342c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801342e:	9a03      	ldr	r2, [sp, #12]
 8013430:	601a      	str	r2, [r3, #0]
      H_SIZE(hp) = size;
 8013432:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013434:	9a02      	ldr	r2, [sp, #8]
 8013436:	605a      	str	r2, [r3, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)ahp;
 8013438:	9b08      	ldr	r3, [sp, #32]
 801343a:	e000      	b.n	801343e <chHeapAllocAligned+0x19e>
      /*lint -restore*/
    }
  }

  return NULL;
 801343c:	2300      	movs	r3, #0
}
 801343e:	4618      	mov	r0, r3
 8013440:	b00d      	add	sp, #52	; 0x34
 8013442:	f85d fb04 	ldr.w	pc, [sp], #4
 8013446:	bf00      	nop
 8013448:	20005d20 	.word	0x20005d20
 801344c:	00000000 	.word	0x00000000

08013450 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8013450:	b500      	push	{lr}
 8013452:	b087      	sub	sp, #28
 8013454:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8013456:	9b01      	ldr	r3, [sp, #4]
 8013458:	3b08      	subs	r3, #8
 801345a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 801345c:	9b04      	ldr	r3, [sp, #16]
 801345e:	681b      	ldr	r3, [r3, #0]
 8013460:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8013462:	9b03      	ldr	r3, [sp, #12]
 8013464:	3304      	adds	r3, #4
 8013466:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8013468:	9b04      	ldr	r3, [sp, #16]
 801346a:	685b      	ldr	r3, [r3, #4]
 801346c:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 801346e:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8013470:	9b04      	ldr	r3, [sp, #16]
 8013472:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8013474:	9b03      	ldr	r3, [sp, #12]
 8013476:	330c      	adds	r3, #12
 8013478:	4618      	mov	r0, r3
 801347a:	f001 fcd9 	bl	8014e30 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 801347e:	9b03      	ldr	r3, [sp, #12]
 8013480:	1d1a      	adds	r2, r3, #4
 8013482:	9b05      	ldr	r3, [sp, #20]
 8013484:	429a      	cmp	r2, r3
 8013486:	d003      	beq.n	8013490 <chHeapFree+0x40>
 8013488:	9a04      	ldr	r2, [sp, #16]
 801348a:	9b05      	ldr	r3, [sp, #20]
 801348c:	429a      	cmp	r2, r3
 801348e:	d942      	bls.n	8013516 <chHeapFree+0xc6>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8013490:	9b05      	ldr	r3, [sp, #20]
 8013492:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8013494:	2b00      	cmp	r3, #0
 8013496:	d004      	beq.n	80134a2 <chHeapFree+0x52>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8013498:	9b05      	ldr	r3, [sp, #20]
 801349a:	681a      	ldr	r2, [r3, #0]
 801349c:	9b04      	ldr	r3, [sp, #16]
 801349e:	429a      	cmp	r2, r3
 80134a0:	d939      	bls.n	8013516 <chHeapFree+0xc6>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80134a2:	9b05      	ldr	r3, [sp, #20]
 80134a4:	681a      	ldr	r2, [r3, #0]
 80134a6:	9b04      	ldr	r3, [sp, #16]
 80134a8:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 80134aa:	9b05      	ldr	r3, [sp, #20]
 80134ac:	9a04      	ldr	r2, [sp, #16]
 80134ae:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80134b0:	9b04      	ldr	r3, [sp, #16]
 80134b2:	685b      	ldr	r3, [r3, #4]
 80134b4:	3301      	adds	r3, #1
 80134b6:	00db      	lsls	r3, r3, #3
 80134b8:	9a04      	ldr	r2, [sp, #16]
 80134ba:	441a      	add	r2, r3
 80134bc:	9b04      	ldr	r3, [sp, #16]
 80134be:	681b      	ldr	r3, [r3, #0]
 80134c0:	429a      	cmp	r2, r3
 80134c2:	d10d      	bne.n	80134e0 <chHeapFree+0x90>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80134c4:	9b04      	ldr	r3, [sp, #16]
 80134c6:	685a      	ldr	r2, [r3, #4]
 80134c8:	9b04      	ldr	r3, [sp, #16]
 80134ca:	681b      	ldr	r3, [r3, #0]
 80134cc:	685b      	ldr	r3, [r3, #4]
 80134ce:	4413      	add	r3, r2
 80134d0:	1c5a      	adds	r2, r3, #1
 80134d2:	9b04      	ldr	r3, [sp, #16]
 80134d4:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80134d6:	9b04      	ldr	r3, [sp, #16]
 80134d8:	681b      	ldr	r3, [r3, #0]
 80134da:	681a      	ldr	r2, [r3, #0]
 80134dc:	9b04      	ldr	r3, [sp, #16]
 80134de:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80134e0:	9b05      	ldr	r3, [sp, #20]
 80134e2:	685b      	ldr	r3, [r3, #4]
 80134e4:	3301      	adds	r3, #1
 80134e6:	00db      	lsls	r3, r3, #3
 80134e8:	9a05      	ldr	r2, [sp, #20]
 80134ea:	441a      	add	r2, r3
 80134ec:	9b04      	ldr	r3, [sp, #16]
 80134ee:	429a      	cmp	r2, r3
 80134f0:	d10b      	bne.n	801350a <chHeapFree+0xba>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80134f2:	9b05      	ldr	r3, [sp, #20]
 80134f4:	685a      	ldr	r2, [r3, #4]
 80134f6:	9b04      	ldr	r3, [sp, #16]
 80134f8:	685b      	ldr	r3, [r3, #4]
 80134fa:	4413      	add	r3, r2
 80134fc:	1c5a      	adds	r2, r3, #1
 80134fe:	9b05      	ldr	r3, [sp, #20]
 8013500:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8013502:	9b04      	ldr	r3, [sp, #16]
 8013504:	681a      	ldr	r2, [r3, #0]
 8013506:	9b05      	ldr	r3, [sp, #20]
 8013508:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 801350a:	9b03      	ldr	r3, [sp, #12]
 801350c:	330c      	adds	r3, #12
 801350e:	4618      	mov	r0, r3
 8013510:	f001 fcfe 	bl	8014f10 <chMtxUnlock>
 8013514:	e003      	b.n	801351e <chHeapFree+0xce>
    qp = H_NEXT(qp);
 8013516:	9b05      	ldr	r3, [sp, #20]
 8013518:	681b      	ldr	r3, [r3, #0]
 801351a:	9305      	str	r3, [sp, #20]
 801351c:	e7af      	b.n	801347e <chHeapFree+0x2e>

  return;
}
 801351e:	b007      	add	sp, #28
 8013520:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08013530 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8013530:	b084      	sub	sp, #16
 8013532:	9003      	str	r0, [sp, #12]
 8013534:	9102      	str	r1, [sp, #8]
 8013536:	9201      	str	r2, [sp, #4]
 8013538:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 801353a:	9b03      	ldr	r3, [sp, #12]
 801353c:	2200      	movs	r2, #0
 801353e:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8013540:	9b03      	ldr	r3, [sp, #12]
 8013542:	9a02      	ldr	r2, [sp, #8]
 8013544:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8013546:	9b03      	ldr	r3, [sp, #12]
 8013548:	9a01      	ldr	r2, [sp, #4]
 801354a:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 801354c:	9b03      	ldr	r3, [sp, #12]
 801354e:	9a00      	ldr	r2, [sp, #0]
 8013550:	60da      	str	r2, [r3, #12]
}
 8013552:	b004      	add	sp, #16
 8013554:	4770      	bx	lr
 8013556:	bf00      	nop
	...

08013560 <chCoreAllocAlignedI>:
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8013560:	b500      	push	{lr}
 8013562:	b083      	sub	sp, #12
 8013564:	9001      	str	r0, [sp, #4]
 8013566:	9100      	str	r1, [sp, #0]
  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8013568:	2200      	movs	r2, #0
 801356a:	9900      	ldr	r1, [sp, #0]
 801356c:	9801      	ldr	r0, [sp, #4]
 801356e:	f7ff fe2f 	bl	80131d0 <chCoreAllocAlignedWithOffsetI>
 8013572:	4603      	mov	r3, r0
}
 8013574:	4618      	mov	r0, r3
 8013576:	b003      	add	sp, #12
 8013578:	f85d fb04 	ldr.w	pc, [sp], #4
 801357c:	0000      	movs	r0, r0
	...

08013580 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8013580:	b500      	push	{lr}
 8013582:	b085      	sub	sp, #20
 8013584:	9003      	str	r0, [sp, #12]
 8013586:	9102      	str	r1, [sp, #8]
 8013588:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 801358a:	9b01      	ldr	r3, [sp, #4]
 801358c:	2204      	movs	r2, #4
 801358e:	9902      	ldr	r1, [sp, #8]
 8013590:	9803      	ldr	r0, [sp, #12]
 8013592:	f7ff ffcd 	bl	8013530 <chPoolObjectInitAligned>
}
 8013596:	b005      	add	sp, #20
 8013598:	f85d fb04 	ldr.w	pc, [sp], #4
 801359c:	0000      	movs	r0, r0
	...

080135a0 <dyn_list_init>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {
 80135a0:	b082      	sub	sp, #8
 80135a2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 80135a4:	9b01      	ldr	r3, [sp, #4]
 80135a6:	9a01      	ldr	r2, [sp, #4]
 80135a8:	601a      	str	r2, [r3, #0]
}
 80135aa:	b002      	add	sp, #8
 80135ac:	4770      	bx	lr
 80135ae:	bf00      	nop

080135b0 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 80135b0:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 80135b2:	480e      	ldr	r0, [pc, #56]	; (80135ec <_factory_init+0x3c>)
 80135b4:	f001 fc2c 	bl	8014e10 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 80135b8:	480d      	ldr	r0, [pc, #52]	; (80135f0 <_factory_init+0x40>)
 80135ba:	f7ff fff1 	bl	80135a0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 80135be:	4a0d      	ldr	r2, [pc, #52]	; (80135f4 <_factory_init+0x44>)
 80135c0:	2114      	movs	r1, #20
 80135c2:	480d      	ldr	r0, [pc, #52]	; (80135f8 <_factory_init+0x48>)
 80135c4:	f7ff ffdc 	bl	8013580 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 80135c8:	480c      	ldr	r0, [pc, #48]	; (80135fc <_factory_init+0x4c>)
 80135ca:	f7ff ffe9 	bl	80135a0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 80135ce:	480c      	ldr	r0, [pc, #48]	; (8013600 <_factory_init+0x50>)
 80135d0:	f7ff ffe6 	bl	80135a0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 80135d4:	4a07      	ldr	r2, [pc, #28]	; (80135f4 <_factory_init+0x44>)
 80135d6:	211c      	movs	r1, #28
 80135d8:	480a      	ldr	r0, [pc, #40]	; (8013604 <_factory_init+0x54>)
 80135da:	f7ff ffd1 	bl	8013580 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 80135de:	480a      	ldr	r0, [pc, #40]	; (8013608 <_factory_init+0x58>)
 80135e0:	f7ff ffde 	bl	80135a0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 80135e4:	4809      	ldr	r0, [pc, #36]	; (801360c <_factory_init+0x5c>)
 80135e6:	f7ff ffdb 	bl	80135a0 <dyn_list_init>
#endif
}
 80135ea:	bd08      	pop	{r3, pc}
 80135ec:	20005d3c 	.word	0x20005d3c
 80135f0:	20005d4c 	.word	0x20005d4c
 80135f4:	08013561 	.word	0x08013561
 80135f8:	20005d50 	.word	0x20005d50
 80135fc:	20005d60 	.word	0x20005d60
 8013600:	20005d64 	.word	0x20005d64
 8013604:	20005d68 	.word	0x20005d68
 8013608:	20005d78 	.word	0x20005d78
 801360c:	20005d7c 	.word	0x20005d7c

08013610 <port_lock.lto_priv.623>:
static inline void port_lock(void) {
 8013610:	b082      	sub	sp, #8
 8013612:	2320      	movs	r3, #32
 8013614:	9301      	str	r3, [sp, #4]
 8013616:	9b01      	ldr	r3, [sp, #4]
 8013618:	f383 8811 	msr	BASEPRI, r3
}
 801361c:	b002      	add	sp, #8
 801361e:	4770      	bx	lr

08013620 <port_unlock.lto_priv.632>:
static inline void port_unlock(void) {
 8013620:	b082      	sub	sp, #8
 8013622:	2300      	movs	r3, #0
 8013624:	9301      	str	r3, [sp, #4]
 8013626:	9b01      	ldr	r3, [sp, #4]
 8013628:	f383 8811 	msr	BASEPRI, r3
}
 801362c:	b002      	add	sp, #8
 801362e:	4770      	bx	lr

08013630 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8013630:	b508      	push	{r3, lr}

  port_lock();
 8013632:	f7ff ffed 	bl	8013610 <port_lock.lto_priv.623>
}
 8013636:	bd08      	pop	{r3, pc}
	...

08013640 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8013640:	b508      	push	{r3, lr}

  port_unlock();
 8013642:	f7ff ffed 	bl	8013620 <port_unlock.lto_priv.632>
}
 8013646:	bd08      	pop	{r3, pc}
	...

08013650 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8013650:	b510      	push	{r4, lr}
 8013652:	b082      	sub	sp, #8
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8013654:	4a0b      	ldr	r2, [pc, #44]	; (8013684 <SVC_Handler+0x34>)
 8013656:	4b0b      	ldr	r3, [pc, #44]	; (8013684 <SVC_Handler+0x34>)
 8013658:	685b      	ldr	r3, [r3, #4]
 801365a:	f023 0301 	bic.w	r3, r3, #1
 801365e:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8013660:	f3ef 8309 	mrs	r3, PSP
 8013664:	461c      	mov	r4, r3
  return(result);
 8013666:	4623      	mov	r3, r4
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8013668:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 801366a:	9b01      	ldr	r3, [sp, #4]
 801366c:	3368      	adds	r3, #104	; 0x68
 801366e:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8013670:	9b01      	ldr	r3, [sp, #4]
 8013672:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8013674:	9b00      	ldr	r3, [sp, #0]
 8013676:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 801367a:	f7ff ffe1 	bl	8013640 <port_unlock_from_isr>
}
 801367e:	b002      	add	sp, #8
 8013680:	bd10      	pop	{r4, pc}
 8013682:	bf00      	nop
 8013684:	e000ef30 	.word	0xe000ef30
	...

08013690 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8013690:	b510      	push	{r4, lr}
 8013692:	b084      	sub	sp, #16

  port_lock_from_isr();
 8013694:	f7ff ffcc 	bl	8013630 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8013698:	4b17      	ldr	r3, [pc, #92]	; (80136f8 <_port_irq_epilogue+0x68>)
 801369a:	685b      	ldr	r3, [r3, #4]
 801369c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80136a0:	2b00      	cmp	r3, #0
 80136a2:	d025      	beq.n	80136f0 <_port_irq_epilogue+0x60>
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 80136a4:	eef1 3a10 	vmrs	r3, fpscr
 80136a8:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80136aa:	f3ef 8309 	mrs	r3, PSP
 80136ae:	461c      	mov	r4, r3
  return(result);
 80136b0:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 80136b2:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80136b4:	9b03      	ldr	r3, [sp, #12]
 80136b6:	3b68      	subs	r3, #104	; 0x68
 80136b8:	9303      	str	r3, [sp, #12]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80136ba:	9b03      	ldr	r3, [sp, #12]
 80136bc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80136c0:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80136c2:	4b0e      	ldr	r3, [pc, #56]	; (80136fc <_port_irq_epilogue+0x6c>)
 80136c4:	68db      	ldr	r3, [r3, #12]
 80136c6:	461a      	mov	r2, r3
 80136c8:	9b03      	ldr	r3, [sp, #12]
 80136ca:	661a      	str	r2, [r3, #96]	; 0x60
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 80136cc:	9b03      	ldr	r3, [sp, #12]
 80136ce:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80136d0:	9b02      	ldr	r3, [sp, #8]
 80136d2:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80136d6:	f000 ff8b 	bl	80145f0 <chSchIsPreemptionRequired>
 80136da:	4603      	mov	r3, r0
 80136dc:	2b00      	cmp	r3, #0
 80136de:	d003      	beq.n	80136e8 <_port_irq_epilogue+0x58>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80136e0:	9b03      	ldr	r3, [sp, #12]
 80136e2:	4a07      	ldr	r2, [pc, #28]	; (8013700 <_port_irq_epilogue+0x70>)
 80136e4:	619a      	str	r2, [r3, #24]
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80136e6:	e005      	b.n	80136f4 <_port_irq_epilogue+0x64>
 80136e8:	9b03      	ldr	r3, [sp, #12]
 80136ea:	4a06      	ldr	r2, [pc, #24]	; (8013704 <_port_irq_epilogue+0x74>)
 80136ec:	619a      	str	r2, [r3, #24]
 80136ee:	e001      	b.n	80136f4 <_port_irq_epilogue+0x64>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80136f0:	f7ff ffa6 	bl	8013640 <port_unlock_from_isr>
}
 80136f4:	b004      	add	sp, #16
 80136f6:	bd10      	pop	{r4, pc}
 80136f8:	e000ed00 	.word	0xe000ed00
 80136fc:	e000ef30 	.word	0xe000ef30
 8013700:	08004331 	.word	0x08004331
 8013704:	08004334 	.word	0x08004334
	...

08013710 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8013710:	b088      	sub	sp, #32
 8013712:	9003      	str	r0, [sp, #12]
 8013714:	9102      	str	r1, [sp, #8]
 8013716:	9201      	str	r2, [sp, #4]
 8013718:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 801371a:	9b02      	ldr	r3, [sp, #8]
 801371c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 801371e:	9b00      	ldr	r3, [sp, #0]
 8013720:	2b00      	cmp	r3, #0
 8013722:	d102      	bne.n	801372a <long_to_string_with_divisor+0x1a>
    ll = num;
 8013724:	9b02      	ldr	r3, [sp, #8]
 8013726:	9304      	str	r3, [sp, #16]
 8013728:	e001      	b.n	801372e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 801372a:	9b00      	ldr	r3, [sp, #0]
 801372c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 801372e:	9b03      	ldr	r3, [sp, #12]
 8013730:	330b      	adds	r3, #11
 8013732:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8013734:	9b05      	ldr	r3, [sp, #20]
 8013736:	9a01      	ldr	r2, [sp, #4]
 8013738:	fbb3 f2f2 	udiv	r2, r3, r2
 801373c:	9901      	ldr	r1, [sp, #4]
 801373e:	fb01 f202 	mul.w	r2, r1, r2
 8013742:	1a9b      	subs	r3, r3, r2
 8013744:	9307      	str	r3, [sp, #28]
    i += '0';
 8013746:	9b07      	ldr	r3, [sp, #28]
 8013748:	3330      	adds	r3, #48	; 0x30
 801374a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 801374c:	9b07      	ldr	r3, [sp, #28]
 801374e:	2b39      	cmp	r3, #57	; 0x39
 8013750:	dd02      	ble.n	8013758 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8013752:	9b07      	ldr	r3, [sp, #28]
 8013754:	3307      	adds	r3, #7
 8013756:	9307      	str	r3, [sp, #28]
    *--q = i;
 8013758:	9b06      	ldr	r3, [sp, #24]
 801375a:	3b01      	subs	r3, #1
 801375c:	9306      	str	r3, [sp, #24]
 801375e:	9b07      	ldr	r3, [sp, #28]
 8013760:	b2da      	uxtb	r2, r3
 8013762:	9b06      	ldr	r3, [sp, #24]
 8013764:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8013766:	9a05      	ldr	r2, [sp, #20]
 8013768:	9b01      	ldr	r3, [sp, #4]
 801376a:	fbb2 f3f3 	udiv	r3, r2, r3
 801376e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8013770:	9a04      	ldr	r2, [sp, #16]
 8013772:	9b01      	ldr	r3, [sp, #4]
 8013774:	fbb2 f3f3 	udiv	r3, r2, r3
 8013778:	9304      	str	r3, [sp, #16]
 801377a:	9b04      	ldr	r3, [sp, #16]
 801377c:	2b00      	cmp	r3, #0
 801377e:	d1d9      	bne.n	8013734 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8013780:	9b03      	ldr	r3, [sp, #12]
 8013782:	330b      	adds	r3, #11
 8013784:	461a      	mov	r2, r3
 8013786:	9b06      	ldr	r3, [sp, #24]
 8013788:	1ad3      	subs	r3, r2, r3
 801378a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 801378c:	9b03      	ldr	r3, [sp, #12]
 801378e:	1c5a      	adds	r2, r3, #1
 8013790:	9203      	str	r2, [sp, #12]
 8013792:	9a06      	ldr	r2, [sp, #24]
 8013794:	1c51      	adds	r1, r2, #1
 8013796:	9106      	str	r1, [sp, #24]
 8013798:	7812      	ldrb	r2, [r2, #0]
 801379a:	701a      	strb	r2, [r3, #0]
  while (--i);
 801379c:	9b07      	ldr	r3, [sp, #28]
 801379e:	3b01      	subs	r3, #1
 80137a0:	9307      	str	r3, [sp, #28]
 80137a2:	9b07      	ldr	r3, [sp, #28]
 80137a4:	2b00      	cmp	r3, #0
 80137a6:	d1f1      	bne.n	801378c <long_to_string_with_divisor+0x7c>

  return p;
 80137a8:	9b03      	ldr	r3, [sp, #12]
}
 80137aa:	4618      	mov	r0, r3
 80137ac:	b008      	add	sp, #32
 80137ae:	4770      	bx	lr

080137b0 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 80137b0:	b500      	push	{lr}
 80137b2:	b085      	sub	sp, #20
 80137b4:	9003      	str	r0, [sp, #12]
 80137b6:	9102      	str	r1, [sp, #8]
 80137b8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 80137ba:	2300      	movs	r3, #0
 80137bc:	9a01      	ldr	r2, [sp, #4]
 80137be:	9902      	ldr	r1, [sp, #8]
 80137c0:	9803      	ldr	r0, [sp, #12]
 80137c2:	f7ff ffa5 	bl	8013710 <long_to_string_with_divisor>
 80137c6:	4603      	mov	r3, r0
}
 80137c8:	4618      	mov	r0, r3
 80137ca:	b005      	add	sp, #20
 80137cc:	f85d fb04 	ldr.w	pc, [sp], #4

080137d0 <ftoa>:
#if CHPRINTF_USE_FLOAT
static const long pow10[FLOAT_PRECISION] = {
    10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
};

static char *ftoa(char *p, double num, unsigned long precision) {
 80137d0:	b530      	push	{r4, r5, lr}
 80137d2:	b087      	sub	sp, #28
 80137d4:	9003      	str	r0, [sp, #12]
 80137d6:	e9cd 2300 	strd	r2, r3, [sp]
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80137da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80137dc:	2b00      	cmp	r3, #0
 80137de:	d002      	beq.n	80137e6 <ftoa+0x16>
 80137e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80137e2:	2b09      	cmp	r3, #9
 80137e4:	d901      	bls.n	80137ea <ftoa+0x1a>
    precision = FLOAT_PRECISION;
 80137e6:	2309      	movs	r3, #9
 80137e8:	930a      	str	r3, [sp, #40]	; 0x28
  precision = pow10[precision - 1];
 80137ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80137ec:	3b01      	subs	r3, #1
 80137ee:	4a22      	ldr	r2, [pc, #136]	; (8013878 <ftoa+0xa8>)
 80137f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80137f4:	930a      	str	r3, [sp, #40]	; 0x28

  l = (long)num;
 80137f6:	e9dd 0100 	ldrd	r0, r1, [sp]
 80137fa:	f7f1 fd7b 	bl	80052f4 <__aeabi_d2iz>
 80137fe:	4603      	mov	r3, r0
 8013800:	9305      	str	r3, [sp, #20]
  p = long_to_string_with_divisor(p, l, 10, 0);
 8013802:	2300      	movs	r3, #0
 8013804:	220a      	movs	r2, #10
 8013806:	9905      	ldr	r1, [sp, #20]
 8013808:	9803      	ldr	r0, [sp, #12]
 801380a:	f7ff ff81 	bl	8013710 <long_to_string_with_divisor>
 801380e:	9003      	str	r0, [sp, #12]
  *p++ = '.';
 8013810:	9b03      	ldr	r3, [sp, #12]
 8013812:	1c5a      	adds	r2, r3, #1
 8013814:	9203      	str	r2, [sp, #12]
 8013816:	222e      	movs	r2, #46	; 0x2e
 8013818:	701a      	strb	r2, [r3, #0]
  l = (long)((num - l) * precision);
 801381a:	9805      	ldr	r0, [sp, #20]
 801381c:	f7f1 faf2 	bl	8004e04 <__aeabi_i2d>
 8013820:	4603      	mov	r3, r0
 8013822:	460c      	mov	r4, r1
 8013824:	461a      	mov	r2, r3
 8013826:	4623      	mov	r3, r4
 8013828:	e9dd 0100 	ldrd	r0, r1, [sp]
 801382c:	f7f1 f99c 	bl	8004b68 <__aeabi_dsub>
 8013830:	4603      	mov	r3, r0
 8013832:	460c      	mov	r4, r1
 8013834:	4625      	mov	r5, r4
 8013836:	461c      	mov	r4, r3
 8013838:	980a      	ldr	r0, [sp, #40]	; 0x28
 801383a:	f7f1 fad3 	bl	8004de4 <__aeabi_ui2d>
 801383e:	4602      	mov	r2, r0
 8013840:	460b      	mov	r3, r1
 8013842:	4620      	mov	r0, r4
 8013844:	4629      	mov	r1, r5
 8013846:	f7f1 fb43 	bl	8004ed0 <__aeabi_dmul>
 801384a:	4603      	mov	r3, r0
 801384c:	460c      	mov	r4, r1
 801384e:	4618      	mov	r0, r3
 8013850:	4621      	mov	r1, r4
 8013852:	f7f1 fd4f 	bl	80052f4 <__aeabi_d2iz>
 8013856:	4603      	mov	r3, r0
 8013858:	9305      	str	r3, [sp, #20]
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 801385a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801385c:	4a07      	ldr	r2, [pc, #28]	; (801387c <ftoa+0xac>)
 801385e:	fba2 2303 	umull	r2, r3, r2, r3
 8013862:	08db      	lsrs	r3, r3, #3
 8013864:	220a      	movs	r2, #10
 8013866:	9905      	ldr	r1, [sp, #20]
 8013868:	9803      	ldr	r0, [sp, #12]
 801386a:	f7ff ff51 	bl	8013710 <long_to_string_with_divisor>
 801386e:	4603      	mov	r3, r0
}
 8013870:	4618      	mov	r0, r3
 8013872:	b007      	add	sp, #28
 8013874:	bd30      	pop	{r4, r5, pc}
 8013876:	bf00      	nop
 8013878:	080241b4 	.word	0x080241b4
 801387c:	cccccccd 	.word	0xcccccccd

08013880 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8013880:	b510      	push	{r4, lr}
 8013882:	b096      	sub	sp, #88	; 0x58
 8013884:	9005      	str	r0, [sp, #20]
 8013886:	9104      	str	r1, [sp, #16]
 8013888:	9203      	str	r2, [sp, #12]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 801388a:	2300      	movs	r3, #0
 801388c:	930f      	str	r3, [sp, #60]	; 0x3c
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 801388e:	9b04      	ldr	r3, [sp, #16]
 8013890:	1c5a      	adds	r2, r3, #1
 8013892:	9204      	str	r2, [sp, #16]
 8013894:	781b      	ldrb	r3, [r3, #0]
 8013896:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    if (c == 0)
 801389a:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 801389e:	2b00      	cmp	r3, #0
 80138a0:	d101      	bne.n	80138a6 <chvprintf+0x26>
      return n;
 80138a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80138a4:	e23a      	b.n	8013d1c <chvprintf+0x49c>
    if (c != '%') {
 80138a6:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80138aa:	2b25      	cmp	r3, #37	; 0x25
 80138ac:	d00b      	beq.n	80138c6 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 80138ae:	9b05      	ldr	r3, [sp, #20]
 80138b0:	681b      	ldr	r3, [r3, #0]
 80138b2:	689b      	ldr	r3, [r3, #8]
 80138b4:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
 80138b8:	4611      	mov	r1, r2
 80138ba:	9805      	ldr	r0, [sp, #20]
 80138bc:	4798      	blx	r3
      n++;
 80138be:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80138c0:	3301      	adds	r3, #1
 80138c2:	930f      	str	r3, [sp, #60]	; 0x3c
 80138c4:	e7e3      	b.n	801388e <chvprintf+0xe>
      continue;
    }
    p = tmpbuf;
 80138c6:	ab06      	add	r3, sp, #24
 80138c8:	9315      	str	r3, [sp, #84]	; 0x54
    s = tmpbuf;
 80138ca:	ab06      	add	r3, sp, #24
 80138cc:	9314      	str	r3, [sp, #80]	; 0x50
    left_align = FALSE;
 80138ce:	2300      	movs	r3, #0
 80138d0:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    if (*fmt == '-') {
 80138d4:	9b04      	ldr	r3, [sp, #16]
 80138d6:	781b      	ldrb	r3, [r3, #0]
 80138d8:	2b2d      	cmp	r3, #45	; 0x2d
 80138da:	d105      	bne.n	80138e8 <chvprintf+0x68>
      fmt++;
 80138dc:	9b04      	ldr	r3, [sp, #16]
 80138de:	3301      	adds	r3, #1
 80138e0:	9304      	str	r3, [sp, #16]
      left_align = TRUE;
 80138e2:	2301      	movs	r3, #1
 80138e4:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    }
    filler = ' ';
 80138e8:	2320      	movs	r3, #32
 80138ea:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
    if (*fmt == '0') {
 80138ee:	9b04      	ldr	r3, [sp, #16]
 80138f0:	781b      	ldrb	r3, [r3, #0]
 80138f2:	2b30      	cmp	r3, #48	; 0x30
 80138f4:	d105      	bne.n	8013902 <chvprintf+0x82>
      fmt++;
 80138f6:	9b04      	ldr	r3, [sp, #16]
 80138f8:	3301      	adds	r3, #1
 80138fa:	9304      	str	r3, [sp, #16]
      filler = '0';
 80138fc:	2330      	movs	r3, #48	; 0x30
 80138fe:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
    }
    width = 0;
 8013902:	2300      	movs	r3, #0
 8013904:	9310      	str	r3, [sp, #64]	; 0x40
    while (TRUE) {
      c = *fmt++;
 8013906:	9b04      	ldr	r3, [sp, #16]
 8013908:	1c5a      	adds	r2, r3, #1
 801390a:	9204      	str	r2, [sp, #16]
 801390c:	781b      	ldrb	r3, [r3, #0]
 801390e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
      if (c >= '0' && c <= '9')
 8013912:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013916:	2b2f      	cmp	r3, #47	; 0x2f
 8013918:	d909      	bls.n	801392e <chvprintf+0xae>
 801391a:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 801391e:	2b39      	cmp	r3, #57	; 0x39
 8013920:	d805      	bhi.n	801392e <chvprintf+0xae>
        c -= '0';
 8013922:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013926:	3b30      	subs	r3, #48	; 0x30
 8013928:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 801392c:	e009      	b.n	8013942 <chvprintf+0xc2>
      else if (c == '*')
 801392e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013932:	2b2a      	cmp	r3, #42	; 0x2a
 8013934:	d110      	bne.n	8013958 <chvprintf+0xd8>
        c = va_arg(ap, int);
 8013936:	9b03      	ldr	r3, [sp, #12]
 8013938:	1d1a      	adds	r2, r3, #4
 801393a:	9203      	str	r2, [sp, #12]
 801393c:	681b      	ldr	r3, [r3, #0]
 801393e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
      else
        break;
      width = width * 10 + c;
 8013942:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8013944:	4613      	mov	r3, r2
 8013946:	009b      	lsls	r3, r3, #2
 8013948:	4413      	add	r3, r2
 801394a:	005b      	lsls	r3, r3, #1
 801394c:	461a      	mov	r2, r3
 801394e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013952:	4413      	add	r3, r2
 8013954:	9310      	str	r3, [sp, #64]	; 0x40
 8013956:	e7d6      	b.n	8013906 <chvprintf+0x86>
    }
    precision = 0;
 8013958:	2300      	movs	r3, #0
 801395a:	9311      	str	r3, [sp, #68]	; 0x44
    if (c == '.') {
 801395c:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013960:	2b2e      	cmp	r3, #46	; 0x2e
 8013962:	d129      	bne.n	80139b8 <chvprintf+0x138>
      while (TRUE) {
        c = *fmt++;
 8013964:	9b04      	ldr	r3, [sp, #16]
 8013966:	1c5a      	adds	r2, r3, #1
 8013968:	9204      	str	r2, [sp, #16]
 801396a:	781b      	ldrb	r3, [r3, #0]
 801396c:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
        if (c >= '0' && c <= '9')
 8013970:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013974:	2b2f      	cmp	r3, #47	; 0x2f
 8013976:	d909      	bls.n	801398c <chvprintf+0x10c>
 8013978:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 801397c:	2b39      	cmp	r3, #57	; 0x39
 801397e:	d805      	bhi.n	801398c <chvprintf+0x10c>
          c -= '0';
 8013980:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013984:	3b30      	subs	r3, #48	; 0x30
 8013986:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 801398a:	e009      	b.n	80139a0 <chvprintf+0x120>
        else if (c == '*')
 801398c:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013990:	2b2a      	cmp	r3, #42	; 0x2a
 8013992:	d111      	bne.n	80139b8 <chvprintf+0x138>
          c = va_arg(ap, int);
 8013994:	9b03      	ldr	r3, [sp, #12]
 8013996:	1d1a      	adds	r2, r3, #4
 8013998:	9203      	str	r2, [sp, #12]
 801399a:	681b      	ldr	r3, [r3, #0]
 801399c:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
        else
          break;
        precision *= 10;
 80139a0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80139a2:	4613      	mov	r3, r2
 80139a4:	009b      	lsls	r3, r3, #2
 80139a6:	4413      	add	r3, r2
 80139a8:	005b      	lsls	r3, r3, #1
 80139aa:	9311      	str	r3, [sp, #68]	; 0x44
        precision += c;
 80139ac:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80139b0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80139b2:	4413      	add	r3, r2
 80139b4:	9311      	str	r3, [sp, #68]	; 0x44
 80139b6:	e7d5      	b.n	8013964 <chvprintf+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80139b8:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80139bc:	2b6c      	cmp	r3, #108	; 0x6c
 80139be:	d003      	beq.n	80139c8 <chvprintf+0x148>
 80139c0:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80139c4:	2b4c      	cmp	r3, #76	; 0x4c
 80139c6:	d10d      	bne.n	80139e4 <chvprintf+0x164>
      is_long = TRUE;
 80139c8:	2301      	movs	r3, #1
 80139ca:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
      if (*fmt)
 80139ce:	9b04      	ldr	r3, [sp, #16]
 80139d0:	781b      	ldrb	r3, [r3, #0]
 80139d2:	2b00      	cmp	r3, #0
 80139d4:	d01a      	beq.n	8013a0c <chvprintf+0x18c>
        c = *fmt++;
 80139d6:	9b04      	ldr	r3, [sp, #16]
 80139d8:	1c5a      	adds	r2, r3, #1
 80139da:	9204      	str	r2, [sp, #16]
 80139dc:	781b      	ldrb	r3, [r3, #0]
 80139de:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 80139e2:	e014      	b.n	8013a0e <chvprintf+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 80139e4:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80139e8:	2b40      	cmp	r3, #64	; 0x40
 80139ea:	d905      	bls.n	80139f8 <chvprintf+0x178>
 80139ec:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 80139f0:	2b5a      	cmp	r3, #90	; 0x5a
 80139f2:	d801      	bhi.n	80139f8 <chvprintf+0x178>
 80139f4:	2301      	movs	r3, #1
 80139f6:	e000      	b.n	80139fa <chvprintf+0x17a>
 80139f8:	2300      	movs	r3, #0
 80139fa:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
 80139fe:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
 8013a02:	f003 0301 	and.w	r3, r3, #1
 8013a06:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
 8013a0a:	e000      	b.n	8013a0e <chvprintf+0x18e>
        c = *fmt++;
 8013a0c:	bf00      	nop

    /* Command decoding.*/
    switch (c) {
 8013a0e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013a12:	3b44      	subs	r3, #68	; 0x44
 8013a14:	2b34      	cmp	r3, #52	; 0x34
 8013a16:	f200 8111 	bhi.w	8013c3c <chvprintf+0x3bc>
 8013a1a:	a201      	add	r2, pc, #4	; (adr r2, 8013a20 <chvprintf+0x1a0>)
 8013a1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013a20:	08013b57 	.word	0x08013b57
 8013a24:	08013c3d 	.word	0x08013c3d
 8013a28:	08013c3d 	.word	0x08013c3d
 8013a2c:	08013c3d 	.word	0x08013c3d
 8013a30:	08013c3d 	.word	0x08013c3d
 8013a34:	08013b57 	.word	0x08013b57
 8013a38:	08013c3d 	.word	0x08013c3d
 8013a3c:	08013c3d 	.word	0x08013c3d
 8013a40:	08013c3d 	.word	0x08013c3d
 8013a44:	08013c3d 	.word	0x08013c3d
 8013a48:	08013c3d 	.word	0x08013c3d
 8013a4c:	08013c07 	.word	0x08013c07
 8013a50:	08013c3d 	.word	0x08013c3d
 8013a54:	08013c3d 	.word	0x08013c3d
 8013a58:	08013c3d 	.word	0x08013c3d
 8013a5c:	08013c3d 	.word	0x08013c3d
 8013a60:	08013c3d 	.word	0x08013c3d
 8013a64:	08013bff 	.word	0x08013bff
 8013a68:	08013c3d 	.word	0x08013c3d
 8013a6c:	08013c3d 	.word	0x08013c3d
 8013a70:	08013bf7 	.word	0x08013bf7
 8013a74:	08013c3d 	.word	0x08013c3d
 8013a78:	08013c3d 	.word	0x08013c3d
 8013a7c:	08013c3d 	.word	0x08013c3d
 8013a80:	08013c3d 	.word	0x08013c3d
 8013a84:	08013c3d 	.word	0x08013c3d
 8013a88:	08013c3d 	.word	0x08013c3d
 8013a8c:	08013c3d 	.word	0x08013c3d
 8013a90:	08013c3d 	.word	0x08013c3d
 8013a94:	08013c3d 	.word	0x08013c3d
 8013a98:	08013c3d 	.word	0x08013c3d
 8013a9c:	08013af5 	.word	0x08013af5
 8013aa0:	08013b57 	.word	0x08013b57
 8013aa4:	08013c3d 	.word	0x08013c3d
 8013aa8:	08013b99 	.word	0x08013b99
 8013aac:	08013c3d 	.word	0x08013c3d
 8013ab0:	08013c3d 	.word	0x08013c3d
 8013ab4:	08013b57 	.word	0x08013b57
 8013ab8:	08013c3d 	.word	0x08013c3d
 8013abc:	08013c3d 	.word	0x08013c3d
 8013ac0:	08013c3d 	.word	0x08013c3d
 8013ac4:	08013c3d 	.word	0x08013c3d
 8013ac8:	08013c3d 	.word	0x08013c3d
 8013acc:	08013c07 	.word	0x08013c07
 8013ad0:	08013c3d 	.word	0x08013c3d
 8013ad4:	08013c3d 	.word	0x08013c3d
 8013ad8:	08013c3d 	.word	0x08013c3d
 8013adc:	08013b0f 	.word	0x08013b0f
 8013ae0:	08013c3d 	.word	0x08013c3d
 8013ae4:	08013bff 	.word	0x08013bff
 8013ae8:	08013c3d 	.word	0x08013c3d
 8013aec:	08013c3d 	.word	0x08013c3d
 8013af0:	08013bf7 	.word	0x08013bf7
    case 'c':
      filler = ' ';
 8013af4:	2320      	movs	r3, #32
 8013af6:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
      *p++ = va_arg(ap, int);
 8013afa:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013afc:	1c5a      	adds	r2, r3, #1
 8013afe:	9215      	str	r2, [sp, #84]	; 0x54
 8013b00:	9a03      	ldr	r2, [sp, #12]
 8013b02:	1d11      	adds	r1, r2, #4
 8013b04:	9103      	str	r1, [sp, #12]
 8013b06:	6812      	ldr	r2, [r2, #0]
 8013b08:	b2d2      	uxtb	r2, r2
 8013b0a:	701a      	strb	r2, [r3, #0]
 8013b0c:	e09c      	b.n	8013c48 <chvprintf+0x3c8>
      break;
    case 's':
      filler = ' ';
 8013b0e:	2320      	movs	r3, #32
 8013b10:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
      if ((s = va_arg(ap, char *)) == 0)
 8013b14:	9b03      	ldr	r3, [sp, #12]
 8013b16:	1d1a      	adds	r2, r3, #4
 8013b18:	9203      	str	r2, [sp, #12]
 8013b1a:	681b      	ldr	r3, [r3, #0]
 8013b1c:	9314      	str	r3, [sp, #80]	; 0x50
 8013b1e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013b20:	2b00      	cmp	r3, #0
 8013b22:	d101      	bne.n	8013b28 <chvprintf+0x2a8>
        s = "(null)";
 8013b24:	4b7f      	ldr	r3, [pc, #508]	; (8013d24 <chvprintf+0x4a4>)
 8013b26:	9314      	str	r3, [sp, #80]	; 0x50
      if (precision == 0)
 8013b28:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013b2a:	2b00      	cmp	r3, #0
 8013b2c:	d102      	bne.n	8013b34 <chvprintf+0x2b4>
        precision = 32767;
 8013b2e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8013b32:	9311      	str	r3, [sp, #68]	; 0x44
      for (p = s; *p && (--precision >= 0); p++)
 8013b34:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013b36:	9315      	str	r3, [sp, #84]	; 0x54
 8013b38:	e002      	b.n	8013b40 <chvprintf+0x2c0>
 8013b3a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013b3c:	3301      	adds	r3, #1
 8013b3e:	9315      	str	r3, [sp, #84]	; 0x54
 8013b40:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013b42:	781b      	ldrb	r3, [r3, #0]
 8013b44:	2b00      	cmp	r3, #0
 8013b46:	d07f      	beq.n	8013c48 <chvprintf+0x3c8>
 8013b48:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013b4a:	3b01      	subs	r3, #1
 8013b4c:	9311      	str	r3, [sp, #68]	; 0x44
 8013b4e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013b50:	2b00      	cmp	r3, #0
 8013b52:	daf2      	bge.n	8013b3a <chvprintf+0x2ba>
 8013b54:	e078      	b.n	8013c48 <chvprintf+0x3c8>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8013b56:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
 8013b5a:	2b00      	cmp	r3, #0
 8013b5c:	d005      	beq.n	8013b6a <chvprintf+0x2ea>
        l = va_arg(ap, long);
 8013b5e:	9b03      	ldr	r3, [sp, #12]
 8013b60:	1d1a      	adds	r2, r3, #4
 8013b62:	9203      	str	r2, [sp, #12]
 8013b64:	681b      	ldr	r3, [r3, #0]
 8013b66:	930d      	str	r3, [sp, #52]	; 0x34
 8013b68:	e004      	b.n	8013b74 <chvprintf+0x2f4>
      else
        l = va_arg(ap, int);
 8013b6a:	9b03      	ldr	r3, [sp, #12]
 8013b6c:	1d1a      	adds	r2, r3, #4
 8013b6e:	9203      	str	r2, [sp, #12]
 8013b70:	681b      	ldr	r3, [r3, #0]
 8013b72:	930d      	str	r3, [sp, #52]	; 0x34
      if (l < 0) {
 8013b74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8013b76:	2b00      	cmp	r3, #0
 8013b78:	da07      	bge.n	8013b8a <chvprintf+0x30a>
        *p++ = '-';
 8013b7a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013b7c:	1c5a      	adds	r2, r3, #1
 8013b7e:	9215      	str	r2, [sp, #84]	; 0x54
 8013b80:	222d      	movs	r2, #45	; 0x2d
 8013b82:	701a      	strb	r2, [r3, #0]
        l = -l;
 8013b84:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8013b86:	425b      	negs	r3, r3
 8013b88:	930d      	str	r3, [sp, #52]	; 0x34
      }
      p = ch_ltoa(p, l, 10);
 8013b8a:	220a      	movs	r2, #10
 8013b8c:	990d      	ldr	r1, [sp, #52]	; 0x34
 8013b8e:	9815      	ldr	r0, [sp, #84]	; 0x54
 8013b90:	f7ff fe0e 	bl	80137b0 <ch_ltoa>
 8013b94:	9015      	str	r0, [sp, #84]	; 0x54
 8013b96:	e057      	b.n	8013c48 <chvprintf+0x3c8>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8013b98:	9b03      	ldr	r3, [sp, #12]
 8013b9a:	3307      	adds	r3, #7
 8013b9c:	f023 0307 	bic.w	r3, r3, #7
 8013ba0:	f103 0208 	add.w	r2, r3, #8
 8013ba4:	9203      	str	r2, [sp, #12]
 8013ba6:	e9d3 3400 	ldrd	r3, r4, [r3]
 8013baa:	4618      	mov	r0, r3
 8013bac:	4621      	mov	r1, r4
 8013bae:	f7f1 fbc9 	bl	8005344 <__aeabi_d2f>
 8013bb2:	4603      	mov	r3, r0
 8013bb4:	930c      	str	r3, [sp, #48]	; 0x30
      if (f < 0) {
 8013bb6:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
 8013bba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013bbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013bc2:	d50a      	bpl.n	8013bda <chvprintf+0x35a>
        *p++ = '-';
 8013bc4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013bc6:	1c5a      	adds	r2, r3, #1
 8013bc8:	9215      	str	r2, [sp, #84]	; 0x54
 8013bca:	222d      	movs	r2, #45	; 0x2d
 8013bcc:	701a      	strb	r2, [r3, #0]
        f = -f;
 8013bce:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
 8013bd2:	eef1 7a67 	vneg.f32	s15, s15
 8013bd6:	edcd 7a0c 	vstr	s15, [sp, #48]	; 0x30
      }
      p = ftoa(p, f, precision);
 8013bda:	980c      	ldr	r0, [sp, #48]	; 0x30
 8013bdc:	f7f1 f924 	bl	8004e28 <__aeabi_f2d>
 8013be0:	460a      	mov	r2, r1
 8013be2:	4601      	mov	r1, r0
 8013be4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013be6:	9300      	str	r3, [sp, #0]
 8013be8:	4613      	mov	r3, r2
 8013bea:	460a      	mov	r2, r1
 8013bec:	9815      	ldr	r0, [sp, #84]	; 0x54
 8013bee:	f7ff fdef 	bl	80137d0 <ftoa>
 8013bf2:	9015      	str	r0, [sp, #84]	; 0x54
 8013bf4:	e028      	b.n	8013c48 <chvprintf+0x3c8>
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8013bf6:	2310      	movs	r3, #16
 8013bf8:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 8013bfc:	e006      	b.n	8013c0c <chvprintf+0x38c>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8013bfe:	230a      	movs	r3, #10
 8013c00:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 8013c04:	e002      	b.n	8013c0c <chvprintf+0x38c>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8013c06:	2308      	movs	r3, #8
 8013c08:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
unsigned_common:
      if (is_long)
 8013c0c:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
 8013c10:	2b00      	cmp	r3, #0
 8013c12:	d005      	beq.n	8013c20 <chvprintf+0x3a0>
        l = va_arg(ap, unsigned long);
 8013c14:	9b03      	ldr	r3, [sp, #12]
 8013c16:	1d1a      	adds	r2, r3, #4
 8013c18:	9203      	str	r2, [sp, #12]
 8013c1a:	681b      	ldr	r3, [r3, #0]
 8013c1c:	930d      	str	r3, [sp, #52]	; 0x34
 8013c1e:	e004      	b.n	8013c2a <chvprintf+0x3aa>
      else
        l = va_arg(ap, unsigned int);
 8013c20:	9b03      	ldr	r3, [sp, #12]
 8013c22:	1d1a      	adds	r2, r3, #4
 8013c24:	9203      	str	r2, [sp, #12]
 8013c26:	681b      	ldr	r3, [r3, #0]
 8013c28:	930d      	str	r3, [sp, #52]	; 0x34
      p = ch_ltoa(p, l, c);
 8013c2a:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8013c2e:	461a      	mov	r2, r3
 8013c30:	990d      	ldr	r1, [sp, #52]	; 0x34
 8013c32:	9815      	ldr	r0, [sp, #84]	; 0x54
 8013c34:	f7ff fdbc 	bl	80137b0 <ch_ltoa>
 8013c38:	9015      	str	r0, [sp, #84]	; 0x54
 8013c3a:	e005      	b.n	8013c48 <chvprintf+0x3c8>
      break;
    default:
      *p++ = c;
 8013c3c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013c3e:	1c5a      	adds	r2, r3, #1
 8013c40:	9215      	str	r2, [sp, #84]	; 0x54
 8013c42:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
 8013c46:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 8013c48:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8013c4a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013c4c:	1ad3      	subs	r3, r2, r3
 8013c4e:	9312      	str	r3, [sp, #72]	; 0x48
    if ((width -= i) < 0)
 8013c50:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8013c52:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013c54:	1ad3      	subs	r3, r2, r3
 8013c56:	9310      	str	r3, [sp, #64]	; 0x40
 8013c58:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013c5a:	2b00      	cmp	r3, #0
 8013c5c:	da01      	bge.n	8013c62 <chvprintf+0x3e2>
      width = 0;
 8013c5e:	2300      	movs	r3, #0
 8013c60:	9310      	str	r3, [sp, #64]	; 0x40
    if (left_align == FALSE)
 8013c62:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
 8013c66:	f083 0301 	eor.w	r3, r3, #1
 8013c6a:	b2db      	uxtb	r3, r3
 8013c6c:	2b00      	cmp	r3, #0
 8013c6e:	d002      	beq.n	8013c76 <chvprintf+0x3f6>
      width = -width;
 8013c70:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013c72:	425b      	negs	r3, r3
 8013c74:	9310      	str	r3, [sp, #64]	; 0x40
    if (width < 0) {
 8013c76:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013c78:	2b00      	cmp	r3, #0
 8013c7a:	da36      	bge.n	8013cea <chvprintf+0x46a>
      if (*s == '-' && filler == '0') {
 8013c7c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013c7e:	781b      	ldrb	r3, [r3, #0]
 8013c80:	2b2d      	cmp	r3, #45	; 0x2d
 8013c82:	d113      	bne.n	8013cac <chvprintf+0x42c>
 8013c84:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
 8013c88:	2b30      	cmp	r3, #48	; 0x30
 8013c8a:	d10f      	bne.n	8013cac <chvprintf+0x42c>
        streamPut(chp, (uint8_t)*s++);
 8013c8c:	9b05      	ldr	r3, [sp, #20]
 8013c8e:	681b      	ldr	r3, [r3, #0]
 8013c90:	689a      	ldr	r2, [r3, #8]
 8013c92:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013c94:	1c59      	adds	r1, r3, #1
 8013c96:	9114      	str	r1, [sp, #80]	; 0x50
 8013c98:	781b      	ldrb	r3, [r3, #0]
 8013c9a:	4619      	mov	r1, r3
 8013c9c:	9805      	ldr	r0, [sp, #20]
 8013c9e:	4790      	blx	r2
        n++;
 8013ca0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013ca2:	3301      	adds	r3, #1
 8013ca4:	930f      	str	r3, [sp, #60]	; 0x3c
        i--;
 8013ca6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013ca8:	3b01      	subs	r3, #1
 8013caa:	9312      	str	r3, [sp, #72]	; 0x48
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8013cac:	9b05      	ldr	r3, [sp, #20]
 8013cae:	681b      	ldr	r3, [r3, #0]
 8013cb0:	689b      	ldr	r3, [r3, #8]
 8013cb2:	f89d 204e 	ldrb.w	r2, [sp, #78]	; 0x4e
 8013cb6:	4611      	mov	r1, r2
 8013cb8:	9805      	ldr	r0, [sp, #20]
 8013cba:	4798      	blx	r3
        n++;
 8013cbc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013cbe:	3301      	adds	r3, #1
 8013cc0:	930f      	str	r3, [sp, #60]	; 0x3c
      } while (++width != 0);
 8013cc2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013cc4:	3301      	adds	r3, #1
 8013cc6:	9310      	str	r3, [sp, #64]	; 0x40
 8013cc8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013cca:	2b00      	cmp	r3, #0
 8013ccc:	d1ee      	bne.n	8013cac <chvprintf+0x42c>
 8013cce:	e00c      	b.n	8013cea <chvprintf+0x46a>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8013cd0:	9b05      	ldr	r3, [sp, #20]
 8013cd2:	681b      	ldr	r3, [r3, #0]
 8013cd4:	689a      	ldr	r2, [r3, #8]
 8013cd6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013cd8:	1c59      	adds	r1, r3, #1
 8013cda:	9114      	str	r1, [sp, #80]	; 0x50
 8013cdc:	781b      	ldrb	r3, [r3, #0]
 8013cde:	4619      	mov	r1, r3
 8013ce0:	9805      	ldr	r0, [sp, #20]
 8013ce2:	4790      	blx	r2
      n++;
 8013ce4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013ce6:	3301      	adds	r3, #1
 8013ce8:	930f      	str	r3, [sp, #60]	; 0x3c
    while (--i >= 0) {
 8013cea:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013cec:	3b01      	subs	r3, #1
 8013cee:	9312      	str	r3, [sp, #72]	; 0x48
 8013cf0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013cf2:	2b00      	cmp	r3, #0
 8013cf4:	daec      	bge.n	8013cd0 <chvprintf+0x450>
 8013cf6:	e00d      	b.n	8013d14 <chvprintf+0x494>
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8013cf8:	9b05      	ldr	r3, [sp, #20]
 8013cfa:	681b      	ldr	r3, [r3, #0]
 8013cfc:	689b      	ldr	r3, [r3, #8]
 8013cfe:	f89d 204e 	ldrb.w	r2, [sp, #78]	; 0x4e
 8013d02:	4611      	mov	r1, r2
 8013d04:	9805      	ldr	r0, [sp, #20]
 8013d06:	4798      	blx	r3
      n++;
 8013d08:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013d0a:	3301      	adds	r3, #1
 8013d0c:	930f      	str	r3, [sp, #60]	; 0x3c
      width--;
 8013d0e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013d10:	3b01      	subs	r3, #1
 8013d12:	9310      	str	r3, [sp, #64]	; 0x40
    while (width) {
 8013d14:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013d16:	2b00      	cmp	r3, #0
 8013d18:	d1ee      	bne.n	8013cf8 <chvprintf+0x478>
 8013d1a:	e5b8      	b.n	801388e <chvprintf+0xe>
    }
  }
}
 8013d1c:	4618      	mov	r0, r3
 8013d1e:	b016      	add	sp, #88	; 0x58
 8013d20:	bd10      	pop	{r4, pc}
 8013d22:	bf00      	nop
 8013d24:	08024c88 	.word	0x08024c88
	...

08013d30 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8013d30:	b40e      	push	{r1, r2, r3}
 8013d32:	b500      	push	{lr}
 8013d34:	b084      	sub	sp, #16
 8013d36:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8013d38:	ab06      	add	r3, sp, #24
 8013d3a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8013d3c:	9a02      	ldr	r2, [sp, #8]
 8013d3e:	9905      	ldr	r1, [sp, #20]
 8013d40:	9801      	ldr	r0, [sp, #4]
 8013d42:	f7ff fd9d 	bl	8013880 <chvprintf>
 8013d46:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8013d48:	9b03      	ldr	r3, [sp, #12]
}
 8013d4a:	4618      	mov	r0, r3
 8013d4c:	b004      	add	sp, #16
 8013d4e:	f85d eb04 	ldr.w	lr, [sp], #4
 8013d52:	b003      	add	sp, #12
 8013d54:	4770      	bx	lr
 8013d56:	bf00      	nop
	...

08013d60 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8013d60:	b500      	push	{lr}
 8013d62:	b087      	sub	sp, #28
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8013d64:	4b3a      	ldr	r3, [pc, #232]	; (8013e50 <chVTDoTickI+0xf0>)
 8013d66:	69db      	ldr	r3, [r3, #28]
 8013d68:	9305      	str	r3, [sp, #20]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
 8013d6a:	f003 f931 	bl	8016fd0 <chVTGetSystemTimeX.lto_priv.697>
 8013d6e:	9002      	str	r0, [sp, #8]
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8013d70:	4b37      	ldr	r3, [pc, #220]	; (8013e50 <chVTDoTickI+0xf0>)
 8013d72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013d74:	9902      	ldr	r1, [sp, #8]
 8013d76:	4618      	mov	r0, r3
 8013d78:	f003 f832 	bl	8016de0 <chTimeDiffX.lto_priv.704>
 8013d7c:	9003      	str	r0, [sp, #12]

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8013d7e:	9b05      	ldr	r3, [sp, #20]
 8013d80:	689a      	ldr	r2, [r3, #8]
 8013d82:	9b03      	ldr	r3, [sp, #12]
 8013d84:	429a      	cmp	r2, r3
 8013d86:	d832      	bhi.n	8013dee <chVTDoTickI+0x8e>
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 8013d88:	4b31      	ldr	r3, [pc, #196]	; (8013e50 <chVTDoTickI+0xf0>)
 8013d8a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8013d8c:	9b05      	ldr	r3, [sp, #20]
 8013d8e:	689b      	ldr	r3, [r3, #8]
 8013d90:	4413      	add	r3, r2
 8013d92:	4a2f      	ldr	r2, [pc, #188]	; (8013e50 <chVTDoTickI+0xf0>)
 8013d94:	6293      	str	r3, [r2, #40]	; 0x28
      nowdelta -= vtp->delta;
 8013d96:	9b05      	ldr	r3, [sp, #20]
 8013d98:	689b      	ldr	r3, [r3, #8]
 8013d9a:	9a03      	ldr	r2, [sp, #12]
 8013d9c:	1ad3      	subs	r3, r2, r3
 8013d9e:	9303      	str	r3, [sp, #12]

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8013da0:	9b05      	ldr	r3, [sp, #20]
 8013da2:	681b      	ldr	r3, [r3, #0]
 8013da4:	4a2b      	ldr	r2, [pc, #172]	; (8013e54 <chVTDoTickI+0xf4>)
 8013da6:	605a      	str	r2, [r3, #4]
      ch.vtlist.next = vtp->next;
 8013da8:	9b05      	ldr	r3, [sp, #20]
 8013daa:	681b      	ldr	r3, [r3, #0]
 8013dac:	4a28      	ldr	r2, [pc, #160]	; (8013e50 <chVTDoTickI+0xf0>)
 8013dae:	61d3      	str	r3, [r2, #28]
      fn = vtp->func;
 8013db0:	9b05      	ldr	r3, [sp, #20]
 8013db2:	68db      	ldr	r3, [r3, #12]
 8013db4:	9301      	str	r3, [sp, #4]
      vtp->func = NULL;
 8013db6:	9b05      	ldr	r3, [sp, #20]
 8013db8:	2200      	movs	r2, #0
 8013dba:	60da      	str	r2, [r3, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8013dbc:	4b24      	ldr	r3, [pc, #144]	; (8013e50 <chVTDoTickI+0xf0>)
 8013dbe:	69db      	ldr	r3, [r3, #28]
 8013dc0:	4a24      	ldr	r2, [pc, #144]	; (8013e54 <chVTDoTickI+0xf4>)
 8013dc2:	4293      	cmp	r3, r2
 8013dc4:	d101      	bne.n	8013dca <chVTDoTickI+0x6a>
        port_timer_stop_alarm();
 8013dc6:	f003 f8cb 	bl	8016f60 <port_timer_stop_alarm.lto_priv.713>
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
 8013dca:	f003 f8f9 	bl	8016fc0 <chSysUnlockFromISR.lto_priv.707>
      fn(vtp->par);
 8013dce:	9b05      	ldr	r3, [sp, #20]
 8013dd0:	691a      	ldr	r2, [r3, #16]
 8013dd2:	9b01      	ldr	r3, [sp, #4]
 8013dd4:	4610      	mov	r0, r2
 8013dd6:	4798      	blx	r3
      chSysLockFromISR();
 8013dd8:	f003 f8ea 	bl	8016fb0 <chSysLockFromISR.lto_priv.709>

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8013ddc:	4b1c      	ldr	r3, [pc, #112]	; (8013e50 <chVTDoTickI+0xf0>)
 8013dde:	69db      	ldr	r3, [r3, #28]
 8013de0:	9305      	str	r3, [sp, #20]
    }
    while (vtp->delta <= nowdelta);
 8013de2:	9b05      	ldr	r3, [sp, #20]
 8013de4:	689a      	ldr	r2, [r3, #8]
 8013de6:	9b03      	ldr	r3, [sp, #12]
 8013de8:	429a      	cmp	r2, r3
 8013dea:	d9cd      	bls.n	8013d88 <chVTDoTickI+0x28>
 8013dec:	e7bd      	b.n	8013d6a <chVTDoTickI+0xa>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8013dee:	4b18      	ldr	r3, [pc, #96]	; (8013e50 <chVTDoTickI+0xf0>)
 8013df0:	69db      	ldr	r3, [r3, #28]
 8013df2:	4a18      	ldr	r2, [pc, #96]	; (8013e54 <chVTDoTickI+0xf4>)
 8013df4:	4293      	cmp	r3, r2
 8013df6:	d028      	beq.n	8013e4a <chVTDoTickI+0xea>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8013df8:	4b15      	ldr	r3, [pc, #84]	; (8013e50 <chVTDoTickI+0xf0>)
 8013dfa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8013dfc:	9b03      	ldr	r3, [sp, #12]
 8013dfe:	4413      	add	r3, r2
 8013e00:	4a13      	ldr	r2, [pc, #76]	; (8013e50 <chVTDoTickI+0xf0>)
 8013e02:	6293      	str	r3, [r2, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8013e04:	4b12      	ldr	r3, [pc, #72]	; (8013e50 <chVTDoTickI+0xf0>)
 8013e06:	69db      	ldr	r3, [r3, #28]
 8013e08:	4a11      	ldr	r2, [pc, #68]	; (8013e50 <chVTDoTickI+0xf0>)
 8013e0a:	69d2      	ldr	r2, [r2, #28]
 8013e0c:	6891      	ldr	r1, [r2, #8]
 8013e0e:	9a03      	ldr	r2, [sp, #12]
 8013e10:	1a8a      	subs	r2, r1, r2
 8013e12:	609a      	str	r2, [r3, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 8013e14:	4b0e      	ldr	r3, [pc, #56]	; (8013e50 <chVTDoTickI+0xf0>)
 8013e16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8013e18:	9b05      	ldr	r3, [sp, #20]
 8013e1a:	689b      	ldr	r3, [r3, #8]
 8013e1c:	4619      	mov	r1, r3
 8013e1e:	4610      	mov	r0, r2
 8013e20:	f002 ffce 	bl	8016dc0 <chTimeAddX.lto_priv.715>
 8013e24:	4603      	mov	r3, r0
 8013e26:	4619      	mov	r1, r3
 8013e28:	9802      	ldr	r0, [sp, #8]
 8013e2a:	f002 ffd9 	bl	8016de0 <chTimeDiffX.lto_priv.704>
 8013e2e:	9004      	str	r0, [sp, #16]
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8013e30:	9b04      	ldr	r3, [sp, #16]
 8013e32:	2b01      	cmp	r3, #1
 8013e34:	d801      	bhi.n	8013e3a <chVTDoTickI+0xda>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8013e36:	2302      	movs	r3, #2
 8013e38:	9304      	str	r3, [sp, #16]
  /* The delta could be too large for the physical timer to handle.*/
  else if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));
 8013e3a:	9904      	ldr	r1, [sp, #16]
 8013e3c:	9802      	ldr	r0, [sp, #8]
 8013e3e:	f002 ffbf 	bl	8016dc0 <chTimeAddX.lto_priv.715>
 8013e42:	4603      	mov	r3, r0
 8013e44:	4618      	mov	r0, r3
 8013e46:	f003 f893 	bl	8016f70 <port_timer_set_alarm.lto_priv.711>

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
              chTimeDiffX(ch.vtlist.lasttime, chTimeAddX(now, delta)),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8013e4a:	b007      	add	sp, #28
 8013e4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e50:	20005ca0 	.word	0x20005ca0
 8013e54:	20005cbc 	.word	0x20005cbc
	...

08013e60 <_idle_thread.lto_priv.162>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8013e60:	b500      	push	{lr}
 8013e62:	b083      	sub	sp, #12
 8013e64:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8013e66:	f003 f863 	bl	8016f30 <port_wait_for_interrupt.lto_priv.724>
 8013e6a:	e7fc      	b.n	8013e66 <_idle_thread.lto_priv.162+0x6>
 8013e6c:	0000      	movs	r0, r0
	...

08013e70 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8013e70:	b508      	push	{r3, lr}

  _scheduler_init();
 8013e72:	f000 fa85 	bl	8014380 <_scheduler_init>
  _vt_init();
 8013e76:	f000 f8c3 	bl	8014000 <_vt_init>
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
  ch.dbg.lock_cnt = (cnt_t)0;
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8013e7a:	f000 fec1 	bl	8014c00 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8013e7e:	f7ff f997 	bl	80131b0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8013e82:	f7ff f9f5 	bl	8013270 <_heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  _factory_init();
 8013e86:	f7ff fb93 	bl	80135b0 <_factory_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8013e8a:	2280      	movs	r2, #128	; 0x80
 8013e8c:	490b      	ldr	r1, [pc, #44]	; (8013ebc <chSysInit+0x4c>)
 8013e8e:	480c      	ldr	r0, [pc, #48]	; (8013ec0 <chSysInit+0x50>)
 8013e90:	f000 fcce 	bl	8014830 <_thread_init>
 8013e94:	4602      	mov	r2, r0
 8013e96:	4b0b      	ldr	r3, [pc, #44]	; (8013ec4 <chSysInit+0x54>)
 8013e98:	619a      	str	r2, [r3, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8013e9a:	4b0a      	ldr	r3, [pc, #40]	; (8013ec4 <chSysInit+0x54>)
 8013e9c:	699b      	ldr	r3, [r3, #24]
 8013e9e:	2200      	movs	r2, #0
 8013ea0:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8013ea2:	4b08      	ldr	r3, [pc, #32]	; (8013ec4 <chSysInit+0x54>)
 8013ea4:	699b      	ldr	r3, [r3, #24]
 8013ea6:	2201      	movs	r2, #1
 8013ea8:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 8013eac:	f002 fff0 	bl	8016e90 <port_init.lto_priv.723>

  /* Initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* It is alive now.*/
  chSysEnable();
 8013eb0:	f003 f876 	bl	8016fa0 <chSysEnable.lto_priv.722>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8013eb4:	4804      	ldr	r0, [pc, #16]	; (8013ec8 <chSysInit+0x58>)
 8013eb6:	f000 fd2b 	bl	8014910 <chThdCreate>
  }
#endif
}
 8013eba:	bd08      	pop	{r3, pc}
 8013ebc:	0802419c 	.word	0x0802419c
 8013ec0:	20005cd0 	.word	0x20005cd0
 8013ec4:	20005ca0 	.word	0x20005ca0
 8013ec8:	08024184 	.word	0x08024184
 8013ecc:	00000000 	.word	0x00000000

08013ed0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8013ed0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8013ed2:	f7ff ff45 	bl	8013d60 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8013ed6:	bd08      	pop	{r3, pc}
	...

08013ee0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8013ee0:	b084      	sub	sp, #16
 8013ee2:	9003      	str	r0, [sp, #12]
 8013ee4:	9102      	str	r1, [sp, #8]
 8013ee6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 8013ee8:	9a03      	ldr	r2, [sp, #12]
 8013eea:	9b02      	ldr	r3, [sp, #8]
 8013eec:	1ad2      	subs	r2, r2, r3
 8013eee:	9901      	ldr	r1, [sp, #4]
 8013ef0:	9b02      	ldr	r3, [sp, #8]
 8013ef2:	1acb      	subs	r3, r1, r3
 8013ef4:	429a      	cmp	r2, r3
 8013ef6:	bf34      	ite	cc
 8013ef8:	2301      	movcc	r3, #1
 8013efa:	2300      	movcs	r3, #0
 8013efc:	b2db      	uxtb	r3, r3
}
 8013efe:	4618      	mov	r0, r3
 8013f00:	b004      	add	sp, #16
 8013f02:	4770      	bx	lr
	...

08013f10 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8013f10:	b500      	push	{lr}
 8013f12:	b085      	sub	sp, #20
 8013f14:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8013f16:	f003 f813 	bl	8016f40 <port_rt_get_counter_value.lto_priv.695>
 8013f1a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 8013f1c:	9a03      	ldr	r2, [sp, #12]
 8013f1e:	9b01      	ldr	r3, [sp, #4]
 8013f20:	4413      	add	r3, r2
 8013f22:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8013f24:	f003 f80c 	bl	8016f40 <port_rt_get_counter_value.lto_priv.695>
 8013f28:	4603      	mov	r3, r0
 8013f2a:	9a02      	ldr	r2, [sp, #8]
 8013f2c:	9903      	ldr	r1, [sp, #12]
 8013f2e:	4618      	mov	r0, r3
 8013f30:	f7ff ffd6 	bl	8013ee0 <chSysIsCounterWithinX>
 8013f34:	4603      	mov	r3, r0
 8013f36:	2b00      	cmp	r3, #0
 8013f38:	d1f4      	bne.n	8013f24 <chSysPolledDelayX+0x14>
  }
}
 8013f3a:	b005      	add	sp, #20
 8013f3c:	f85d fb04 	ldr.w	pc, [sp], #4

08013f40 <chTimeAddX.lto_priv.716>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8013f40:	b082      	sub	sp, #8
 8013f42:	9001      	str	r0, [sp, #4]
 8013f44:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8013f46:	9a01      	ldr	r2, [sp, #4]
 8013f48:	9b00      	ldr	r3, [sp, #0]
 8013f4a:	4413      	add	r3, r2
}
 8013f4c:	4618      	mov	r0, r3
 8013f4e:	b002      	add	sp, #8
 8013f50:	4770      	bx	lr
 8013f52:	bf00      	nop
	...

08013f60 <chTimeDiffX.lto_priv.705>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8013f60:	b082      	sub	sp, #8
 8013f62:	9001      	str	r0, [sp, #4]
 8013f64:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8013f66:	9a00      	ldr	r2, [sp, #0]
 8013f68:	9b01      	ldr	r3, [sp, #4]
 8013f6a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8013f6c:	4618      	mov	r0, r3
 8013f6e:	b002      	add	sp, #8
 8013f70:	4770      	bx	lr
 8013f72:	bf00      	nop
	...

08013f80 <st_lld_get_counter.lto_priv.702>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8013f80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8013f84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8013f86:	4618      	mov	r0, r3
 8013f88:	4770      	bx	lr
 8013f8a:	bf00      	nop
 8013f8c:	0000      	movs	r0, r0
	...

08013f90 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8013f90:	b500      	push	{lr}
 8013f92:	b083      	sub	sp, #12
 8013f94:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8013f96:	9801      	ldr	r0, [sp, #4]
 8013f98:	f005 fd4a 	bl	8019a30 <stStartAlarm>
}
 8013f9c:	b003      	add	sp, #12
 8013f9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fa2:	bf00      	nop
	...

08013fb0 <port_timer_stop_alarm.lto_priv.714>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8013fb0:	b508      	push	{r3, lr}

  stStopAlarm();
 8013fb2:	f005 fd4d 	bl	8019a50 <stStopAlarm>
}
 8013fb6:	bd08      	pop	{r3, pc}
	...

08013fc0 <port_timer_set_alarm.lto_priv.712>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8013fc0:	b500      	push	{lr}
 8013fc2:	b083      	sub	sp, #12
 8013fc4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8013fc6:	9801      	ldr	r0, [sp, #4]
 8013fc8:	f005 fd4a 	bl	8019a60 <stSetAlarm>
}
 8013fcc:	b003      	add	sp, #12
 8013fce:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fd2:	bf00      	nop
	...

08013fe0 <port_timer_get_time.lto_priv.700>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8013fe0:	b508      	push	{r3, lr}

  return stGetCounter();
 8013fe2:	f7ff ffcd 	bl	8013f80 <st_lld_get_counter.lto_priv.702>
 8013fe6:	4603      	mov	r3, r0
}
 8013fe8:	4618      	mov	r0, r3
 8013fea:	bd08      	pop	{r3, pc}
 8013fec:	0000      	movs	r0, r0
	...

08013ff0 <chVTGetSystemTimeX.lto_priv.698>:
static inline systime_t chVTGetSystemTimeX(void) {
 8013ff0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8013ff2:	f7ff fff5 	bl	8013fe0 <port_timer_get_time.lto_priv.700>
 8013ff6:	4603      	mov	r3, r0
}
 8013ff8:	4618      	mov	r0, r3
 8013ffa:	bd08      	pop	{r3, pc}
 8013ffc:	0000      	movs	r0, r0
	...

08014000 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8014000:	4b06      	ldr	r3, [pc, #24]	; (801401c <_vt_init+0x1c>)
 8014002:	4a07      	ldr	r2, [pc, #28]	; (8014020 <_vt_init+0x20>)
 8014004:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8014006:	4b05      	ldr	r3, [pc, #20]	; (801401c <_vt_init+0x1c>)
 8014008:	4a05      	ldr	r2, [pc, #20]	; (8014020 <_vt_init+0x20>)
 801400a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 801400c:	4b03      	ldr	r3, [pc, #12]	; (801401c <_vt_init+0x1c>)
 801400e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8014012:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8014014:	4b01      	ldr	r3, [pc, #4]	; (801401c <_vt_init+0x1c>)
 8014016:	2200      	movs	r2, #0
 8014018:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 801401a:	4770      	bx	lr
 801401c:	20005ca0 	.word	0x20005ca0
 8014020:	20005cbc 	.word	0x20005cbc
	...

08014030 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8014030:	b500      	push	{lr}
 8014032:	b089      	sub	sp, #36	; 0x24
 8014034:	9003      	str	r0, [sp, #12]
 8014036:	9102      	str	r1, [sp, #8]
 8014038:	9201      	str	r2, [sp, #4]
 801403a:	9300      	str	r3, [sp, #0]
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 801403c:	9b03      	ldr	r3, [sp, #12]
 801403e:	9a00      	ldr	r2, [sp, #0]
 8014040:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 8014042:	9b03      	ldr	r3, [sp, #12]
 8014044:	9a01      	ldr	r2, [sp, #4]
 8014046:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8014048:	f7ff ffd2 	bl	8013ff0 <chVTGetSystemTimeX.lto_priv.698>
 801404c:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 801404e:	9b02      	ldr	r3, [sp, #8]
 8014050:	2b01      	cmp	r3, #1
 8014052:	d801      	bhi.n	8014058 <chVTDoSetI+0x28>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8014054:	2302      	movs	r3, #2
 8014056:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8014058:	4b3f      	ldr	r3, [pc, #252]	; (8014158 <chVTDoSetI+0x128>)
 801405a:	69db      	ldr	r3, [r3, #28]
 801405c:	4a3f      	ldr	r2, [pc, #252]	; (801415c <chVTDoSetI+0x12c>)
 801405e:	4293      	cmp	r3, r2
 8014060:	d11c      	bne.n	801409c <chVTDoSetI+0x6c>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8014062:	4a3d      	ldr	r2, [pc, #244]	; (8014158 <chVTDoSetI+0x128>)
 8014064:	9b05      	ldr	r3, [sp, #20]
 8014066:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.next = vtp;
 8014068:	4a3b      	ldr	r2, [pc, #236]	; (8014158 <chVTDoSetI+0x128>)
 801406a:	9b03      	ldr	r3, [sp, #12]
 801406c:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 801406e:	4a3a      	ldr	r2, [pc, #232]	; (8014158 <chVTDoSetI+0x128>)
 8014070:	9b03      	ldr	r3, [sp, #12]
 8014072:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8014074:	9b03      	ldr	r3, [sp, #12]
 8014076:	4a39      	ldr	r2, [pc, #228]	; (801415c <chVTDoSetI+0x12c>)
 8014078:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 801407a:	9b03      	ldr	r3, [sp, #12]
 801407c:	4a37      	ldr	r2, [pc, #220]	; (801415c <chVTDoSetI+0x12c>)
 801407e:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 8014080:	9b03      	ldr	r3, [sp, #12]
 8014082:	9a02      	ldr	r2, [sp, #8]
 8014084:	609a      	str	r2, [r3, #8]
        delay = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 8014086:	4b34      	ldr	r3, [pc, #208]	; (8014158 <chVTDoSetI+0x128>)
 8014088:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801408a:	9902      	ldr	r1, [sp, #8]
 801408c:	4618      	mov	r0, r3
 801408e:	f7ff ff57 	bl	8013f40 <chTimeAddX.lto_priv.716>
 8014092:	4603      	mov	r3, r0
 8014094:	4618      	mov	r0, r3
 8014096:	f7ff ff7b 	bl	8013f90 <port_timer_start_alarm>
 801409a:	e05a      	b.n	8014152 <chVTDoSetI+0x122>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 801409c:	4b2e      	ldr	r3, [pc, #184]	; (8014158 <chVTDoSetI+0x128>)
 801409e:	69db      	ldr	r3, [r3, #28]
 80140a0:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80140a2:	4b2d      	ldr	r3, [pc, #180]	; (8014158 <chVTDoSetI+0x128>)
 80140a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80140a6:	9905      	ldr	r1, [sp, #20]
 80140a8:	4618      	mov	r0, r3
 80140aa:	f7ff ff59 	bl	8013f60 <chTimeDiffX.lto_priv.705>
 80140ae:	4602      	mov	r2, r0
 80140b0:	9b02      	ldr	r3, [sp, #8]
 80140b2:	4413      	add	r3, r2
 80140b4:	9306      	str	r3, [sp, #24]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80140b6:	4b28      	ldr	r3, [pc, #160]	; (8014158 <chVTDoSetI+0x128>)
 80140b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80140ba:	9905      	ldr	r1, [sp, #20]
 80140bc:	4618      	mov	r0, r3
 80140be:	f7ff ff4f 	bl	8013f60 <chTimeDiffX.lto_priv.705>
 80140c2:	4602      	mov	r2, r0
 80140c4:	9b06      	ldr	r3, [sp, #24]
 80140c6:	429a      	cmp	r2, r3
 80140c8:	d908      	bls.n	80140dc <chVTDoSetI+0xac>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80140ca:	9b07      	ldr	r3, [sp, #28]
 80140cc:	689b      	ldr	r3, [r3, #8]
 80140ce:	9a06      	ldr	r2, [sp, #24]
 80140d0:	1ad3      	subs	r3, r2, r3
 80140d2:	9306      	str	r3, [sp, #24]
      p = p->next;
 80140d4:	9b07      	ldr	r3, [sp, #28]
 80140d6:	681b      	ldr	r3, [r3, #0]
 80140d8:	9307      	str	r3, [sp, #28]
 80140da:	e019      	b.n	8014110 <chVTDoSetI+0xe0>
    }
    else if (delta < p->delta) {
 80140dc:	9b07      	ldr	r3, [sp, #28]
 80140de:	689a      	ldr	r2, [r3, #8]
 80140e0:	9b06      	ldr	r3, [sp, #24]
 80140e2:	429a      	cmp	r2, r3
 80140e4:	d914      	bls.n	8014110 <chVTDoSetI+0xe0>
      sysinterval_t deadline_delta;

      /* A small delay that will become the first element in the delta list
         and next deadline.*/
      deadline_delta = delta;
 80140e6:	9b06      	ldr	r3, [sp, #24]
 80140e8:	9304      	str	r3, [sp, #16]
      /* The delta could be too large for the physical timer to handle.*/
      if (deadline_delta > (sysinterval_t)TIME_MAX_SYSTIME) {
        deadline_delta = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif
      port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, deadline_delta));
 80140ea:	4b1b      	ldr	r3, [pc, #108]	; (8014158 <chVTDoSetI+0x128>)
 80140ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80140ee:	9904      	ldr	r1, [sp, #16]
 80140f0:	4618      	mov	r0, r3
 80140f2:	f7ff ff25 	bl	8013f40 <chTimeAddX.lto_priv.716>
 80140f6:	4603      	mov	r3, r0
 80140f8:	4618      	mov	r0, r3
 80140fa:	f7ff ff61 	bl	8013fc0 <port_timer_set_alarm.lto_priv.712>
 80140fe:	e007      	b.n	8014110 <chVTDoSetI+0xe0>
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8014100:	9b07      	ldr	r3, [sp, #28]
 8014102:	689b      	ldr	r3, [r3, #8]
 8014104:	9a06      	ldr	r2, [sp, #24]
 8014106:	1ad3      	subs	r3, r2, r3
 8014108:	9306      	str	r3, [sp, #24]
    p = p->next;
 801410a:	9b07      	ldr	r3, [sp, #28]
 801410c:	681b      	ldr	r3, [r3, #0]
 801410e:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8014110:	9b07      	ldr	r3, [sp, #28]
 8014112:	689a      	ldr	r2, [r3, #8]
 8014114:	9b06      	ldr	r3, [sp, #24]
 8014116:	429a      	cmp	r2, r3
 8014118:	d3f2      	bcc.n	8014100 <chVTDoSetI+0xd0>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 801411a:	9b03      	ldr	r3, [sp, #12]
 801411c:	9a07      	ldr	r2, [sp, #28]
 801411e:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8014120:	9b03      	ldr	r3, [sp, #12]
 8014122:	681b      	ldr	r3, [r3, #0]
 8014124:	685a      	ldr	r2, [r3, #4]
 8014126:	9b03      	ldr	r3, [sp, #12]
 8014128:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 801412a:	9b03      	ldr	r3, [sp, #12]
 801412c:	685b      	ldr	r3, [r3, #4]
 801412e:	9a03      	ldr	r2, [sp, #12]
 8014130:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8014132:	9b07      	ldr	r3, [sp, #28]
 8014134:	9a03      	ldr	r2, [sp, #12]
 8014136:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 8014138:	9b03      	ldr	r3, [sp, #12]
 801413a:	9a06      	ldr	r2, [sp, #24]
 801413c:	609a      	str	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 801413e:	9b07      	ldr	r3, [sp, #28]
 8014140:	689a      	ldr	r2, [r3, #8]
 8014142:	9b06      	ldr	r3, [sp, #24]
 8014144:	1ad2      	subs	r2, r2, r3
 8014146:	9b07      	ldr	r3, [sp, #28]
 8014148:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 801414a:	4b03      	ldr	r3, [pc, #12]	; (8014158 <chVTDoSetI+0x128>)
 801414c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8014150:	625a      	str	r2, [r3, #36]	; 0x24
}
 8014152:	b009      	add	sp, #36	; 0x24
 8014154:	f85d fb04 	ldr.w	pc, [sp], #4
 8014158:	20005ca0 	.word	0x20005ca0
 801415c:	20005cbc 	.word	0x20005cbc

08014160 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8014160:	b510      	push	{r4, lr}
 8014162:	b084      	sub	sp, #16
 8014164:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8014166:	4b36      	ldr	r3, [pc, #216]	; (8014240 <chVTDoResetI+0xe0>)
 8014168:	69da      	ldr	r2, [r3, #28]
 801416a:	9b01      	ldr	r3, [sp, #4]
 801416c:	429a      	cmp	r2, r3
 801416e:	d01b      	beq.n	80141a8 <chVTDoResetI+0x48>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8014170:	9b01      	ldr	r3, [sp, #4]
 8014172:	685b      	ldr	r3, [r3, #4]
 8014174:	9a01      	ldr	r2, [sp, #4]
 8014176:	6812      	ldr	r2, [r2, #0]
 8014178:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 801417a:	9b01      	ldr	r3, [sp, #4]
 801417c:	681b      	ldr	r3, [r3, #0]
 801417e:	9a01      	ldr	r2, [sp, #4]
 8014180:	6852      	ldr	r2, [r2, #4]
 8014182:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8014184:	9b01      	ldr	r3, [sp, #4]
 8014186:	2200      	movs	r2, #0
 8014188:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 801418a:	9b01      	ldr	r3, [sp, #4]
 801418c:	681b      	ldr	r3, [r3, #0]
 801418e:	4a2d      	ldr	r2, [pc, #180]	; (8014244 <chVTDoResetI+0xe4>)
 8014190:	4293      	cmp	r3, r2
 8014192:	d051      	beq.n	8014238 <chVTDoResetI+0xd8>
      vtp->next->delta += vtp->delta;
 8014194:	9b01      	ldr	r3, [sp, #4]
 8014196:	681b      	ldr	r3, [r3, #0]
 8014198:	9a01      	ldr	r2, [sp, #4]
 801419a:	6812      	ldr	r2, [r2, #0]
 801419c:	6891      	ldr	r1, [r2, #8]
 801419e:	9a01      	ldr	r2, [sp, #4]
 80141a0:	6892      	ldr	r2, [r2, #8]
 80141a2:	440a      	add	r2, r1
 80141a4:	609a      	str	r2, [r3, #8]
 80141a6:	e048      	b.n	801423a <chVTDoResetI+0xda>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80141a8:	9b01      	ldr	r3, [sp, #4]
 80141aa:	681b      	ldr	r3, [r3, #0]
 80141ac:	4a24      	ldr	r2, [pc, #144]	; (8014240 <chVTDoResetI+0xe0>)
 80141ae:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80141b0:	4b23      	ldr	r3, [pc, #140]	; (8014240 <chVTDoResetI+0xe0>)
 80141b2:	69db      	ldr	r3, [r3, #28]
 80141b4:	4a23      	ldr	r2, [pc, #140]	; (8014244 <chVTDoResetI+0xe4>)
 80141b6:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 80141b8:	9b01      	ldr	r3, [sp, #4]
 80141ba:	2200      	movs	r2, #0
 80141bc:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80141be:	4b20      	ldr	r3, [pc, #128]	; (8014240 <chVTDoResetI+0xe0>)
 80141c0:	69db      	ldr	r3, [r3, #28]
 80141c2:	4a20      	ldr	r2, [pc, #128]	; (8014244 <chVTDoResetI+0xe4>)
 80141c4:	4293      	cmp	r3, r2
 80141c6:	d102      	bne.n	80141ce <chVTDoResetI+0x6e>
    port_timer_stop_alarm();
 80141c8:	f7ff fef2 	bl	8013fb0 <port_timer_stop_alarm.lto_priv.714>
 80141cc:	e035      	b.n	801423a <chVTDoResetI+0xda>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80141ce:	4b1c      	ldr	r3, [pc, #112]	; (8014240 <chVTDoResetI+0xe0>)
 80141d0:	69db      	ldr	r3, [r3, #28]
 80141d2:	4a1b      	ldr	r2, [pc, #108]	; (8014240 <chVTDoResetI+0xe0>)
 80141d4:	69d2      	ldr	r2, [r2, #28]
 80141d6:	6891      	ldr	r1, [r2, #8]
 80141d8:	9a01      	ldr	r2, [sp, #4]
 80141da:	6892      	ldr	r2, [r2, #8]
 80141dc:	440a      	add	r2, r1
 80141de:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80141e0:	4b17      	ldr	r3, [pc, #92]	; (8014240 <chVTDoResetI+0xe0>)
 80141e2:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 80141e4:	f7ff ff04 	bl	8013ff0 <chVTGetSystemTimeX.lto_priv.698>
 80141e8:	4603      	mov	r3, r0
 80141ea:	4619      	mov	r1, r3
 80141ec:	4620      	mov	r0, r4
 80141ee:	f7ff feb7 	bl	8013f60 <chTimeDiffX.lto_priv.705>
 80141f2:	9002      	str	r0, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80141f4:	4b12      	ldr	r3, [pc, #72]	; (8014240 <chVTDoResetI+0xe0>)
 80141f6:	69db      	ldr	r3, [r3, #28]
 80141f8:	689a      	ldr	r2, [r3, #8]
 80141fa:	9b02      	ldr	r3, [sp, #8]
 80141fc:	429a      	cmp	r2, r3
 80141fe:	d91c      	bls.n	801423a <chVTDoResetI+0xda>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8014200:	4b0f      	ldr	r3, [pc, #60]	; (8014240 <chVTDoResetI+0xe0>)
 8014202:	69db      	ldr	r3, [r3, #28]
 8014204:	689a      	ldr	r2, [r3, #8]
 8014206:	9b02      	ldr	r3, [sp, #8]
 8014208:	1ad3      	subs	r3, r2, r3
 801420a:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 801420c:	9b03      	ldr	r3, [sp, #12]
 801420e:	2b01      	cmp	r3, #1
 8014210:	d803      	bhi.n	801421a <chVTDoResetI+0xba>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8014212:	9b02      	ldr	r3, [sp, #8]
 8014214:	3302      	adds	r3, #2
 8014216:	9303      	str	r3, [sp, #12]
 8014218:	e003      	b.n	8014222 <chVTDoResetI+0xc2>
  }
  else {
    delta = nowdelta + delta;
 801421a:	9a03      	ldr	r2, [sp, #12]
 801421c:	9b02      	ldr	r3, [sp, #8]
 801421e:	4413      	add	r3, r2
 8014220:	9303      	str	r3, [sp, #12]
    if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
      delta = (sysinterval_t)TIME_MAX_SYSTIME;
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
 8014222:	4b07      	ldr	r3, [pc, #28]	; (8014240 <chVTDoResetI+0xe0>)
 8014224:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014226:	9903      	ldr	r1, [sp, #12]
 8014228:	4618      	mov	r0, r3
 801422a:	f7ff fe89 	bl	8013f40 <chTimeAddX.lto_priv.716>
 801422e:	4603      	mov	r3, r0
 8014230:	4618      	mov	r0, r3
 8014232:	f7ff fec5 	bl	8013fc0 <port_timer_set_alarm.lto_priv.712>
 8014236:	e000      	b.n	801423a <chVTDoResetI+0xda>
      vtp->next->delta += vtp->delta;
 8014238:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 801423a:	b004      	add	sp, #16
 801423c:	bd10      	pop	{r4, pc}
 801423e:	bf00      	nop
 8014240:	20005ca0 	.word	0x20005ca0
 8014244:	20005cbc 	.word	0x20005cbc
	...

08014250 <port_lock.lto_priv.663>:
static inline void port_lock(void) {
 8014250:	b082      	sub	sp, #8
 8014252:	2320      	movs	r3, #32
 8014254:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014256:	9b01      	ldr	r3, [sp, #4]
 8014258:	f383 8811 	msr	BASEPRI, r3
}
 801425c:	b002      	add	sp, #8
 801425e:	4770      	bx	lr

08014260 <port_unlock.lto_priv.657>:
static inline void port_unlock(void) {
 8014260:	b082      	sub	sp, #8
 8014262:	2300      	movs	r3, #0
 8014264:	9301      	str	r3, [sp, #4]
 8014266:	9b01      	ldr	r3, [sp, #4]
 8014268:	f383 8811 	msr	BASEPRI, r3
}
 801426c:	b002      	add	sp, #8
 801426e:	4770      	bx	lr

08014270 <port_lock_from_isr>:
static inline void port_lock_from_isr(void) {
 8014270:	b508      	push	{r3, lr}
  port_lock();
 8014272:	f7ff ffed 	bl	8014250 <port_lock.lto_priv.663>
}
 8014276:	bd08      	pop	{r3, pc}
	...

08014280 <port_unlock_from_isr>:
static inline void port_unlock_from_isr(void) {
 8014280:	b508      	push	{r3, lr}
  port_unlock();
 8014282:	f7ff ffed 	bl	8014260 <port_unlock.lto_priv.657>
}
 8014286:	bd08      	pop	{r3, pc}
	...

08014290 <queue_init.lto_priv.687>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8014290:	b082      	sub	sp, #8
 8014292:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8014294:	9b01      	ldr	r3, [sp, #4]
 8014296:	9a01      	ldr	r2, [sp, #4]
 8014298:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 801429a:	9b01      	ldr	r3, [sp, #4]
 801429c:	9a01      	ldr	r2, [sp, #4]
 801429e:	605a      	str	r2, [r3, #4]
}
 80142a0:	b002      	add	sp, #8
 80142a2:	4770      	bx	lr
	...

080142b0 <queue_fifo_remove.lto_priv.681>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80142b0:	b084      	sub	sp, #16
 80142b2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80142b4:	9b01      	ldr	r3, [sp, #4]
 80142b6:	681b      	ldr	r3, [r3, #0]
 80142b8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 80142ba:	9b03      	ldr	r3, [sp, #12]
 80142bc:	681a      	ldr	r2, [r3, #0]
 80142be:	9b01      	ldr	r3, [sp, #4]
 80142c0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80142c2:	9b01      	ldr	r3, [sp, #4]
 80142c4:	681b      	ldr	r3, [r3, #0]
 80142c6:	9a01      	ldr	r2, [sp, #4]
 80142c8:	605a      	str	r2, [r3, #4]

  return tp;
 80142ca:	9b03      	ldr	r3, [sp, #12]
}
 80142cc:	4618      	mov	r0, r3
 80142ce:	b004      	add	sp, #16
 80142d0:	4770      	bx	lr
 80142d2:	bf00      	nop
	...

080142e0 <queue_dequeue.lto_priv.679>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 80142e0:	b082      	sub	sp, #8
 80142e2:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 80142e4:	9b01      	ldr	r3, [sp, #4]
 80142e6:	685b      	ldr	r3, [r3, #4]
 80142e8:	9a01      	ldr	r2, [sp, #4]
 80142ea:	6812      	ldr	r2, [r2, #0]
 80142ec:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80142ee:	9b01      	ldr	r3, [sp, #4]
 80142f0:	681b      	ldr	r3, [r3, #0]
 80142f2:	9a01      	ldr	r2, [sp, #4]
 80142f4:	6852      	ldr	r2, [r2, #4]
 80142f6:	605a      	str	r2, [r3, #4]

  return tp;
 80142f8:	9b01      	ldr	r3, [sp, #4]
}
 80142fa:	4618      	mov	r0, r3
 80142fc:	b002      	add	sp, #8
 80142fe:	4770      	bx	lr

08014300 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8014300:	4b06      	ldr	r3, [pc, #24]	; (801431c <chSchIsRescRequiredI+0x1c>)
 8014302:	681b      	ldr	r3, [r3, #0]
 8014304:	689a      	ldr	r2, [r3, #8]
 8014306:	4b05      	ldr	r3, [pc, #20]	; (801431c <chSchIsRescRequiredI+0x1c>)
 8014308:	699b      	ldr	r3, [r3, #24]
 801430a:	689b      	ldr	r3, [r3, #8]
 801430c:	429a      	cmp	r2, r3
 801430e:	bf8c      	ite	hi
 8014310:	2301      	movhi	r3, #1
 8014312:	2300      	movls	r3, #0
 8014314:	b2db      	uxtb	r3, r3
}
 8014316:	4618      	mov	r0, r3
 8014318:	4770      	bx	lr
 801431a:	bf00      	nop
 801431c:	20005ca0 	.word	0x20005ca0

08014320 <chSysLockFromISR.lto_priv.710>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8014320:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8014322:	f7ff ffa5 	bl	8014270 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8014326:	bd08      	pop	{r3, pc}
	...

08014330 <chSysUnlockFromISR.lto_priv.708>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8014330:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8014332:	f7ff ffa5 	bl	8014280 <port_unlock_from_isr>
}
 8014336:	bd08      	pop	{r3, pc}
	...

08014340 <chVTIsArmedI>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8014340:	b082      	sub	sp, #8
 8014342:	9001      	str	r0, [sp, #4]
  return (bool)(vtp->func != NULL);
 8014344:	9b01      	ldr	r3, [sp, #4]
 8014346:	68db      	ldr	r3, [r3, #12]
 8014348:	2b00      	cmp	r3, #0
 801434a:	bf14      	ite	ne
 801434c:	2301      	movne	r3, #1
 801434e:	2300      	moveq	r3, #0
 8014350:	b2db      	uxtb	r3, r3
}
 8014352:	4618      	mov	r0, r3
 8014354:	b002      	add	sp, #8
 8014356:	4770      	bx	lr
	...

08014360 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8014360:	b082      	sub	sp, #8
 8014362:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
 8014364:	9b01      	ldr	r3, [sp, #4]
 8014366:	689b      	ldr	r3, [r3, #8]
 8014368:	1c5a      	adds	r2, r3, #1
 801436a:	9b01      	ldr	r3, [sp, #4]
 801436c:	609a      	str	r2, [r3, #8]
}
 801436e:	b002      	add	sp, #8
 8014370:	4770      	bx	lr
 8014372:	bf00      	nop
	...

08014380 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8014380:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.queue);
 8014382:	4806      	ldr	r0, [pc, #24]	; (801439c <_scheduler_init+0x1c>)
 8014384:	f7ff ff84 	bl	8014290 <queue_init.lto_priv.687>
  ch.rlist.prio = NOPRIO;
 8014388:	4b04      	ldr	r3, [pc, #16]	; (801439c <_scheduler_init+0x1c>)
 801438a:	2200      	movs	r2, #0
 801438c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 801438e:	4b03      	ldr	r3, [pc, #12]	; (801439c <_scheduler_init+0x1c>)
 8014390:	4a02      	ldr	r2, [pc, #8]	; (801439c <_scheduler_init+0x1c>)
 8014392:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8014394:	4b01      	ldr	r3, [pc, #4]	; (801439c <_scheduler_init+0x1c>)
 8014396:	4a01      	ldr	r2, [pc, #4]	; (801439c <_scheduler_init+0x1c>)
 8014398:	615a      	str	r2, [r3, #20]
#endif
}
 801439a:	bd08      	pop	{r3, pc}
 801439c:	20005ca0 	.word	0x20005ca0

080143a0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80143a0:	b084      	sub	sp, #16
 80143a2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80143a4:	9b01      	ldr	r3, [sp, #4]
 80143a6:	2200      	movs	r2, #0
 80143a8:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80143ac:	4b0e      	ldr	r3, [pc, #56]	; (80143e8 <chSchReadyI+0x48>)
 80143ae:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 80143b0:	9b03      	ldr	r3, [sp, #12]
 80143b2:	681b      	ldr	r3, [r3, #0]
 80143b4:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 80143b6:	9b03      	ldr	r3, [sp, #12]
 80143b8:	689a      	ldr	r2, [r3, #8]
 80143ba:	9b01      	ldr	r3, [sp, #4]
 80143bc:	689b      	ldr	r3, [r3, #8]
 80143be:	429a      	cmp	r2, r3
 80143c0:	d2f6      	bcs.n	80143b0 <chSchReadyI+0x10>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80143c2:	9b01      	ldr	r3, [sp, #4]
 80143c4:	9a03      	ldr	r2, [sp, #12]
 80143c6:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 80143c8:	9b03      	ldr	r3, [sp, #12]
 80143ca:	685a      	ldr	r2, [r3, #4]
 80143cc:	9b01      	ldr	r3, [sp, #4]
 80143ce:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80143d0:	9b01      	ldr	r3, [sp, #4]
 80143d2:	685b      	ldr	r3, [r3, #4]
 80143d4:	9a01      	ldr	r2, [sp, #4]
 80143d6:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 80143d8:	9b03      	ldr	r3, [sp, #12]
 80143da:	9a01      	ldr	r2, [sp, #4]
 80143dc:	605a      	str	r2, [r3, #4]

  return tp;
 80143de:	9b01      	ldr	r3, [sp, #4]
}
 80143e0:	4618      	mov	r0, r3
 80143e2:	b004      	add	sp, #16
 80143e4:	4770      	bx	lr
 80143e6:	bf00      	nop
 80143e8:	20005ca0 	.word	0x20005ca0
 80143ec:	00000000 	.word	0x00000000

080143f0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 80143f0:	b084      	sub	sp, #16
 80143f2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80143f4:	9b01      	ldr	r3, [sp, #4]
 80143f6:	2200      	movs	r2, #0
 80143f8:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80143fc:	4b0e      	ldr	r3, [pc, #56]	; (8014438 <chSchReadyAheadI+0x48>)
 80143fe:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8014400:	9b03      	ldr	r3, [sp, #12]
 8014402:	681b      	ldr	r3, [r3, #0]
 8014404:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8014406:	9b03      	ldr	r3, [sp, #12]
 8014408:	689a      	ldr	r2, [r3, #8]
 801440a:	9b01      	ldr	r3, [sp, #4]
 801440c:	689b      	ldr	r3, [r3, #8]
 801440e:	429a      	cmp	r2, r3
 8014410:	d8f6      	bhi.n	8014400 <chSchReadyAheadI+0x10>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8014412:	9b01      	ldr	r3, [sp, #4]
 8014414:	9a03      	ldr	r2, [sp, #12]
 8014416:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8014418:	9b03      	ldr	r3, [sp, #12]
 801441a:	685a      	ldr	r2, [r3, #4]
 801441c:	9b01      	ldr	r3, [sp, #4]
 801441e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8014420:	9b01      	ldr	r3, [sp, #4]
 8014422:	685b      	ldr	r3, [r3, #4]
 8014424:	9a01      	ldr	r2, [sp, #4]
 8014426:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8014428:	9b03      	ldr	r3, [sp, #12]
 801442a:	9a01      	ldr	r2, [sp, #4]
 801442c:	605a      	str	r2, [r3, #4]

  return tp;
 801442e:	9b01      	ldr	r3, [sp, #4]
}
 8014430:	4618      	mov	r0, r3
 8014432:	b004      	add	sp, #16
 8014434:	4770      	bx	lr
 8014436:	bf00      	nop
 8014438:	20005ca0 	.word	0x20005ca0
 801443c:	00000000 	.word	0x00000000

08014440 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8014440:	b500      	push	{lr}
 8014442:	b085      	sub	sp, #20
 8014444:	4603      	mov	r3, r0
 8014446:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp = currp;
 801444a:	4b0e      	ldr	r3, [pc, #56]	; (8014484 <chSchGoSleepS+0x44>)
 801444c:	699b      	ldr	r3, [r3, #24]
 801444e:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8014450:	9b03      	ldr	r3, [sp, #12]
 8014452:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8014456:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 801445a:	480a      	ldr	r0, [pc, #40]	; (8014484 <chSchGoSleepS+0x44>)
 801445c:	f7ff ff28 	bl	80142b0 <queue_fifo_remove.lto_priv.681>
 8014460:	4602      	mov	r2, r0
 8014462:	4b08      	ldr	r3, [pc, #32]	; (8014484 <chSchGoSleepS+0x44>)
 8014464:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8014466:	4b07      	ldr	r3, [pc, #28]	; (8014484 <chSchGoSleepS+0x44>)
 8014468:	699b      	ldr	r3, [r3, #24]
 801446a:	2201      	movs	r2, #1
 801446c:	f883 2020 	strb.w	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8014470:	4b04      	ldr	r3, [pc, #16]	; (8014484 <chSchGoSleepS+0x44>)
 8014472:	699b      	ldr	r3, [r3, #24]
 8014474:	9903      	ldr	r1, [sp, #12]
 8014476:	4618      	mov	r0, r3
 8014478:	f7ef ff46 	bl	8004308 <_port_switch>
}
 801447c:	b005      	add	sp, #20
 801447e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014482:	bf00      	nop
 8014484:	20005ca0 	.word	0x20005ca0
	...

08014490 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8014490:	b500      	push	{lr}
 8014492:	b085      	sub	sp, #20
 8014494:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8014496:	9b01      	ldr	r3, [sp, #4]
 8014498:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 801449a:	f7ff ff41 	bl	8014320 <chSysLockFromISR.lto_priv.710>
  switch (tp->state) {
 801449e:	9b03      	ldr	r3, [sp, #12]
 80144a0:	f893 3020 	ldrb.w	r3, [r3, #32]
 80144a4:	2b07      	cmp	r3, #7
 80144a6:	d823      	bhi.n	80144f0 <wakeup+0x60>
 80144a8:	a201      	add	r2, pc, #4	; (adr r2, 80144b0 <wakeup+0x20>)
 80144aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80144ae:	bf00      	nop
 80144b0:	080144d1 	.word	0x080144d1
 80144b4:	080144f1 	.word	0x080144f1
 80144b8:	080144f1 	.word	0x080144f1
 80144bc:	080144d7 	.word	0x080144d7
 80144c0:	080144eb 	.word	0x080144eb
 80144c4:	080144e1 	.word	0x080144e1
 80144c8:	080144f1 	.word	0x080144f1
 80144cc:	080144eb 	.word	0x080144eb
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80144d0:	f7ff ff2e 	bl	8014330 <chSysUnlockFromISR.lto_priv.708>
 80144d4:	e015      	b.n	8014502 <wakeup+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80144d6:	9b03      	ldr	r3, [sp, #12]
 80144d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80144da:	2200      	movs	r2, #0
 80144dc:	601a      	str	r2, [r3, #0]
 80144de:	e007      	b.n	80144f0 <wakeup+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80144e0:	9b03      	ldr	r3, [sp, #12]
 80144e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80144e4:	4618      	mov	r0, r3
 80144e6:	f7ff ff3b 	bl	8014360 <chSemFastSignalI>
    /* Falls through.*/
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 80144ea:	9803      	ldr	r0, [sp, #12]
 80144ec:	f7ff fef8 	bl	80142e0 <queue_dequeue.lto_priv.679>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80144f0:	9b03      	ldr	r3, [sp, #12]
 80144f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80144f6:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80144f8:	9803      	ldr	r0, [sp, #12]
 80144fa:	f7ff ff51 	bl	80143a0 <chSchReadyI>
  chSysUnlockFromISR();
 80144fe:	f7ff ff17 	bl	8014330 <chSysUnlockFromISR.lto_priv.708>
}
 8014502:	b005      	add	sp, #20
 8014504:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014510 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8014510:	b500      	push	{lr}
 8014512:	b089      	sub	sp, #36	; 0x24
 8014514:	4603      	mov	r3, r0
 8014516:	9100      	str	r1, [sp, #0]
 8014518:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 801451c:	9b00      	ldr	r3, [sp, #0]
 801451e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014522:	d017      	beq.n	8014554 <chSchGoSleepTimeoutS+0x44>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8014524:	4b11      	ldr	r3, [pc, #68]	; (801456c <chSchGoSleepTimeoutS+0x5c>)
 8014526:	699b      	ldr	r3, [r3, #24]
 8014528:	a803      	add	r0, sp, #12
 801452a:	4a11      	ldr	r2, [pc, #68]	; (8014570 <chSchGoSleepTimeoutS+0x60>)
 801452c:	9900      	ldr	r1, [sp, #0]
 801452e:	f7ff fd7f 	bl	8014030 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8014532:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8014536:	4618      	mov	r0, r3
 8014538:	f7ff ff82 	bl	8014440 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 801453c:	ab03      	add	r3, sp, #12
 801453e:	4618      	mov	r0, r3
 8014540:	f7ff fefe 	bl	8014340 <chVTIsArmedI>
 8014544:	4603      	mov	r3, r0
 8014546:	2b00      	cmp	r3, #0
 8014548:	d009      	beq.n	801455e <chSchGoSleepTimeoutS+0x4e>
      chVTDoResetI(&vt);
 801454a:	ab03      	add	r3, sp, #12
 801454c:	4618      	mov	r0, r3
 801454e:	f7ff fe07 	bl	8014160 <chVTDoResetI>
 8014552:	e004      	b.n	801455e <chSchGoSleepTimeoutS+0x4e>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8014554:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8014558:	4618      	mov	r0, r3
 801455a:	f7ff ff71 	bl	8014440 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 801455e:	4b03      	ldr	r3, [pc, #12]	; (801456c <chSchGoSleepTimeoutS+0x5c>)
 8014560:	699b      	ldr	r3, [r3, #24]
 8014562:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8014564:	4618      	mov	r0, r3
 8014566:	b009      	add	sp, #36	; 0x24
 8014568:	f85d fb04 	ldr.w	pc, [sp], #4
 801456c:	20005ca0 	.word	0x20005ca0
 8014570:	08014491 	.word	0x08014491
	...

08014580 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8014580:	b500      	push	{lr}
 8014582:	b085      	sub	sp, #20
 8014584:	9001      	str	r0, [sp, #4]
 8014586:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8014588:	4b10      	ldr	r3, [pc, #64]	; (80145cc <chSchWakeupS+0x4c>)
 801458a:	699b      	ldr	r3, [r3, #24]
 801458c:	9303      	str	r3, [sp, #12]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 801458e:	9b01      	ldr	r3, [sp, #4]
 8014590:	9a00      	ldr	r2, [sp, #0]
 8014592:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8014594:	9b01      	ldr	r3, [sp, #4]
 8014596:	689a      	ldr	r2, [r3, #8]
 8014598:	9b03      	ldr	r3, [sp, #12]
 801459a:	689b      	ldr	r3, [r3, #8]
 801459c:	429a      	cmp	r2, r3
 801459e:	d803      	bhi.n	80145a8 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
 80145a0:	9801      	ldr	r0, [sp, #4]
 80145a2:	f7ff fefd 	bl	80143a0 <chSchReadyI>
 80145a6:	e00e      	b.n	80145c6 <chSchWakeupS+0x46>
  }
  else {
    otp = chSchReadyI(otp);
 80145a8:	9803      	ldr	r0, [sp, #12]
 80145aa:	f7ff fef9 	bl	80143a0 <chSchReadyI>
 80145ae:	9003      	str	r0, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80145b0:	4a06      	ldr	r2, [pc, #24]	; (80145cc <chSchWakeupS+0x4c>)
 80145b2:	9b01      	ldr	r3, [sp, #4]
 80145b4:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 80145b6:	9b01      	ldr	r3, [sp, #4]
 80145b8:	2201      	movs	r2, #1
 80145ba:	f883 2020 	strb.w	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80145be:	9903      	ldr	r1, [sp, #12]
 80145c0:	9801      	ldr	r0, [sp, #4]
 80145c2:	f7ef fea1 	bl	8004308 <_port_switch>
  }
}
 80145c6:	b005      	add	sp, #20
 80145c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80145cc:	20005ca0 	.word	0x20005ca0

080145d0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 80145d0:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80145d2:	f7ff fe95 	bl	8014300 <chSchIsRescRequiredI>
 80145d6:	4603      	mov	r3, r0
 80145d8:	2b00      	cmp	r3, #0
 80145da:	d001      	beq.n	80145e0 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 80145dc:	f000 f820 	bl	8014620 <chSchDoRescheduleAhead>
  }
}
 80145e0:	bd08      	pop	{r3, pc}
 80145e2:	bf00      	nop
	...

080145f0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80145f0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80145f2:	4b09      	ldr	r3, [pc, #36]	; (8014618 <chSchIsPreemptionRequired+0x28>)
 80145f4:	681b      	ldr	r3, [r3, #0]
 80145f6:	689b      	ldr	r3, [r3, #8]
 80145f8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 80145fa:	4b07      	ldr	r3, [pc, #28]	; (8014618 <chSchIsPreemptionRequired+0x28>)
 80145fc:	699b      	ldr	r3, [r3, #24]
 80145fe:	689b      	ldr	r3, [r3, #8]
 8014600:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8014602:	9a01      	ldr	r2, [sp, #4]
 8014604:	9b00      	ldr	r3, [sp, #0]
 8014606:	429a      	cmp	r2, r3
 8014608:	bf8c      	ite	hi
 801460a:	2301      	movhi	r3, #1
 801460c:	2300      	movls	r3, #0
 801460e:	b2db      	uxtb	r3, r3
#endif
}
 8014610:	4618      	mov	r0, r3
 8014612:	b002      	add	sp, #8
 8014614:	4770      	bx	lr
 8014616:	bf00      	nop
 8014618:	20005ca0 	.word	0x20005ca0
 801461c:	00000000 	.word	0x00000000

08014620 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8014620:	b500      	push	{lr}
 8014622:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8014624:	4b0d      	ldr	r3, [pc, #52]	; (801465c <chSchDoRescheduleAhead+0x3c>)
 8014626:	699b      	ldr	r3, [r3, #24]
 8014628:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 801462a:	480c      	ldr	r0, [pc, #48]	; (801465c <chSchDoRescheduleAhead+0x3c>)
 801462c:	f7ff fe40 	bl	80142b0 <queue_fifo_remove.lto_priv.681>
 8014630:	4602      	mov	r2, r0
 8014632:	4b0a      	ldr	r3, [pc, #40]	; (801465c <chSchDoRescheduleAhead+0x3c>)
 8014634:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8014636:	4b09      	ldr	r3, [pc, #36]	; (801465c <chSchDoRescheduleAhead+0x3c>)
 8014638:	699b      	ldr	r3, [r3, #24]
 801463a:	2201      	movs	r2, #1
 801463c:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8014640:	9801      	ldr	r0, [sp, #4]
 8014642:	f7ff fed5 	bl	80143f0 <chSchReadyAheadI>
 8014646:	9001      	str	r0, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8014648:	4b04      	ldr	r3, [pc, #16]	; (801465c <chSchDoRescheduleAhead+0x3c>)
 801464a:	699b      	ldr	r3, [r3, #24]
 801464c:	9901      	ldr	r1, [sp, #4]
 801464e:	4618      	mov	r0, r3
 8014650:	f7ef fe5a 	bl	8004308 <_port_switch>
}
 8014654:	b003      	add	sp, #12
 8014656:	f85d fb04 	ldr.w	pc, [sp], #4
 801465a:	bf00      	nop
 801465c:	20005ca0 	.word	0x20005ca0

08014660 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8014660:	b500      	push	{lr}
 8014662:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8014664:	4b0d      	ldr	r3, [pc, #52]	; (801469c <chSchDoReschedule+0x3c>)
 8014666:	699b      	ldr	r3, [r3, #24]
 8014668:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 801466a:	480c      	ldr	r0, [pc, #48]	; (801469c <chSchDoReschedule+0x3c>)
 801466c:	f7ff fe20 	bl	80142b0 <queue_fifo_remove.lto_priv.681>
 8014670:	4602      	mov	r2, r0
 8014672:	4b0a      	ldr	r3, [pc, #40]	; (801469c <chSchDoReschedule+0x3c>)
 8014674:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8014676:	4b09      	ldr	r3, [pc, #36]	; (801469c <chSchDoReschedule+0x3c>)
 8014678:	699b      	ldr	r3, [r3, #24]
 801467a:	2201      	movs	r2, #1
 801467c:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8014680:	9801      	ldr	r0, [sp, #4]
 8014682:	f7ff feb5 	bl	80143f0 <chSchReadyAheadI>
 8014686:	9001      	str	r0, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8014688:	4b04      	ldr	r3, [pc, #16]	; (801469c <chSchDoReschedule+0x3c>)
 801468a:	699b      	ldr	r3, [r3, #24]
 801468c:	9901      	ldr	r1, [sp, #4]
 801468e:	4618      	mov	r0, r3
 8014690:	f7ef fe3a 	bl	8004308 <_port_switch>
}
 8014694:	b003      	add	sp, #12
 8014696:	f85d fb04 	ldr.w	pc, [sp], #4
 801469a:	bf00      	nop
 801469c:	20005ca0 	.word	0x20005ca0

080146a0 <port_lock.lto_priv.664>:
static inline void port_lock(void) {
 80146a0:	b082      	sub	sp, #8
 80146a2:	2320      	movs	r3, #32
 80146a4:	9301      	str	r3, [sp, #4]
 80146a6:	9b01      	ldr	r3, [sp, #4]
 80146a8:	f383 8811 	msr	BASEPRI, r3
}
 80146ac:	b002      	add	sp, #8
 80146ae:	4770      	bx	lr

080146b0 <port_unlock.lto_priv.658>:
static inline void port_unlock(void) {
 80146b0:	b082      	sub	sp, #8
 80146b2:	2300      	movs	r3, #0
 80146b4:	9301      	str	r3, [sp, #4]
 80146b6:	9b01      	ldr	r3, [sp, #4]
 80146b8:	f383 8811 	msr	BASEPRI, r3
}
 80146bc:	b002      	add	sp, #8
 80146be:	4770      	bx	lr

080146c0 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 80146c0:	b082      	sub	sp, #8
 80146c2:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 80146c4:	9b01      	ldr	r3, [sp, #4]
 80146c6:	9a01      	ldr	r2, [sp, #4]
 80146c8:	601a      	str	r2, [r3, #0]
}
 80146ca:	b002      	add	sp, #8
 80146cc:	4770      	bx	lr
 80146ce:	bf00      	nop

080146d0 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 80146d0:	b082      	sub	sp, #8
 80146d2:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 80146d4:	9b01      	ldr	r3, [sp, #4]
 80146d6:	681a      	ldr	r2, [r3, #0]
 80146d8:	9b01      	ldr	r3, [sp, #4]
 80146da:	429a      	cmp	r2, r3
 80146dc:	bf14      	ite	ne
 80146de:	2301      	movne	r3, #1
 80146e0:	2300      	moveq	r3, #0
 80146e2:	b2db      	uxtb	r3, r3
}
 80146e4:	4618      	mov	r0, r3
 80146e6:	b002      	add	sp, #8
 80146e8:	4770      	bx	lr
 80146ea:	bf00      	nop
 80146ec:	0000      	movs	r0, r0
	...

080146f0 <queue_init.lto_priv.688>:
static inline void queue_init(threads_queue_t *tqp) {
 80146f0:	b082      	sub	sp, #8
 80146f2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80146f4:	9b01      	ldr	r3, [sp, #4]
 80146f6:	9a01      	ldr	r2, [sp, #4]
 80146f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80146fa:	9b01      	ldr	r3, [sp, #4]
 80146fc:	9a01      	ldr	r2, [sp, #4]
 80146fe:	605a      	str	r2, [r3, #4]
}
 8014700:	b002      	add	sp, #8
 8014702:	4770      	bx	lr
	...

08014710 <queue_notempty.lto_priv.685>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8014710:	b082      	sub	sp, #8
 8014712:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8014714:	9b01      	ldr	r3, [sp, #4]
 8014716:	681a      	ldr	r2, [r3, #0]
 8014718:	9b01      	ldr	r3, [sp, #4]
 801471a:	429a      	cmp	r2, r3
 801471c:	bf14      	ite	ne
 801471e:	2301      	movne	r3, #1
 8014720:	2300      	moveq	r3, #0
 8014722:	b2db      	uxtb	r3, r3
}
 8014724:	4618      	mov	r0, r3
 8014726:	b002      	add	sp, #8
 8014728:	4770      	bx	lr
 801472a:	bf00      	nop
 801472c:	0000      	movs	r0, r0
	...

08014730 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8014730:	b084      	sub	sp, #16
 8014732:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 8014734:	9b01      	ldr	r3, [sp, #4]
 8014736:	681b      	ldr	r3, [r3, #0]
 8014738:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 801473a:	9b03      	ldr	r3, [sp, #12]
 801473c:	681a      	ldr	r2, [r3, #0]
 801473e:	9b01      	ldr	r3, [sp, #4]
 8014740:	601a      	str	r2, [r3, #0]
  return tp;
 8014742:	9b03      	ldr	r3, [sp, #12]
}
 8014744:	4618      	mov	r0, r3
 8014746:	b004      	add	sp, #16
 8014748:	4770      	bx	lr
 801474a:	bf00      	nop
 801474c:	0000      	movs	r0, r0
	...

08014750 <queue_insert.lto_priv.691>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8014750:	b082      	sub	sp, #8
 8014752:	9001      	str	r0, [sp, #4]
 8014754:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8014756:	9b01      	ldr	r3, [sp, #4]
 8014758:	9a00      	ldr	r2, [sp, #0]
 801475a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 801475c:	9b00      	ldr	r3, [sp, #0]
 801475e:	685a      	ldr	r2, [r3, #4]
 8014760:	9b01      	ldr	r3, [sp, #4]
 8014762:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8014764:	9b01      	ldr	r3, [sp, #4]
 8014766:	685b      	ldr	r3, [r3, #4]
 8014768:	9a01      	ldr	r2, [sp, #4]
 801476a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 801476c:	9b00      	ldr	r3, [sp, #0]
 801476e:	9a01      	ldr	r2, [sp, #4]
 8014770:	605a      	str	r2, [r3, #4]
}
 8014772:	b002      	add	sp, #8
 8014774:	4770      	bx	lr
 8014776:	bf00      	nop
	...

08014780 <queue_fifo_remove.lto_priv.682>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8014780:	b084      	sub	sp, #16
 8014782:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8014784:	9b01      	ldr	r3, [sp, #4]
 8014786:	681b      	ldr	r3, [r3, #0]
 8014788:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 801478a:	9b03      	ldr	r3, [sp, #12]
 801478c:	681a      	ldr	r2, [r3, #0]
 801478e:	9b01      	ldr	r3, [sp, #4]
 8014790:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8014792:	9b01      	ldr	r3, [sp, #4]
 8014794:	681b      	ldr	r3, [r3, #0]
 8014796:	9a01      	ldr	r2, [sp, #4]
 8014798:	605a      	str	r2, [r3, #4]
  return tp;
 801479a:	9b03      	ldr	r3, [sp, #12]
}
 801479c:	4618      	mov	r0, r3
 801479e:	b004      	add	sp, #16
 80147a0:	4770      	bx	lr
 80147a2:	bf00      	nop
	...

080147b0 <chSysLock.lto_priv.675>:
static inline void chSysLock(void) {
 80147b0:	b508      	push	{r3, lr}
  port_lock();
 80147b2:	f7ff ff75 	bl	80146a0 <port_lock.lto_priv.664>
}
 80147b6:	bd08      	pop	{r3, pc}
	...

080147c0 <chSysUnlock.lto_priv.670>:
static inline void chSysUnlock(void) {
 80147c0:	b508      	push	{r3, lr}
  port_unlock();
 80147c2:	f7ff ff75 	bl	80146b0 <port_unlock.lto_priv.658>
}
 80147c6:	bd08      	pop	{r3, pc}
	...

080147d0 <chThdGetSelfX.lto_priv.655>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80147d0:	4b01      	ldr	r3, [pc, #4]	; (80147d8 <chThdGetSelfX.lto_priv.655+0x8>)
 80147d2:	699b      	ldr	r3, [r3, #24]
}
 80147d4:	4618      	mov	r0, r3
 80147d6:	4770      	bx	lr
 80147d8:	20005ca0 	.word	0x20005ca0
 80147dc:	00000000 	.word	0x00000000

080147e0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 80147e0:	b500      	push	{lr}
 80147e2:	b083      	sub	sp, #12
 80147e4:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80147e6:	9901      	ldr	r1, [sp, #4]
 80147e8:	2008      	movs	r0, #8
 80147ea:	f7ff fe91 	bl	8014510 <chSchGoSleepTimeoutS>
}
 80147ee:	b003      	add	sp, #12
 80147f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014800 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8014800:	b500      	push	{lr}
 8014802:	b085      	sub	sp, #20
 8014804:	9001      	str	r0, [sp, #4]
 8014806:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8014808:	9801      	ldr	r0, [sp, #4]
 801480a:	f7ff ffb9 	bl	8014780 <queue_fifo_remove.lto_priv.682>
 801480e:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8014810:	9b03      	ldr	r3, [sp, #12]
 8014812:	9a00      	ldr	r2, [sp, #0]
 8014814:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8014816:	9803      	ldr	r0, [sp, #12]
 8014818:	f7ff fdc2 	bl	80143a0 <chSchReadyI>
}
 801481c:	b005      	add	sp, #20
 801481e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014822:	bf00      	nop
	...

08014830 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8014830:	b500      	push	{lr}
 8014832:	b085      	sub	sp, #20
 8014834:	9003      	str	r0, [sp, #12]
 8014836:	9102      	str	r1, [sp, #8]
 8014838:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 801483a:	9b03      	ldr	r3, [sp, #12]
 801483c:	9a01      	ldr	r2, [sp, #4]
 801483e:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8014840:	9b03      	ldr	r3, [sp, #12]
 8014842:	2202      	movs	r2, #2
 8014844:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8014848:	9b03      	ldr	r3, [sp, #12]
 801484a:	2200      	movs	r2, #0
 801484c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8014850:	9b03      	ldr	r3, [sp, #12]
 8014852:	9a01      	ldr	r2, [sp, #4]
 8014854:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8014856:	9b03      	ldr	r3, [sp, #12]
 8014858:	2200      	movs	r2, #0
 801485a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 801485c:	9b03      	ldr	r3, [sp, #12]
 801485e:	2200      	movs	r2, #0
 8014860:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8014862:	9b03      	ldr	r3, [sp, #12]
 8014864:	2201      	movs	r2, #1
 8014866:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 801486a:	9b03      	ldr	r3, [sp, #12]
 801486c:	9a02      	ldr	r2, [sp, #8]
 801486e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8014870:	9b03      	ldr	r3, [sp, #12]
 8014872:	4a0e      	ldr	r2, [pc, #56]	; (80148ac <_thread_init+0x7c>)
 8014874:	611a      	str	r2, [r3, #16]
 8014876:	4b0d      	ldr	r3, [pc, #52]	; (80148ac <_thread_init+0x7c>)
 8014878:	695a      	ldr	r2, [r3, #20]
 801487a:	9b03      	ldr	r3, [sp, #12]
 801487c:	615a      	str	r2, [r3, #20]
 801487e:	9b03      	ldr	r3, [sp, #12]
 8014880:	695b      	ldr	r3, [r3, #20]
 8014882:	9a03      	ldr	r2, [sp, #12]
 8014884:	611a      	str	r2, [r3, #16]
 8014886:	4a09      	ldr	r2, [pc, #36]	; (80148ac <_thread_init+0x7c>)
 8014888:	9b03      	ldr	r3, [sp, #12]
 801488a:	6153      	str	r3, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 801488c:	9b03      	ldr	r3, [sp, #12]
 801488e:	3328      	adds	r3, #40	; 0x28
 8014890:	4618      	mov	r0, r3
 8014892:	f7ff ff15 	bl	80146c0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8014896:	9b03      	ldr	r3, [sp, #12]
 8014898:	332c      	adds	r3, #44	; 0x2c
 801489a:	4618      	mov	r0, r3
 801489c:	f7ff ff28 	bl	80146f0 <queue_init.lto_priv.688>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 80148a0:	9b03      	ldr	r3, [sp, #12]
}
 80148a2:	4618      	mov	r0, r3
 80148a4:	b005      	add	sp, #20
 80148a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80148aa:	bf00      	nop
 80148ac:	20005ca0 	.word	0x20005ca0

080148b0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80148b0:	b500      	push	{lr}
 80148b2:	b085      	sub	sp, #20
 80148b4:	9001      	str	r0, [sp, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 80148b6:	9b01      	ldr	r3, [sp, #4]
 80148b8:	689b      	ldr	r3, [r3, #8]
 80148ba:	3b48      	subs	r3, #72	; 0x48
 80148bc:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80148be:	9b01      	ldr	r3, [sp, #4]
 80148c0:	685a      	ldr	r2, [r3, #4]
 80148c2:	9b03      	ldr	r3, [sp, #12]
 80148c4:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80148c6:	9b03      	ldr	r3, [sp, #12]
 80148c8:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 80148cc:	9b03      	ldr	r3, [sp, #12]
 80148ce:	60da      	str	r2, [r3, #12]
 80148d0:	9b03      	ldr	r3, [sp, #12]
 80148d2:	68db      	ldr	r3, [r3, #12]
 80148d4:	9a01      	ldr	r2, [sp, #4]
 80148d6:	6912      	ldr	r2, [r2, #16]
 80148d8:	641a      	str	r2, [r3, #64]	; 0x40
 80148da:	9b03      	ldr	r3, [sp, #12]
 80148dc:	68db      	ldr	r3, [r3, #12]
 80148de:	9a01      	ldr	r2, [sp, #4]
 80148e0:	6952      	ldr	r2, [r2, #20]
 80148e2:	645a      	str	r2, [r3, #68]	; 0x44
 80148e4:	9b03      	ldr	r3, [sp, #12]
 80148e6:	68db      	ldr	r3, [r3, #12]
 80148e8:	4a07      	ldr	r2, [pc, #28]	; (8014908 <chThdCreateSuspendedI+0x58>)
 80148ea:	661a      	str	r2, [r3, #96]	; 0x60

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 80148ec:	9b01      	ldr	r3, [sp, #4]
 80148ee:	6819      	ldr	r1, [r3, #0]
 80148f0:	9b01      	ldr	r3, [sp, #4]
 80148f2:	68db      	ldr	r3, [r3, #12]
 80148f4:	461a      	mov	r2, r3
 80148f6:	9803      	ldr	r0, [sp, #12]
 80148f8:	f7ff ff9a 	bl	8014830 <_thread_init>
 80148fc:	4603      	mov	r3, r0
}
 80148fe:	4618      	mov	r0, r3
 8014900:	b005      	add	sp, #20
 8014902:	f85d fb04 	ldr.w	pc, [sp], #4
 8014906:	bf00      	nop
 8014908:	08004321 	.word	0x08004321
 801490c:	00000000 	.word	0x00000000

08014910 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8014910:	b500      	push	{lr}
 8014912:	b085      	sub	sp, #20
 8014914:	9001      	str	r0, [sp, #4]
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8014916:	f7ff ff4b 	bl	80147b0 <chSysLock.lto_priv.675>
  tp = chThdCreateSuspendedI(tdp);
 801491a:	9801      	ldr	r0, [sp, #4]
 801491c:	f7ff ffc8 	bl	80148b0 <chThdCreateSuspendedI>
 8014920:	9003      	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 8014922:	2100      	movs	r1, #0
 8014924:	9803      	ldr	r0, [sp, #12]
 8014926:	f7ff fe2b 	bl	8014580 <chSchWakeupS>
  chSysUnlock();
 801492a:	f7ff ff49 	bl	80147c0 <chSysUnlock.lto_priv.670>

  return tp;
 801492e:	9b03      	ldr	r3, [sp, #12]
}
 8014930:	4618      	mov	r0, r3
 8014932:	b005      	add	sp, #20
 8014934:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014940 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8014940:	b500      	push	{lr}
 8014942:	b087      	sub	sp, #28
 8014944:	9003      	str	r0, [sp, #12]
 8014946:	9102      	str	r1, [sp, #8]
 8014948:	9201      	str	r2, [sp, #4]
 801494a:	9300      	str	r3, [sp, #0]
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 801494c:	f7ff ff30 	bl	80147b0 <chSysLock.lto_priv.675>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8014950:	9b02      	ldr	r3, [sp, #8]
 8014952:	3b48      	subs	r3, #72	; 0x48
 8014954:	9a03      	ldr	r2, [sp, #12]
 8014956:	4413      	add	r3, r2
 8014958:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 801495a:	9b05      	ldr	r3, [sp, #20]
 801495c:	9a03      	ldr	r2, [sp, #12]
 801495e:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8014960:	9b05      	ldr	r3, [sp, #20]
 8014962:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 8014966:	9b05      	ldr	r3, [sp, #20]
 8014968:	60da      	str	r2, [r3, #12]
 801496a:	9b05      	ldr	r3, [sp, #20]
 801496c:	68db      	ldr	r3, [r3, #12]
 801496e:	9a00      	ldr	r2, [sp, #0]
 8014970:	641a      	str	r2, [r3, #64]	; 0x40
 8014972:	9b05      	ldr	r3, [sp, #20]
 8014974:	68db      	ldr	r3, [r3, #12]
 8014976:	9a08      	ldr	r2, [sp, #32]
 8014978:	645a      	str	r2, [r3, #68]	; 0x44
 801497a:	9b05      	ldr	r3, [sp, #20]
 801497c:	68db      	ldr	r3, [r3, #12]
 801497e:	4a09      	ldr	r2, [pc, #36]	; (80149a4 <chThdCreateStatic+0x64>)
 8014980:	661a      	str	r2, [r3, #96]	; 0x60

  tp = _thread_init(tp, "noname", prio);
 8014982:	9a01      	ldr	r2, [sp, #4]
 8014984:	4908      	ldr	r1, [pc, #32]	; (80149a8 <chThdCreateStatic+0x68>)
 8014986:	9805      	ldr	r0, [sp, #20]
 8014988:	f7ff ff52 	bl	8014830 <_thread_init>
 801498c:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 801498e:	2100      	movs	r1, #0
 8014990:	9805      	ldr	r0, [sp, #20]
 8014992:	f7ff fdf5 	bl	8014580 <chSchWakeupS>
  chSysUnlock();
 8014996:	f7ff ff13 	bl	80147c0 <chSysUnlock.lto_priv.670>

  return tp;
 801499a:	9b05      	ldr	r3, [sp, #20]
}
 801499c:	4618      	mov	r0, r3
 801499e:	b007      	add	sp, #28
 80149a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80149a4:	08004321 	.word	0x08004321
 80149a8:	08024c90 	.word	0x08024c90
 80149ac:	00000000 	.word	0x00000000

080149b0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80149b0:	b500      	push	{lr}
 80149b2:	b083      	sub	sp, #12
 80149b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80149b6:	f7ff fefb 	bl	80147b0 <chSysLock.lto_priv.675>
  chThdExitS(msg);
 80149ba:	9801      	ldr	r0, [sp, #4]
 80149bc:	f000 f808 	bl	80149d0 <chThdExitS>
  /* The thread never returns here.*/
}
 80149c0:	b003      	add	sp, #12
 80149c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80149c6:	bf00      	nop
	...

080149d0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80149d0:	b500      	push	{lr}
 80149d2:	b085      	sub	sp, #20
 80149d4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80149d6:	4b1a      	ldr	r3, [pc, #104]	; (8014a40 <chThdExitS+0x70>)
 80149d8:	699b      	ldr	r3, [r3, #24]
 80149da:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80149dc:	9b03      	ldr	r3, [sp, #12]
 80149de:	9a01      	ldr	r2, [sp, #4]
 80149e0:	625a      	str	r2, [r3, #36]	; 0x24
 80149e2:	e008      	b.n	80149f6 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 80149e4:	9b03      	ldr	r3, [sp, #12]
 80149e6:	3328      	adds	r3, #40	; 0x28
 80149e8:	4618      	mov	r0, r3
 80149ea:	f7ff fea1 	bl	8014730 <list_remove>
 80149ee:	4603      	mov	r3, r0
 80149f0:	4618      	mov	r0, r3
 80149f2:	f7ff fcd5 	bl	80143a0 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 80149f6:	9b03      	ldr	r3, [sp, #12]
 80149f8:	3328      	adds	r3, #40	; 0x28
 80149fa:	4618      	mov	r0, r3
 80149fc:	f7ff fe68 	bl	80146d0 <list_notempty>
 8014a00:	4603      	mov	r3, r0
 8014a02:	2b00      	cmp	r3, #0
 8014a04:	d1ee      	bne.n	80149e4 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8014a06:	9b03      	ldr	r3, [sp, #12]
 8014a08:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8014a0c:	2b00      	cmp	r3, #0
 8014a0e:	d110      	bne.n	8014a32 <chThdExitS+0x62>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8014a10:	9b03      	ldr	r3, [sp, #12]
 8014a12:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8014a16:	f003 0303 	and.w	r3, r3, #3
  if ((tp->refs == (trefs_t)0) &&
 8014a1a:	2b00      	cmp	r3, #0
 8014a1c:	d109      	bne.n	8014a32 <chThdExitS+0x62>
    REG_REMOVE(tp);
 8014a1e:	9b03      	ldr	r3, [sp, #12]
 8014a20:	695b      	ldr	r3, [r3, #20]
 8014a22:	9a03      	ldr	r2, [sp, #12]
 8014a24:	6912      	ldr	r2, [r2, #16]
 8014a26:	611a      	str	r2, [r3, #16]
 8014a28:	9b03      	ldr	r3, [sp, #12]
 8014a2a:	691b      	ldr	r3, [r3, #16]
 8014a2c:	9a03      	ldr	r2, [sp, #12]
 8014a2e:	6952      	ldr	r2, [r2, #20]
 8014a30:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8014a32:	200f      	movs	r0, #15
 8014a34:	f7ff fd04 	bl	8014440 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8014a38:	b005      	add	sp, #20
 8014a3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a3e:	bf00      	nop
 8014a40:	20005ca0 	.word	0x20005ca0
	...

08014a50 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8014a50:	b500      	push	{lr}
 8014a52:	b083      	sub	sp, #12
 8014a54:	9001      	str	r0, [sp, #4]

  chSysLock();
 8014a56:	f7ff feab 	bl	80147b0 <chSysLock.lto_priv.675>
  chThdSleepS(time);
 8014a5a:	9801      	ldr	r0, [sp, #4]
 8014a5c:	f7ff fec0 	bl	80147e0 <chThdSleepS>
  chSysUnlock();
 8014a60:	f7ff feae 	bl	80147c0 <chSysUnlock.lto_priv.670>
}
 8014a64:	b003      	add	sp, #12
 8014a66:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a6a:	bf00      	nop
 8014a6c:	0000      	movs	r0, r0
	...

08014a70 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8014a70:	b500      	push	{lr}
 8014a72:	b085      	sub	sp, #20
 8014a74:	9001      	str	r0, [sp, #4]
 8014a76:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8014a78:	f7ff feaa 	bl	80147d0 <chThdGetSelfX.lto_priv.655>
 8014a7c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 8014a7e:	9b00      	ldr	r3, [sp, #0]
 8014a80:	2b00      	cmp	r3, #0
 8014a82:	d102      	bne.n	8014a8a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8014a84:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8014a88:	e00a      	b.n	8014aa0 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 8014a8a:	9b01      	ldr	r3, [sp, #4]
 8014a8c:	9a03      	ldr	r2, [sp, #12]
 8014a8e:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8014a90:	9b03      	ldr	r3, [sp, #12]
 8014a92:	9a01      	ldr	r2, [sp, #4]
 8014a94:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8014a96:	9900      	ldr	r1, [sp, #0]
 8014a98:	2003      	movs	r0, #3
 8014a9a:	f7ff fd39 	bl	8014510 <chSchGoSleepTimeoutS>
 8014a9e:	4603      	mov	r3, r0
}
 8014aa0:	4618      	mov	r0, r3
 8014aa2:	b005      	add	sp, #20
 8014aa4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014ab0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8014ab0:	b500      	push	{lr}
 8014ab2:	b085      	sub	sp, #20
 8014ab4:	9001      	str	r0, [sp, #4]
 8014ab6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8014ab8:	9b01      	ldr	r3, [sp, #4]
 8014aba:	681b      	ldr	r3, [r3, #0]
 8014abc:	2b00      	cmp	r3, #0
 8014abe:	d00b      	beq.n	8014ad8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8014ac0:	9b01      	ldr	r3, [sp, #4]
 8014ac2:	681b      	ldr	r3, [r3, #0]
 8014ac4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8014ac6:	9b01      	ldr	r3, [sp, #4]
 8014ac8:	2200      	movs	r2, #0
 8014aca:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8014acc:	9b03      	ldr	r3, [sp, #12]
 8014ace:	9a00      	ldr	r2, [sp, #0]
 8014ad0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8014ad2:	9803      	ldr	r0, [sp, #12]
 8014ad4:	f7ff fc64 	bl	80143a0 <chSchReadyI>
  }
}
 8014ad8:	b005      	add	sp, #20
 8014ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ade:	bf00      	nop

08014ae0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8014ae0:	b500      	push	{lr}
 8014ae2:	b083      	sub	sp, #12
 8014ae4:	9001      	str	r0, [sp, #4]
 8014ae6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8014ae8:	9b00      	ldr	r3, [sp, #0]
 8014aea:	2b00      	cmp	r3, #0
 8014aec:	d102      	bne.n	8014af4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8014aee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8014af2:	e00a      	b.n	8014b0a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8014af4:	4b07      	ldr	r3, [pc, #28]	; (8014b14 <chThdEnqueueTimeoutS+0x34>)
 8014af6:	699b      	ldr	r3, [r3, #24]
 8014af8:	9901      	ldr	r1, [sp, #4]
 8014afa:	4618      	mov	r0, r3
 8014afc:	f7ff fe28 	bl	8014750 <queue_insert.lto_priv.691>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8014b00:	9900      	ldr	r1, [sp, #0]
 8014b02:	2004      	movs	r0, #4
 8014b04:	f7ff fd04 	bl	8014510 <chSchGoSleepTimeoutS>
 8014b08:	4603      	mov	r3, r0
}
 8014b0a:	4618      	mov	r0, r3
 8014b0c:	b003      	add	sp, #12
 8014b0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b12:	bf00      	nop
 8014b14:	20005ca0 	.word	0x20005ca0
	...

08014b20 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8014b20:	b500      	push	{lr}
 8014b22:	b083      	sub	sp, #12
 8014b24:	9001      	str	r0, [sp, #4]
 8014b26:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8014b28:	9801      	ldr	r0, [sp, #4]
 8014b2a:	f7ff fdf1 	bl	8014710 <queue_notempty.lto_priv.685>
 8014b2e:	4603      	mov	r3, r0
 8014b30:	2b00      	cmp	r3, #0
 8014b32:	d003      	beq.n	8014b3c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8014b34:	9900      	ldr	r1, [sp, #0]
 8014b36:	9801      	ldr	r0, [sp, #4]
 8014b38:	f7ff fe62 	bl	8014800 <chThdDoDequeueNextI>
  }
}
 8014b3c:	b003      	add	sp, #12
 8014b3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b42:	bf00      	nop
	...

08014b50 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8014b50:	b500      	push	{lr}
 8014b52:	b083      	sub	sp, #12
 8014b54:	9001      	str	r0, [sp, #4]
 8014b56:	9100      	str	r1, [sp, #0]
 8014b58:	e003      	b.n	8014b62 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 8014b5a:	9900      	ldr	r1, [sp, #0]
 8014b5c:	9801      	ldr	r0, [sp, #4]
 8014b5e:	f7ff fe4f 	bl	8014800 <chThdDoDequeueNextI>
  while (queue_notempty(tqp)) {
 8014b62:	9801      	ldr	r0, [sp, #4]
 8014b64:	f7ff fdd4 	bl	8014710 <queue_notempty.lto_priv.685>
 8014b68:	4603      	mov	r3, r0
 8014b6a:	2b00      	cmp	r3, #0
 8014b6c:	d1f5      	bne.n	8014b5a <chThdDequeueAllI+0xa>
  }
}
 8014b6e:	b003      	add	sp, #12
 8014b70:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014b80 <port_rt_get_counter_value.lto_priv.696>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8014b80:	4b01      	ldr	r3, [pc, #4]	; (8014b88 <port_rt_get_counter_value.lto_priv.696+0x8>)
 8014b82:	685b      	ldr	r3, [r3, #4]
}
 8014b84:	4618      	mov	r0, r3
 8014b86:	4770      	bx	lr
 8014b88:	e0001000 	.word	0xe0001000
 8014b8c:	00000000 	.word	0x00000000

08014b90 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8014b90:	b410      	push	{r4}
 8014b92:	b085      	sub	sp, #20
 8014b94:	9003      	str	r0, [sp, #12]
 8014b96:	9102      	str	r1, [sp, #8]
 8014b98:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8014b9a:	9b03      	ldr	r3, [sp, #12]
 8014b9c:	68db      	ldr	r3, [r3, #12]
 8014b9e:	1c5a      	adds	r2, r3, #1
 8014ba0:	9b03      	ldr	r3, [sp, #12]
 8014ba2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8014ba4:	9b03      	ldr	r3, [sp, #12]
 8014ba6:	689b      	ldr	r3, [r3, #8]
 8014ba8:	9a02      	ldr	r2, [sp, #8]
 8014baa:	1ad2      	subs	r2, r2, r3
 8014bac:	9b01      	ldr	r3, [sp, #4]
 8014bae:	1ad2      	subs	r2, r2, r3
 8014bb0:	9b03      	ldr	r3, [sp, #12]
 8014bb2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8014bb4:	9b03      	ldr	r3, [sp, #12]
 8014bb6:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
 8014bba:	9b03      	ldr	r3, [sp, #12]
 8014bbc:	689b      	ldr	r3, [r3, #8]
 8014bbe:	f04f 0400 	mov.w	r4, #0
 8014bc2:	185b      	adds	r3, r3, r1
 8014bc4:	eb44 0402 	adc.w	r4, r4, r2
 8014bc8:	9a03      	ldr	r2, [sp, #12]
 8014bca:	e9c2 3404 	strd	r3, r4, [r2, #16]
  if (tmp->last > tmp->worst) {
 8014bce:	9b03      	ldr	r3, [sp, #12]
 8014bd0:	689a      	ldr	r2, [r3, #8]
 8014bd2:	9b03      	ldr	r3, [sp, #12]
 8014bd4:	685b      	ldr	r3, [r3, #4]
 8014bd6:	429a      	cmp	r2, r3
 8014bd8:	d903      	bls.n	8014be2 <tm_stop+0x52>
    tmp->worst = tmp->last;
 8014bda:	9b03      	ldr	r3, [sp, #12]
 8014bdc:	689a      	ldr	r2, [r3, #8]
 8014bde:	9b03      	ldr	r3, [sp, #12]
 8014be0:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8014be2:	9b03      	ldr	r3, [sp, #12]
 8014be4:	689a      	ldr	r2, [r3, #8]
 8014be6:	9b03      	ldr	r3, [sp, #12]
 8014be8:	681b      	ldr	r3, [r3, #0]
 8014bea:	429a      	cmp	r2, r3
 8014bec:	d203      	bcs.n	8014bf6 <tm_stop+0x66>
    tmp->best = tmp->last;
 8014bee:	9b03      	ldr	r3, [sp, #12]
 8014bf0:	689a      	ldr	r2, [r3, #8]
 8014bf2:	9b03      	ldr	r3, [sp, #12]
 8014bf4:	601a      	str	r2, [r3, #0]
  }
}
 8014bf6:	b005      	add	sp, #20
 8014bf8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014bfc:	4770      	bx	lr
 8014bfe:	bf00      	nop

08014c00 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8014c00:	b500      	push	{lr}
 8014c02:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8014c04:	4b0a      	ldr	r3, [pc, #40]	; (8014c30 <_tm_init+0x30>)
 8014c06:	2200      	movs	r2, #0
 8014c08:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 8014c0a:	466b      	mov	r3, sp
 8014c0c:	4618      	mov	r0, r3
 8014c0e:	f000 f817 	bl	8014c40 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8014c12:	466b      	mov	r3, sp
 8014c14:	4618      	mov	r0, r3
 8014c16:	f000 f833 	bl	8014c80 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8014c1a:	466b      	mov	r3, sp
 8014c1c:	4618      	mov	r0, r3
 8014c1e:	f000 f83f 	bl	8014ca0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8014c22:	9b02      	ldr	r3, [sp, #8]
 8014c24:	4a02      	ldr	r2, [pc, #8]	; (8014c30 <_tm_init+0x30>)
 8014c26:	6753      	str	r3, [r2, #116]	; 0x74
}
 8014c28:	b007      	add	sp, #28
 8014c2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c2e:	bf00      	nop
 8014c30:	20005ca0 	.word	0x20005ca0
	...

08014c40 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8014c40:	b410      	push	{r4}
 8014c42:	b083      	sub	sp, #12
 8014c44:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8014c46:	9b01      	ldr	r3, [sp, #4]
 8014c48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8014c4c:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8014c4e:	9b01      	ldr	r3, [sp, #4]
 8014c50:	2200      	movs	r2, #0
 8014c52:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8014c54:	9b01      	ldr	r3, [sp, #4]
 8014c56:	2200      	movs	r2, #0
 8014c58:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8014c5a:	9b01      	ldr	r3, [sp, #4]
 8014c5c:	2200      	movs	r2, #0
 8014c5e:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8014c60:	9a01      	ldr	r2, [sp, #4]
 8014c62:	f04f 0300 	mov.w	r3, #0
 8014c66:	f04f 0400 	mov.w	r4, #0
 8014c6a:	e9c2 3404 	strd	r3, r4, [r2, #16]
}
 8014c6e:	b003      	add	sp, #12
 8014c70:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014c74:	4770      	bx	lr
 8014c76:	bf00      	nop
	...

08014c80 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8014c80:	b500      	push	{lr}
 8014c82:	b083      	sub	sp, #12
 8014c84:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8014c86:	f7ff ff7b 	bl	8014b80 <port_rt_get_counter_value.lto_priv.696>
 8014c8a:	4602      	mov	r2, r0
 8014c8c:	9b01      	ldr	r3, [sp, #4]
 8014c8e:	609a      	str	r2, [r3, #8]
}
 8014c90:	b003      	add	sp, #12
 8014c92:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c96:	bf00      	nop
	...

08014ca0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8014ca0:	b500      	push	{lr}
 8014ca2:	b083      	sub	sp, #12
 8014ca4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8014ca6:	f7ff ff6b 	bl	8014b80 <port_rt_get_counter_value.lto_priv.696>
 8014caa:	4601      	mov	r1, r0
 8014cac:	4b04      	ldr	r3, [pc, #16]	; (8014cc0 <chTMStopMeasurementX+0x20>)
 8014cae:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8014cb0:	461a      	mov	r2, r3
 8014cb2:	9801      	ldr	r0, [sp, #4]
 8014cb4:	f7ff ff6c 	bl	8014b90 <tm_stop>
}
 8014cb8:	b003      	add	sp, #12
 8014cba:	f85d fb04 	ldr.w	pc, [sp], #4
 8014cbe:	bf00      	nop
 8014cc0:	20005ca0 	.word	0x20005ca0
	...

08014cd0 <port_lock.lto_priv.667>:
static inline void port_lock(void) {
 8014cd0:	b082      	sub	sp, #8
 8014cd2:	2320      	movs	r3, #32
 8014cd4:	9301      	str	r3, [sp, #4]
 8014cd6:	9b01      	ldr	r3, [sp, #4]
 8014cd8:	f383 8811 	msr	BASEPRI, r3
}
 8014cdc:	b002      	add	sp, #8
 8014cde:	4770      	bx	lr

08014ce0 <port_unlock.lto_priv.661>:
static inline void port_unlock(void) {
 8014ce0:	b082      	sub	sp, #8
 8014ce2:	2300      	movs	r3, #0
 8014ce4:	9301      	str	r3, [sp, #4]
 8014ce6:	9b01      	ldr	r3, [sp, #4]
 8014ce8:	f383 8811 	msr	BASEPRI, r3
}
 8014cec:	b002      	add	sp, #8
 8014cee:	4770      	bx	lr

08014cf0 <queue_init.lto_priv.690>:
static inline void queue_init(threads_queue_t *tqp) {
 8014cf0:	b082      	sub	sp, #8
 8014cf2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8014cf4:	9b01      	ldr	r3, [sp, #4]
 8014cf6:	9a01      	ldr	r2, [sp, #4]
 8014cf8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8014cfa:	9b01      	ldr	r3, [sp, #4]
 8014cfc:	9a01      	ldr	r2, [sp, #4]
 8014cfe:	605a      	str	r2, [r3, #4]
}
 8014d00:	b002      	add	sp, #8
 8014d02:	4770      	bx	lr
	...

08014d10 <queue_notempty.lto_priv.686>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8014d10:	b082      	sub	sp, #8
 8014d12:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8014d14:	9b01      	ldr	r3, [sp, #4]
 8014d16:	681a      	ldr	r2, [r3, #0]
 8014d18:	9b01      	ldr	r3, [sp, #4]
 8014d1a:	429a      	cmp	r2, r3
 8014d1c:	bf14      	ite	ne
 8014d1e:	2301      	movne	r3, #1
 8014d20:	2300      	moveq	r3, #0
 8014d22:	b2db      	uxtb	r3, r3
}
 8014d24:	4618      	mov	r0, r3
 8014d26:	b002      	add	sp, #8
 8014d28:	4770      	bx	lr
 8014d2a:	bf00      	nop
 8014d2c:	0000      	movs	r0, r0
	...

08014d30 <queue_prio_insert>:
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8014d30:	b084      	sub	sp, #16
 8014d32:	9001      	str	r0, [sp, #4]
 8014d34:	9100      	str	r1, [sp, #0]
  thread_t *cp = (thread_t *)tqp;
 8014d36:	9b00      	ldr	r3, [sp, #0]
 8014d38:	9303      	str	r3, [sp, #12]
    cp = cp->queue.next;
 8014d3a:	9b03      	ldr	r3, [sp, #12]
 8014d3c:	681b      	ldr	r3, [r3, #0]
 8014d3e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8014d40:	9a03      	ldr	r2, [sp, #12]
 8014d42:	9b00      	ldr	r3, [sp, #0]
 8014d44:	429a      	cmp	r2, r3
 8014d46:	d005      	beq.n	8014d54 <queue_prio_insert+0x24>
 8014d48:	9b03      	ldr	r3, [sp, #12]
 8014d4a:	689a      	ldr	r2, [r3, #8]
 8014d4c:	9b01      	ldr	r3, [sp, #4]
 8014d4e:	689b      	ldr	r3, [r3, #8]
 8014d50:	429a      	cmp	r2, r3
 8014d52:	d2f2      	bcs.n	8014d3a <queue_prio_insert+0xa>
  tp->queue.next             = cp;
 8014d54:	9b01      	ldr	r3, [sp, #4]
 8014d56:	9a03      	ldr	r2, [sp, #12]
 8014d58:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8014d5a:	9b03      	ldr	r3, [sp, #12]
 8014d5c:	685a      	ldr	r2, [r3, #4]
 8014d5e:	9b01      	ldr	r3, [sp, #4]
 8014d60:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8014d62:	9b01      	ldr	r3, [sp, #4]
 8014d64:	685b      	ldr	r3, [r3, #4]
 8014d66:	9a01      	ldr	r2, [sp, #4]
 8014d68:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8014d6a:	9b03      	ldr	r3, [sp, #12]
 8014d6c:	9a01      	ldr	r2, [sp, #4]
 8014d6e:	605a      	str	r2, [r3, #4]
}
 8014d70:	b004      	add	sp, #16
 8014d72:	4770      	bx	lr
	...

08014d80 <queue_fifo_remove.lto_priv.684>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8014d80:	b084      	sub	sp, #16
 8014d82:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8014d84:	9b01      	ldr	r3, [sp, #4]
 8014d86:	681b      	ldr	r3, [r3, #0]
 8014d88:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 8014d8a:	9b03      	ldr	r3, [sp, #12]
 8014d8c:	681a      	ldr	r2, [r3, #0]
 8014d8e:	9b01      	ldr	r3, [sp, #4]
 8014d90:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8014d92:	9b01      	ldr	r3, [sp, #4]
 8014d94:	681b      	ldr	r3, [r3, #0]
 8014d96:	9a01      	ldr	r2, [sp, #4]
 8014d98:	605a      	str	r2, [r3, #4]
  return tp;
 8014d9a:	9b03      	ldr	r3, [sp, #12]
}
 8014d9c:	4618      	mov	r0, r3
 8014d9e:	b004      	add	sp, #16
 8014da0:	4770      	bx	lr
 8014da2:	bf00      	nop
	...

08014db0 <queue_dequeue.lto_priv.680>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8014db0:	b082      	sub	sp, #8
 8014db2:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 8014db4:	9b01      	ldr	r3, [sp, #4]
 8014db6:	685b      	ldr	r3, [r3, #4]
 8014db8:	9a01      	ldr	r2, [sp, #4]
 8014dba:	6812      	ldr	r2, [r2, #0]
 8014dbc:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8014dbe:	9b01      	ldr	r3, [sp, #4]
 8014dc0:	681b      	ldr	r3, [r3, #0]
 8014dc2:	9a01      	ldr	r2, [sp, #4]
 8014dc4:	6852      	ldr	r2, [r2, #4]
 8014dc6:	605a      	str	r2, [r3, #4]
  return tp;
 8014dc8:	9b01      	ldr	r3, [sp, #4]
}
 8014dca:	4618      	mov	r0, r3
 8014dcc:	b002      	add	sp, #8
 8014dce:	4770      	bx	lr

08014dd0 <chSysLock.lto_priv.678>:
static inline void chSysLock(void) {
 8014dd0:	b508      	push	{r3, lr}
  port_lock();
 8014dd2:	f7ff ff7d 	bl	8014cd0 <port_lock.lto_priv.667>
}
 8014dd6:	bd08      	pop	{r3, pc}
	...

08014de0 <chSysUnlock.lto_priv.673>:
static inline void chSysUnlock(void) {
 8014de0:	b508      	push	{r3, lr}
  port_unlock();
 8014de2:	f7ff ff7d 	bl	8014ce0 <port_unlock.lto_priv.661>
}
 8014de6:	bd08      	pop	{r3, pc}
	...

08014df0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8014df0:	b500      	push	{lr}
 8014df2:	b083      	sub	sp, #12
 8014df4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->queue);
 8014df6:	9b01      	ldr	r3, [sp, #4]
 8014df8:	4618      	mov	r0, r3
 8014dfa:	f7ff ff89 	bl	8014d10 <queue_notempty.lto_priv.686>
 8014dfe:	4603      	mov	r3, r0
}
 8014e00:	4618      	mov	r0, r3
 8014e02:	b003      	add	sp, #12
 8014e04:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014e10 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8014e10:	b500      	push	{lr}
 8014e12:	b083      	sub	sp, #12
 8014e14:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
 8014e16:	9b01      	ldr	r3, [sp, #4]
 8014e18:	4618      	mov	r0, r3
 8014e1a:	f7ff ff69 	bl	8014cf0 <queue_init.lto_priv.690>
  mp->owner = NULL;
 8014e1e:	9b01      	ldr	r3, [sp, #4]
 8014e20:	2200      	movs	r2, #0
 8014e22:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8014e24:	b003      	add	sp, #12
 8014e26:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e2a:	bf00      	nop
 8014e2c:	0000      	movs	r0, r0
	...

08014e30 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8014e30:	b500      	push	{lr}
 8014e32:	b083      	sub	sp, #12
 8014e34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8014e36:	f7ff ffcb 	bl	8014dd0 <chSysLock.lto_priv.678>
  chMtxLockS(mp);
 8014e3a:	9801      	ldr	r0, [sp, #4]
 8014e3c:	f000 f808 	bl	8014e50 <chMtxLockS>
  chSysUnlock();
 8014e40:	f7ff ffce 	bl	8014de0 <chSysUnlock.lto_priv.673>
}
 8014e44:	b003      	add	sp, #12
 8014e46:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e4a:	bf00      	nop
 8014e4c:	0000      	movs	r0, r0
	...

08014e50 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8014e50:	b500      	push	{lr}
 8014e52:	b085      	sub	sp, #20
 8014e54:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8014e56:	4b2d      	ldr	r3, [pc, #180]	; (8014f0c <chMtxLockS+0xbc>)
 8014e58:	699b      	ldr	r3, [r3, #24]
 8014e5a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8014e5c:	9b01      	ldr	r3, [sp, #4]
 8014e5e:	689b      	ldr	r3, [r3, #8]
 8014e60:	2b00      	cmp	r3, #0
 8014e62:	d045      	beq.n	8014ef0 <chMtxLockS+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8014e64:	9b01      	ldr	r3, [sp, #4]
 8014e66:	689b      	ldr	r3, [r3, #8]
 8014e68:	9303      	str	r3, [sp, #12]
 8014e6a:	e02f      	b.n	8014ecc <chMtxLockS+0x7c>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8014e6c:	9b02      	ldr	r3, [sp, #8]
 8014e6e:	689a      	ldr	r2, [r3, #8]
 8014e70:	9b03      	ldr	r3, [sp, #12]
 8014e72:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8014e74:	9b03      	ldr	r3, [sp, #12]
 8014e76:	f893 3020 	ldrb.w	r3, [r3, #32]
 8014e7a:	2b06      	cmp	r3, #6
 8014e7c:	d004      	beq.n	8014e88 <chMtxLockS+0x38>
 8014e7e:	2b07      	cmp	r3, #7
 8014e80:	d011      	beq.n	8014ea6 <chMtxLockS+0x56>
 8014e82:	2b00      	cmp	r3, #0
 8014e84:	d01a      	beq.n	8014ebc <chMtxLockS+0x6c>
 8014e86:	e027      	b.n	8014ed8 <chMtxLockS+0x88>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8014e88:	9803      	ldr	r0, [sp, #12]
 8014e8a:	f7ff ff91 	bl	8014db0 <queue_dequeue.lto_priv.680>
 8014e8e:	4602      	mov	r2, r0
 8014e90:	9b03      	ldr	r3, [sp, #12]
 8014e92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014e94:	4619      	mov	r1, r3
 8014e96:	4610      	mov	r0, r2
 8014e98:	f7ff ff4a 	bl	8014d30 <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 8014e9c:	9b03      	ldr	r3, [sp, #12]
 8014e9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014ea0:	689b      	ldr	r3, [r3, #8]
 8014ea2:	9303      	str	r3, [sp, #12]
 8014ea4:	e012      	b.n	8014ecc <chMtxLockS+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8014ea6:	9803      	ldr	r0, [sp, #12]
 8014ea8:	f7ff ff82 	bl	8014db0 <queue_dequeue.lto_priv.680>
 8014eac:	4602      	mov	r2, r0
 8014eae:	9b03      	ldr	r3, [sp, #12]
 8014eb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014eb2:	4619      	mov	r1, r3
 8014eb4:	4610      	mov	r0, r2
 8014eb6:	f7ff ff3b 	bl	8014d30 <queue_prio_insert>
 8014eba:	e00d      	b.n	8014ed8 <chMtxLockS+0x88>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8014ebc:	9803      	ldr	r0, [sp, #12]
 8014ebe:	f7ff ff77 	bl	8014db0 <queue_dequeue.lto_priv.680>
 8014ec2:	4603      	mov	r3, r0
 8014ec4:	4618      	mov	r0, r3
 8014ec6:	f7ff fa6b 	bl	80143a0 <chSchReadyI>
 8014eca:	e005      	b.n	8014ed8 <chMtxLockS+0x88>
      while (tp->prio < ctp->prio) {
 8014ecc:	9b03      	ldr	r3, [sp, #12]
 8014ece:	689a      	ldr	r2, [r3, #8]
 8014ed0:	9b02      	ldr	r3, [sp, #8]
 8014ed2:	689b      	ldr	r3, [r3, #8]
 8014ed4:	429a      	cmp	r2, r3
 8014ed6:	d3c9      	bcc.n	8014e6c <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8014ed8:	9b01      	ldr	r3, [sp, #4]
 8014eda:	4619      	mov	r1, r3
 8014edc:	9802      	ldr	r0, [sp, #8]
 8014ede:	f7ff ff27 	bl	8014d30 <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 8014ee2:	9b02      	ldr	r3, [sp, #8]
 8014ee4:	9a01      	ldr	r2, [sp, #4]
 8014ee6:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8014ee8:	2006      	movs	r0, #6
 8014eea:	f7ff faa9 	bl	8014440 <chSchGoSleepS>
 8014eee:	e009      	b.n	8014f04 <chMtxLockS+0xb4>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8014ef0:	9b01      	ldr	r3, [sp, #4]
 8014ef2:	9a02      	ldr	r2, [sp, #8]
 8014ef4:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 8014ef6:	9b02      	ldr	r3, [sp, #8]
 8014ef8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014efa:	9b01      	ldr	r3, [sp, #4]
 8014efc:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8014efe:	9b02      	ldr	r3, [sp, #8]
 8014f00:	9a01      	ldr	r2, [sp, #4]
 8014f02:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8014f04:	b005      	add	sp, #20
 8014f06:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f0a:	bf00      	nop
 8014f0c:	20005ca0 	.word	0x20005ca0

08014f10 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8014f10:	b500      	push	{lr}
 8014f12:	b087      	sub	sp, #28
 8014f14:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8014f16:	4b26      	ldr	r3, [pc, #152]	; (8014fb0 <chMtxUnlock+0xa0>)
 8014f18:	699b      	ldr	r3, [r3, #24]
 8014f1a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 8014f1c:	f7ff ff58 	bl	8014dd0 <chSysLock.lto_priv.678>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8014f20:	9b01      	ldr	r3, [sp, #4]
 8014f22:	68da      	ldr	r2, [r3, #12]
 8014f24:	9b03      	ldr	r3, [sp, #12]
 8014f26:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8014f28:	9801      	ldr	r0, [sp, #4]
 8014f2a:	f7ff ff61 	bl	8014df0 <chMtxQueueNotEmptyS>
 8014f2e:	4603      	mov	r3, r0
 8014f30:	2b00      	cmp	r3, #0
 8014f32:	d034      	beq.n	8014f9e <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8014f34:	9b03      	ldr	r3, [sp, #12]
 8014f36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014f38:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 8014f3a:	9b03      	ldr	r3, [sp, #12]
 8014f3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014f3e:	9305      	str	r3, [sp, #20]
 8014f40:	e012      	b.n	8014f68 <chMtxUnlock+0x58>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8014f42:	9805      	ldr	r0, [sp, #20]
 8014f44:	f7ff ff54 	bl	8014df0 <chMtxQueueNotEmptyS>
 8014f48:	4603      	mov	r3, r0
 8014f4a:	2b00      	cmp	r3, #0
 8014f4c:	d009      	beq.n	8014f62 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 8014f4e:	9b05      	ldr	r3, [sp, #20]
 8014f50:	681b      	ldr	r3, [r3, #0]
 8014f52:	689a      	ldr	r2, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8014f54:	9b04      	ldr	r3, [sp, #16]
 8014f56:	429a      	cmp	r2, r3
 8014f58:	d903      	bls.n	8014f62 <chMtxUnlock+0x52>
          newprio = lmp->queue.next->prio;
 8014f5a:	9b05      	ldr	r3, [sp, #20]
 8014f5c:	681b      	ldr	r3, [r3, #0]
 8014f5e:	689b      	ldr	r3, [r3, #8]
 8014f60:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8014f62:	9b05      	ldr	r3, [sp, #20]
 8014f64:	68db      	ldr	r3, [r3, #12]
 8014f66:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8014f68:	9b05      	ldr	r3, [sp, #20]
 8014f6a:	2b00      	cmp	r3, #0
 8014f6c:	d1e9      	bne.n	8014f42 <chMtxUnlock+0x32>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8014f6e:	9b03      	ldr	r3, [sp, #12]
 8014f70:	9a04      	ldr	r2, [sp, #16]
 8014f72:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8014f74:	9b01      	ldr	r3, [sp, #4]
 8014f76:	4618      	mov	r0, r3
 8014f78:	f7ff ff02 	bl	8014d80 <queue_fifo_remove.lto_priv.684>
 8014f7c:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8014f7e:	9b01      	ldr	r3, [sp, #4]
 8014f80:	9a02      	ldr	r2, [sp, #8]
 8014f82:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8014f84:	9b02      	ldr	r3, [sp, #8]
 8014f86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014f88:	9b01      	ldr	r3, [sp, #4]
 8014f8a:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8014f8c:	9b02      	ldr	r3, [sp, #8]
 8014f8e:	9a01      	ldr	r2, [sp, #4]
 8014f90:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8014f92:	9802      	ldr	r0, [sp, #8]
 8014f94:	f7ff fa04 	bl	80143a0 <chSchReadyI>
      chSchRescheduleS();
 8014f98:	f7ff fb1a 	bl	80145d0 <chSchRescheduleS>
 8014f9c:	e002      	b.n	8014fa4 <chMtxUnlock+0x94>
    }
    else {
      mp->owner = NULL;
 8014f9e:	9b01      	ldr	r3, [sp, #4]
 8014fa0:	2200      	movs	r2, #0
 8014fa2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8014fa4:	f7ff ff1c 	bl	8014de0 <chSysUnlock.lto_priv.673>
}
 8014fa8:	b007      	add	sp, #28
 8014faa:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fae:	bf00      	nop
 8014fb0:	20005ca0 	.word	0x20005ca0
	...

08014fc0 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8014fc0:	b500      	push	{lr}
 8014fc2:	b087      	sub	sp, #28
 8014fc4:	9001      	str	r0, [sp, #4]
 8014fc6:	460b      	mov	r3, r1
 8014fc8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 8014fcc:	9b01      	ldr	r3, [sp, #4]
 8014fce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014fd0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8014fd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014fd6:	9a05      	ldr	r2, [sp, #20]
 8014fd8:	015b      	lsls	r3, r3, #5
 8014fda:	4413      	add	r3, r2
 8014fdc:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8014fe0:	681b      	ldr	r3, [r3, #0]
 8014fe2:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8014fe4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014fe8:	9a05      	ldr	r2, [sp, #20]
 8014fea:	015b      	lsls	r3, r3, #5
 8014fec:	4413      	add	r3, r2
 8014fee:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8014ff2:	9a04      	ldr	r2, [sp, #16]
 8014ff4:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8014ff6:	9b04      	ldr	r3, [sp, #16]
 8014ff8:	f003 0301 	and.w	r3, r3, #1
 8014ffc:	2b00      	cmp	r3, #0
 8014ffe:	d062      	beq.n	80150c6 <otg_epin_handler+0x106>
 8015000:	9b05      	ldr	r3, [sp, #20]
 8015002:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8015006:	f003 0301 	and.w	r3, r3, #1
 801500a:	2b00      	cmp	r3, #0
 801500c:	d05b      	beq.n	80150c6 <otg_epin_handler+0x106>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 801500e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015012:	9a01      	ldr	r2, [sp, #4]
 8015014:	3302      	adds	r3, #2
 8015016:	009b      	lsls	r3, r3, #2
 8015018:	4413      	add	r3, r2
 801501a:	685b      	ldr	r3, [r3, #4]
 801501c:	695b      	ldr	r3, [r3, #20]
 801501e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8015020:	9b03      	ldr	r3, [sp, #12]
 8015022:	681a      	ldr	r2, [r3, #0]
 8015024:	9b03      	ldr	r3, [sp, #12]
 8015026:	691b      	ldr	r3, [r3, #16]
 8015028:	429a      	cmp	r2, r3
 801502a:	d214      	bcs.n	8015056 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 801502c:	9b03      	ldr	r3, [sp, #12]
 801502e:	691a      	ldr	r2, [r3, #16]
 8015030:	9b03      	ldr	r3, [sp, #12]
 8015032:	681b      	ldr	r3, [r3, #0]
 8015034:	1ad2      	subs	r2, r2, r3
 8015036:	9b03      	ldr	r3, [sp, #12]
 8015038:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 801503a:	9b03      	ldr	r3, [sp, #12]
 801503c:	2200      	movs	r2, #0
 801503e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8015040:	f003 f916 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
      usb_lld_start_in(usbp, ep);
 8015044:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015048:	4619      	mov	r1, r3
 801504a:	9801      	ldr	r0, [sp, #4]
 801504c:	f000 fcd0 	bl	80159f0 <usb_lld_start_in>
      osalSysUnlockFromISR();
 8015050:	f003 f916 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
 8015054:	e037      	b.n	80150c6 <otg_epin_handler+0x106>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8015056:	9b01      	ldr	r3, [sp, #4]
 8015058:	891b      	ldrh	r3, [r3, #8]
 801505a:	b21a      	sxth	r2, r3
 801505c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015060:	2101      	movs	r1, #1
 8015062:	fa01 f303 	lsl.w	r3, r1, r3
 8015066:	b21b      	sxth	r3, r3
 8015068:	43db      	mvns	r3, r3
 801506a:	b21b      	sxth	r3, r3
 801506c:	4013      	ands	r3, r2
 801506e:	b21b      	sxth	r3, r3
 8015070:	b29a      	uxth	r2, r3
 8015072:	9b01      	ldr	r3, [sp, #4]
 8015074:	811a      	strh	r2, [r3, #8]
 8015076:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801507a:	9a01      	ldr	r2, [sp, #4]
 801507c:	3302      	adds	r3, #2
 801507e:	009b      	lsls	r3, r3, #2
 8015080:	4413      	add	r3, r2
 8015082:	685b      	ldr	r3, [r3, #4]
 8015084:	689b      	ldr	r3, [r3, #8]
 8015086:	2b00      	cmp	r3, #0
 8015088:	d00c      	beq.n	80150a4 <otg_epin_handler+0xe4>
 801508a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801508e:	9a01      	ldr	r2, [sp, #4]
 8015090:	3302      	adds	r3, #2
 8015092:	009b      	lsls	r3, r3, #2
 8015094:	4413      	add	r3, r2
 8015096:	685b      	ldr	r3, [r3, #4]
 8015098:	689b      	ldr	r3, [r3, #8]
 801509a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801509e:	4611      	mov	r1, r2
 80150a0:	9801      	ldr	r0, [sp, #4]
 80150a2:	4798      	blx	r3
 80150a4:	f003 f8e4 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
 80150a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150ac:	9a01      	ldr	r2, [sp, #4]
 80150ae:	3302      	adds	r3, #2
 80150b0:	009b      	lsls	r3, r3, #2
 80150b2:	4413      	add	r3, r2
 80150b4:	685b      	ldr	r3, [r3, #4]
 80150b6:	695b      	ldr	r3, [r3, #20]
 80150b8:	330c      	adds	r3, #12
 80150ba:	2100      	movs	r1, #0
 80150bc:	4618      	mov	r0, r3
 80150be:	f003 f8f7 	bl	80182b0 <osalThreadResumeI.lto_priv.759>
 80150c2:	f003 f8dd 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80150c6:	9b04      	ldr	r3, [sp, #16]
 80150c8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80150cc:	2b00      	cmp	r3, #0
 80150ce:	d010      	beq.n	80150f2 <otg_epin_handler+0x132>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 80150d0:	9b05      	ldr	r3, [sp, #20]
 80150d2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80150d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150da:	2101      	movs	r1, #1
 80150dc:	fa01 f303 	lsl.w	r3, r1, r3
 80150e0:	4013      	ands	r3, r2
  if ((epint & DIEPINT_TXFE) &&
 80150e2:	2b00      	cmp	r3, #0
 80150e4:	d005      	beq.n	80150f2 <otg_epin_handler+0x132>
    otgp->DIEPEMPMSK &= ~(1 << ep);
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
#else
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 80150e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150ea:	4619      	mov	r1, r3
 80150ec:	9801      	ldr	r0, [sp, #4]
 80150ee:	f003 fa4f 	bl	8018590 <otg_txfifo_handler.lto_priv.772>
#endif
  }
}
 80150f2:	b007      	add	sp, #28
 80150f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08015100 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8015100:	b500      	push	{lr}
 8015102:	b087      	sub	sp, #28
 8015104:	9001      	str	r0, [sp, #4]
 8015106:	460b      	mov	r3, r1
 8015108:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 801510c:	9b01      	ldr	r3, [sp, #4]
 801510e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015110:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8015112:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015116:	9a05      	ldr	r2, [sp, #20]
 8015118:	015b      	lsls	r3, r3, #5
 801511a:	4413      	add	r3, r2
 801511c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8015120:	681b      	ldr	r3, [r3, #0]
 8015122:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8015124:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015128:	9a05      	ldr	r2, [sp, #20]
 801512a:	015b      	lsls	r3, r3, #5
 801512c:	4413      	add	r3, r2
 801512e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8015132:	9a04      	ldr	r2, [sp, #16]
 8015134:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8015136:	9b04      	ldr	r3, [sp, #16]
 8015138:	f003 0308 	and.w	r3, r3, #8
 801513c:	2b00      	cmp	r3, #0
 801513e:	d013      	beq.n	8015168 <otg_epout_handler+0x68>
 8015140:	9b05      	ldr	r3, [sp, #20]
 8015142:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8015146:	f003 0308 	and.w	r3, r3, #8
 801514a:	2b00      	cmp	r3, #0
 801514c:	d00c      	beq.n	8015168 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 801514e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015152:	9a01      	ldr	r2, [sp, #4]
 8015154:	3302      	adds	r3, #2
 8015156:	009b      	lsls	r3, r3, #2
 8015158:	4413      	add	r3, r2
 801515a:	685b      	ldr	r3, [r3, #4]
 801515c:	685b      	ldr	r3, [r3, #4]
 801515e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015162:	4611      	mov	r1, r2
 8015164:	9801      	ldr	r0, [sp, #4]
 8015166:	4798      	blx	r3
  }

  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8015168:	9b04      	ldr	r3, [sp, #16]
 801516a:	f003 0301 	and.w	r3, r3, #1
 801516e:	2b00      	cmp	r3, #0
 8015170:	f000 8081 	beq.w	8015276 <otg_epout_handler+0x176>
 8015174:	9b05      	ldr	r3, [sp, #20]
 8015176:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 801517a:	f003 0301 	and.w	r3, r3, #1
 801517e:	2b00      	cmp	r3, #0
 8015180:	d079      	beq.n	8015276 <otg_epout_handler+0x176>
    USBOutEndpointState *osp;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8015182:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015186:	9a01      	ldr	r2, [sp, #4]
 8015188:	3302      	adds	r3, #2
 801518a:	009b      	lsls	r3, r3, #2
 801518c:	4413      	add	r3, r2
 801518e:	685b      	ldr	r3, [r3, #4]
 8015190:	699b      	ldr	r3, [r3, #24]
 8015192:	9303      	str	r3, [sp, #12]

    /* EP0 requires special handling.*/
    if (ep == 0) {
 8015194:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015198:	2b00      	cmp	r3, #0
 801519a:	d12b      	bne.n	80151f4 <otg_epout_handler+0xf4>
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 801519c:	9b03      	ldr	r3, [sp, #12]
 801519e:	685a      	ldr	r2, [r3, #4]
 80151a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80151a4:	9901      	ldr	r1, [sp, #4]
 80151a6:	3302      	adds	r3, #2
 80151a8:	009b      	lsls	r3, r3, #2
 80151aa:	440b      	add	r3, r1
 80151ac:	685b      	ldr	r3, [r3, #4]
 80151ae:	8a5b      	ldrh	r3, [r3, #18]
 80151b0:	fbb2 f1f3 	udiv	r1, r2, r3
 80151b4:	fb03 f301 	mul.w	r3, r3, r1
 80151b8:	1ad3      	subs	r3, r2, r3
 80151ba:	2b00      	cmp	r3, #0
 80151bc:	d11a      	bne.n	80151f4 <otg_epout_handler+0xf4>
          (osp->rxsize < osp->totsize)) {
 80151be:	9b03      	ldr	r3, [sp, #12]
 80151c0:	681a      	ldr	r2, [r3, #0]
 80151c2:	9b03      	ldr	r3, [sp, #12]
 80151c4:	691b      	ldr	r3, [r3, #16]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80151c6:	429a      	cmp	r2, r3
 80151c8:	d214      	bcs.n	80151f4 <otg_epout_handler+0xf4>
        osp->rxsize = osp->totsize - osp->rxsize;
 80151ca:	9b03      	ldr	r3, [sp, #12]
 80151cc:	691a      	ldr	r2, [r3, #16]
 80151ce:	9b03      	ldr	r3, [sp, #12]
 80151d0:	681b      	ldr	r3, [r3, #0]
 80151d2:	1ad2      	subs	r2, r2, r3
 80151d4:	9b03      	ldr	r3, [sp, #12]
 80151d6:	601a      	str	r2, [r3, #0]
        osp->rxcnt  = 0;
 80151d8:	9b03      	ldr	r3, [sp, #12]
 80151da:	2200      	movs	r2, #0
 80151dc:	605a      	str	r2, [r3, #4]
        osalSysLockFromISR();
 80151de:	f003 f847 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
        usb_lld_start_out(usbp, ep);
 80151e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80151e6:	4619      	mov	r1, r3
 80151e8:	9801      	ldr	r0, [sp, #4]
 80151ea:	f000 fb61 	bl	80158b0 <usb_lld_start_out>
        osalSysUnlockFromISR();
 80151ee:	f003 f847 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
 80151f2:	e040      	b.n	8015276 <otg_epout_handler+0x176>
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 80151f4:	9b01      	ldr	r3, [sp, #4]
 80151f6:	895b      	ldrh	r3, [r3, #10]
 80151f8:	b21a      	sxth	r2, r3
 80151fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80151fe:	2101      	movs	r1, #1
 8015200:	fa01 f303 	lsl.w	r3, r1, r3
 8015204:	b21b      	sxth	r3, r3
 8015206:	43db      	mvns	r3, r3
 8015208:	b21b      	sxth	r3, r3
 801520a:	4013      	ands	r3, r2
 801520c:	b21b      	sxth	r3, r3
 801520e:	b29a      	uxth	r2, r3
 8015210:	9b01      	ldr	r3, [sp, #4]
 8015212:	815a      	strh	r2, [r3, #10]
 8015214:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015218:	9a01      	ldr	r2, [sp, #4]
 801521a:	3302      	adds	r3, #2
 801521c:	009b      	lsls	r3, r3, #2
 801521e:	4413      	add	r3, r2
 8015220:	685b      	ldr	r3, [r3, #4]
 8015222:	68db      	ldr	r3, [r3, #12]
 8015224:	2b00      	cmp	r3, #0
 8015226:	d00c      	beq.n	8015242 <otg_epout_handler+0x142>
 8015228:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801522c:	9a01      	ldr	r2, [sp, #4]
 801522e:	3302      	adds	r3, #2
 8015230:	009b      	lsls	r3, r3, #2
 8015232:	4413      	add	r3, r2
 8015234:	685b      	ldr	r3, [r3, #4]
 8015236:	68db      	ldr	r3, [r3, #12]
 8015238:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801523c:	4611      	mov	r1, r2
 801523e:	9801      	ldr	r0, [sp, #4]
 8015240:	4798      	blx	r3
 8015242:	f003 f815 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
 8015246:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801524a:	9a01      	ldr	r2, [sp, #4]
 801524c:	3302      	adds	r3, #2
 801524e:	009b      	lsls	r3, r3, #2
 8015250:	4413      	add	r3, r2
 8015252:	685b      	ldr	r3, [r3, #4]
 8015254:	699b      	ldr	r3, [r3, #24]
 8015256:	f103 000c 	add.w	r0, r3, #12
 801525a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801525e:	9a01      	ldr	r2, [sp, #4]
 8015260:	3302      	adds	r3, #2
 8015262:	009b      	lsls	r3, r3, #2
 8015264:	4413      	add	r3, r2
 8015266:	685b      	ldr	r3, [r3, #4]
 8015268:	699b      	ldr	r3, [r3, #24]
 801526a:	685b      	ldr	r3, [r3, #4]
 801526c:	4619      	mov	r1, r3
 801526e:	f003 f81f 	bl	80182b0 <osalThreadResumeI.lto_priv.759>
 8015272:	f003 f805 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
  }
}
 8015276:	b007      	add	sp, #28
 8015278:	f85d fb04 	ldr.w	pc, [sp], #4
 801527c:	0000      	movs	r0, r0
	...

08015280 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8015280:	b500      	push	{lr}
 8015282:	b085      	sub	sp, #20
 8015284:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8015286:	9b01      	ldr	r3, [sp, #4]
 8015288:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801528a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 801528c:	2300      	movs	r3, #0
 801528e:	f88d 300f 	strb.w	r3, [sp, #15]
 8015292:	e076      	b.n	8015382 <otg_isoc_in_failed_handler+0x102>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8015294:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015298:	9a02      	ldr	r2, [sp, #8]
 801529a:	3348      	adds	r3, #72	; 0x48
 801529c:	015b      	lsls	r3, r3, #5
 801529e:	4413      	add	r3, r2
 80152a0:	681b      	ldr	r3, [r3, #0]
 80152a2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80152a6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80152aa:	d165      	bne.n	8015378 <otg_isoc_in_failed_handler+0xf8>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 80152ac:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80152b0:	9a02      	ldr	r2, [sp, #8]
 80152b2:	3348      	adds	r3, #72	; 0x48
 80152b4:	015b      	lsls	r3, r3, #5
 80152b6:	4413      	add	r3, r2
 80152b8:	681b      	ldr	r3, [r3, #0]
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80152ba:	2b00      	cmp	r3, #0
 80152bc:	da5c      	bge.n	8015378 <otg_isoc_in_failed_handler+0xf8>
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 80152be:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80152c2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80152c6:	9902      	ldr	r1, [sp, #8]
 80152c8:	3248      	adds	r2, #72	; 0x48
 80152ca:	0152      	lsls	r2, r2, #5
 80152cc:	440a      	add	r2, r1
 80152ce:	6812      	ldr	r2, [r2, #0]
 80152d0:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 80152d4:	9902      	ldr	r1, [sp, #8]
 80152d6:	3348      	adds	r3, #72	; 0x48
 80152d8:	015b      	lsls	r3, r3, #5
 80152da:	440b      	add	r3, r1
 80152dc:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 80152de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80152e2:	9a02      	ldr	r2, [sp, #8]
 80152e4:	3348      	adds	r3, #72	; 0x48
 80152e6:	015b      	lsls	r3, r3, #5
 80152e8:	4413      	add	r3, r2
 80152ea:	681b      	ldr	r3, [r3, #0]
 80152ec:	2b00      	cmp	r3, #0
 80152ee:	dbf6      	blt.n	80152de <otg_isoc_in_failed_handler+0x5e>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 80152f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80152f4:	4619      	mov	r1, r3
 80152f6:	9801      	ldr	r0, [sp, #4]
 80152f8:	f003 f84a 	bl	8018390 <otg_txfifo_flush.lto_priv.767>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 80152fc:	9b01      	ldr	r3, [sp, #4]
 80152fe:	891b      	ldrh	r3, [r3, #8]
 8015300:	b21a      	sxth	r2, r3
 8015302:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015306:	2101      	movs	r1, #1
 8015308:	fa01 f303 	lsl.w	r3, r1, r3
 801530c:	b21b      	sxth	r3, r3
 801530e:	43db      	mvns	r3, r3
 8015310:	b21b      	sxth	r3, r3
 8015312:	4013      	ands	r3, r2
 8015314:	b21b      	sxth	r3, r3
 8015316:	b29a      	uxth	r2, r3
 8015318:	9b01      	ldr	r3, [sp, #4]
 801531a:	811a      	strh	r2, [r3, #8]
 801531c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015320:	9a01      	ldr	r2, [sp, #4]
 8015322:	3302      	adds	r3, #2
 8015324:	009b      	lsls	r3, r3, #2
 8015326:	4413      	add	r3, r2
 8015328:	685b      	ldr	r3, [r3, #4]
 801532a:	689b      	ldr	r3, [r3, #8]
 801532c:	2b00      	cmp	r3, #0
 801532e:	d00c      	beq.n	801534a <otg_isoc_in_failed_handler+0xca>
 8015330:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015334:	9a01      	ldr	r2, [sp, #4]
 8015336:	3302      	adds	r3, #2
 8015338:	009b      	lsls	r3, r3, #2
 801533a:	4413      	add	r3, r2
 801533c:	685b      	ldr	r3, [r3, #4]
 801533e:	689b      	ldr	r3, [r3, #8]
 8015340:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015344:	4611      	mov	r1, r2
 8015346:	9801      	ldr	r0, [sp, #4]
 8015348:	4798      	blx	r3
 801534a:	f002 ff91 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
 801534e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015352:	9a01      	ldr	r2, [sp, #4]
 8015354:	3302      	adds	r3, #2
 8015356:	009b      	lsls	r3, r3, #2
 8015358:	4413      	add	r3, r2
 801535a:	685b      	ldr	r3, [r3, #4]
 801535c:	695b      	ldr	r3, [r3, #20]
 801535e:	330c      	adds	r3, #12
 8015360:	2100      	movs	r1, #0
 8015362:	4618      	mov	r0, r3
 8015364:	f002 ffa4 	bl	80182b0 <osalThreadResumeI.lto_priv.759>
 8015368:	f002 ff8a 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
#else
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 801536c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015370:	4619      	mov	r1, r3
 8015372:	9801      	ldr	r0, [sp, #4]
 8015374:	f003 f90c 	bl	8018590 <otg_txfifo_handler.lto_priv.772>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8015378:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801537c:	3301      	adds	r3, #1
 801537e:	f88d 300f 	strb.w	r3, [sp, #15]
 8015382:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015386:	9b01      	ldr	r3, [sp, #4]
 8015388:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801538a:	689b      	ldr	r3, [r3, #8]
 801538c:	429a      	cmp	r2, r3
 801538e:	d981      	bls.n	8015294 <otg_isoc_in_failed_handler+0x14>
#endif
    }
  }
}
 8015390:	b005      	add	sp, #20
 8015392:	f85d fb04 	ldr.w	pc, [sp], #4
 8015396:	bf00      	nop
	...

080153a0 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 80153a0:	b500      	push	{lr}
 80153a2:	b085      	sub	sp, #20
 80153a4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80153a6:	9b01      	ldr	r3, [sp, #4]
 80153a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80153aa:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80153ac:	2300      	movs	r3, #0
 80153ae:	f88d 300f 	strb.w	r3, [sp, #15]
 80153b2:	e05a      	b.n	801546a <otg_isoc_out_failed_handler+0xca>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80153b4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80153b8:	9a02      	ldr	r2, [sp, #8]
 80153ba:	3358      	adds	r3, #88	; 0x58
 80153bc:	015b      	lsls	r3, r3, #5
 80153be:	4413      	add	r3, r2
 80153c0:	681b      	ldr	r3, [r3, #0]
 80153c2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80153c6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80153ca:	d149      	bne.n	8015460 <otg_isoc_out_failed_handler+0xc0>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 80153cc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80153d0:	9a02      	ldr	r2, [sp, #8]
 80153d2:	3358      	adds	r3, #88	; 0x58
 80153d4:	015b      	lsls	r3, r3, #5
 80153d6:	4413      	add	r3, r2
 80153d8:	681b      	ldr	r3, [r3, #0]
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80153da:	2b00      	cmp	r3, #0
 80153dc:	da40      	bge.n	8015460 <otg_isoc_out_failed_handler+0xc0>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 80153de:	9b01      	ldr	r3, [sp, #4]
 80153e0:	895b      	ldrh	r3, [r3, #10]
 80153e2:	b21a      	sxth	r2, r3
 80153e4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80153e8:	2101      	movs	r1, #1
 80153ea:	fa01 f303 	lsl.w	r3, r1, r3
 80153ee:	b21b      	sxth	r3, r3
 80153f0:	43db      	mvns	r3, r3
 80153f2:	b21b      	sxth	r3, r3
 80153f4:	4013      	ands	r3, r2
 80153f6:	b21b      	sxth	r3, r3
 80153f8:	b29a      	uxth	r2, r3
 80153fa:	9b01      	ldr	r3, [sp, #4]
 80153fc:	815a      	strh	r2, [r3, #10]
 80153fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015402:	9a01      	ldr	r2, [sp, #4]
 8015404:	3302      	adds	r3, #2
 8015406:	009b      	lsls	r3, r3, #2
 8015408:	4413      	add	r3, r2
 801540a:	685b      	ldr	r3, [r3, #4]
 801540c:	68db      	ldr	r3, [r3, #12]
 801540e:	2b00      	cmp	r3, #0
 8015410:	d00c      	beq.n	801542c <otg_isoc_out_failed_handler+0x8c>
 8015412:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015416:	9a01      	ldr	r2, [sp, #4]
 8015418:	3302      	adds	r3, #2
 801541a:	009b      	lsls	r3, r3, #2
 801541c:	4413      	add	r3, r2
 801541e:	685b      	ldr	r3, [r3, #4]
 8015420:	68db      	ldr	r3, [r3, #12]
 8015422:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015426:	4611      	mov	r1, r2
 8015428:	9801      	ldr	r0, [sp, #4]
 801542a:	4798      	blx	r3
 801542c:	f002 ff20 	bl	8018270 <osalSysLockFromISR.lto_priv.747>
 8015430:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015434:	9a01      	ldr	r2, [sp, #4]
 8015436:	3302      	adds	r3, #2
 8015438:	009b      	lsls	r3, r3, #2
 801543a:	4413      	add	r3, r2
 801543c:	685b      	ldr	r3, [r3, #4]
 801543e:	699b      	ldr	r3, [r3, #24]
 8015440:	f103 000c 	add.w	r0, r3, #12
 8015444:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015448:	9a01      	ldr	r2, [sp, #4]
 801544a:	3302      	adds	r3, #2
 801544c:	009b      	lsls	r3, r3, #2
 801544e:	4413      	add	r3, r2
 8015450:	685b      	ldr	r3, [r3, #4]
 8015452:	699b      	ldr	r3, [r3, #24]
 8015454:	685b      	ldr	r3, [r3, #4]
 8015456:	4619      	mov	r1, r3
 8015458:	f002 ff2a 	bl	80182b0 <osalThreadResumeI.lto_priv.759>
 801545c:	f002 ff10 	bl	8018280 <osalSysUnlockFromISR.lto_priv.743>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8015460:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015464:	3301      	adds	r3, #1
 8015466:	f88d 300f 	strb.w	r3, [sp, #15]
 801546a:	f89d 200f 	ldrb.w	r2, [sp, #15]
 801546e:	9b01      	ldr	r3, [sp, #4]
 8015470:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8015472:	689b      	ldr	r3, [r3, #8]
 8015474:	429a      	cmp	r2, r3
 8015476:	d99d      	bls.n	80153b4 <otg_isoc_out_failed_handler+0x14>
    }
  }
}
 8015478:	b005      	add	sp, #20
 801547a:	f85d fb04 	ldr.w	pc, [sp], #4
 801547e:	bf00      	nop

08015480 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8015480:	b500      	push	{lr}
 8015482:	b087      	sub	sp, #28
 8015484:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8015486:	9b01      	ldr	r3, [sp, #4]
 8015488:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801548a:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 801548c:	9b05      	ldr	r3, [sp, #20]
 801548e:	695b      	ldr	r3, [r3, #20]
 8015490:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8015492:	9b05      	ldr	r3, [sp, #20]
 8015494:	699b      	ldr	r3, [r3, #24]
 8015496:	9a04      	ldr	r2, [sp, #16]
 8015498:	4013      	ands	r3, r2
 801549a:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 801549c:	9b05      	ldr	r3, [sp, #20]
 801549e:	9a04      	ldr	r2, [sp, #16]
 80154a0:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80154a2:	9b04      	ldr	r3, [sp, #16]
 80154a4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80154a8:	2b00      	cmp	r3, #0
 80154aa:	d003      	beq.n	80154b4 <usb_lld_serve_interrupt+0x34>
#if 0
    /* Resetting pending operations.*/
    usbp->txpending = 0;
#endif
    /* Default reset action.*/
    _usb_reset(usbp);
 80154ac:	9801      	ldr	r0, [sp, #4]
 80154ae:	f003 feef 	bl	8019290 <_usb_reset>
 80154b2:	e0be      	b.n	8015632 <usb_lld_serve_interrupt+0x1b2>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 80154b4:	9b04      	ldr	r3, [sp, #16]
 80154b6:	2b00      	cmp	r3, #0
 80154b8:	da19      	bge.n	80154ee <usb_lld_serve_interrupt+0x6e>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 80154ba:	9b05      	ldr	r3, [sp, #20]
 80154bc:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 80154c0:	f003 0303 	and.w	r3, r3, #3
 80154c4:	2b00      	cmp	r3, #0
 80154c6:	d007      	beq.n	80154d8 <usb_lld_serve_interrupt+0x58>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 80154c8:	9b05      	ldr	r3, [sp, #20]
 80154ca:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 80154ce:	f023 0203 	bic.w	r2, r3, #3
 80154d2:	9b05      	ldr	r3, [sp, #20]
 80154d4:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL &= ~DCTL_RWUSIG;
 80154d8:	9b05      	ldr	r3, [sp, #20]
 80154da:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 80154de:	f023 0201 	bic.w	r2, r3, #1
 80154e2:	9b05      	ldr	r3, [sp, #20]
 80154e4:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 80154e8:	9801      	ldr	r0, [sp, #4]
 80154ea:	f003 ffa9 	bl	8019440 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 80154ee:	9b04      	ldr	r3, [sp, #16]
 80154f0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80154f4:	2b00      	cmp	r3, #0
 80154f6:	d002      	beq.n	80154fe <usb_lld_serve_interrupt+0x7e>
#if 0
    /* Resetting pending operations.*/
    usbp->txpending = 0;
#endif
    /* Default suspend action.*/
    _usb_suspend(usbp);
 80154f8:	9801      	ldr	r0, [sp, #4]
 80154fa:	f003 ff41 	bl	8019380 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 80154fe:	9b04      	ldr	r3, [sp, #16]
 8015500:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8015504:	2b00      	cmp	r3, #0
 8015506:	d017      	beq.n	8015538 <usb_lld_serve_interrupt+0xb8>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8015508:	9b05      	ldr	r3, [sp, #20]
 801550a:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 801550e:	f003 0306 	and.w	r3, r3, #6
 8015512:	2b00      	cmp	r3, #0
 8015514:	d108      	bne.n	8015528 <usb_lld_serve_interrupt+0xa8>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8015516:	9b05      	ldr	r3, [sp, #20]
 8015518:	68db      	ldr	r3, [r3, #12]
 801551a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 801551e:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8015522:	9b05      	ldr	r3, [sp, #20]
 8015524:	60da      	str	r2, [r3, #12]
 8015526:	e007      	b.n	8015538 <usb_lld_serve_interrupt+0xb8>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8015528:	9b05      	ldr	r3, [sp, #20]
 801552a:	68db      	ldr	r3, [r3, #12]
 801552c:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8015530:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8015534:	9b05      	ldr	r3, [sp, #20]
 8015536:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8015538:	9b04      	ldr	r3, [sp, #16]
 801553a:	f003 0308 	and.w	r3, r3, #8
 801553e:	2b00      	cmp	r3, #0
 8015540:	d009      	beq.n	8015556 <usb_lld_serve_interrupt+0xd6>
    _usb_isr_invoke_sof_cb(usbp);
 8015542:	9b01      	ldr	r3, [sp, #4]
 8015544:	685b      	ldr	r3, [r3, #4]
 8015546:	68db      	ldr	r3, [r3, #12]
 8015548:	2b00      	cmp	r3, #0
 801554a:	d004      	beq.n	8015556 <usb_lld_serve_interrupt+0xd6>
 801554c:	9b01      	ldr	r3, [sp, #4]
 801554e:	685b      	ldr	r3, [r3, #4]
 8015550:	68db      	ldr	r3, [r3, #12]
 8015552:	9801      	ldr	r0, [sp, #4]
 8015554:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8015556:	9b04      	ldr	r3, [sp, #16]
 8015558:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 801555c:	2b00      	cmp	r3, #0
 801555e:	d002      	beq.n	8015566 <usb_lld_serve_interrupt+0xe6>
    otg_isoc_in_failed_handler(usbp);
 8015560:	9801      	ldr	r0, [sp, #4]
 8015562:	f7ff fe8d 	bl	8015280 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8015566:	9b04      	ldr	r3, [sp, #16]
 8015568:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 801556c:	2b00      	cmp	r3, #0
 801556e:	d002      	beq.n	8015576 <usb_lld_serve_interrupt+0xf6>
    otg_isoc_out_failed_handler(usbp);
 8015570:	9801      	ldr	r0, [sp, #4]
 8015572:	f7ff ff15 	bl	80153a0 <otg_isoc_out_failed_handler>
    osalSysUnlockFromISR();
  }
#else
  /* Performing the whole FIFO emptying in the ISR, it is advised to keep
     this IRQ at a very low priority level.*/
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8015576:	9b04      	ldr	r3, [sp, #16]
 8015578:	f003 0310 	and.w	r3, r3, #16
 801557c:	2b00      	cmp	r3, #0
 801557e:	d002      	beq.n	8015586 <usb_lld_serve_interrupt+0x106>
    otg_rxfifo_handler(usbp);
 8015580:	9801      	ldr	r0, [sp, #4]
 8015582:	f002 ff85 	bl	8018490 <otg_rxfifo_handler.lto_priv.771>
  }
#endif

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8015586:	9b05      	ldr	r3, [sp, #20]
 8015588:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 801558c:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_OEPINT) {
 801558e:	9b04      	ldr	r3, [sp, #16]
 8015590:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8015594:	2b00      	cmp	r3, #0
 8015596:	d023      	beq.n	80155e0 <usb_lld_serve_interrupt+0x160>
    if (src & (1 << 16))
 8015598:	9b03      	ldr	r3, [sp, #12]
 801559a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801559e:	2b00      	cmp	r3, #0
 80155a0:	d003      	beq.n	80155aa <usb_lld_serve_interrupt+0x12a>
      otg_epout_handler(usbp, 0);
 80155a2:	2100      	movs	r1, #0
 80155a4:	9801      	ldr	r0, [sp, #4]
 80155a6:	f7ff fdab 	bl	8015100 <otg_epout_handler>
    if (src & (1 << 17))
 80155aa:	9b03      	ldr	r3, [sp, #12]
 80155ac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80155b0:	2b00      	cmp	r3, #0
 80155b2:	d003      	beq.n	80155bc <usb_lld_serve_interrupt+0x13c>
      otg_epout_handler(usbp, 1);
 80155b4:	2101      	movs	r1, #1
 80155b6:	9801      	ldr	r0, [sp, #4]
 80155b8:	f7ff fda2 	bl	8015100 <otg_epout_handler>
    if (src & (1 << 18))
 80155bc:	9b03      	ldr	r3, [sp, #12]
 80155be:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80155c2:	2b00      	cmp	r3, #0
 80155c4:	d003      	beq.n	80155ce <usb_lld_serve_interrupt+0x14e>
      otg_epout_handler(usbp, 2);
 80155c6:	2102      	movs	r1, #2
 80155c8:	9801      	ldr	r0, [sp, #4]
 80155ca:	f7ff fd99 	bl	8015100 <otg_epout_handler>
    if (src & (1 << 19))
 80155ce:	9b03      	ldr	r3, [sp, #12]
 80155d0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80155d4:	2b00      	cmp	r3, #0
 80155d6:	d003      	beq.n	80155e0 <usb_lld_serve_interrupt+0x160>
      otg_epout_handler(usbp, 3);
 80155d8:	2103      	movs	r1, #3
 80155da:	9801      	ldr	r0, [sp, #4]
 80155dc:	f7ff fd90 	bl	8015100 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 80155e0:	9b04      	ldr	r3, [sp, #16]
 80155e2:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80155e6:	2b00      	cmp	r3, #0
 80155e8:	d023      	beq.n	8015632 <usb_lld_serve_interrupt+0x1b2>
    if (src & (1 << 0))
 80155ea:	9b03      	ldr	r3, [sp, #12]
 80155ec:	f003 0301 	and.w	r3, r3, #1
 80155f0:	2b00      	cmp	r3, #0
 80155f2:	d003      	beq.n	80155fc <usb_lld_serve_interrupt+0x17c>
      otg_epin_handler(usbp, 0);
 80155f4:	2100      	movs	r1, #0
 80155f6:	9801      	ldr	r0, [sp, #4]
 80155f8:	f7ff fce2 	bl	8014fc0 <otg_epin_handler>
    if (src & (1 << 1))
 80155fc:	9b03      	ldr	r3, [sp, #12]
 80155fe:	f003 0302 	and.w	r3, r3, #2
 8015602:	2b00      	cmp	r3, #0
 8015604:	d003      	beq.n	801560e <usb_lld_serve_interrupt+0x18e>
      otg_epin_handler(usbp, 1);
 8015606:	2101      	movs	r1, #1
 8015608:	9801      	ldr	r0, [sp, #4]
 801560a:	f7ff fcd9 	bl	8014fc0 <otg_epin_handler>
    if (src & (1 << 2))
 801560e:	9b03      	ldr	r3, [sp, #12]
 8015610:	f003 0304 	and.w	r3, r3, #4
 8015614:	2b00      	cmp	r3, #0
 8015616:	d003      	beq.n	8015620 <usb_lld_serve_interrupt+0x1a0>
      otg_epin_handler(usbp, 2);
 8015618:	2102      	movs	r1, #2
 801561a:	9801      	ldr	r0, [sp, #4]
 801561c:	f7ff fcd0 	bl	8014fc0 <otg_epin_handler>
    if (src & (1 << 3))
 8015620:	9b03      	ldr	r3, [sp, #12]
 8015622:	f003 0308 	and.w	r3, r3, #8
 8015626:	2b00      	cmp	r3, #0
 8015628:	d003      	beq.n	8015632 <usb_lld_serve_interrupt+0x1b2>
      otg_epin_handler(usbp, 3);
 801562a:	2103      	movs	r1, #3
 801562c:	9801      	ldr	r0, [sp, #4]
 801562e:	f7ff fcc7 	bl	8014fc0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 8015632:	b007      	add	sp, #28
 8015634:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08015640 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8015640:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8015642:	4803      	ldr	r0, [pc, #12]	; (8015650 <Vector14C+0x10>)
 8015644:	f7ff ff1c 	bl	8015480 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8015648:	f7fe f822 	bl	8013690 <_port_irq_epilogue>
}
 801564c:	bd08      	pop	{r3, pc}
 801564e:	bf00      	nop
 8015650:	2000501c 	.word	0x2000501c
	...

08015660 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8015660:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8015662:	4805      	ldr	r0, [pc, #20]	; (8015678 <usb_lld_init+0x18>)
 8015664:	f003 fd1c 	bl	80190a0 <usbObjectInit>
#if 0
  USBD1.wait      = NULL;
#endif
  USBD1.otg       = OTG_FS;
 8015668:	4b03      	ldr	r3, [pc, #12]	; (8015678 <usb_lld_init+0x18>)
 801566a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 801566e:	655a      	str	r2, [r3, #84]	; 0x54
  USBD1.otgparams = &fsparams;
 8015670:	4b01      	ldr	r3, [pc, #4]	; (8015678 <usb_lld_init+0x18>)
 8015672:	4a02      	ldr	r2, [pc, #8]	; (801567c <usb_lld_init+0x1c>)
 8015674:	659a      	str	r2, [r3, #88]	; 0x58
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
#endif
}
 8015676:	bd08      	pop	{r3, pc}
 8015678:	2000501c 	.word	0x2000501c
 801567c:	080230d4 	.word	0x080230d4

08015680 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8015680:	b510      	push	{r4, lr}
 8015682:	b084      	sub	sp, #16
 8015684:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8015686:	9b01      	ldr	r3, [sp, #4]
 8015688:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801568a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 801568c:	2100      	movs	r1, #0
 801568e:	9801      	ldr	r0, [sp, #4]
 8015690:	f002 fe7e 	bl	8018390 <otg_txfifo_flush.lto_priv.767>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8015694:	9b02      	ldr	r3, [sp, #8]
 8015696:	2200      	movs	r2, #0
 8015698:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 801569c:	9b02      	ldr	r3, [sp, #8]
 801569e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80156a2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80156a6:	2300      	movs	r3, #0
 80156a8:	9303      	str	r3, [sp, #12]
 80156aa:	e024      	b.n	80156f6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80156ac:	9a02      	ldr	r2, [sp, #8]
 80156ae:	9b03      	ldr	r3, [sp, #12]
 80156b0:	3348      	adds	r3, #72	; 0x48
 80156b2:	015b      	lsls	r3, r3, #5
 80156b4:	4413      	add	r3, r2
 80156b6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80156ba:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80156bc:	9a02      	ldr	r2, [sp, #8]
 80156be:	9b03      	ldr	r3, [sp, #12]
 80156c0:	3358      	adds	r3, #88	; 0x58
 80156c2:	015b      	lsls	r3, r3, #5
 80156c4:	4413      	add	r3, r2
 80156c6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80156ca:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80156cc:	9a02      	ldr	r2, [sp, #8]
 80156ce:	9b03      	ldr	r3, [sp, #12]
 80156d0:	015b      	lsls	r3, r3, #5
 80156d2:	4413      	add	r3, r2
 80156d4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80156d8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80156dc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80156de:	9a02      	ldr	r2, [sp, #8]
 80156e0:	9b03      	ldr	r3, [sp, #12]
 80156e2:	015b      	lsls	r3, r3, #5
 80156e4:	4413      	add	r3, r2
 80156e6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80156ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80156ee:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80156f0:	9b03      	ldr	r3, [sp, #12]
 80156f2:	3301      	adds	r3, #1
 80156f4:	9303      	str	r3, [sp, #12]
 80156f6:	9b01      	ldr	r3, [sp, #4]
 80156f8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80156fa:	689a      	ldr	r2, [r3, #8]
 80156fc:	9b03      	ldr	r3, [sp, #12]
 80156fe:	429a      	cmp	r2, r3
 8015700:	d2d4      	bcs.n	80156ac <usb_lld_reset+0x2c>
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8015702:	9801      	ldr	r0, [sp, #4]
 8015704:	f002 fe64 	bl	80183d0 <otg_ram_reset.lto_priv.766>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8015708:	9b01      	ldr	r3, [sp, #4]
 801570a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801570c:	681a      	ldr	r2, [r3, #0]
 801570e:	9b02      	ldr	r3, [sp, #8]
 8015710:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8015712:	9801      	ldr	r0, [sp, #4]
 8015714:	f002 fe24 	bl	8018360 <otg_rxfifo_flush.lto_priv.769>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8015718:	9b02      	ldr	r3, [sp, #8]
 801571a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 801571e:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8015722:	9b02      	ldr	r3, [sp, #8]
 8015724:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8015728:	9b02      	ldr	r3, [sp, #8]
 801572a:	699b      	ldr	r3, [r3, #24]
 801572c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8015730:	f043 0310 	orr.w	r3, r3, #16
 8015734:	9a02      	ldr	r2, [sp, #8]
 8015736:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8015738:	9b02      	ldr	r3, [sp, #8]
 801573a:	2209      	movs	r2, #9
 801573c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8015740:	9b02      	ldr	r3, [sp, #8]
 8015742:	2209      	movs	r2, #9
 8015744:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8015748:	9b01      	ldr	r3, [sp, #4]
 801574a:	4a17      	ldr	r2, [pc, #92]	; (80157a8 <usb_lld_reset+0x128>)
 801574c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 801574e:	9b02      	ldr	r3, [sp, #8]
 8015750:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 8015754:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8015758:	2340      	movs	r3, #64	; 0x40
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 801575a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801575e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8015762:	9a02      	ldr	r2, [sp, #8]
 8015764:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8015768:	9b02      	ldr	r3, [sp, #8]
 801576a:	2200      	movs	r2, #0
 801576c:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 8015770:	2340      	movs	r3, #64	; 0x40
 8015772:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8015776:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 801577a:	9a02      	ldr	r2, [sp, #8]
 801577c:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8015780:	2340      	movs	r3, #64	; 0x40
 8015782:	089b      	lsrs	r3, r3, #2
 8015784:	b29b      	uxth	r3, r3
 8015786:	041b      	lsls	r3, r3, #16
 8015788:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 801578a:	2340      	movs	r3, #64	; 0x40
 801578c:	089b      	lsrs	r3, r3, #2
 801578e:	b29b      	uxth	r3, r3
 8015790:	4619      	mov	r1, r3
 8015792:	9801      	ldr	r0, [sp, #4]
 8015794:	f002 fe2c 	bl	80183f0 <otg_ram_alloc.lto_priv.768>
 8015798:	4603      	mov	r3, r0
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 801579a:	ea44 0203 	orr.w	r2, r4, r3
 801579e:	9b02      	ldr	r3, [sp, #8]
 80157a0:	629a      	str	r2, [r3, #40]	; 0x28
                                                  ep0config.in_maxsize / 4));
}
 80157a2:	b004      	add	sp, #16
 80157a4:	bd10      	pop	{r4, pc}
 80157a6:	bf00      	nop
 80157a8:	080230b0 	.word	0x080230b0
 80157ac:	00000000 	.word	0x00000000

080157b0 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 80157b0:	b084      	sub	sp, #16
 80157b2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80157b4:	9b01      	ldr	r3, [sp, #4]
 80157b6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80157b8:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80157ba:	9b03      	ldr	r3, [sp, #12]
 80157bc:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80157c0:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80157c4:	9a01      	ldr	r2, [sp, #4]
 80157c6:	f892 204e 	ldrb.w	r2, [r2, #78]	; 0x4e
 80157ca:	0112      	lsls	r2, r2, #4
 80157cc:	431a      	orrs	r2, r3
 80157ce:	9b03      	ldr	r3, [sp, #12]
 80157d0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 80157d4:	b004      	add	sp, #16
 80157d6:	4770      	bx	lr
	...

080157e0 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 80157e0:	b500      	push	{lr}
 80157e2:	b083      	sub	sp, #12
 80157e4:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80157e6:	9801      	ldr	r0, [sp, #4]
 80157e8:	f002 fdf2 	bl	80183d0 <otg_ram_reset.lto_priv.766>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 80157ec:	9801      	ldr	r0, [sp, #4]
 80157ee:	f002 fd6f 	bl	80182d0 <otg_disable_ep.lto_priv.765>
}
 80157f2:	b003      	add	sp, #12
 80157f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08015800 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8015800:	b084      	sub	sp, #16
 8015802:	9001      	str	r0, [sp, #4]
 8015804:	460b      	mov	r3, r1
 8015806:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 801580a:	9b01      	ldr	r3, [sp, #4]
 801580c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801580e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015812:	3358      	adds	r3, #88	; 0x58
 8015814:	015b      	lsls	r3, r3, #5
 8015816:	4413      	add	r3, r2
 8015818:	681b      	ldr	r3, [r3, #0]
 801581a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 801581c:	9b03      	ldr	r3, [sp, #12]
 801581e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8015822:	2b00      	cmp	r3, #0
 8015824:	d101      	bne.n	801582a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8015826:	2300      	movs	r3, #0
 8015828:	e007      	b.n	801583a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 801582a:	9b03      	ldr	r3, [sp, #12]
 801582c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8015830:	2b00      	cmp	r3, #0
 8015832:	d001      	beq.n	8015838 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8015834:	2301      	movs	r3, #1
 8015836:	e000      	b.n	801583a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8015838:	2302      	movs	r3, #2
}
 801583a:	4618      	mov	r0, r3
 801583c:	b004      	add	sp, #16
 801583e:	4770      	bx	lr

08015840 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8015840:	b084      	sub	sp, #16
 8015842:	9001      	str	r0, [sp, #4]
 8015844:	460b      	mov	r3, r1
 8015846:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 801584a:	9b01      	ldr	r3, [sp, #4]
 801584c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801584e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015852:	3348      	adds	r3, #72	; 0x48
 8015854:	015b      	lsls	r3, r3, #5
 8015856:	4413      	add	r3, r2
 8015858:	681b      	ldr	r3, [r3, #0]
 801585a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 801585c:	9b03      	ldr	r3, [sp, #12]
 801585e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8015862:	2b00      	cmp	r3, #0
 8015864:	d101      	bne.n	801586a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 8015866:	2300      	movs	r3, #0
 8015868:	e007      	b.n	801587a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 801586a:	9b03      	ldr	r3, [sp, #12]
 801586c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8015870:	2b00      	cmp	r3, #0
 8015872:	d001      	beq.n	8015878 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 8015874:	2301      	movs	r3, #1
 8015876:	e000      	b.n	801587a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 8015878:	2302      	movs	r3, #2
}
 801587a:	4618      	mov	r0, r3
 801587c:	b004      	add	sp, #16
 801587e:	4770      	bx	lr

08015880 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8015880:	b500      	push	{lr}
 8015882:	b085      	sub	sp, #20
 8015884:	9003      	str	r0, [sp, #12]
 8015886:	460b      	mov	r3, r1
 8015888:	9201      	str	r2, [sp, #4]
 801588a:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 801588e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8015892:	9a03      	ldr	r2, [sp, #12]
 8015894:	3302      	adds	r3, #2
 8015896:	009b      	lsls	r3, r3, #2
 8015898:	4413      	add	r3, r2
 801589a:	685b      	ldr	r3, [r3, #4]
 801589c:	6a1b      	ldr	r3, [r3, #32]
 801589e:	2208      	movs	r2, #8
 80158a0:	4619      	mov	r1, r3
 80158a2:	9801      	ldr	r0, [sp, #4]
 80158a4:	f7ee ff3a 	bl	800471c <memcpy>
}
 80158a8:	b005      	add	sp, #20
 80158aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80158ae:	bf00      	nop

080158b0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80158b0:	b086      	sub	sp, #24
 80158b2:	9001      	str	r0, [sp, #4]
 80158b4:	460b      	mov	r3, r1
 80158b6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80158ba:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158be:	9a01      	ldr	r2, [sp, #4]
 80158c0:	3302      	adds	r3, #2
 80158c2:	009b      	lsls	r3, r3, #2
 80158c4:	4413      	add	r3, r2
 80158c6:	685b      	ldr	r3, [r3, #4]
 80158c8:	699b      	ldr	r3, [r3, #24]
 80158ca:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 80158cc:	9b05      	ldr	r3, [sp, #20]
 80158ce:	681a      	ldr	r2, [r3, #0]
 80158d0:	9b05      	ldr	r3, [sp, #20]
 80158d2:	611a      	str	r2, [r3, #16]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 80158d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158d8:	2b00      	cmp	r3, #0
 80158da:	d106      	bne.n	80158ea <usb_lld_start_out+0x3a>
 80158dc:	9b05      	ldr	r3, [sp, #20]
 80158de:	681b      	ldr	r3, [r3, #0]
 80158e0:	2b40      	cmp	r3, #64	; 0x40
 80158e2:	d902      	bls.n	80158ea <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 80158e4:	9b05      	ldr	r3, [sp, #20]
 80158e6:	2240      	movs	r2, #64	; 0x40
 80158e8:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80158ea:	9b05      	ldr	r3, [sp, #20]
 80158ec:	681a      	ldr	r2, [r3, #0]
 80158ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158f2:	9901      	ldr	r1, [sp, #4]
 80158f4:	3302      	adds	r3, #2
 80158f6:	009b      	lsls	r3, r3, #2
 80158f8:	440b      	add	r3, r1
 80158fa:	685b      	ldr	r3, [r3, #4]
 80158fc:	8a5b      	ldrh	r3, [r3, #18]
 80158fe:	4413      	add	r3, r2
 8015900:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8015902:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015906:	9901      	ldr	r1, [sp, #4]
 8015908:	3302      	adds	r3, #2
 801590a:	009b      	lsls	r3, r3, #2
 801590c:	440b      	add	r3, r1
 801590e:	685b      	ldr	r3, [r3, #4]
 8015910:	8a5b      	ldrh	r3, [r3, #18]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8015912:	fbb2 f3f3 	udiv	r3, r2, r3
 8015916:	9304      	str	r3, [sp, #16]
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8015918:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801591c:	9a01      	ldr	r2, [sp, #4]
 801591e:	3302      	adds	r3, #2
 8015920:	009b      	lsls	r3, r3, #2
 8015922:	4413      	add	r3, r2
 8015924:	685b      	ldr	r3, [r3, #4]
 8015926:	8a5b      	ldrh	r3, [r3, #18]
 8015928:	461a      	mov	r2, r3
 801592a:	9b04      	ldr	r3, [sp, #16]
 801592c:	fb03 f302 	mul.w	r3, r3, r2
 8015930:	3303      	adds	r3, #3
 8015932:	f023 0303 	bic.w	r3, r3, #3
 8015936:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8015938:	9b01      	ldr	r3, [sp, #4]
 801593a:	6d59      	ldr	r1, [r3, #84]	; 0x54
 801593c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015940:	9a04      	ldr	r2, [sp, #16]
 8015942:	04d0      	lsls	r0, r2, #19
 8015944:	9a03      	ldr	r2, [sp, #12]
 8015946:	4302      	orrs	r2, r0
 8015948:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 801594c:	015b      	lsls	r3, r3, #5
 801594e:	440b      	add	r3, r1
 8015950:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8015954:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8015956:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801595a:	9a01      	ldr	r2, [sp, #4]
 801595c:	3302      	adds	r3, #2
 801595e:	009b      	lsls	r3, r3, #2
 8015960:	4413      	add	r3, r2
 8015962:	685b      	ldr	r3, [r3, #4]
 8015964:	681b      	ldr	r3, [r3, #0]
 8015966:	f003 0303 	and.w	r3, r3, #3
 801596a:	2b01      	cmp	r3, #1
 801596c:	d12c      	bne.n	80159c8 <usb_lld_start_out+0x118>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 801596e:	9b01      	ldr	r3, [sp, #4]
 8015970:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015972:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8015976:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801597a:	2b00      	cmp	r3, #0
 801597c:	d012      	beq.n	80159a4 <usb_lld_start_out+0xf4>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 801597e:	9b01      	ldr	r3, [sp, #4]
 8015980:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015982:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015986:	9a01      	ldr	r2, [sp, #4]
 8015988:	6d50      	ldr	r0, [r2, #84]	; 0x54
 801598a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801598e:	3258      	adds	r2, #88	; 0x58
 8015990:	0152      	lsls	r2, r2, #5
 8015992:	4402      	add	r2, r0
 8015994:	6812      	ldr	r2, [r2, #0]
 8015996:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 801599a:	3358      	adds	r3, #88	; 0x58
 801599c:	015b      	lsls	r3, r3, #5
 801599e:	440b      	add	r3, r1
 80159a0:	601a      	str	r2, [r3, #0]
 80159a2:	e011      	b.n	80159c8 <usb_lld_start_out+0x118>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80159a4:	9b01      	ldr	r3, [sp, #4]
 80159a6:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80159a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80159ac:	9a01      	ldr	r2, [sp, #4]
 80159ae:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80159b0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80159b4:	3258      	adds	r2, #88	; 0x58
 80159b6:	0152      	lsls	r2, r2, #5
 80159b8:	4402      	add	r2, r0
 80159ba:	6812      	ldr	r2, [r2, #0]
 80159bc:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80159c0:	3358      	adds	r3, #88	; 0x58
 80159c2:	015b      	lsls	r3, r3, #5
 80159c4:	440b      	add	r3, r1
 80159c6:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80159c8:	9b01      	ldr	r3, [sp, #4]
 80159ca:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80159cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80159d0:	9a01      	ldr	r2, [sp, #4]
 80159d2:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80159d4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80159d8:	3258      	adds	r2, #88	; 0x58
 80159da:	0152      	lsls	r2, r2, #5
 80159dc:	4402      	add	r2, r0
 80159de:	6812      	ldr	r2, [r2, #0]
 80159e0:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80159e4:	3358      	adds	r3, #88	; 0x58
 80159e6:	015b      	lsls	r3, r3, #5
 80159e8:	440b      	add	r3, r1
 80159ea:	601a      	str	r2, [r3, #0]
}
 80159ec:	b006      	add	sp, #24
 80159ee:	4770      	bx	lr

080159f0 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80159f0:	b084      	sub	sp, #16
 80159f2:	9001      	str	r0, [sp, #4]
 80159f4:	460b      	mov	r3, r1
 80159f6:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80159fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80159fe:	9a01      	ldr	r2, [sp, #4]
 8015a00:	3302      	adds	r3, #2
 8015a02:	009b      	lsls	r3, r3, #2
 8015a04:	4413      	add	r3, r2
 8015a06:	685b      	ldr	r3, [r3, #4]
 8015a08:	695b      	ldr	r3, [r3, #20]
 8015a0a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8015a0c:	9b03      	ldr	r3, [sp, #12]
 8015a0e:	681a      	ldr	r2, [r3, #0]
 8015a10:	9b03      	ldr	r3, [sp, #12]
 8015a12:	611a      	str	r2, [r3, #16]
  if (isp->txsize == 0) {
 8015a14:	9b03      	ldr	r3, [sp, #12]
 8015a16:	681b      	ldr	r3, [r3, #0]
 8015a18:	2b00      	cmp	r3, #0
 8015a1a:	d10b      	bne.n	8015a34 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8015a1c:	9b01      	ldr	r3, [sp, #4]
 8015a1e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8015a20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a24:	015b      	lsls	r3, r3, #5
 8015a26:	4413      	add	r3, r2
 8015a28:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8015a2c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8015a30:	601a      	str	r2, [r3, #0]
 8015a32:	e031      	b.n	8015a98 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8015a34:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a38:	2b00      	cmp	r3, #0
 8015a3a:	d106      	bne.n	8015a4a <usb_lld_start_in+0x5a>
 8015a3c:	9b03      	ldr	r3, [sp, #12]
 8015a3e:	681b      	ldr	r3, [r3, #0]
 8015a40:	2b40      	cmp	r3, #64	; 0x40
 8015a42:	d902      	bls.n	8015a4a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8015a44:	9b03      	ldr	r3, [sp, #12]
 8015a46:	2240      	movs	r2, #64	; 0x40
 8015a48:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8015a4a:	9b03      	ldr	r3, [sp, #12]
 8015a4c:	681a      	ldr	r2, [r3, #0]
 8015a4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a52:	9901      	ldr	r1, [sp, #4]
 8015a54:	3302      	adds	r3, #2
 8015a56:	009b      	lsls	r3, r3, #2
 8015a58:	440b      	add	r3, r1
 8015a5a:	685b      	ldr	r3, [r3, #4]
 8015a5c:	8a1b      	ldrh	r3, [r3, #16]
 8015a5e:	4413      	add	r3, r2
 8015a60:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 8015a62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a66:	9901      	ldr	r1, [sp, #4]
 8015a68:	3302      	adds	r3, #2
 8015a6a:	009b      	lsls	r3, r3, #2
 8015a6c:	440b      	add	r3, r1
 8015a6e:	685b      	ldr	r3, [r3, #4]
 8015a70:	8a1b      	ldrh	r3, [r3, #16]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8015a72:	fbb2 f3f3 	udiv	r3, r2, r3
 8015a76:	9302      	str	r3, [sp, #8]
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8015a78:	9b01      	ldr	r3, [sp, #4]
 8015a7a:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015a7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a80:	9a02      	ldr	r2, [sp, #8]
 8015a82:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 8015a84:	9a03      	ldr	r2, [sp, #12]
 8015a86:	6812      	ldr	r2, [r2, #0]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8015a88:	4302      	orrs	r2, r0
 8015a8a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8015a8e:	015b      	lsls	r3, r3, #5
 8015a90:	440b      	add	r3, r1
 8015a92:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8015a96:	601a      	str	r2, [r3, #0]
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8015a98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a9c:	9a01      	ldr	r2, [sp, #4]
 8015a9e:	3302      	adds	r3, #2
 8015aa0:	009b      	lsls	r3, r3, #2
 8015aa2:	4413      	add	r3, r2
 8015aa4:	685b      	ldr	r3, [r3, #4]
 8015aa6:	681b      	ldr	r3, [r3, #0]
 8015aa8:	f003 0303 	and.w	r3, r3, #3
 8015aac:	2b01      	cmp	r3, #1
 8015aae:	d12c      	bne.n	8015b0a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8015ab0:	9b01      	ldr	r3, [sp, #4]
 8015ab2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015ab4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8015ab8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8015abc:	2b00      	cmp	r3, #0
 8015abe:	d012      	beq.n	8015ae6 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8015ac0:	9b01      	ldr	r3, [sp, #4]
 8015ac2:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015ac4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015ac8:	9a01      	ldr	r2, [sp, #4]
 8015aca:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015acc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015ad0:	3248      	adds	r2, #72	; 0x48
 8015ad2:	0152      	lsls	r2, r2, #5
 8015ad4:	4402      	add	r2, r0
 8015ad6:	6812      	ldr	r2, [r2, #0]
 8015ad8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8015adc:	3348      	adds	r3, #72	; 0x48
 8015ade:	015b      	lsls	r3, r3, #5
 8015ae0:	440b      	add	r3, r1
 8015ae2:	601a      	str	r2, [r3, #0]
 8015ae4:	e011      	b.n	8015b0a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8015ae6:	9b01      	ldr	r3, [sp, #4]
 8015ae8:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015aea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015aee:	9a01      	ldr	r2, [sp, #4]
 8015af0:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015af2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015af6:	3248      	adds	r2, #72	; 0x48
 8015af8:	0152      	lsls	r2, r2, #5
 8015afa:	4402      	add	r2, r0
 8015afc:	6812      	ldr	r2, [r2, #0]
 8015afe:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8015b02:	3348      	adds	r3, #72	; 0x48
 8015b04:	015b      	lsls	r3, r3, #5
 8015b06:	440b      	add	r3, r1
 8015b08:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8015b0a:	9b01      	ldr	r3, [sp, #4]
 8015b0c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015b0e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015b12:	9a01      	ldr	r2, [sp, #4]
 8015b14:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015b16:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015b1a:	3248      	adds	r2, #72	; 0x48
 8015b1c:	0152      	lsls	r2, r2, #5
 8015b1e:	4402      	add	r2, r0
 8015b20:	6812      	ldr	r2, [r2, #0]
 8015b22:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8015b26:	3348      	adds	r3, #72	; 0x48
 8015b28:	015b      	lsls	r3, r3, #5
 8015b2a:	440b      	add	r3, r1
 8015b2c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8015b2e:	9b01      	ldr	r3, [sp, #4]
 8015b30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015b32:	9a01      	ldr	r2, [sp, #4]
 8015b34:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8015b36:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 8015b3a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015b3e:	2001      	movs	r0, #1
 8015b40:	fa00 f202 	lsl.w	r2, r0, r2
 8015b44:	430a      	orrs	r2, r1
 8015b46:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 8015b4a:	b004      	add	sp, #16
 8015b4c:	4770      	bx	lr
 8015b4e:	bf00      	nop

08015b50 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8015b50:	b082      	sub	sp, #8
 8015b52:	9001      	str	r0, [sp, #4]
 8015b54:	460b      	mov	r3, r1
 8015b56:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8015b5a:	9b01      	ldr	r3, [sp, #4]
 8015b5c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015b5e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015b62:	9a01      	ldr	r2, [sp, #4]
 8015b64:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015b66:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015b6a:	3258      	adds	r2, #88	; 0x58
 8015b6c:	0152      	lsls	r2, r2, #5
 8015b6e:	4402      	add	r2, r0
 8015b70:	6812      	ldr	r2, [r2, #0]
 8015b72:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8015b76:	3358      	adds	r3, #88	; 0x58
 8015b78:	015b      	lsls	r3, r3, #5
 8015b7a:	440b      	add	r3, r1
 8015b7c:	601a      	str	r2, [r3, #0]
}
 8015b7e:	b002      	add	sp, #8
 8015b80:	4770      	bx	lr
 8015b82:	bf00      	nop
	...

08015b90 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8015b90:	b082      	sub	sp, #8
 8015b92:	9001      	str	r0, [sp, #4]
 8015b94:	460b      	mov	r3, r1
 8015b96:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8015b9a:	9b01      	ldr	r3, [sp, #4]
 8015b9c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015b9e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015ba2:	9a01      	ldr	r2, [sp, #4]
 8015ba4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015ba6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015baa:	3248      	adds	r2, #72	; 0x48
 8015bac:	0152      	lsls	r2, r2, #5
 8015bae:	4402      	add	r2, r0
 8015bb0:	6812      	ldr	r2, [r2, #0]
 8015bb2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8015bb6:	3348      	adds	r3, #72	; 0x48
 8015bb8:	015b      	lsls	r3, r3, #5
 8015bba:	440b      	add	r3, r1
 8015bbc:	601a      	str	r2, [r3, #0]
}
 8015bbe:	b002      	add	sp, #8
 8015bc0:	4770      	bx	lr
 8015bc2:	bf00      	nop
	...

08015bd0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8015bd0:	b082      	sub	sp, #8
 8015bd2:	9001      	str	r0, [sp, #4]
 8015bd4:	460b      	mov	r3, r1
 8015bd6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8015bda:	9b01      	ldr	r3, [sp, #4]
 8015bdc:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015bde:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015be2:	9a01      	ldr	r2, [sp, #4]
 8015be4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015be6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015bea:	3258      	adds	r2, #88	; 0x58
 8015bec:	0152      	lsls	r2, r2, #5
 8015bee:	4402      	add	r2, r0
 8015bf0:	6812      	ldr	r2, [r2, #0]
 8015bf2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8015bf6:	3358      	adds	r3, #88	; 0x58
 8015bf8:	015b      	lsls	r3, r3, #5
 8015bfa:	440b      	add	r3, r1
 8015bfc:	601a      	str	r2, [r3, #0]
}
 8015bfe:	b002      	add	sp, #8
 8015c00:	4770      	bx	lr
 8015c02:	bf00      	nop
	...

08015c10 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8015c10:	b082      	sub	sp, #8
 8015c12:	9001      	str	r0, [sp, #4]
 8015c14:	460b      	mov	r3, r1
 8015c16:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8015c1a:	9b01      	ldr	r3, [sp, #4]
 8015c1c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8015c1e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015c22:	9a01      	ldr	r2, [sp, #4]
 8015c24:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8015c26:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8015c2a:	3248      	adds	r2, #72	; 0x48
 8015c2c:	0152      	lsls	r2, r2, #5
 8015c2e:	4402      	add	r2, r0
 8015c30:	6812      	ldr	r2, [r2, #0]
 8015c32:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8015c36:	3348      	adds	r3, #72	; 0x48
 8015c38:	015b      	lsls	r3, r3, #5
 8015c3a:	440b      	add	r3, r1
 8015c3c:	601a      	str	r2, [r3, #0]
}
 8015c3e:	b002      	add	sp, #8
 8015c40:	4770      	bx	lr
 8015c42:	bf00      	nop
	...

08015c50 <port_lock.lto_priv.737>:
static inline void port_lock(void) {
 8015c50:	b082      	sub	sp, #8
 8015c52:	2320      	movs	r3, #32
 8015c54:	9301      	str	r3, [sp, #4]
 8015c56:	9b01      	ldr	r3, [sp, #4]
 8015c58:	f383 8811 	msr	BASEPRI, r3
}
 8015c5c:	b002      	add	sp, #8
 8015c5e:	4770      	bx	lr

08015c60 <port_unlock.lto_priv.733>:
static inline void port_unlock(void) {
 8015c60:	b082      	sub	sp, #8
 8015c62:	2300      	movs	r3, #0
 8015c64:	9301      	str	r3, [sp, #4]
 8015c66:	9b01      	ldr	r3, [sp, #4]
 8015c68:	f383 8811 	msr	BASEPRI, r3
}
 8015c6c:	b002      	add	sp, #8
 8015c6e:	4770      	bx	lr

08015c70 <port_lock_from_isr.lto_priv.729>:
static inline void port_lock_from_isr(void) {
 8015c70:	b508      	push	{r3, lr}
  port_lock();
 8015c72:	f7ff ffed 	bl	8015c50 <port_lock.lto_priv.737>
}
 8015c76:	bd08      	pop	{r3, pc}
	...

08015c80 <port_unlock_from_isr.lto_priv.725>:
static inline void port_unlock_from_isr(void) {
 8015c80:	b508      	push	{r3, lr}
  port_unlock();
 8015c82:	f7ff ffed 	bl	8015c60 <port_unlock.lto_priv.733>
}
 8015c86:	bd08      	pop	{r3, pc}
	...

08015c90 <chSysLock>:
static inline void chSysLock(void) {
 8015c90:	b508      	push	{r3, lr}
  port_lock();
 8015c92:	f7ff ffdd 	bl	8015c50 <port_lock.lto_priv.737>
}
 8015c96:	bd08      	pop	{r3, pc}
	...

08015ca0 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8015ca0:	b508      	push	{r3, lr}
  port_unlock();
 8015ca2:	f7ff ffdd 	bl	8015c60 <port_unlock.lto_priv.733>
}
 8015ca6:	bd08      	pop	{r3, pc}
	...

08015cb0 <chSysLockFromISR.lto_priv.754>:
static inline void chSysLockFromISR(void) {
 8015cb0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8015cb2:	f7ff ffdd 	bl	8015c70 <port_lock_from_isr.lto_priv.729>
}
 8015cb6:	bd08      	pop	{r3, pc}
	...

08015cc0 <chSysUnlockFromISR.lto_priv.751>:
static inline void chSysUnlockFromISR(void) {
 8015cc0:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8015cc2:	f7ff ffdd 	bl	8015c80 <port_unlock_from_isr.lto_priv.725>
}
 8015cc6:	bd08      	pop	{r3, pc}
	...

08015cd0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8015cd0:	b508      	push	{r3, lr}

  chSysLock();
 8015cd2:	f7ff ffdd 	bl	8015c90 <chSysLock>
}
 8015cd6:	bd08      	pop	{r3, pc}
	...

08015ce0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8015ce0:	b508      	push	{r3, lr}

  chSysUnlock();
 8015ce2:	f7ff ffdd 	bl	8015ca0 <chSysUnlock>
}
 8015ce6:	bd08      	pop	{r3, pc}
	...

08015cf0 <osalSysLockFromISR.lto_priv.748>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8015cf0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8015cf2:	f7ff ffdd 	bl	8015cb0 <chSysLockFromISR.lto_priv.754>
}
 8015cf6:	bd08      	pop	{r3, pc}
	...

08015d00 <osalSysUnlockFromISR.lto_priv.744>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8015d00:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8015d02:	f7ff ffdd 	bl	8015cc0 <chSysUnlockFromISR.lto_priv.751>
}
 8015d06:	bd08      	pop	{r3, pc}
	...

08015d10 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(sysinterval_t delay) {
 8015d10:	b500      	push	{lr}
 8015d12:	b083      	sub	sp, #12
 8015d14:	9001      	str	r0, [sp, #4]

  chThdSleep(delay);
 8015d16:	9801      	ldr	r0, [sp, #4]
 8015d18:	f7fe fe9a 	bl	8014a50 <chThdSleep>
}
 8015d1c:	b003      	add	sp, #12
 8015d1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d22:	bf00      	nop
	...

08015d30 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8015d30:	b500      	push	{lr}
 8015d32:	b083      	sub	sp, #12
 8015d34:	9001      	str	r0, [sp, #4]

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8015d36:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8015d3a:	9801      	ldr	r0, [sp, #4]
 8015d3c:	f7fe fe98 	bl	8014a70 <chThdSuspendTimeoutS>
 8015d40:	4603      	mov	r3, r0
}
 8015d42:	4618      	mov	r0, r3
 8015d44:	b003      	add	sp, #12
 8015d46:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d4a:	bf00      	nop
 8015d4c:	0000      	movs	r0, r0
	...

08015d50 <osalThreadResumeI.lto_priv.760>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8015d50:	b500      	push	{lr}
 8015d52:	b083      	sub	sp, #12
 8015d54:	9001      	str	r0, [sp, #4]
 8015d56:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8015d58:	9900      	ldr	r1, [sp, #0]
 8015d5a:	9801      	ldr	r0, [sp, #4]
 8015d5c:	f7fe fea8 	bl	8014ab0 <chThdResumeI>
}
 8015d60:	b003      	add	sp, #12
 8015d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d66:	bf00      	nop
	...

08015d70 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 8015d70:	b500      	push	{lr}
 8015d72:	b085      	sub	sp, #20
 8015d74:	9003      	str	r0, [sp, #12]
 8015d76:	9102      	str	r1, [sp, #8]
 8015d78:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8015d7a:	9b03      	ldr	r3, [sp, #12]
 8015d7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015d7e:	4a1d      	ldr	r2, [pc, #116]	; (8015df4 <sdc_lld_prepare_read_bytes+0x84>)
 8015d80:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8015d82:	9803      	ldr	r0, [sp, #12]
 8015d84:	f004 fdac 	bl	801a8e0 <_sdc_wait_for_transfer_state>
 8015d88:	4603      	mov	r3, r0
 8015d8a:	2b00      	cmp	r3, #0
 8015d8c:	d001      	beq.n	8015d92 <sdc_lld_prepare_read_bytes+0x22>
    return HAL_FAILED;
 8015d8e:	2301      	movs	r3, #1
 8015d90:	e02c      	b.n	8015dec <sdc_lld_prepare_read_bytes+0x7c>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8015d92:	9b03      	ldr	r3, [sp, #12]
 8015d94:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015d96:	681b      	ldr	r3, [r3, #0]
 8015d98:	9a02      	ldr	r2, [sp, #8]
 8015d9a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 8015d9c:	9b03      	ldr	r3, [sp, #12]
 8015d9e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015da0:	681b      	ldr	r3, [r3, #0]
 8015da2:	9a01      	ldr	r2, [sp, #4]
 8015da4:	0892      	lsrs	r2, r2, #2
 8015da6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8015da8:	9b03      	ldr	r3, [sp, #12]
 8015daa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015dac:	681b      	ldr	r3, [r3, #0]
 8015dae:	9a03      	ldr	r2, [sp, #12]
 8015db0:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8015db2:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8015db4:	9b03      	ldr	r3, [sp, #12]
 8015db6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015db8:	681b      	ldr	r3, [r3, #0]
 8015dba:	9a03      	ldr	r2, [sp, #12]
 8015dbc:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8015dbe:	6812      	ldr	r2, [r2, #0]
 8015dc0:	6812      	ldr	r2, [r2, #0]
 8015dc2:	f042 0201 	orr.w	r2, r2, #1
 8015dc6:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8015dc8:	9b03      	ldr	r3, [sp, #12]
 8015dca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015dcc:	4a0a      	ldr	r2, [pc, #40]	; (8015df8 <sdc_lld_prepare_read_bytes+0x88>)
 8015dce:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8015dd0:	9b03      	ldr	r3, [sp, #12]
 8015dd2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015dd4:	f240 322a 	movw	r2, #810	; 0x32a
 8015dd8:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = bytes;
 8015dda:	9b03      	ldr	r3, [sp, #12]
 8015ddc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015dde:	9a01      	ldr	r2, [sp, #4]
 8015de0:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 8015de2:	9b03      	ldr	r3, [sp, #12]
 8015de4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015de6:	220f      	movs	r2, #15
 8015de8:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DTMODE |   /* multibyte data transfer */
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  return HAL_SUCCESS;
 8015dea:	2300      	movs	r3, #0
}
 8015dec:	4618      	mov	r0, r3
 8015dee:	b005      	add	sp, #20
 8015df0:	f85d fb04 	ldr.w	pc, [sp], #4
 8015df4:	016e3600 	.word	0x016e3600
 8015df8:	00c007ff 	.word	0x00c007ff
 8015dfc:	00000000 	.word	0x00000000

08015e00 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 8015e00:	b500      	push	{lr}
 8015e02:	b085      	sub	sp, #20
 8015e04:	9003      	str	r0, [sp, #12]
 8015e06:	9102      	str	r1, [sp, #8]
 8015e08:	9201      	str	r2, [sp, #4]
 8015e0a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8015e0c:	9b03      	ldr	r3, [sp, #12]
 8015e0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e10:	f003 0310 	and.w	r3, r3, #16
 8015e14:	2b00      	cmp	r3, #0
 8015e16:	d102      	bne.n	8015e1e <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 8015e18:	9b02      	ldr	r3, [sp, #8]
 8015e1a:	025b      	lsls	r3, r3, #9
 8015e1c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 8015e1e:	9b01      	ldr	r3, [sp, #4]
 8015e20:	2b01      	cmp	r3, #1
 8015e22:	d910      	bls.n	8015e46 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8015e24:	9b00      	ldr	r3, [sp, #0]
 8015e26:	9a02      	ldr	r2, [sp, #8]
 8015e28:	2112      	movs	r1, #18
 8015e2a:	9803      	ldr	r0, [sp, #12]
 8015e2c:	f000 fa50 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 8015e30:	4603      	mov	r3, r0
 8015e32:	2b00      	cmp	r3, #0
 8015e34:	d105      	bne.n	8015e42 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8015e36:	9b00      	ldr	r3, [sp, #0]
 8015e38:	681a      	ldr	r2, [r3, #0]
 8015e3a:	4b0e      	ldr	r3, [pc, #56]	; (8015e74 <sdc_lld_prepare_read+0x74>)
 8015e3c:	4013      	ands	r3, r2
 8015e3e:	2b00      	cmp	r3, #0
 8015e40:	d012      	beq.n	8015e68 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8015e42:	2301      	movs	r3, #1
 8015e44:	e011      	b.n	8015e6a <sdc_lld_prepare_read+0x6a>
  }
  else {
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 8015e46:	9b00      	ldr	r3, [sp, #0]
 8015e48:	9a02      	ldr	r2, [sp, #8]
 8015e4a:	2111      	movs	r1, #17
 8015e4c:	9803      	ldr	r0, [sp, #12]
 8015e4e:	f000 fa3f 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 8015e52:	4603      	mov	r3, r0
 8015e54:	2b00      	cmp	r3, #0
 8015e56:	d105      	bne.n	8015e64 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8015e58:	9b00      	ldr	r3, [sp, #0]
 8015e5a:	681a      	ldr	r2, [r3, #0]
 8015e5c:	4b05      	ldr	r3, [pc, #20]	; (8015e74 <sdc_lld_prepare_read+0x74>)
 8015e5e:	4013      	ands	r3, r2
 8015e60:	2b00      	cmp	r3, #0
 8015e62:	d001      	beq.n	8015e68 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8015e64:	2301      	movs	r3, #1
 8015e66:	e000      	b.n	8015e6a <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 8015e68:	2300      	movs	r3, #0
}
 8015e6a:	4618      	mov	r0, r3
 8015e6c:	b005      	add	sp, #20
 8015e6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e72:	bf00      	nop
 8015e74:	fdffe008 	.word	0xfdffe008
	...

08015e80 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 8015e80:	b500      	push	{lr}
 8015e82:	b085      	sub	sp, #20
 8015e84:	9003      	str	r0, [sp, #12]
 8015e86:	9102      	str	r1, [sp, #8]
 8015e88:	9201      	str	r2, [sp, #4]
 8015e8a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8015e8c:	9b03      	ldr	r3, [sp, #12]
 8015e8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e90:	f003 0310 	and.w	r3, r3, #16
 8015e94:	2b00      	cmp	r3, #0
 8015e96:	d102      	bne.n	8015e9e <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 8015e98:	9b02      	ldr	r3, [sp, #8]
 8015e9a:	025b      	lsls	r3, r3, #9
 8015e9c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 8015e9e:	9b01      	ldr	r3, [sp, #4]
 8015ea0:	2b01      	cmp	r3, #1
 8015ea2:	d910      	bls.n	8015ec6 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8015ea4:	9b00      	ldr	r3, [sp, #0]
 8015ea6:	9a02      	ldr	r2, [sp, #8]
 8015ea8:	2119      	movs	r1, #25
 8015eaa:	9803      	ldr	r0, [sp, #12]
 8015eac:	f000 fa10 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 8015eb0:	4603      	mov	r3, r0
 8015eb2:	2b00      	cmp	r3, #0
 8015eb4:	d105      	bne.n	8015ec2 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8015eb6:	9b00      	ldr	r3, [sp, #0]
 8015eb8:	681a      	ldr	r2, [r3, #0]
 8015eba:	4b0e      	ldr	r3, [pc, #56]	; (8015ef4 <sdc_lld_prepare_write+0x74>)
 8015ebc:	4013      	ands	r3, r2
 8015ebe:	2b00      	cmp	r3, #0
 8015ec0:	d012      	beq.n	8015ee8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 8015ec2:	2301      	movs	r3, #1
 8015ec4:	e011      	b.n	8015eea <sdc_lld_prepare_write+0x6a>
  }
  else {
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 8015ec6:	9b00      	ldr	r3, [sp, #0]
 8015ec8:	9a02      	ldr	r2, [sp, #8]
 8015eca:	2118      	movs	r1, #24
 8015ecc:	9803      	ldr	r0, [sp, #12]
 8015ece:	f000 f9ff 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 8015ed2:	4603      	mov	r3, r0
 8015ed4:	2b00      	cmp	r3, #0
 8015ed6:	d105      	bne.n	8015ee4 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8015ed8:	9b00      	ldr	r3, [sp, #0]
 8015eda:	681a      	ldr	r2, [r3, #0]
 8015edc:	4b05      	ldr	r3, [pc, #20]	; (8015ef4 <sdc_lld_prepare_write+0x74>)
 8015ede:	4013      	ands	r3, r2
 8015ee0:	2b00      	cmp	r3, #0
 8015ee2:	d001      	beq.n	8015ee8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 8015ee4:	2301      	movs	r3, #1
 8015ee6:	e000      	b.n	8015eea <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 8015ee8:	2300      	movs	r3, #0
}
 8015eea:	4618      	mov	r0, r3
 8015eec:	b005      	add	sp, #20
 8015eee:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ef2:	bf00      	nop
 8015ef4:	fdffe008 	.word	0xfdffe008
	...

08015f00 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 8015f00:	b500      	push	{lr}
 8015f02:	b085      	sub	sp, #20
 8015f04:	9003      	str	r0, [sp, #12]
 8015f06:	9102      	str	r1, [sp, #8]
 8015f08:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 8015f0a:	f7ff fee1 	bl	8015cd0 <osalSysLock>
  if (sdcp->sdio->MASK != 0)
 8015f0e:	9b03      	ldr	r3, [sp, #12]
 8015f10:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015f12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8015f14:	2b00      	cmp	r3, #0
 8015f16:	d004      	beq.n	8015f22 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 8015f18:	9b03      	ldr	r3, [sp, #12]
 8015f1a:	333c      	adds	r3, #60	; 0x3c
 8015f1c:	4618      	mov	r0, r3
 8015f1e:	f7ff ff07 	bl	8015d30 <osalThreadSuspendS>
  if ((sdcp->sdio->STA & SDIO_STA_DATAEND) == 0) {
 8015f22:	9b03      	ldr	r3, [sp, #12]
 8015f24:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015f26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f28:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8015f2c:	2b00      	cmp	r3, #0
 8015f2e:	d103      	bne.n	8015f38 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 8015f30:	f7ff fed6 	bl	8015ce0 <osalSysUnlock>
    return HAL_FAILED;
 8015f34:	2301      	movs	r3, #1
 8015f36:	e027      	b.n	8015f88 <sdc_lld_wait_transaction_end+0x88>
  }

#if (defined(STM32F4XX) || defined(STM32F2XX))
  /* Wait until DMA channel enabled to be sure that all data transferred.*/
  while (sdcp->dma->stream->CR & STM32_DMA_CR_EN)
 8015f38:	9b03      	ldr	r3, [sp, #12]
 8015f3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015f3c:	681b      	ldr	r3, [r3, #0]
 8015f3e:	681b      	ldr	r3, [r3, #0]
 8015f40:	f003 0301 	and.w	r3, r3, #1
 8015f44:	2b00      	cmp	r3, #0
 8015f46:	d1f7      	bne.n	8015f38 <sdc_lld_wait_transaction_end+0x38>
    ;

  /* DMA event flags must be manually cleared.*/
  dmaStreamClearInterrupt(sdcp->dma);
 8015f48:	9b03      	ldr	r3, [sp, #12]
 8015f4a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015f4c:	685b      	ldr	r3, [r3, #4]
 8015f4e:	9a03      	ldr	r2, [sp, #12]
 8015f50:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8015f52:	7a12      	ldrb	r2, [r2, #8]
 8015f54:	4611      	mov	r1, r2
 8015f56:	223d      	movs	r2, #61	; 0x3d
 8015f58:	408a      	lsls	r2, r1
 8015f5a:	601a      	str	r2, [r3, #0]

  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 8015f5c:	9b03      	ldr	r3, [sp, #12]
 8015f5e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015f60:	4a0b      	ldr	r2, [pc, #44]	; (8015f90 <sdc_lld_wait_transaction_end+0x90>)
 8015f62:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->DCTRL = 0;
 8015f64:	9b03      	ldr	r3, [sp, #12]
 8015f66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015f68:	2200      	movs	r2, #0
 8015f6a:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 8015f6c:	f7ff feb8 	bl	8015ce0 <osalSysUnlock>
  sdcp->sdio->DCTRL = 0;
  osalSysUnlock();
#endif

  /* Finalize transaction.*/
  if (n > 1)
 8015f70:	9b02      	ldr	r3, [sp, #8]
 8015f72:	2b01      	cmp	r3, #1
 8015f74:	d907      	bls.n	8015f86 <sdc_lld_wait_transaction_end+0x86>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8015f76:	9b01      	ldr	r3, [sp, #4]
 8015f78:	2200      	movs	r2, #0
 8015f7a:	210c      	movs	r1, #12
 8015f7c:	9803      	ldr	r0, [sp, #12]
 8015f7e:	f000 f9a7 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 8015f82:	4603      	mov	r3, r0
 8015f84:	e000      	b.n	8015f88 <sdc_lld_wait_transaction_end+0x88>

  return HAL_SUCCESS;
 8015f86:	2300      	movs	r3, #0
}
 8015f88:	4618      	mov	r0, r3
 8015f8a:	b005      	add	sp, #20
 8015f8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8015f90:	00c007ff 	.word	0x00c007ff
	...

08015fa0 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 8015fa0:	b084      	sub	sp, #16
 8015fa2:	9001      	str	r0, [sp, #4]
 8015fa4:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 8015fa6:	2300      	movs	r3, #0
 8015fa8:	9303      	str	r3, [sp, #12]

  if (sta & SDIO_STA_CCRCFAIL)
 8015faa:	9b00      	ldr	r3, [sp, #0]
 8015fac:	f003 0301 	and.w	r3, r3, #1
 8015fb0:	2b00      	cmp	r3, #0
 8015fb2:	d003      	beq.n	8015fbc <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 8015fb4:	9b03      	ldr	r3, [sp, #12]
 8015fb6:	f043 0301 	orr.w	r3, r3, #1
 8015fba:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_DCRCFAIL)
 8015fbc:	9b00      	ldr	r3, [sp, #0]
 8015fbe:	f003 0302 	and.w	r3, r3, #2
 8015fc2:	2b00      	cmp	r3, #0
 8015fc4:	d003      	beq.n	8015fce <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 8015fc6:	9b03      	ldr	r3, [sp, #12]
 8015fc8:	f043 0302 	orr.w	r3, r3, #2
 8015fcc:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_CTIMEOUT)
 8015fce:	9b00      	ldr	r3, [sp, #0]
 8015fd0:	f003 0304 	and.w	r3, r3, #4
 8015fd4:	2b00      	cmp	r3, #0
 8015fd6:	d003      	beq.n	8015fe0 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 8015fd8:	9b03      	ldr	r3, [sp, #12]
 8015fda:	f043 0308 	orr.w	r3, r3, #8
 8015fde:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_DTIMEOUT)
 8015fe0:	9b00      	ldr	r3, [sp, #0]
 8015fe2:	f003 0308 	and.w	r3, r3, #8
 8015fe6:	2b00      	cmp	r3, #0
 8015fe8:	d003      	beq.n	8015ff2 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 8015fea:	9b03      	ldr	r3, [sp, #12]
 8015fec:	f043 0304 	orr.w	r3, r3, #4
 8015ff0:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_TXUNDERR)
 8015ff2:	9b00      	ldr	r3, [sp, #0]
 8015ff4:	f003 0310 	and.w	r3, r3, #16
 8015ff8:	2b00      	cmp	r3, #0
 8015ffa:	d003      	beq.n	8016004 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 8015ffc:	9b03      	ldr	r3, [sp, #12]
 8015ffe:	f043 0310 	orr.w	r3, r3, #16
 8016002:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_RXOVERR)
 8016004:	9b00      	ldr	r3, [sp, #0]
 8016006:	f003 0320 	and.w	r3, r3, #32
 801600a:	2b00      	cmp	r3, #0
 801600c:	d003      	beq.n	8016016 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 801600e:	9b03      	ldr	r3, [sp, #12]
 8016010:	f043 0320 	orr.w	r3, r3, #32
 8016014:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_STBITERR)
 8016016:	9b00      	ldr	r3, [sp, #0]
 8016018:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801601c:	2b00      	cmp	r3, #0
 801601e:	d003      	beq.n	8016028 <sdc_lld_collect_errors+0x88>
    errors |= SDC_STARTBIT_ERROR;
 8016020:	9b03      	ldr	r3, [sp, #12]
 8016022:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016026:	9303      	str	r3, [sp, #12]

  sdcp->errors |= errors;
 8016028:	9b01      	ldr	r3, [sp, #4]
 801602a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801602c:	9b03      	ldr	r3, [sp, #12]
 801602e:	431a      	orrs	r2, r3
 8016030:	9b01      	ldr	r3, [sp, #4]
 8016032:	635a      	str	r2, [r3, #52]	; 0x34
}
 8016034:	b004      	add	sp, #16
 8016036:	4770      	bx	lr
	...

08016040 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 8016040:	b500      	push	{lr}
 8016042:	b087      	sub	sp, #28
 8016044:	9003      	str	r0, [sp, #12]
 8016046:	9102      	str	r1, [sp, #8]
 8016048:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdio->STA;
 801604a:	9b03      	ldr	r3, [sp, #12]
 801604c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801604e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016050:	9305      	str	r3, [sp, #20]

  dmaStreamClearInterrupt(sdcp->dma);
 8016052:	9b03      	ldr	r3, [sp, #12]
 8016054:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016056:	685b      	ldr	r3, [r3, #4]
 8016058:	9a03      	ldr	r2, [sp, #12]
 801605a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 801605c:	7a12      	ldrb	r2, [r2, #8]
 801605e:	4611      	mov	r1, r2
 8016060:	223d      	movs	r2, #61	; 0x3d
 8016062:	408a      	lsls	r2, r1
 8016064:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(sdcp->dma);
 8016066:	9b03      	ldr	r3, [sp, #12]
 8016068:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801606a:	681b      	ldr	r3, [r3, #0]
 801606c:	9a03      	ldr	r2, [sp, #12]
 801606e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8016070:	6812      	ldr	r2, [r2, #0]
 8016072:	6812      	ldr	r2, [r2, #0]
 8016074:	f022 021f 	bic.w	r2, r2, #31
 8016078:	601a      	str	r2, [r3, #0]
 801607a:	9b03      	ldr	r3, [sp, #12]
 801607c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801607e:	681b      	ldr	r3, [r3, #0]
 8016080:	681b      	ldr	r3, [r3, #0]
 8016082:	f003 0301 	and.w	r3, r3, #1
 8016086:	2b00      	cmp	r3, #0
 8016088:	d1f7      	bne.n	801607a <sdc_lld_error_cleanup+0x3a>
 801608a:	9b03      	ldr	r3, [sp, #12]
 801608c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801608e:	685b      	ldr	r3, [r3, #4]
 8016090:	9a03      	ldr	r2, [sp, #12]
 8016092:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8016094:	7a12      	ldrb	r2, [r2, #8]
 8016096:	4611      	mov	r1, r2
 8016098:	223d      	movs	r2, #61	; 0x3d
 801609a:	408a      	lsls	r2, r1
 801609c:	601a      	str	r2, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 801609e:	9b03      	ldr	r3, [sp, #12]
 80160a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80160a2:	4a0d      	ldr	r2, [pc, #52]	; (80160d8 <sdc_lld_error_cleanup+0x98>)
 80160a4:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = 0;
 80160a6:	9b03      	ldr	r3, [sp, #12]
 80160a8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80160aa:	2200      	movs	r2, #0
 80160ac:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdio->DCTRL = 0;
 80160ae:	9b03      	ldr	r3, [sp, #12]
 80160b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80160b2:	2200      	movs	r2, #0
 80160b4:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80160b6:	9905      	ldr	r1, [sp, #20]
 80160b8:	9803      	ldr	r0, [sp, #12]
 80160ba:	f7ff ff71 	bl	8015fa0 <sdc_lld_collect_errors>
  if (n > 1)
 80160be:	9b02      	ldr	r3, [sp, #8]
 80160c0:	2b01      	cmp	r3, #1
 80160c2:	d905      	bls.n	80160d0 <sdc_lld_error_cleanup+0x90>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 80160c4:	9b01      	ldr	r3, [sp, #4]
 80160c6:	2200      	movs	r2, #0
 80160c8:	210c      	movs	r1, #12
 80160ca:	9803      	ldr	r0, [sp, #12]
 80160cc:	f000 f900 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
}
 80160d0:	b007      	add	sp, #28
 80160d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80160d6:	bf00      	nop
 80160d8:	00c007ff 	.word	0x00c007ff
 80160dc:	00000000 	.word	0x00000000

080160e0 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDIO_HANDLER) {
 80160e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 80160e2:	f7ff fe05 	bl	8015cf0 <osalSysLockFromISR.lto_priv.748>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDIO->MASK = 0;
 80160e6:	4b06      	ldr	r3, [pc, #24]	; (8016100 <Vector104+0x20>)
 80160e8:	2200      	movs	r2, #0
 80160ea:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 80160ec:	2100      	movs	r1, #0
 80160ee:	4805      	ldr	r0, [pc, #20]	; (8016104 <Vector104+0x24>)
 80160f0:	f7ff fe2e 	bl	8015d50 <osalThreadResumeI.lto_priv.760>

  osalSysUnlockFromISR();
 80160f4:	f7ff fe04 	bl	8015d00 <osalSysUnlockFromISR.lto_priv.744>

  OSAL_IRQ_EPILOGUE();
 80160f8:	f7fd faca 	bl	8013690 <_port_irq_epilogue>
}
 80160fc:	bd08      	pop	{r3, pc}
 80160fe:	bf00      	nop
 8016100:	40012c00 	.word	0x40012c00
 8016104:	200050d4 	.word	0x200050d4
	...

08016110 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 8016110:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 8016112:	4806      	ldr	r0, [pc, #24]	; (801612c <sdc_lld_init+0x1c>)
 8016114:	f004 fc1c 	bl	801a950 <sdcObjectInit>
  SDCD1.thread = NULL;
 8016118:	4b04      	ldr	r3, [pc, #16]	; (801612c <sdc_lld_init+0x1c>)
 801611a:	2200      	movs	r2, #0
 801611c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDIO_DMA_STREAM);
 801611e:	4b03      	ldr	r3, [pc, #12]	; (801612c <sdc_lld_init+0x1c>)
 8016120:	4a03      	ldr	r2, [pc, #12]	; (8016130 <sdc_lld_init+0x20>)
 8016122:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdio   = SDIO;
 8016124:	4b01      	ldr	r3, [pc, #4]	; (801612c <sdc_lld_init+0x1c>)
 8016126:	4a03      	ldr	r2, [pc, #12]	; (8016134 <sdc_lld_init+0x24>)
 8016128:	649a      	str	r2, [r3, #72]	; 0x48
}
 801612a:	bd08      	pop	{r3, pc}
 801612c:	20005098 	.word	0x20005098
 8016130:	08023074 	.word	0x08023074
 8016134:	40012c00 	.word	0x40012c00
	...

08016140 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 8016140:	b500      	push	{lr}
 8016142:	b083      	sub	sp, #12
 8016144:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdio->CLKCR  = STM32_SDIO_DIV_LS;
 8016146:	9b01      	ldr	r3, [sp, #4]
 8016148:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801614a:	2278      	movs	r2, #120	; 0x78
 801614c:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER |= SDIO_POWER_PWRCTRL_0 | SDIO_POWER_PWRCTRL_1;
 801614e:	9b01      	ldr	r3, [sp, #4]
 8016150:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016152:	9a01      	ldr	r2, [sp, #4]
 8016154:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8016156:	6812      	ldr	r2, [r2, #0]
 8016158:	f042 0203 	orr.w	r2, r2, #3
 801615c:	601a      	str	r2, [r3, #0]
  sdcp->sdio->CLKCR |= SDIO_CLKCR_CLKEN;
 801615e:	9b01      	ldr	r3, [sp, #4]
 8016160:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016162:	9a01      	ldr	r2, [sp, #4]
 8016164:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8016166:	6852      	ldr	r2, [r2, #4]
 8016168:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 801616c:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2I(STM32_SDC_CLOCK_ACTIVATION_DELAY));
 801616e:	2064      	movs	r0, #100	; 0x64
 8016170:	f7ff fdce 	bl	8015d10 <osalThreadSleep>
}
 8016174:	b003      	add	sp, #12
 8016176:	f85d fb04 	ldr.w	pc, [sp], #4
 801617a:	bf00      	nop
 801617c:	0000      	movs	r0, r0
	...

08016180 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 8016180:	b082      	sub	sp, #8
 8016182:	9001      	str	r0, [sp, #4]
 8016184:	460b      	mov	r3, r1
 8016186:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
#else
  (void)clk;

  sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
 801618a:	9b01      	ldr	r3, [sp, #4]
 801618c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801618e:	9a01      	ldr	r2, [sp, #4]
 8016190:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8016192:	6852      	ldr	r2, [r2, #4]
 8016194:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8016198:	605a      	str	r2, [r3, #4]
#endif
}
 801619a:	b002      	add	sp, #8
 801619c:	4770      	bx	lr
 801619e:	bf00      	nop

080161a0 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 80161a0:	b082      	sub	sp, #8
 80161a2:	9001      	str	r0, [sp, #4]

  sdcp->sdio->CLKCR = 0;
 80161a4:	9b01      	ldr	r3, [sp, #4]
 80161a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80161a8:	2200      	movs	r2, #0
 80161aa:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER = 0;
 80161ac:	9b01      	ldr	r3, [sp, #4]
 80161ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80161b0:	2200      	movs	r2, #0
 80161b2:	601a      	str	r2, [r3, #0]
}
 80161b4:	b002      	add	sp, #8
 80161b6:	4770      	bx	lr
	...

080161c0 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 80161c0:	b084      	sub	sp, #16
 80161c2:	9001      	str	r0, [sp, #4]
 80161c4:	460b      	mov	r3, r1
 80161c6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 80161ca:	9b01      	ldr	r3, [sp, #4]
 80161cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80161ce:	685b      	ldr	r3, [r3, #4]
 80161d0:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 80161d4:	9303      	str	r3, [sp, #12]

  switch (mode) {
 80161d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80161da:	2b01      	cmp	r3, #1
 80161dc:	d008      	beq.n	80161f0 <sdc_lld_set_bus_mode+0x30>
 80161de:	2b02      	cmp	r3, #2
 80161e0:	d00d      	beq.n	80161fe <sdc_lld_set_bus_mode+0x3e>
 80161e2:	2b00      	cmp	r3, #0
 80161e4:	d111      	bne.n	801620a <sdc_lld_set_bus_mode+0x4a>
  case SDC_MODE_1BIT:
    sdcp->sdio->CLKCR = clk;
 80161e6:	9b01      	ldr	r3, [sp, #4]
 80161e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80161ea:	9a03      	ldr	r2, [sp, #12]
 80161ec:	605a      	str	r2, [r3, #4]
 80161ee:	e00c      	b.n	801620a <sdc_lld_set_bus_mode+0x4a>
    break;
  case SDC_MODE_4BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 80161f0:	9b01      	ldr	r3, [sp, #4]
 80161f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80161f4:	9a03      	ldr	r2, [sp, #12]
 80161f6:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80161fa:	605a      	str	r2, [r3, #4]
 80161fc:	e005      	b.n	801620a <sdc_lld_set_bus_mode+0x4a>
    break;
  case SDC_MODE_8BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_1;
 80161fe:	9b01      	ldr	r3, [sp, #4]
 8016200:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016202:	9a03      	ldr	r2, [sp, #12]
 8016204:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8016208:	605a      	str	r2, [r3, #4]
    break;
  }
}
 801620a:	b004      	add	sp, #16
 801620c:	4770      	bx	lr
 801620e:	bf00      	nop

08016210 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 8016210:	b084      	sub	sp, #16
 8016212:	9003      	str	r0, [sp, #12]
 8016214:	460b      	mov	r3, r1
 8016216:	9201      	str	r2, [sp, #4]
 8016218:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdio->ARG = arg;
 801621c:	9b03      	ldr	r3, [sp, #12]
 801621e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016220:	9a01      	ldr	r2, [sp, #4]
 8016222:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8016224:	9b03      	ldr	r3, [sp, #12]
 8016226:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016228:	f89d 200b 	ldrb.w	r2, [sp, #11]
 801622c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8016230:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8016232:	9b03      	ldr	r3, [sp, #12]
 8016234:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016236:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016238:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801623c:	2b00      	cmp	r3, #0
 801623e:	d0f8      	beq.n	8016232 <sdc_lld_send_cmd_none+0x22>
    ;
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8016240:	9b03      	ldr	r3, [sp, #12]
 8016242:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016244:	2280      	movs	r2, #128	; 0x80
 8016246:	639a      	str	r2, [r3, #56]	; 0x38
}
 8016248:	b004      	add	sp, #16
 801624a:	4770      	bx	lr
 801624c:	0000      	movs	r0, r0
	...

08016250 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 8016250:	b500      	push	{lr}
 8016252:	b087      	sub	sp, #28
 8016254:	9003      	str	r0, [sp, #12]
 8016256:	9201      	str	r2, [sp, #4]
 8016258:	9300      	str	r3, [sp, #0]
 801625a:	460b      	mov	r3, r1
 801625c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8016260:	9b03      	ldr	r3, [sp, #12]
 8016262:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016264:	9a01      	ldr	r2, [sp, #4]
 8016266:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8016268:	9b03      	ldr	r3, [sp, #12]
 801626a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801626c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8016270:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8016274:	b2d2      	uxtb	r2, r2
 8016276:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 801627a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 801627c:	9b03      	ldr	r3, [sp, #12]
 801627e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016280:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016282:	9305      	str	r3, [sp, #20]
 8016284:	9b05      	ldr	r3, [sp, #20]
 8016286:	f003 0345 	and.w	r3, r3, #69	; 0x45
 801628a:	2b00      	cmp	r3, #0
 801628c:	d0f6      	beq.n	801627c <sdc_lld_send_cmd_short+0x2c>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 801628e:	9b03      	ldr	r3, [sp, #12]
 8016290:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016292:	9a05      	ldr	r2, [sp, #20]
 8016294:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8016298:	639a      	str	r2, [r3, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 801629a:	9b05      	ldr	r3, [sp, #20]
 801629c:	f003 0304 	and.w	r3, r3, #4
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	d005      	beq.n	80162b0 <sdc_lld_send_cmd_short+0x60>
    sdc_lld_collect_errors(sdcp, sta);
 80162a4:	9905      	ldr	r1, [sp, #20]
 80162a6:	9803      	ldr	r0, [sp, #12]
 80162a8:	f7ff fe7a 	bl	8015fa0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 80162ac:	2301      	movs	r3, #1
 80162ae:	e005      	b.n	80162bc <sdc_lld_send_cmd_short+0x6c>
  }
  *resp = sdcp->sdio->RESP1;
 80162b0:	9b03      	ldr	r3, [sp, #12]
 80162b2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80162b4:	695a      	ldr	r2, [r3, #20]
 80162b6:	9b00      	ldr	r3, [sp, #0]
 80162b8:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 80162ba:	2300      	movs	r3, #0
}
 80162bc:	4618      	mov	r0, r3
 80162be:	b007      	add	sp, #28
 80162c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080162d0 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 80162d0:	b500      	push	{lr}
 80162d2:	b087      	sub	sp, #28
 80162d4:	9003      	str	r0, [sp, #12]
 80162d6:	9201      	str	r2, [sp, #4]
 80162d8:	9300      	str	r3, [sp, #0]
 80162da:	460b      	mov	r3, r1
 80162dc:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 80162e0:	9b03      	ldr	r3, [sp, #12]
 80162e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80162e4:	9a01      	ldr	r2, [sp, #4]
 80162e6:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 80162e8:	9b03      	ldr	r3, [sp, #12]
 80162ea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80162ec:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80162f0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80162f4:	b2d2      	uxtb	r2, r2
 80162f6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80162fa:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 80162fc:	9b03      	ldr	r3, [sp, #12]
 80162fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016300:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016302:	9305      	str	r3, [sp, #20]
 8016304:	9b05      	ldr	r3, [sp, #20]
 8016306:	f003 0345 	and.w	r3, r3, #69	; 0x45
 801630a:	2b00      	cmp	r3, #0
 801630c:	d0f6      	beq.n	80162fc <sdc_lld_send_cmd_short_crc+0x2c>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL);
 801630e:	9b03      	ldr	r3, [sp, #12]
 8016310:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016312:	9a05      	ldr	r2, [sp, #20]
 8016314:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8016318:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) != 0) {
 801631a:	9b05      	ldr	r3, [sp, #20]
 801631c:	f003 0305 	and.w	r3, r3, #5
 8016320:	2b00      	cmp	r3, #0
 8016322:	d005      	beq.n	8016330 <sdc_lld_send_cmd_short_crc+0x60>
    sdc_lld_collect_errors(sdcp, sta);
 8016324:	9905      	ldr	r1, [sp, #20]
 8016326:	9803      	ldr	r0, [sp, #12]
 8016328:	f7ff fe3a 	bl	8015fa0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 801632c:	2301      	movs	r3, #1
 801632e:	e005      	b.n	801633c <sdc_lld_send_cmd_short_crc+0x6c>
  }
  *resp = sdcp->sdio->RESP1;
 8016330:	9b03      	ldr	r3, [sp, #12]
 8016332:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016334:	695a      	ldr	r2, [r3, #20]
 8016336:	9b00      	ldr	r3, [sp, #0]
 8016338:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 801633a:	2300      	movs	r3, #0
}
 801633c:	4618      	mov	r0, r3
 801633e:	b007      	add	sp, #28
 8016340:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08016350 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 8016350:	b500      	push	{lr}
 8016352:	b087      	sub	sp, #28
 8016354:	9003      	str	r0, [sp, #12]
 8016356:	9201      	str	r2, [sp, #4]
 8016358:	9300      	str	r3, [sp, #0]
 801635a:	460b      	mov	r3, r1
 801635c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdio->ARG = arg;
 8016360:	9b03      	ldr	r3, [sp, #12]
 8016362:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016364:	9a01      	ldr	r2, [sp, #4]
 8016366:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 8016368:	9b03      	ldr	r3, [sp, #12]
 801636a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801636c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8016370:	f062 023f 	orn	r2, r2, #63	; 0x3f
 8016374:	b2d2      	uxtb	r2, r2
 8016376:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 801637a:	60da      	str	r2, [r3, #12]
                                    SDIO_CMD_CPSMEN;
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 801637c:	9b03      	ldr	r3, [sp, #12]
 801637e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016380:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016382:	9305      	str	r3, [sp, #20]
 8016384:	9b05      	ldr	r3, [sp, #20]
 8016386:	f003 0345 	and.w	r3, r3, #69	; 0x45
 801638a:	2b00      	cmp	r3, #0
 801638c:	d0f6      	beq.n	801637c <sdc_lld_send_cmd_long_crc+0x2c>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 801638e:	9b03      	ldr	r3, [sp, #12]
 8016390:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016392:	9a05      	ldr	r2, [sp, #20]
 8016394:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8016398:	639a      	str	r2, [r3, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (STM32_SDIO_STA_ERROR_MASK)) != 0) {
 801639a:	9b05      	ldr	r3, [sp, #20]
 801639c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80163a0:	2b00      	cmp	r3, #0
 80163a2:	d005      	beq.n	80163b0 <sdc_lld_send_cmd_long_crc+0x60>
    sdc_lld_collect_errors(sdcp, sta);
 80163a4:	9905      	ldr	r1, [sp, #20]
 80163a6:	9803      	ldr	r0, [sp, #12]
 80163a8:	f7ff fdfa 	bl	8015fa0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 80163ac:	2301      	movs	r3, #1
 80163ae:	e01a      	b.n	80163e6 <sdc_lld_send_cmd_long_crc+0x96>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdio->RESP4;
 80163b0:	9b00      	ldr	r3, [sp, #0]
 80163b2:	1d1a      	adds	r2, r3, #4
 80163b4:	9200      	str	r2, [sp, #0]
 80163b6:	9a03      	ldr	r2, [sp, #12]
 80163b8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80163ba:	6a12      	ldr	r2, [r2, #32]
 80163bc:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdio->RESP3;
 80163be:	9b00      	ldr	r3, [sp, #0]
 80163c0:	1d1a      	adds	r2, r3, #4
 80163c2:	9200      	str	r2, [sp, #0]
 80163c4:	9a03      	ldr	r2, [sp, #12]
 80163c6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80163c8:	69d2      	ldr	r2, [r2, #28]
 80163ca:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdio->RESP2;
 80163cc:	9b00      	ldr	r3, [sp, #0]
 80163ce:	1d1a      	adds	r2, r3, #4
 80163d0:	9200      	str	r2, [sp, #0]
 80163d2:	9a03      	ldr	r2, [sp, #12]
 80163d4:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80163d6:	6992      	ldr	r2, [r2, #24]
 80163d8:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdio->RESP1;
 80163da:	9b03      	ldr	r3, [sp, #12]
 80163dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80163de:	695a      	ldr	r2, [r3, #20]
 80163e0:	9b00      	ldr	r3, [sp, #0]
 80163e2:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 80163e4:	2300      	movs	r3, #0
}
 80163e6:	4618      	mov	r0, r3
 80163e8:	b007      	add	sp, #28
 80163ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80163ee:	bf00      	nop

080163f0 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 80163f0:	b500      	push	{lr}
 80163f2:	b087      	sub	sp, #28
 80163f4:	9003      	str	r0, [sp, #12]
 80163f6:	9102      	str	r1, [sp, #8]
 80163f8:	9201      	str	r2, [sp, #4]
 80163fa:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 80163fe:	9a01      	ldr	r2, [sp, #4]
 8016400:	9902      	ldr	r1, [sp, #8]
 8016402:	9803      	ldr	r0, [sp, #12]
 8016404:	f7ff fcb4 	bl	8015d70 <sdc_lld_prepare_read_bytes>
 8016408:	4603      	mov	r3, r0
 801640a:	2b00      	cmp	r3, #0
 801640c:	d119      	bne.n	8016442 <sdc_lld_read_special+0x52>
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 801640e:	ab05      	add	r3, sp, #20
 8016410:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8016414:	9a08      	ldr	r2, [sp, #32]
 8016416:	9803      	ldr	r0, [sp, #12]
 8016418:	f7ff ff5a 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801641c:	4603      	mov	r3, r0
 801641e:	2b00      	cmp	r3, #0
 8016420:	d10f      	bne.n	8016442 <sdc_lld_read_special+0x52>
                                 || MMCSD_R1_ERROR(resp[0]))
 8016422:	9a05      	ldr	r2, [sp, #20]
 8016424:	4b0c      	ldr	r3, [pc, #48]	; (8016458 <sdc_lld_read_special+0x68>)
 8016426:	4013      	ands	r3, r2
 8016428:	2b00      	cmp	r3, #0
 801642a:	d10a      	bne.n	8016442 <sdc_lld_read_special+0x52>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 801642c:	ab05      	add	r3, sp, #20
 801642e:	461a      	mov	r2, r3
 8016430:	2101      	movs	r1, #1
 8016432:	9803      	ldr	r0, [sp, #12]
 8016434:	f7ff fd64 	bl	8015f00 <sdc_lld_wait_transaction_end>
 8016438:	4603      	mov	r3, r0
 801643a:	2b00      	cmp	r3, #0
 801643c:	d101      	bne.n	8016442 <sdc_lld_read_special+0x52>
    goto error;

  return HAL_SUCCESS;
 801643e:	2300      	movs	r3, #0
 8016440:	e006      	b.n	8016450 <sdc_lld_read_special+0x60>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 8016442:	ab05      	add	r3, sp, #20
 8016444:	461a      	mov	r2, r3
 8016446:	2101      	movs	r1, #1
 8016448:	9803      	ldr	r0, [sp, #12]
 801644a:	f7ff fdf9 	bl	8016040 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 801644e:	2301      	movs	r3, #1
}
 8016450:	4618      	mov	r0, r3
 8016452:	b007      	add	sp, #28
 8016454:	f85d fb04 	ldr.w	pc, [sp], #4
 8016458:	fdffe008 	.word	0xfdffe008
 801645c:	00000000 	.word	0x00000000

08016460 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 8016460:	b500      	push	{lr}
 8016462:	b087      	sub	sp, #28
 8016464:	9003      	str	r0, [sp, #12]
 8016466:	9102      	str	r1, [sp, #8]
 8016468:	9201      	str	r2, [sp, #4]
 801646a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 801646c:	9b03      	ldr	r3, [sp, #12]
 801646e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016470:	4a2b      	ldr	r2, [pc, #172]	; (8016520 <sdc_lld_read_aligned+0xc0>)
 8016472:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8016474:	9803      	ldr	r0, [sp, #12]
 8016476:	f004 fa33 	bl	801a8e0 <_sdc_wait_for_transfer_state>
 801647a:	4603      	mov	r3, r0
 801647c:	2b00      	cmp	r3, #0
 801647e:	d001      	beq.n	8016484 <sdc_lld_read_aligned+0x24>
    return HAL_FAILED;
 8016480:	2301      	movs	r3, #1
 8016482:	e048      	b.n	8016516 <sdc_lld_read_aligned+0xb6>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8016484:	9b03      	ldr	r3, [sp, #12]
 8016486:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016488:	681b      	ldr	r3, [r3, #0]
 801648a:	9a01      	ldr	r2, [sp, #4]
 801648c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 801648e:	9b03      	ldr	r3, [sp, #12]
 8016490:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016492:	681b      	ldr	r3, [r3, #0]
 8016494:	9a00      	ldr	r2, [sp, #0]
 8016496:	0252      	lsls	r2, r2, #9
 8016498:	0892      	lsrs	r2, r2, #2
 801649a:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 801649c:	9b03      	ldr	r3, [sp, #12]
 801649e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80164a0:	681b      	ldr	r3, [r3, #0]
 80164a2:	9a03      	ldr	r2, [sp, #12]
 80164a4:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80164a6:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 80164a8:	9b03      	ldr	r3, [sp, #12]
 80164aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80164ac:	681b      	ldr	r3, [r3, #0]
 80164ae:	9a03      	ldr	r2, [sp, #12]
 80164b0:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80164b2:	6812      	ldr	r2, [r2, #0]
 80164b4:	6812      	ldr	r2, [r2, #0]
 80164b6:	f042 0201 	orr.w	r2, r2, #1
 80164ba:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80164bc:	9b03      	ldr	r3, [sp, #12]
 80164be:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80164c0:	4a18      	ldr	r2, [pc, #96]	; (8016524 <sdc_lld_read_aligned+0xc4>)
 80164c2:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80164c4:	9b03      	ldr	r3, [sp, #12]
 80164c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80164c8:	f240 322a 	movw	r2, #810	; 0x32a
 80164cc:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 80164ce:	9b03      	ldr	r3, [sp, #12]
 80164d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80164d2:	9a00      	ldr	r2, [sp, #0]
 80164d4:	0252      	lsls	r2, r2, #9
 80164d6:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 80164d8:	9b03      	ldr	r3, [sp, #12]
 80164da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80164dc:	229b      	movs	r2, #155	; 0x9b
 80164de:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DBLOCKSIZE_3 |
                      SDIO_DCTRL_DBLOCKSIZE_0 |
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == true)
 80164e0:	ab05      	add	r3, sp, #20
 80164e2:	9a00      	ldr	r2, [sp, #0]
 80164e4:	9902      	ldr	r1, [sp, #8]
 80164e6:	9803      	ldr	r0, [sp, #12]
 80164e8:	f7ff fc8a 	bl	8015e00 <sdc_lld_prepare_read>
 80164ec:	4603      	mov	r3, r0
 80164ee:	2b00      	cmp	r3, #0
 80164f0:	d10a      	bne.n	8016508 <sdc_lld_read_aligned+0xa8>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
 80164f2:	ab05      	add	r3, sp, #20
 80164f4:	461a      	mov	r2, r3
 80164f6:	9900      	ldr	r1, [sp, #0]
 80164f8:	9803      	ldr	r0, [sp, #12]
 80164fa:	f7ff fd01 	bl	8015f00 <sdc_lld_wait_transaction_end>
 80164fe:	4603      	mov	r3, r0
 8016500:	2b00      	cmp	r3, #0
 8016502:	d101      	bne.n	8016508 <sdc_lld_read_aligned+0xa8>
    goto error;

  return HAL_SUCCESS;
 8016504:	2300      	movs	r3, #0
 8016506:	e006      	b.n	8016516 <sdc_lld_read_aligned+0xb6>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8016508:	ab05      	add	r3, sp, #20
 801650a:	461a      	mov	r2, r3
 801650c:	9900      	ldr	r1, [sp, #0]
 801650e:	9803      	ldr	r0, [sp, #12]
 8016510:	f7ff fd96 	bl	8016040 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8016514:	2301      	movs	r3, #1
}
 8016516:	4618      	mov	r0, r3
 8016518:	b007      	add	sp, #28
 801651a:	f85d fb04 	ldr.w	pc, [sp], #4
 801651e:	bf00      	nop
 8016520:	016e3600 	.word	0x016e3600
 8016524:	00c007ff 	.word	0x00c007ff
	...

08016530 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 8016530:	b500      	push	{lr}
 8016532:	b087      	sub	sp, #28
 8016534:	9003      	str	r0, [sp, #12]
 8016536:	9102      	str	r1, [sp, #8]
 8016538:	9201      	str	r2, [sp, #4]
 801653a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 801653c:	9b03      	ldr	r3, [sp, #12]
 801653e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016540:	4a2c      	ldr	r2, [pc, #176]	; (80165f4 <sdc_lld_write_aligned+0xc4>)
 8016542:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8016544:	9803      	ldr	r0, [sp, #12]
 8016546:	f004 f9cb 	bl	801a8e0 <_sdc_wait_for_transfer_state>
 801654a:	4603      	mov	r3, r0
 801654c:	2b00      	cmp	r3, #0
 801654e:	d001      	beq.n	8016554 <sdc_lld_write_aligned+0x24>
    return HAL_FAILED;
 8016550:	2301      	movs	r3, #1
 8016552:	e04a      	b.n	80165ea <sdc_lld_write_aligned+0xba>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8016554:	9b03      	ldr	r3, [sp, #12]
 8016556:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016558:	681b      	ldr	r3, [r3, #0]
 801655a:	9a01      	ldr	r2, [sp, #4]
 801655c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 801655e:	9b03      	ldr	r3, [sp, #12]
 8016560:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016562:	681b      	ldr	r3, [r3, #0]
 8016564:	9a00      	ldr	r2, [sp, #0]
 8016566:	0252      	lsls	r2, r2, #9
 8016568:	0892      	lsrs	r2, r2, #2
 801656a:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 801656c:	9b03      	ldr	r3, [sp, #12]
 801656e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016570:	681b      	ldr	r3, [r3, #0]
 8016572:	9a03      	ldr	r2, [sp, #12]
 8016574:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8016576:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801657a:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 801657c:	9b03      	ldr	r3, [sp, #12]
 801657e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016580:	681b      	ldr	r3, [r3, #0]
 8016582:	9a03      	ldr	r2, [sp, #12]
 8016584:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8016586:	6812      	ldr	r2, [r2, #0]
 8016588:	6812      	ldr	r2, [r2, #0]
 801658a:	f042 0201 	orr.w	r2, r2, #1
 801658e:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8016590:	9b03      	ldr	r3, [sp, #12]
 8016592:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016594:	4a18      	ldr	r2, [pc, #96]	; (80165f8 <sdc_lld_write_aligned+0xc8>)
 8016596:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8016598:	9b03      	ldr	r3, [sp, #12]
 801659a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801659c:	f240 321a 	movw	r2, #794	; 0x31a
 80165a0:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_TXUNDERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 80165a2:	9b03      	ldr	r3, [sp, #12]
 80165a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80165a6:	9a00      	ldr	r2, [sp, #0]
 80165a8:	0252      	lsls	r2, r2, #9
 80165aa:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == true)
 80165ac:	ab05      	add	r3, sp, #20
 80165ae:	9a00      	ldr	r2, [sp, #0]
 80165b0:	9902      	ldr	r1, [sp, #8]
 80165b2:	9803      	ldr	r0, [sp, #12]
 80165b4:	f7ff fc64 	bl	8015e80 <sdc_lld_prepare_write>
 80165b8:	4603      	mov	r3, r0
 80165ba:	2b00      	cmp	r3, #0
 80165bc:	d10e      	bne.n	80165dc <sdc_lld_write_aligned+0xac>
    goto error;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DBLOCKSIZE_3 |
 80165be:	9b03      	ldr	r3, [sp, #12]
 80165c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80165c2:	2299      	movs	r2, #153	; 0x99
 80165c4:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DBLOCKSIZE_0 |
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
 80165c6:	ab05      	add	r3, sp, #20
 80165c8:	461a      	mov	r2, r3
 80165ca:	9900      	ldr	r1, [sp, #0]
 80165cc:	9803      	ldr	r0, [sp, #12]
 80165ce:	f7ff fc97 	bl	8015f00 <sdc_lld_wait_transaction_end>
 80165d2:	4603      	mov	r3, r0
 80165d4:	2b00      	cmp	r3, #0
 80165d6:	d101      	bne.n	80165dc <sdc_lld_write_aligned+0xac>
    goto error;

  return HAL_SUCCESS;
 80165d8:	2300      	movs	r3, #0
 80165da:	e006      	b.n	80165ea <sdc_lld_write_aligned+0xba>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 80165dc:	ab05      	add	r3, sp, #20
 80165de:	461a      	mov	r2, r3
 80165e0:	9900      	ldr	r1, [sp, #0]
 80165e2:	9803      	ldr	r0, [sp, #12]
 80165e4:	f7ff fd2c 	bl	8016040 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 80165e8:	2301      	movs	r3, #1
}
 80165ea:	4618      	mov	r0, r3
 80165ec:	b007      	add	sp, #28
 80165ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80165f2:	bf00      	nop
 80165f4:	016e3600 	.word	0x016e3600
 80165f8:	00c007ff 	.word	0x00c007ff
 80165fc:	00000000 	.word	0x00000000

08016600 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 8016600:	b500      	push	{lr}
 8016602:	b087      	sub	sp, #28
 8016604:	9003      	str	r0, [sp, #12]
 8016606:	9102      	str	r1, [sp, #8]
 8016608:	9201      	str	r2, [sp, #4]
 801660a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 801660c:	9b01      	ldr	r3, [sp, #4]
 801660e:	f003 0303 	and.w	r3, r3, #3
 8016612:	2b00      	cmp	r3, #0
 8016614:	d026      	beq.n	8016664 <sdc_lld_read+0x64>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 8016616:	2300      	movs	r3, #0
 8016618:	9305      	str	r3, [sp, #20]
 801661a:	e01d      	b.n	8016658 <sdc_lld_read+0x58>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 801661c:	2301      	movs	r3, #1
 801661e:	4a17      	ldr	r2, [pc, #92]	; (801667c <sdc_lld_read+0x7c>)
 8016620:	9902      	ldr	r1, [sp, #8]
 8016622:	9803      	ldr	r0, [sp, #12]
 8016624:	f7ff ff1c 	bl	8016460 <sdc_lld_read_aligned>
 8016628:	4603      	mov	r3, r0
 801662a:	2b00      	cmp	r3, #0
 801662c:	d001      	beq.n	8016632 <sdc_lld_read+0x32>
        return HAL_FAILED;
 801662e:	2301      	movs	r3, #1
 8016630:	e01f      	b.n	8016672 <sdc_lld_read+0x72>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 8016632:	9b01      	ldr	r3, [sp, #4]
 8016634:	4a11      	ldr	r2, [pc, #68]	; (801667c <sdc_lld_read+0x7c>)
 8016636:	4618      	mov	r0, r3
 8016638:	4611      	mov	r1, r2
 801663a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801663e:	461a      	mov	r2, r3
 8016640:	f7ee f86c 	bl	800471c <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 8016644:	9b01      	ldr	r3, [sp, #4]
 8016646:	f503 7300 	add.w	r3, r3, #512	; 0x200
 801664a:	9301      	str	r3, [sp, #4]
      startblk++;
 801664c:	9b02      	ldr	r3, [sp, #8]
 801664e:	3301      	adds	r3, #1
 8016650:	9302      	str	r3, [sp, #8]
    for (i = 0; i < blocks; i++) {
 8016652:	9b05      	ldr	r3, [sp, #20]
 8016654:	3301      	adds	r3, #1
 8016656:	9305      	str	r3, [sp, #20]
 8016658:	9a05      	ldr	r2, [sp, #20]
 801665a:	9b00      	ldr	r3, [sp, #0]
 801665c:	429a      	cmp	r2, r3
 801665e:	d3dd      	bcc.n	801661c <sdc_lld_read+0x1c>
    }
    return HAL_SUCCESS;
 8016660:	2300      	movs	r3, #0
 8016662:	e006      	b.n	8016672 <sdc_lld_read+0x72>
  }
#else /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  osalDbgAssert((((unsigned)buf & 3) == 0), "unaligned buffer");
#endif /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 8016664:	9b00      	ldr	r3, [sp, #0]
 8016666:	9a01      	ldr	r2, [sp, #4]
 8016668:	9902      	ldr	r1, [sp, #8]
 801666a:	9803      	ldr	r0, [sp, #12]
 801666c:	f7ff fef8 	bl	8016460 <sdc_lld_read_aligned>
 8016670:	4603      	mov	r3, r0
}
 8016672:	4618      	mov	r0, r3
 8016674:	b007      	add	sp, #28
 8016676:	f85d fb04 	ldr.w	pc, [sp], #4
 801667a:	bf00      	nop
 801667c:	200050e4 	.word	0x200050e4

08016680 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 8016680:	b500      	push	{lr}
 8016682:	b087      	sub	sp, #28
 8016684:	9003      	str	r0, [sp, #12]
 8016686:	9102      	str	r1, [sp, #8]
 8016688:	9201      	str	r2, [sp, #4]
 801668a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 801668c:	9b01      	ldr	r3, [sp, #4]
 801668e:	f003 0303 	and.w	r3, r3, #3
 8016692:	2b00      	cmp	r3, #0
 8016694:	d026      	beq.n	80166e4 <sdc_lld_write+0x64>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 8016696:	2300      	movs	r3, #0
 8016698:	9305      	str	r3, [sp, #20]
 801669a:	e01d      	b.n	80166d8 <sdc_lld_write+0x58>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 801669c:	4a17      	ldr	r2, [pc, #92]	; (80166fc <sdc_lld_write+0x7c>)
 801669e:	9b01      	ldr	r3, [sp, #4]
 80166a0:	4610      	mov	r0, r2
 80166a2:	4619      	mov	r1, r3
 80166a4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80166a8:	461a      	mov	r2, r3
 80166aa:	f7ee f837 	bl	800471c <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 80166ae:	9b01      	ldr	r3, [sp, #4]
 80166b0:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80166b4:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 80166b6:	2301      	movs	r3, #1
 80166b8:	4a10      	ldr	r2, [pc, #64]	; (80166fc <sdc_lld_write+0x7c>)
 80166ba:	9902      	ldr	r1, [sp, #8]
 80166bc:	9803      	ldr	r0, [sp, #12]
 80166be:	f7ff ff37 	bl	8016530 <sdc_lld_write_aligned>
 80166c2:	4603      	mov	r3, r0
 80166c4:	2b00      	cmp	r3, #0
 80166c6:	d001      	beq.n	80166cc <sdc_lld_write+0x4c>
        return HAL_FAILED;
 80166c8:	2301      	movs	r3, #1
 80166ca:	e012      	b.n	80166f2 <sdc_lld_write+0x72>
      startblk++;
 80166cc:	9b02      	ldr	r3, [sp, #8]
 80166ce:	3301      	adds	r3, #1
 80166d0:	9302      	str	r3, [sp, #8]
    for (i = 0; i < blocks; i++) {
 80166d2:	9b05      	ldr	r3, [sp, #20]
 80166d4:	3301      	adds	r3, #1
 80166d6:	9305      	str	r3, [sp, #20]
 80166d8:	9a05      	ldr	r2, [sp, #20]
 80166da:	9b00      	ldr	r3, [sp, #0]
 80166dc:	429a      	cmp	r2, r3
 80166de:	d3dd      	bcc.n	801669c <sdc_lld_write+0x1c>
    }
    return HAL_SUCCESS;
 80166e0:	2300      	movs	r3, #0
 80166e2:	e006      	b.n	80166f2 <sdc_lld_write+0x72>
  }
#else /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  osalDbgAssert((((unsigned)buf & 3) == 0), "unaligned buffer");
#endif /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 80166e4:	9b00      	ldr	r3, [sp, #0]
 80166e6:	9a01      	ldr	r2, [sp, #4]
 80166e8:	9902      	ldr	r1, [sp, #8]
 80166ea:	9803      	ldr	r0, [sp, #12]
 80166ec:	f7ff ff20 	bl	8016530 <sdc_lld_write_aligned>
 80166f0:	4603      	mov	r3, r0
}
 80166f2:	4618      	mov	r0, r3
 80166f4:	b007      	add	sp, #28
 80166f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80166fa:	bf00      	nop
 80166fc:	200050e4 	.word	0x200050e4

08016700 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 8016700:	b082      	sub	sp, #8
 8016702:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 8016704:	2300      	movs	r3, #0
}
 8016706:	4618      	mov	r0, r3
 8016708:	b002      	add	sp, #8
 801670a:	4770      	bx	lr
 801670c:	0000      	movs	r0, r0
	...

08016710 <port_lock.lto_priv.738>:
static inline void port_lock(void) {
 8016710:	b082      	sub	sp, #8
 8016712:	2320      	movs	r3, #32
 8016714:	9301      	str	r3, [sp, #4]
 8016716:	9b01      	ldr	r3, [sp, #4]
 8016718:	f383 8811 	msr	BASEPRI, r3
}
 801671c:	b002      	add	sp, #8
 801671e:	4770      	bx	lr

08016720 <port_unlock.lto_priv.734>:
static inline void port_unlock(void) {
 8016720:	b082      	sub	sp, #8
 8016722:	2300      	movs	r3, #0
 8016724:	9301      	str	r3, [sp, #4]
 8016726:	9b01      	ldr	r3, [sp, #4]
 8016728:	f383 8811 	msr	BASEPRI, r3
}
 801672c:	b002      	add	sp, #8
 801672e:	4770      	bx	lr

08016730 <port_lock_from_isr.lto_priv.730>:
static inline void port_lock_from_isr(void) {
 8016730:	b508      	push	{r3, lr}
  port_lock();
 8016732:	f7ff ffed 	bl	8016710 <port_lock.lto_priv.738>
}
 8016736:	bd08      	pop	{r3, pc}
	...

08016740 <port_unlock_from_isr.lto_priv.726>:
static inline void port_unlock_from_isr(void) {
 8016740:	b508      	push	{r3, lr}
  port_unlock();
 8016742:	f7ff ffed 	bl	8016720 <port_unlock.lto_priv.734>
}
 8016746:	bd08      	pop	{r3, pc}
	...

08016750 <chSysLockFromISR.lto_priv.755>:
static inline void chSysLockFromISR(void) {
 8016750:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8016752:	f7ff ffed 	bl	8016730 <port_lock_from_isr.lto_priv.730>
}
 8016756:	bd08      	pop	{r3, pc}
	...

08016760 <chSysUnlockFromISR.lto_priv.752>:
static inline void chSysUnlockFromISR(void) {
 8016760:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8016762:	f7ff ffed 	bl	8016740 <port_unlock_from_isr.lto_priv.726>
}
 8016766:	bd08      	pop	{r3, pc}
	...

08016770 <osalSysLockFromISR.lto_priv.749>:
static inline void osalSysLockFromISR(void) {
 8016770:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8016772:	f7ff ffed 	bl	8016750 <chSysLockFromISR.lto_priv.755>
}
 8016776:	bd08      	pop	{r3, pc}
	...

08016780 <osalSysUnlockFromISR.lto_priv.745>:
static inline void osalSysUnlockFromISR(void) {
 8016780:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8016782:	f7ff ffed 	bl	8016760 <chSysUnlockFromISR.lto_priv.752>
}
 8016786:	bd08      	pop	{r3, pc}
	...

08016790 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8016790:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 8016792:	f7fd fb9d 	bl	8013ed0 <chSysTimerHandlerI>
}
 8016796:	bd08      	pop	{r3, pc}
	...

080167a0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80167a0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80167a2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80167a6:	691b      	ldr	r3, [r3, #16]
 80167a8:	f003 0302 	and.w	r3, r3, #2
 80167ac:	2b00      	cmp	r3, #0
 80167ae:	d009      	beq.n	80167c4 <VectorB0+0x24>
    STM32_ST_TIM->SR = 0U;
 80167b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80167b4:	2200      	movs	r2, #0
 80167b6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80167b8:	f7ff ffda 	bl	8016770 <osalSysLockFromISR.lto_priv.749>
    osalOsTimerHandlerI();
 80167bc:	f7ff ffe8 	bl	8016790 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80167c0:	f7ff ffde 	bl	8016780 <osalSysUnlockFromISR.lto_priv.745>
  }

  OSAL_IRQ_EPILOGUE();
 80167c4:	f7fc ff64 	bl	8013690 <_port_irq_epilogue>
}
 80167c8:	bd08      	pop	{r3, pc}
 80167ca:	bf00      	nop
 80167cc:	0000      	movs	r0, r0
	...

080167d0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80167d0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80167d2:	4a1c      	ldr	r2, [pc, #112]	; (8016844 <st_lld_init+0x74>)
 80167d4:	4b1b      	ldr	r3, [pc, #108]	; (8016844 <st_lld_init+0x74>)
 80167d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80167d8:	f043 0301 	orr.w	r3, r3, #1
 80167dc:	6413      	str	r3, [r2, #64]	; 0x40
 80167de:	4a19      	ldr	r2, [pc, #100]	; (8016844 <st_lld_init+0x74>)
 80167e0:	4b18      	ldr	r3, [pc, #96]	; (8016844 <st_lld_init+0x74>)
 80167e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80167e4:	f043 0301 	orr.w	r3, r3, #1
 80167e8:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80167ea:	4a17      	ldr	r2, [pc, #92]	; (8016848 <st_lld_init+0x78>)
 80167ec:	4b16      	ldr	r3, [pc, #88]	; (8016848 <st_lld_init+0x78>)
 80167ee:	689b      	ldr	r3, [r3, #8]
 80167f0:	f043 0301 	orr.w	r3, r3, #1
 80167f4:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80167f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80167fa:	f242 02cf 	movw	r2, #8399	; 0x20cf
 80167fe:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8016800:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8016804:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8016808:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 801680a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801680e:	2200      	movs	r2, #0
 8016810:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8016812:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8016816:	2200      	movs	r2, #0
 8016818:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 801681a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801681e:	2200      	movs	r2, #0
 8016820:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8016822:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8016826:	2200      	movs	r2, #0
 8016828:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 801682a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801682e:	2201      	movs	r2, #1
 8016830:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8016832:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8016836:	2201      	movs	r2, #1
 8016838:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 801683a:	2108      	movs	r1, #8
 801683c:	201c      	movs	r0, #28
 801683e:	f002 ffdf 	bl	8019800 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8016842:	bd08      	pop	{r3, pc}
 8016844:	40023800 	.word	0x40023800
 8016848:	e0042000 	.word	0xe0042000
 801684c:	00000000 	.word	0x00000000

08016850 <port_lock.lto_priv.739>:
static inline void port_lock(void) {
 8016850:	b082      	sub	sp, #8
 8016852:	2320      	movs	r3, #32
 8016854:	9301      	str	r3, [sp, #4]
 8016856:	9b01      	ldr	r3, [sp, #4]
 8016858:	f383 8811 	msr	BASEPRI, r3
}
 801685c:	b002      	add	sp, #8
 801685e:	4770      	bx	lr

08016860 <port_unlock.lto_priv.735>:
static inline void port_unlock(void) {
 8016860:	b082      	sub	sp, #8
 8016862:	2300      	movs	r3, #0
 8016864:	9301      	str	r3, [sp, #4]
 8016866:	9b01      	ldr	r3, [sp, #4]
 8016868:	f383 8811 	msr	BASEPRI, r3
}
 801686c:	b002      	add	sp, #8
 801686e:	4770      	bx	lr

08016870 <port_lock_from_isr.lto_priv.731>:
static inline void port_lock_from_isr(void) {
 8016870:	b508      	push	{r3, lr}
  port_lock();
 8016872:	f7ff ffed 	bl	8016850 <port_lock.lto_priv.739>
}
 8016876:	bd08      	pop	{r3, pc}
	...

08016880 <port_unlock_from_isr.lto_priv.727>:
static inline void port_unlock_from_isr(void) {
 8016880:	b508      	push	{r3, lr}
  port_unlock();
 8016882:	f7ff ffed 	bl	8016860 <port_unlock.lto_priv.735>
}
 8016886:	bd08      	pop	{r3, pc}
	...

08016890 <chSysLockFromISR.lto_priv.756>:
static inline void chSysLockFromISR(void) {
 8016890:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8016892:	f7ff ffed 	bl	8016870 <port_lock_from_isr.lto_priv.731>
}
 8016896:	bd08      	pop	{r3, pc}
	...

080168a0 <chSysUnlockFromISR.lto_priv.753>:
static inline void chSysUnlockFromISR(void) {
 80168a0:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 80168a2:	f7ff ffed 	bl	8016880 <port_unlock_from_isr.lto_priv.727>
}
 80168a6:	bd08      	pop	{r3, pc}
	...

080168b0 <osalSysLockFromISR.lto_priv.750>:
static inline void osalSysLockFromISR(void) {
 80168b0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80168b2:	f7ff ffed 	bl	8016890 <chSysLockFromISR.lto_priv.756>
}
 80168b6:	bd08      	pop	{r3, pc}
	...

080168c0 <osalSysUnlockFromISR.lto_priv.746>:
static inline void osalSysUnlockFromISR(void) {
 80168c0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80168c2:	f7ff ffed 	bl	80168a0 <chSysUnlockFromISR.lto_priv.753>
}
 80168c6:	bd08      	pop	{r3, pc}
	...

080168d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80168d0:	b500      	push	{lr}
 80168d2:	b083      	sub	sp, #12
 80168d4:	9001      	str	r0, [sp, #4]
 80168d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80168d8:	9900      	ldr	r1, [sp, #0]
 80168da:	9801      	ldr	r0, [sp, #4]
 80168dc:	f7fc fbe8 	bl	80130b0 <chEvtBroadcastFlagsI>
}
 80168e0:	b003      	add	sp, #12
 80168e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80168e6:	bf00      	nop
	...

080168f0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 80168f0:	b084      	sub	sp, #16
 80168f2:	9001      	str	r0, [sp, #4]
 80168f4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 80168f6:	9b01      	ldr	r3, [sp, #4]
 80168f8:	f8d3 3854 	ldr.w	r3, [r3, #2132]	; 0x854
 80168fc:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 80168fe:	9b01      	ldr	r3, [sp, #4]
 8016900:	f8d3 3854 	ldr.w	r3, [r3, #2132]	; 0x854
 8016904:	4a25      	ldr	r2, [pc, #148]	; (801699c <usart_init+0xac>)
 8016906:	4293      	cmp	r3, r2
 8016908:	d005      	beq.n	8016916 <usart_init+0x26>
 801690a:	9b01      	ldr	r3, [sp, #4]
 801690c:	f8d3 3854 	ldr.w	r3, [r3, #2132]	; 0x854
 8016910:	4a23      	ldr	r2, [pc, #140]	; (80169a0 <usart_init+0xb0>)
 8016912:	4293      	cmp	r3, r2
 8016914:	d107      	bne.n	8016926 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8016916:	9b00      	ldr	r3, [sp, #0]
 8016918:	681b      	ldr	r3, [r3, #0]
 801691a:	4a22      	ldr	r2, [pc, #136]	; (80169a4 <usart_init+0xb4>)
 801691c:	fbb2 f2f3 	udiv	r2, r2, r3
 8016920:	9b03      	ldr	r3, [sp, #12]
 8016922:	609a      	str	r2, [r3, #8]
 8016924:	e006      	b.n	8016934 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8016926:	9b00      	ldr	r3, [sp, #0]
 8016928:	681b      	ldr	r3, [r3, #0]
 801692a:	4a1f      	ldr	r2, [pc, #124]	; (80169a8 <usart_init+0xb8>)
 801692c:	fbb2 f2f3 	udiv	r2, r2, r3
 8016930:	9b03      	ldr	r3, [sp, #12]
 8016932:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8016934:	9b00      	ldr	r3, [sp, #0]
 8016936:	88db      	ldrh	r3, [r3, #6]
 8016938:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801693c:	b29b      	uxth	r3, r3
 801693e:	461a      	mov	r2, r3
 8016940:	9b03      	ldr	r3, [sp, #12]
 8016942:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8016944:	9b00      	ldr	r3, [sp, #0]
 8016946:	891b      	ldrh	r3, [r3, #8]
 8016948:	f043 0301 	orr.w	r3, r3, #1
 801694c:	b29b      	uxth	r3, r3
 801694e:	461a      	mov	r2, r3
 8016950:	9b03      	ldr	r3, [sp, #12]
 8016952:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8016954:	9b00      	ldr	r3, [sp, #0]
 8016956:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8016958:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 801695c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8016960:	b29b      	uxth	r3, r3
 8016962:	461a      	mov	r2, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8016964:	9b03      	ldr	r3, [sp, #12]
 8016966:	60da      	str	r2, [r3, #12]
                         USART_CR1_RE;
  u->SR = 0;
 8016968:	9b03      	ldr	r3, [sp, #12]
 801696a:	2200      	movs	r2, #0
 801696c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 801696e:	9b03      	ldr	r3, [sp, #12]
 8016970:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8016972:	9b03      	ldr	r3, [sp, #12]
 8016974:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8016976:	9b00      	ldr	r3, [sp, #0]
 8016978:	889b      	ldrh	r3, [r3, #4]
 801697a:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 801697e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8016982:	d104      	bne.n	801698e <usart_init+0x9e>
    sdp->rxmask = 0x7F;
 8016984:	9b01      	ldr	r3, [sp, #4]
 8016986:	227f      	movs	r2, #127	; 0x7f
 8016988:	f883 2858 	strb.w	r2, [r3, #2136]	; 0x858
 801698c:	e003      	b.n	8016996 <usart_init+0xa6>
  }
  else {
    sdp->rxmask = 0xFF;
 801698e:	9b01      	ldr	r3, [sp, #4]
 8016990:	22ff      	movs	r2, #255	; 0xff
 8016992:	f883 2858 	strb.w	r2, [r3, #2136]	; 0x858
  }
}
 8016996:	b004      	add	sp, #16
 8016998:	4770      	bx	lr
 801699a:	bf00      	nop
 801699c:	40011000 	.word	0x40011000
 80169a0:	40011400 	.word	0x40011400
 80169a4:	0501bd00 	.word	0x0501bd00
 80169a8:	0280de80 	.word	0x0280de80
 80169ac:	00000000 	.word	0x00000000

080169b0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 80169b0:	b500      	push	{lr}
 80169b2:	b085      	sub	sp, #20
 80169b4:	9001      	str	r0, [sp, #4]
 80169b6:	460b      	mov	r3, r1
 80169b8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 80169bc:	2300      	movs	r3, #0
 80169be:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 80169c0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80169c4:	f003 0308 	and.w	r3, r3, #8
 80169c8:	2b00      	cmp	r3, #0
 80169ca:	d003      	beq.n	80169d4 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 80169cc:	9b03      	ldr	r3, [sp, #12]
 80169ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80169d2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 80169d4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80169d8:	f003 0301 	and.w	r3, r3, #1
 80169dc:	2b00      	cmp	r3, #0
 80169de:	d003      	beq.n	80169e8 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 80169e0:	9b03      	ldr	r3, [sp, #12]
 80169e2:	f043 0320 	orr.w	r3, r3, #32
 80169e6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 80169e8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80169ec:	f003 0302 	and.w	r3, r3, #2
 80169f0:	2b00      	cmp	r3, #0
 80169f2:	d003      	beq.n	80169fc <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 80169f4:	9b03      	ldr	r3, [sp, #12]
 80169f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80169fa:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 80169fc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8016a00:	f003 0304 	and.w	r3, r3, #4
 8016a04:	2b00      	cmp	r3, #0
 8016a06:	d003      	beq.n	8016a10 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8016a08:	9b03      	ldr	r3, [sp, #12]
 8016a0a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8016a0e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8016a10:	9b01      	ldr	r3, [sp, #4]
 8016a12:	3304      	adds	r3, #4
 8016a14:	9903      	ldr	r1, [sp, #12]
 8016a16:	4618      	mov	r0, r3
 8016a18:	f7ff ff5a 	bl	80168d0 <osalEventBroadcastFlagsI>
}
 8016a1c:	b005      	add	sp, #20
 8016a1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8016a22:	bf00      	nop
	...

08016a30 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8016a30:	b500      	push	{lr}
 8016a32:	b087      	sub	sp, #28
 8016a34:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8016a36:	9b01      	ldr	r3, [sp, #4]
 8016a38:	f8d3 3854 	ldr.w	r3, [r3, #2132]	; 0x854
 8016a3c:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
 8016a3e:	9b04      	ldr	r3, [sp, #16]
 8016a40:	68db      	ldr	r3, [r3, #12]
 8016a42:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
 8016a46:	9b04      	ldr	r3, [sp, #16]
 8016a48:	681b      	ldr	r3, [r3, #0]
 8016a4a:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8016a4e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016a52:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8016a56:	2b00      	cmp	r3, #0
 8016a58:	d00e      	beq.n	8016a78 <serve_interrupt+0x48>
    osalSysLockFromISR();
 8016a5a:	f7ff ff29 	bl	80168b0 <osalSysLockFromISR.lto_priv.750>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8016a5e:	9b01      	ldr	r3, [sp, #4]
 8016a60:	3304      	adds	r3, #4
 8016a62:	f44f 7100 	mov.w	r1, #512	; 0x200
 8016a66:	4618      	mov	r0, r3
 8016a68:	f7ff ff32 	bl	80168d0 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8016a6c:	9b04      	ldr	r3, [sp, #16]
 8016a6e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8016a72:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8016a74:	f7ff ff24 	bl	80168c0 <osalSysUnlockFromISR.lto_priv.746>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8016a78:	f7ff ff1a 	bl	80168b0 <osalSysLockFromISR.lto_priv.750>
 8016a7c:	e024      	b.n	8016ac8 <serve_interrupt+0x98>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8016a7e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016a82:	f003 030f 	and.w	r3, r3, #15
 8016a86:	2b00      	cmp	r3, #0
 8016a88:	d005      	beq.n	8016a96 <serve_interrupt+0x66>
      set_error(sdp, sr);
 8016a8a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016a8e:	4619      	mov	r1, r3
 8016a90:	9801      	ldr	r0, [sp, #4]
 8016a92:	f7ff ff8d 	bl	80169b0 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8016a96:	9b04      	ldr	r3, [sp, #16]
 8016a98:	685b      	ldr	r3, [r3, #4]
 8016a9a:	b2da      	uxtb	r2, r3
 8016a9c:	9b01      	ldr	r3, [sp, #4]
 8016a9e:	f893 3858 	ldrb.w	r3, [r3, #2136]	; 0x858
 8016aa2:	4013      	ands	r3, r2
 8016aa4:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
 8016aa8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016aac:	f003 0320 	and.w	r3, r3, #32
 8016ab0:	2b00      	cmp	r3, #0
 8016ab2:	d005      	beq.n	8016ac0 <serve_interrupt+0x90>
      sdIncomingDataI(sdp, b);
 8016ab4:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016ab8:	4619      	mov	r1, r3
 8016aba:	9801      	ldr	r0, [sp, #4]
 8016abc:	f002 f840 	bl	8018b40 <sdIncomingDataI>
    sr = u->SR;
 8016ac0:	9b04      	ldr	r3, [sp, #16]
 8016ac2:	681b      	ldr	r3, [r3, #0]
 8016ac4:	f8ad 3016 	strh.w	r3, [sp, #22]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8016ac8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016acc:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8016ad0:	2b00      	cmp	r3, #0
 8016ad2:	d1d4      	bne.n	8016a7e <serve_interrupt+0x4e>
  }
  osalSysUnlockFromISR();
 8016ad4:	f7ff fef4 	bl	80168c0 <osalSysUnlockFromISR.lto_priv.746>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8016ad8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8016adc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8016ae0:	2b00      	cmp	r3, #0
 8016ae2:	d024      	beq.n	8016b2e <serve_interrupt+0xfe>
 8016ae4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016ae8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8016aec:	2b00      	cmp	r3, #0
 8016aee:	d01e      	beq.n	8016b2e <serve_interrupt+0xfe>
    msg_t b;
    osalSysLockFromISR();
 8016af0:	f7ff fede 	bl	80168b0 <osalSysLockFromISR.lto_priv.750>
    b = oqGetI(&sdp->oqueue);
 8016af4:	9b01      	ldr	r3, [sp, #4]
 8016af6:	3330      	adds	r3, #48	; 0x30
 8016af8:	4618      	mov	r0, r3
 8016afa:	f003 fa59 	bl	8019fb0 <oqGetI>
 8016afe:	9002      	str	r0, [sp, #8]
    if (b < MSG_OK) {
 8016b00:	9b02      	ldr	r3, [sp, #8]
 8016b02:	2b00      	cmp	r3, #0
 8016b04:	da0e      	bge.n	8016b24 <serve_interrupt+0xf4>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8016b06:	9b01      	ldr	r3, [sp, #4]
 8016b08:	3304      	adds	r3, #4
 8016b0a:	2108      	movs	r1, #8
 8016b0c:	4618      	mov	r0, r3
 8016b0e:	f7ff fedf 	bl	80168d0 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8016b12:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8016b16:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8016b1a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8016b1e:	9b04      	ldr	r3, [sp, #16]
 8016b20:	60da      	str	r2, [r3, #12]
 8016b22:	e002      	b.n	8016b2a <serve_interrupt+0xfa>
    }
    else
      u->DR = b;
 8016b24:	9a02      	ldr	r2, [sp, #8]
 8016b26:	9b04      	ldr	r3, [sp, #16]
 8016b28:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8016b2a:	f7ff fec9 	bl	80168c0 <osalSysUnlockFromISR.lto_priv.746>
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8016b2e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8016b32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016b36:	2b00      	cmp	r3, #0
 8016b38:	d027      	beq.n	8016b8a <serve_interrupt+0x15a>
 8016b3a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8016b3e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016b42:	2b00      	cmp	r3, #0
 8016b44:	d021      	beq.n	8016b8a <serve_interrupt+0x15a>
    osalSysLockFromISR();
 8016b46:	f7ff feb3 	bl	80168b0 <osalSysLockFromISR.lto_priv.750>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8016b4a:	9b01      	ldr	r3, [sp, #4]
 8016b4c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8016b4e:	9b01      	ldr	r3, [sp, #4]
 8016b50:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8016b52:	429a      	cmp	r2, r3
 8016b54:	d105      	bne.n	8016b62 <serve_interrupt+0x132>
 8016b56:	9b01      	ldr	r3, [sp, #4]
 8016b58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8016b5a:	2b00      	cmp	r3, #0
 8016b5c:	d001      	beq.n	8016b62 <serve_interrupt+0x132>
 8016b5e:	2301      	movs	r3, #1
 8016b60:	e000      	b.n	8016b64 <serve_interrupt+0x134>
 8016b62:	2300      	movs	r3, #0
 8016b64:	f003 0301 	and.w	r3, r3, #1
 8016b68:	b2db      	uxtb	r3, r3
 8016b6a:	2b00      	cmp	r3, #0
 8016b6c:	d00b      	beq.n	8016b86 <serve_interrupt+0x156>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8016b6e:	9b01      	ldr	r3, [sp, #4]
 8016b70:	3304      	adds	r3, #4
 8016b72:	2110      	movs	r1, #16
 8016b74:	4618      	mov	r0, r3
 8016b76:	f7ff feab 	bl	80168d0 <osalEventBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8016b7a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8016b7e:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8016b82:	9b04      	ldr	r3, [sp, #16]
 8016b84:	60da      	str	r2, [r3, #12]
    }
    osalSysUnlockFromISR();
 8016b86:	f7ff fe9b 	bl	80168c0 <osalSysUnlockFromISR.lto_priv.746>
  }
}
 8016b8a:	b007      	add	sp, #28
 8016b8c:	f85d fb04 	ldr.w	pc, [sp], #4

08016b90 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8016b90:	b082      	sub	sp, #8
 8016b92:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8016b94:	4a03      	ldr	r2, [pc, #12]	; (8016ba4 <notify1+0x14>)
 8016b96:	4b03      	ldr	r3, [pc, #12]	; (8016ba4 <notify1+0x14>)
 8016b98:	68db      	ldr	r3, [r3, #12]
 8016b9a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016b9e:	60d3      	str	r3, [r2, #12]
}
 8016ba0:	b002      	add	sp, #8
 8016ba2:	4770      	bx	lr
 8016ba4:	40011000 	.word	0x40011000
	...

08016bb0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8016bb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
 8016bb2:	4803      	ldr	r0, [pc, #12]	; (8016bc0 <VectorD4+0x10>)
 8016bb4:	f7ff ff3c 	bl	8016a30 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8016bb8:	f7fc fd6a 	bl	8013690 <_port_irq_epilogue>
}
 8016bbc:	bd08      	pop	{r3, pc}
 8016bbe:	bf00      	nop
 8016bc0:	200052e4 	.word	0x200052e4
	...

08016bd0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8016bd0:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8016bd2:	4a05      	ldr	r2, [pc, #20]	; (8016be8 <sd_lld_init+0x18>)
 8016bd4:	2100      	movs	r1, #0
 8016bd6:	4805      	ldr	r0, [pc, #20]	; (8016bec <sd_lld_init+0x1c>)
 8016bd8:	f001 ff6a 	bl	8018ab0 <sdObjectInit>
  SD1.usart = USART1;
 8016bdc:	4b03      	ldr	r3, [pc, #12]	; (8016bec <sd_lld_init+0x1c>)
 8016bde:	4a04      	ldr	r2, [pc, #16]	; (8016bf0 <sd_lld_init+0x20>)
 8016be0:	f8c3 2854 	str.w	r2, [r3, #2132]	; 0x854

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 8016be4:	bd08      	pop	{r3, pc}
 8016be6:	bf00      	nop
 8016be8:	08016b91 	.word	0x08016b91
 8016bec:	200052e4 	.word	0x200052e4
 8016bf0:	40011000 	.word	0x40011000
	...

08016c00 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8016c00:	b500      	push	{lr}
 8016c02:	b083      	sub	sp, #12
 8016c04:	9001      	str	r0, [sp, #4]
 8016c06:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8016c08:	9b00      	ldr	r3, [sp, #0]
 8016c0a:	2b00      	cmp	r3, #0
 8016c0c:	d101      	bne.n	8016c12 <sd_lld_start+0x12>
    config = &default_config;
 8016c0e:	4b10      	ldr	r3, [pc, #64]	; (8016c50 <sd_lld_start+0x50>)
 8016c10:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8016c12:	9b01      	ldr	r3, [sp, #4]
 8016c14:	7a1b      	ldrb	r3, [r3, #8]
 8016c16:	2b01      	cmp	r3, #1
 8016c18:	d113      	bne.n	8016c42 <sd_lld_start+0x42>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8016c1a:	9b01      	ldr	r3, [sp, #4]
 8016c1c:	4a0d      	ldr	r2, [pc, #52]	; (8016c54 <sd_lld_start+0x54>)
 8016c1e:	4293      	cmp	r3, r2
 8016c20:	d10f      	bne.n	8016c42 <sd_lld_start+0x42>
      rccEnableUSART1(true);
 8016c22:	4a0d      	ldr	r2, [pc, #52]	; (8016c58 <sd_lld_start+0x58>)
 8016c24:	4b0c      	ldr	r3, [pc, #48]	; (8016c58 <sd_lld_start+0x58>)
 8016c26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016c28:	f043 0310 	orr.w	r3, r3, #16
 8016c2c:	6453      	str	r3, [r2, #68]	; 0x44
 8016c2e:	4a0a      	ldr	r2, [pc, #40]	; (8016c58 <sd_lld_start+0x58>)
 8016c30:	4b09      	ldr	r3, [pc, #36]	; (8016c58 <sd_lld_start+0x58>)
 8016c32:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8016c34:	f043 0310 	orr.w	r3, r3, #16
 8016c38:	6653      	str	r3, [r2, #100]	; 0x64
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8016c3a:	210c      	movs	r1, #12
 8016c3c:	2025      	movs	r0, #37	; 0x25
 8016c3e:	f002 fddf 	bl	8019800 <nvicEnableVector>
      rccEnableUART8(true);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8016c42:	9900      	ldr	r1, [sp, #0]
 8016c44:	9801      	ldr	r0, [sp, #4]
 8016c46:	f7ff fe53 	bl	80168f0 <usart_init>
}
 8016c4a:	b003      	add	sp, #12
 8016c4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8016c50:	080230e0 	.word	0x080230e0
 8016c54:	200052e4 	.word	0x200052e4
 8016c58:	40023800 	.word	0x40023800
 8016c5c:	00000000 	.word	0x00000000

08016c60 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8016c60:	b082      	sub	sp, #8
 8016c62:	9001      	str	r0, [sp, #4]
 8016c64:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8016c66:	9b00      	ldr	r3, [sp, #0]
 8016c68:	685a      	ldr	r2, [r3, #4]
 8016c6a:	9b01      	ldr	r3, [sp, #4]
 8016c6c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8016c6e:	9b00      	ldr	r3, [sp, #0]
 8016c70:	689a      	ldr	r2, [r3, #8]
 8016c72:	9b01      	ldr	r3, [sp, #4]
 8016c74:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8016c76:	9b00      	ldr	r3, [sp, #0]
 8016c78:	68da      	ldr	r2, [r3, #12]
 8016c7a:	9b01      	ldr	r3, [sp, #4]
 8016c7c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8016c7e:	9b00      	ldr	r3, [sp, #0]
 8016c80:	691a      	ldr	r2, [r3, #16]
 8016c82:	9b01      	ldr	r3, [sp, #4]
 8016c84:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8016c86:	9b00      	ldr	r3, [sp, #0]
 8016c88:	695a      	ldr	r2, [r3, #20]
 8016c8a:	9b01      	ldr	r3, [sp, #4]
 8016c8c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8016c8e:	9b00      	ldr	r3, [sp, #0]
 8016c90:	699a      	ldr	r2, [r3, #24]
 8016c92:	9b01      	ldr	r3, [sp, #4]
 8016c94:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8016c96:	9b00      	ldr	r3, [sp, #0]
 8016c98:	681a      	ldr	r2, [r3, #0]
 8016c9a:	9b01      	ldr	r3, [sp, #4]
 8016c9c:	601a      	str	r2, [r3, #0]
}
 8016c9e:	b002      	add	sp, #8
 8016ca0:	4770      	bx	lr
 8016ca2:	bf00      	nop
	...

08016cb0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8016cb0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8016cb2:	4a20      	ldr	r2, [pc, #128]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cb4:	4b1f      	ldr	r3, [pc, #124]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cb6:	691b      	ldr	r3, [r3, #16]
 8016cb8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8016cbc:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8016cc0:	6113      	str	r3, [r2, #16]
 8016cc2:	4b1c      	ldr	r3, [pc, #112]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cc4:	2200      	movs	r2, #0
 8016cc6:	611a      	str	r2, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8016cc8:	4a1a      	ldr	r2, [pc, #104]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cca:	4b1a      	ldr	r3, [pc, #104]	; (8016d34 <stm32_gpio_init+0x84>)
 8016ccc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016cce:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8016cd2:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8016cd6:	6313      	str	r3, [r2, #48]	; 0x30
 8016cd8:	4a16      	ldr	r2, [pc, #88]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cda:	4b16      	ldr	r3, [pc, #88]	; (8016d34 <stm32_gpio_init+0x84>)
 8016cdc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016cde:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8016ce2:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8016ce6:	6513      	str	r3, [r2, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8016ce8:	4913      	ldr	r1, [pc, #76]	; (8016d38 <stm32_gpio_init+0x88>)
 8016cea:	4814      	ldr	r0, [pc, #80]	; (8016d3c <stm32_gpio_init+0x8c>)
 8016cec:	f7ff ffb8 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8016cf0:	4913      	ldr	r1, [pc, #76]	; (8016d40 <stm32_gpio_init+0x90>)
 8016cf2:	4814      	ldr	r0, [pc, #80]	; (8016d44 <stm32_gpio_init+0x94>)
 8016cf4:	f7ff ffb4 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8016cf8:	4913      	ldr	r1, [pc, #76]	; (8016d48 <stm32_gpio_init+0x98>)
 8016cfa:	4814      	ldr	r0, [pc, #80]	; (8016d4c <stm32_gpio_init+0x9c>)
 8016cfc:	f7ff ffb0 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8016d00:	4913      	ldr	r1, [pc, #76]	; (8016d50 <stm32_gpio_init+0xa0>)
 8016d02:	4814      	ldr	r0, [pc, #80]	; (8016d54 <stm32_gpio_init+0xa4>)
 8016d04:	f7ff ffac 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8016d08:	4913      	ldr	r1, [pc, #76]	; (8016d58 <stm32_gpio_init+0xa8>)
 8016d0a:	4814      	ldr	r0, [pc, #80]	; (8016d5c <stm32_gpio_init+0xac>)
 8016d0c:	f7ff ffa8 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8016d10:	4913      	ldr	r1, [pc, #76]	; (8016d60 <stm32_gpio_init+0xb0>)
 8016d12:	4814      	ldr	r0, [pc, #80]	; (8016d64 <stm32_gpio_init+0xb4>)
 8016d14:	f7ff ffa4 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 8016d18:	4913      	ldr	r1, [pc, #76]	; (8016d68 <stm32_gpio_init+0xb8>)
 8016d1a:	4814      	ldr	r0, [pc, #80]	; (8016d6c <stm32_gpio_init+0xbc>)
 8016d1c:	f7ff ffa0 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8016d20:	4913      	ldr	r1, [pc, #76]	; (8016d70 <stm32_gpio_init+0xc0>)
 8016d22:	4814      	ldr	r0, [pc, #80]	; (8016d74 <stm32_gpio_init+0xc4>)
 8016d24:	f7ff ff9c 	bl	8016c60 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 8016d28:	4913      	ldr	r1, [pc, #76]	; (8016d78 <stm32_gpio_init+0xc8>)
 8016d2a:	4814      	ldr	r0, [pc, #80]	; (8016d7c <stm32_gpio_init+0xcc>)
 8016d2c:	f7ff ff98 	bl	8016c60 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8016d30:	bd08      	pop	{r3, pc}
 8016d32:	bf00      	nop
 8016d34:	40023800 	.word	0x40023800
 8016d38:	080230ec 	.word	0x080230ec
 8016d3c:	40020000 	.word	0x40020000
 8016d40:	08023108 	.word	0x08023108
 8016d44:	40020400 	.word	0x40020400
 8016d48:	08023124 	.word	0x08023124
 8016d4c:	40020800 	.word	0x40020800
 8016d50:	08023140 	.word	0x08023140
 8016d54:	40020c00 	.word	0x40020c00
 8016d58:	0802315c 	.word	0x0802315c
 8016d5c:	40021000 	.word	0x40021000
 8016d60:	08023178 	.word	0x08023178
 8016d64:	40021400 	.word	0x40021400
 8016d68:	08023194 	.word	0x08023194
 8016d6c:	40021800 	.word	0x40021800
 8016d70:	080231b0 	.word	0x080231b0
 8016d74:	40021c00 	.word	0x40021c00
 8016d78:	080231cc 	.word	0x080231cc
 8016d7c:	40022000 	.word	0x40022000

08016d80 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8016d80:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8016d82:	f7ff ff95 	bl	8016cb0 <stm32_gpio_init>
  stm32_clock_init();
 8016d86:	f000 fc1b 	bl	80175c0 <stm32_clock_init>
}
 8016d8a:	bd08      	pop	{r3, pc}
 8016d8c:	0000      	movs	r0, r0
	...

08016d90 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 8016d90:	b082      	sub	sp, #8
 8016d92:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
 8016d94:	2301      	movs	r3, #1
}
 8016d96:	4618      	mov	r0, r3
 8016d98:	b002      	add	sp, #8
 8016d9a:	4770      	bx	lr
 8016d9c:	0000      	movs	r0, r0
	...

08016da0 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 8016da0:	b082      	sub	sp, #8
 8016da2:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
 8016da4:	2300      	movs	r3, #0
}
 8016da6:	4618      	mov	r0, r3
 8016da8:	b002      	add	sp, #8
 8016daa:	4770      	bx	lr
 8016dac:	0000      	movs	r0, r0
	...

08016db0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {

}
 8016db0:	4770      	bx	lr
 8016db2:	bf00      	nop
	...

08016dc0 <chTimeAddX.lto_priv.715>:
                                   sysinterval_t interval) {
 8016dc0:	b082      	sub	sp, #8
 8016dc2:	9001      	str	r0, [sp, #4]
 8016dc4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 8016dc6:	9a01      	ldr	r2, [sp, #4]
 8016dc8:	9b00      	ldr	r3, [sp, #0]
 8016dca:	4413      	add	r3, r2
}
 8016dcc:	4618      	mov	r0, r3
 8016dce:	b002      	add	sp, #8
 8016dd0:	4770      	bx	lr
 8016dd2:	bf00      	nop
	...

08016de0 <chTimeDiffX.lto_priv.704>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8016de0:	b082      	sub	sp, #8
 8016de2:	9001      	str	r0, [sp, #4]
 8016de4:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8016de6:	9a00      	ldr	r2, [sp, #0]
 8016de8:	9b01      	ldr	r3, [sp, #4]
 8016dea:	1ad3      	subs	r3, r2, r3
}
 8016dec:	4618      	mov	r0, r3
 8016dee:	b002      	add	sp, #8
 8016df0:	4770      	bx	lr
 8016df2:	bf00      	nop
	...

08016e00 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8016e00:	b084      	sub	sp, #16
 8016e02:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8016e04:	9b01      	ldr	r3, [sp, #4]
 8016e06:	f003 0307 	and.w	r3, r3, #7
 8016e0a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8016e0c:	4b0a      	ldr	r3, [pc, #40]	; (8016e38 <__NVIC_SetPriorityGrouping+0x38>)
 8016e0e:	68db      	ldr	r3, [r3, #12]
 8016e10:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8016e12:	9a02      	ldr	r2, [sp, #8]
 8016e14:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8016e18:	4013      	ands	r3, r2
 8016e1a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8016e1c:	9b03      	ldr	r3, [sp, #12]
 8016e1e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8016e20:	9b02      	ldr	r3, [sp, #8]
 8016e22:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8016e24:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8016e28:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8016e2c:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8016e2e:	4a02      	ldr	r2, [pc, #8]	; (8016e38 <__NVIC_SetPriorityGrouping+0x38>)
 8016e30:	9b02      	ldr	r3, [sp, #8]
 8016e32:	60d3      	str	r3, [r2, #12]
}
 8016e34:	b004      	add	sp, #16
 8016e36:	4770      	bx	lr
 8016e38:	e000ed00 	.word	0xe000ed00
 8016e3c:	00000000 	.word	0x00000000

08016e40 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8016e40:	b082      	sub	sp, #8
 8016e42:	4603      	mov	r3, r0
 8016e44:	9100      	str	r1, [sp, #0]
 8016e46:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8016e4a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8016e4e:	2b00      	cmp	r3, #0
 8016e50:	db0a      	blt.n	8016e68 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8016e52:	490c      	ldr	r1, [pc, #48]	; (8016e84 <__NVIC_SetPriority+0x44>)
 8016e54:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8016e58:	9a00      	ldr	r2, [sp, #0]
 8016e5a:	b2d2      	uxtb	r2, r2
 8016e5c:	0112      	lsls	r2, r2, #4
 8016e5e:	b2d2      	uxtb	r2, r2
 8016e60:	440b      	add	r3, r1
 8016e62:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8016e66:	e00b      	b.n	8016e80 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8016e68:	4907      	ldr	r1, [pc, #28]	; (8016e88 <__NVIC_SetPriority+0x48>)
 8016e6a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016e6e:	f003 030f 	and.w	r3, r3, #15
 8016e72:	3b04      	subs	r3, #4
 8016e74:	9a00      	ldr	r2, [sp, #0]
 8016e76:	b2d2      	uxtb	r2, r2
 8016e78:	0112      	lsls	r2, r2, #4
 8016e7a:	b2d2      	uxtb	r2, r2
 8016e7c:	440b      	add	r3, r1
 8016e7e:	761a      	strb	r2, [r3, #24]
  }
}
 8016e80:	b002      	add	sp, #8
 8016e82:	4770      	bx	lr
 8016e84:	e000e100 	.word	0xe000e100
 8016e88:	e000ed00 	.word	0xe000ed00
 8016e8c:	00000000 	.word	0x00000000

08016e90 <port_init.lto_priv.723>:
static inline void port_init(void) {
 8016e90:	b508      	push	{r3, lr}
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8016e92:	2003      	movs	r0, #3
 8016e94:	f7ff ffb4 	bl	8016e00 <__NVIC_SetPriorityGrouping>
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8016e98:	4a0b      	ldr	r2, [pc, #44]	; (8016ec8 <port_init.lto_priv.723+0x38>)
 8016e9a:	4b0b      	ldr	r3, [pc, #44]	; (8016ec8 <port_init.lto_priv.723+0x38>)
 8016e9c:	68db      	ldr	r3, [r3, #12]
 8016e9e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8016ea2:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8016ea4:	4a09      	ldr	r2, [pc, #36]	; (8016ecc <port_init.lto_priv.723+0x3c>)
 8016ea6:	4b09      	ldr	r3, [pc, #36]	; (8016ecc <port_init.lto_priv.723+0x3c>)
 8016ea8:	681b      	ldr	r3, [r3, #0]
 8016eaa:	f043 0301 	orr.w	r3, r3, #1
 8016eae:	6013      	str	r3, [r2, #0]
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8016eb0:	2101      	movs	r1, #1
 8016eb2:	f06f 0004 	mvn.w	r0, #4
 8016eb6:	f7ff ffc3 	bl	8016e40 <__NVIC_SetPriority>
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8016eba:	2102      	movs	r1, #2
 8016ebc:	f06f 0001 	mvn.w	r0, #1
 8016ec0:	f7ff ffbe 	bl	8016e40 <__NVIC_SetPriority>
}
 8016ec4:	bd08      	pop	{r3, pc}
 8016ec6:	bf00      	nop
 8016ec8:	e000edf0 	.word	0xe000edf0
 8016ecc:	e0001000 	.word	0xe0001000

08016ed0 <port_lock.lto_priv.740>:
static inline void port_lock(void) {
 8016ed0:	b082      	sub	sp, #8
 8016ed2:	2320      	movs	r3, #32
 8016ed4:	9301      	str	r3, [sp, #4]
 8016ed6:	9b01      	ldr	r3, [sp, #4]
 8016ed8:	f383 8811 	msr	BASEPRI, r3
}
 8016edc:	b002      	add	sp, #8
 8016ede:	4770      	bx	lr

08016ee0 <port_unlock.lto_priv.736>:
static inline void port_unlock(void) {
 8016ee0:	b082      	sub	sp, #8
 8016ee2:	2300      	movs	r3, #0
 8016ee4:	9301      	str	r3, [sp, #4]
 8016ee6:	9b01      	ldr	r3, [sp, #4]
 8016ee8:	f383 8811 	msr	BASEPRI, r3
}
 8016eec:	b002      	add	sp, #8
 8016eee:	4770      	bx	lr

08016ef0 <port_lock_from_isr.lto_priv.732>:
static inline void port_lock_from_isr(void) {
 8016ef0:	b508      	push	{r3, lr}
  port_lock();
 8016ef2:	f7ff ffed 	bl	8016ed0 <port_lock.lto_priv.740>
}
 8016ef6:	bd08      	pop	{r3, pc}
	...

08016f00 <port_unlock_from_isr.lto_priv.728>:
static inline void port_unlock_from_isr(void) {
 8016f00:	b508      	push	{r3, lr}
  port_unlock();
 8016f02:	f7ff ffed 	bl	8016ee0 <port_unlock.lto_priv.736>
}
 8016f06:	bd08      	pop	{r3, pc}
	...

08016f10 <port_enable>:
static inline void port_enable(void) {
 8016f10:	b082      	sub	sp, #8
 8016f12:	2300      	movs	r3, #0
 8016f14:	9301      	str	r3, [sp, #4]
 8016f16:	9b01      	ldr	r3, [sp, #4]
 8016f18:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8016f1c:	b662      	cpsie	i
}
 8016f1e:	b002      	add	sp, #8
 8016f20:	4770      	bx	lr
 8016f22:	bf00      	nop
	...

08016f30 <port_wait_for_interrupt.lto_priv.724>:
}
 8016f30:	4770      	bx	lr
 8016f32:	bf00      	nop
	...

08016f40 <port_rt_get_counter_value.lto_priv.695>:
  return DWT->CYCCNT;
 8016f40:	4b01      	ldr	r3, [pc, #4]	; (8016f48 <port_rt_get_counter_value.lto_priv.695+0x8>)
 8016f42:	685b      	ldr	r3, [r3, #4]
}
 8016f44:	4618      	mov	r0, r3
 8016f46:	4770      	bx	lr
 8016f48:	e0001000 	.word	0xe0001000
 8016f4c:	00000000 	.word	0x00000000

08016f50 <st_lld_get_counter>:
  return (systime_t)STM32_ST_TIM->CNT;
 8016f50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8016f54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8016f56:	4618      	mov	r0, r3
 8016f58:	4770      	bx	lr
 8016f5a:	bf00      	nop
 8016f5c:	0000      	movs	r0, r0
	...

08016f60 <port_timer_stop_alarm.lto_priv.713>:
static inline void port_timer_stop_alarm(void) {
 8016f60:	b508      	push	{r3, lr}
  stStopAlarm();
 8016f62:	f002 fd75 	bl	8019a50 <stStopAlarm>
}
 8016f66:	bd08      	pop	{r3, pc}
	...

08016f70 <port_timer_set_alarm.lto_priv.711>:
static inline void port_timer_set_alarm(systime_t time) {
 8016f70:	b500      	push	{lr}
 8016f72:	b083      	sub	sp, #12
 8016f74:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8016f76:	9801      	ldr	r0, [sp, #4]
 8016f78:	f002 fd72 	bl	8019a60 <stSetAlarm>
}
 8016f7c:	b003      	add	sp, #12
 8016f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8016f82:	bf00      	nop
	...

08016f90 <port_timer_get_time>:
static inline systime_t port_timer_get_time(void) {
 8016f90:	b508      	push	{r3, lr}
  return stGetCounter();
 8016f92:	f7ff ffdd 	bl	8016f50 <st_lld_get_counter>
 8016f96:	4603      	mov	r3, r0
}
 8016f98:	4618      	mov	r0, r3
 8016f9a:	bd08      	pop	{r3, pc}
 8016f9c:	0000      	movs	r0, r0
	...

08016fa0 <chSysEnable.lto_priv.722>:
static inline void chSysEnable(void) {
 8016fa0:	b508      	push	{r3, lr}
  port_enable();
 8016fa2:	f7ff ffb5 	bl	8016f10 <port_enable>
}
 8016fa6:	bd08      	pop	{r3, pc}
	...

08016fb0 <chSysLockFromISR.lto_priv.709>:
static inline void chSysLockFromISR(void) {
 8016fb0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8016fb2:	f7ff ff9d 	bl	8016ef0 <port_lock_from_isr.lto_priv.732>
}
 8016fb6:	bd08      	pop	{r3, pc}
	...

08016fc0 <chSysUnlockFromISR.lto_priv.707>:
static inline void chSysUnlockFromISR(void) {
 8016fc0:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8016fc2:	f7ff ff9d 	bl	8016f00 <port_unlock_from_isr.lto_priv.728>
}
 8016fc6:	bd08      	pop	{r3, pc}
	...

08016fd0 <chVTGetSystemTimeX.lto_priv.697>:
static inline systime_t chVTGetSystemTimeX(void) {
 8016fd0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8016fd2:	f7ff ffdd 	bl	8016f90 <port_timer_get_time>
 8016fd6:	4603      	mov	r3, r0
}
 8016fd8:	4618      	mov	r0, r3
 8016fda:	bd08      	pop	{r3, pc}
 8016fdc:	0000      	movs	r0, r0
	...

08016fe0 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8016fe0:	b500      	push	{lr}
 8016fe2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8016fe4:	4b14      	ldr	r3, [pc, #80]	; (8017038 <Vector58+0x58>)
 8016fe6:	695b      	ldr	r3, [r3, #20]
 8016fe8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 0);
 8016fea:	4b13      	ldr	r3, [pc, #76]	; (8017038 <Vector58+0x58>)
 8016fec:	681b      	ldr	r3, [r3, #0]
 8016fee:	f003 0301 	and.w	r3, r3, #1
 8016ff2:	9a01      	ldr	r2, [sp, #4]
 8016ff4:	4013      	ands	r3, r2
 8016ff6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8016ff8:	4a0f      	ldr	r2, [pc, #60]	; (8017038 <Vector58+0x58>)
 8016ffa:	9b01      	ldr	r3, [sp, #4]
 8016ffc:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 0);
 8016ffe:	9b01      	ldr	r3, [sp, #4]
 8017000:	f003 0301 	and.w	r3, r3, #1
 8017004:	2b00      	cmp	r3, #0
 8017006:	d011      	beq.n	801702c <Vector58+0x4c>
 8017008:	4b0c      	ldr	r3, [pc, #48]	; (801703c <Vector58+0x5c>)
 801700a:	689b      	ldr	r3, [r3, #8]
 801700c:	2b00      	cmp	r3, #0
 801700e:	d005      	beq.n	801701c <Vector58+0x3c>
 8017010:	4b0a      	ldr	r3, [pc, #40]	; (801703c <Vector58+0x5c>)
 8017012:	689b      	ldr	r3, [r3, #8]
 8017014:	4a09      	ldr	r2, [pc, #36]	; (801703c <Vector58+0x5c>)
 8017016:	68d2      	ldr	r2, [r2, #12]
 8017018:	4610      	mov	r0, r2
 801701a:	4798      	blx	r3
 801701c:	f002 fc50 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017020:	2100      	movs	r1, #0
 8017022:	4806      	ldr	r0, [pc, #24]	; (801703c <Vector58+0x5c>)
 8017024:	f002 fc5c 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017028:	f002 fc52 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 801702c:	f7fc fb30 	bl	8013690 <_port_irq_epilogue>
}
 8017030:	b003      	add	sp, #12
 8017032:	f85d fb04 	ldr.w	pc, [sp], #4
 8017036:	bf00      	nop
 8017038:	40013c00 	.word	0x40013c00
 801703c:	20004f1c 	.word	0x20004f1c

08017040 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8017040:	b500      	push	{lr}
 8017042:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8017044:	4b14      	ldr	r3, [pc, #80]	; (8017098 <Vector5C+0x58>)
 8017046:	695b      	ldr	r3, [r3, #20]
 8017048:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 1);
 801704a:	4b13      	ldr	r3, [pc, #76]	; (8017098 <Vector5C+0x58>)
 801704c:	681b      	ldr	r3, [r3, #0]
 801704e:	f003 0302 	and.w	r3, r3, #2
 8017052:	9a01      	ldr	r2, [sp, #4]
 8017054:	4013      	ands	r3, r2
 8017056:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8017058:	4a0f      	ldr	r2, [pc, #60]	; (8017098 <Vector5C+0x58>)
 801705a:	9b01      	ldr	r3, [sp, #4]
 801705c:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 1);
 801705e:	9b01      	ldr	r3, [sp, #4]
 8017060:	f003 0302 	and.w	r3, r3, #2
 8017064:	2b00      	cmp	r3, #0
 8017066:	d011      	beq.n	801708c <Vector5C+0x4c>
 8017068:	4b0c      	ldr	r3, [pc, #48]	; (801709c <Vector5C+0x5c>)
 801706a:	699b      	ldr	r3, [r3, #24]
 801706c:	2b00      	cmp	r3, #0
 801706e:	d005      	beq.n	801707c <Vector5C+0x3c>
 8017070:	4b0a      	ldr	r3, [pc, #40]	; (801709c <Vector5C+0x5c>)
 8017072:	699b      	ldr	r3, [r3, #24]
 8017074:	4a09      	ldr	r2, [pc, #36]	; (801709c <Vector5C+0x5c>)
 8017076:	69d2      	ldr	r2, [r2, #28]
 8017078:	4610      	mov	r0, r2
 801707a:	4798      	blx	r3
 801707c:	f002 fc20 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017080:	2100      	movs	r1, #0
 8017082:	4807      	ldr	r0, [pc, #28]	; (80170a0 <Vector5C+0x60>)
 8017084:	f002 fc2c 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017088:	f002 fc22 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 801708c:	f7fc fb00 	bl	8013690 <_port_irq_epilogue>
}
 8017090:	b003      	add	sp, #12
 8017092:	f85d fb04 	ldr.w	pc, [sp], #4
 8017096:	bf00      	nop
 8017098:	40013c00 	.word	0x40013c00
 801709c:	20004f1c 	.word	0x20004f1c
 80170a0:	20004f2c 	.word	0x20004f2c
	...

080170b0 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 80170b0:	b500      	push	{lr}
 80170b2:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80170b4:	4b14      	ldr	r3, [pc, #80]	; (8017108 <Vector60+0x58>)
 80170b6:	695b      	ldr	r3, [r3, #20]
 80170b8:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 2);
 80170ba:	4b13      	ldr	r3, [pc, #76]	; (8017108 <Vector60+0x58>)
 80170bc:	681b      	ldr	r3, [r3, #0]
 80170be:	f003 0304 	and.w	r3, r3, #4
 80170c2:	9a01      	ldr	r2, [sp, #4]
 80170c4:	4013      	ands	r3, r2
 80170c6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80170c8:	4a0f      	ldr	r2, [pc, #60]	; (8017108 <Vector60+0x58>)
 80170ca:	9b01      	ldr	r3, [sp, #4]
 80170cc:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 2);
 80170ce:	9b01      	ldr	r3, [sp, #4]
 80170d0:	f003 0304 	and.w	r3, r3, #4
 80170d4:	2b00      	cmp	r3, #0
 80170d6:	d011      	beq.n	80170fc <Vector60+0x4c>
 80170d8:	4b0c      	ldr	r3, [pc, #48]	; (801710c <Vector60+0x5c>)
 80170da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80170dc:	2b00      	cmp	r3, #0
 80170de:	d005      	beq.n	80170ec <Vector60+0x3c>
 80170e0:	4b0a      	ldr	r3, [pc, #40]	; (801710c <Vector60+0x5c>)
 80170e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80170e4:	4a09      	ldr	r2, [pc, #36]	; (801710c <Vector60+0x5c>)
 80170e6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80170e8:	4610      	mov	r0, r2
 80170ea:	4798      	blx	r3
 80170ec:	f002 fbe8 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 80170f0:	2100      	movs	r1, #0
 80170f2:	4807      	ldr	r0, [pc, #28]	; (8017110 <Vector60+0x60>)
 80170f4:	f002 fbf4 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80170f8:	f002 fbea 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 80170fc:	f7fc fac8 	bl	8013690 <_port_irq_epilogue>
}
 8017100:	b003      	add	sp, #12
 8017102:	f85d fb04 	ldr.w	pc, [sp], #4
 8017106:	bf00      	nop
 8017108:	40013c00 	.word	0x40013c00
 801710c:	20004f1c 	.word	0x20004f1c
 8017110:	20004f3c 	.word	0x20004f3c
	...

08017120 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 8017120:	b500      	push	{lr}
 8017122:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8017124:	4b14      	ldr	r3, [pc, #80]	; (8017178 <Vector64+0x58>)
 8017126:	695b      	ldr	r3, [r3, #20]
 8017128:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 3);
 801712a:	4b13      	ldr	r3, [pc, #76]	; (8017178 <Vector64+0x58>)
 801712c:	681b      	ldr	r3, [r3, #0]
 801712e:	f003 0308 	and.w	r3, r3, #8
 8017132:	9a01      	ldr	r2, [sp, #4]
 8017134:	4013      	ands	r3, r2
 8017136:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 8017138:	4a0f      	ldr	r2, [pc, #60]	; (8017178 <Vector64+0x58>)
 801713a:	9b01      	ldr	r3, [sp, #4]
 801713c:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 3);
 801713e:	9b01      	ldr	r3, [sp, #4]
 8017140:	f003 0308 	and.w	r3, r3, #8
 8017144:	2b00      	cmp	r3, #0
 8017146:	d011      	beq.n	801716c <Vector64+0x4c>
 8017148:	4b0c      	ldr	r3, [pc, #48]	; (801717c <Vector64+0x5c>)
 801714a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801714c:	2b00      	cmp	r3, #0
 801714e:	d005      	beq.n	801715c <Vector64+0x3c>
 8017150:	4b0a      	ldr	r3, [pc, #40]	; (801717c <Vector64+0x5c>)
 8017152:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8017154:	4a09      	ldr	r2, [pc, #36]	; (801717c <Vector64+0x5c>)
 8017156:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8017158:	4610      	mov	r0, r2
 801715a:	4798      	blx	r3
 801715c:	f002 fbb0 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017160:	2100      	movs	r1, #0
 8017162:	4807      	ldr	r0, [pc, #28]	; (8017180 <Vector64+0x60>)
 8017164:	f002 fbbc 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017168:	f002 fbb2 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 801716c:	f7fc fa90 	bl	8013690 <_port_irq_epilogue>
}
 8017170:	b003      	add	sp, #12
 8017172:	f85d fb04 	ldr.w	pc, [sp], #4
 8017176:	bf00      	nop
 8017178:	40013c00 	.word	0x40013c00
 801717c:	20004f1c 	.word	0x20004f1c
 8017180:	20004f4c 	.word	0x20004f4c
	...

08017190 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 8017190:	b500      	push	{lr}
 8017192:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8017194:	4b14      	ldr	r3, [pc, #80]	; (80171e8 <Vector68+0x58>)
 8017196:	695b      	ldr	r3, [r3, #20]
 8017198:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & (1U << 4);
 801719a:	4b13      	ldr	r3, [pc, #76]	; (80171e8 <Vector68+0x58>)
 801719c:	681b      	ldr	r3, [r3, #0]
 801719e:	f003 0310 	and.w	r3, r3, #16
 80171a2:	9a01      	ldr	r2, [sp, #4]
 80171a4:	4013      	ands	r3, r2
 80171a6:	9301      	str	r3, [sp, #4]
  EXTI->PR = pr;
 80171a8:	4a0f      	ldr	r2, [pc, #60]	; (80171e8 <Vector68+0x58>)
 80171aa:	9b01      	ldr	r3, [sp, #4]
 80171ac:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 4);
 80171ae:	9b01      	ldr	r3, [sp, #4]
 80171b0:	f003 0310 	and.w	r3, r3, #16
 80171b4:	2b00      	cmp	r3, #0
 80171b6:	d011      	beq.n	80171dc <Vector68+0x4c>
 80171b8:	4b0c      	ldr	r3, [pc, #48]	; (80171ec <Vector68+0x5c>)
 80171ba:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80171bc:	2b00      	cmp	r3, #0
 80171be:	d005      	beq.n	80171cc <Vector68+0x3c>
 80171c0:	4b0a      	ldr	r3, [pc, #40]	; (80171ec <Vector68+0x5c>)
 80171c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80171c4:	4a09      	ldr	r2, [pc, #36]	; (80171ec <Vector68+0x5c>)
 80171c6:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 80171c8:	4610      	mov	r0, r2
 80171ca:	4798      	blx	r3
 80171cc:	f002 fb78 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 80171d0:	2100      	movs	r1, #0
 80171d2:	4807      	ldr	r0, [pc, #28]	; (80171f0 <Vector68+0x60>)
 80171d4:	f002 fb84 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80171d8:	f002 fb7a 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 80171dc:	f7fc fa58 	bl	8013690 <_port_irq_epilogue>
}
 80171e0:	b003      	add	sp, #12
 80171e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80171e6:	bf00      	nop
 80171e8:	40013c00 	.word	0x40013c00
 80171ec:	20004f1c 	.word	0x20004f1c
 80171f0:	20004f5c 	.word	0x20004f5c
	...

08017200 <Vector9C>:
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 8017200:	b500      	push	{lr}
 8017202:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8017204:	4b45      	ldr	r3, [pc, #276]	; (801731c <Vector9C+0x11c>)
 8017206:	695b      	ldr	r3, [r3, #20]
 8017208:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 801720a:	4b44      	ldr	r3, [pc, #272]	; (801731c <Vector9C+0x11c>)
 801720c:	681b      	ldr	r3, [r3, #0]
 801720e:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 8017212:	9a01      	ldr	r2, [sp, #4]
 8017214:	4013      	ands	r3, r2
 8017216:	9301      	str	r3, [sp, #4]
                     (1U << 9));
  EXTI->PR = pr;
 8017218:	4a40      	ldr	r2, [pc, #256]	; (801731c <Vector9C+0x11c>)
 801721a:	9b01      	ldr	r3, [sp, #4]
 801721c:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 5);
 801721e:	9b01      	ldr	r3, [sp, #4]
 8017220:	f003 0320 	and.w	r3, r3, #32
 8017224:	2b00      	cmp	r3, #0
 8017226:	d011      	beq.n	801724c <Vector9C+0x4c>
 8017228:	4b3d      	ldr	r3, [pc, #244]	; (8017320 <Vector9C+0x120>)
 801722a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801722c:	2b00      	cmp	r3, #0
 801722e:	d005      	beq.n	801723c <Vector9C+0x3c>
 8017230:	4b3b      	ldr	r3, [pc, #236]	; (8017320 <Vector9C+0x120>)
 8017232:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017234:	4a3a      	ldr	r2, [pc, #232]	; (8017320 <Vector9C+0x120>)
 8017236:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8017238:	4610      	mov	r0, r2
 801723a:	4798      	blx	r3
 801723c:	f002 fb40 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017240:	2100      	movs	r1, #0
 8017242:	4838      	ldr	r0, [pc, #224]	; (8017324 <Vector9C+0x124>)
 8017244:	f002 fb4c 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017248:	f002 fb42 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 6);
 801724c:	9b01      	ldr	r3, [sp, #4]
 801724e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017252:	2b00      	cmp	r3, #0
 8017254:	d011      	beq.n	801727a <Vector9C+0x7a>
 8017256:	4b32      	ldr	r3, [pc, #200]	; (8017320 <Vector9C+0x120>)
 8017258:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801725a:	2b00      	cmp	r3, #0
 801725c:	d005      	beq.n	801726a <Vector9C+0x6a>
 801725e:	4b30      	ldr	r3, [pc, #192]	; (8017320 <Vector9C+0x120>)
 8017260:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017262:	4a2f      	ldr	r2, [pc, #188]	; (8017320 <Vector9C+0x120>)
 8017264:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8017266:	4610      	mov	r0, r2
 8017268:	4798      	blx	r3
 801726a:	f002 fb29 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 801726e:	2100      	movs	r1, #0
 8017270:	482d      	ldr	r0, [pc, #180]	; (8017328 <Vector9C+0x128>)
 8017272:	f002 fb35 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017276:	f002 fb2b 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 7);
 801727a:	9b01      	ldr	r3, [sp, #4]
 801727c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8017280:	2b00      	cmp	r3, #0
 8017282:	d011      	beq.n	80172a8 <Vector9C+0xa8>
 8017284:	4b26      	ldr	r3, [pc, #152]	; (8017320 <Vector9C+0x120>)
 8017286:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017288:	2b00      	cmp	r3, #0
 801728a:	d005      	beq.n	8017298 <Vector9C+0x98>
 801728c:	4b24      	ldr	r3, [pc, #144]	; (8017320 <Vector9C+0x120>)
 801728e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017290:	4a23      	ldr	r2, [pc, #140]	; (8017320 <Vector9C+0x120>)
 8017292:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8017294:	4610      	mov	r0, r2
 8017296:	4798      	blx	r3
 8017298:	f002 fb12 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 801729c:	2100      	movs	r1, #0
 801729e:	4823      	ldr	r0, [pc, #140]	; (801732c <Vector9C+0x12c>)
 80172a0:	f002 fb1e 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80172a4:	f002 fb14 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 8);
 80172a8:	9b01      	ldr	r3, [sp, #4]
 80172aa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80172ae:	2b00      	cmp	r3, #0
 80172b0:	d014      	beq.n	80172dc <Vector9C+0xdc>
 80172b2:	4b1b      	ldr	r3, [pc, #108]	; (8017320 <Vector9C+0x120>)
 80172b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80172b8:	2b00      	cmp	r3, #0
 80172ba:	d007      	beq.n	80172cc <Vector9C+0xcc>
 80172bc:	4b18      	ldr	r3, [pc, #96]	; (8017320 <Vector9C+0x120>)
 80172be:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80172c2:	4a17      	ldr	r2, [pc, #92]	; (8017320 <Vector9C+0x120>)
 80172c4:	f8d2 208c 	ldr.w	r2, [r2, #140]	; 0x8c
 80172c8:	4610      	mov	r0, r2
 80172ca:	4798      	blx	r3
 80172cc:	f002 faf8 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 80172d0:	2100      	movs	r1, #0
 80172d2:	4817      	ldr	r0, [pc, #92]	; (8017330 <Vector9C+0x130>)
 80172d4:	f002 fb04 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80172d8:	f002 fafa 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 9);
 80172dc:	9b01      	ldr	r3, [sp, #4]
 80172de:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80172e2:	2b00      	cmp	r3, #0
 80172e4:	d014      	beq.n	8017310 <Vector9C+0x110>
 80172e6:	4b0e      	ldr	r3, [pc, #56]	; (8017320 <Vector9C+0x120>)
 80172e8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80172ec:	2b00      	cmp	r3, #0
 80172ee:	d007      	beq.n	8017300 <Vector9C+0x100>
 80172f0:	4b0b      	ldr	r3, [pc, #44]	; (8017320 <Vector9C+0x120>)
 80172f2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80172f6:	4a0a      	ldr	r2, [pc, #40]	; (8017320 <Vector9C+0x120>)
 80172f8:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
 80172fc:	4610      	mov	r0, r2
 80172fe:	4798      	blx	r3
 8017300:	f002 fade 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017304:	2100      	movs	r1, #0
 8017306:	480b      	ldr	r0, [pc, #44]	; (8017334 <Vector9C+0x134>)
 8017308:	f002 faea 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 801730c:	f002 fae0 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 8017310:	f7fc f9be 	bl	8013690 <_port_irq_epilogue>
}
 8017314:	b003      	add	sp, #12
 8017316:	f85d fb04 	ldr.w	pc, [sp], #4
 801731a:	bf00      	nop
 801731c:	40013c00 	.word	0x40013c00
 8017320:	20004f1c 	.word	0x20004f1c
 8017324:	20004f6c 	.word	0x20004f6c
 8017328:	20004f7c 	.word	0x20004f7c
 801732c:	20004f8c 	.word	0x20004f8c
 8017330:	20004f9c 	.word	0x20004f9c
 8017334:	20004fac 	.word	0x20004fac
	...

08017340 <VectorE0>:
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 8017340:	b500      	push	{lr}
 8017342:	b083      	sub	sp, #12
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8017344:	4b56      	ldr	r3, [pc, #344]	; (80174a0 <VectorE0+0x160>)
 8017346:	695b      	ldr	r3, [r3, #20]
 8017348:	9301      	str	r3, [sp, #4]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 801734a:	4b55      	ldr	r3, [pc, #340]	; (80174a0 <VectorE0+0x160>)
 801734c:	681b      	ldr	r3, [r3, #0]
 801734e:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8017352:	9a01      	ldr	r2, [sp, #4]
 8017354:	4013      	ands	r3, r2
 8017356:	9301      	str	r3, [sp, #4]
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8017358:	4a51      	ldr	r2, [pc, #324]	; (80174a0 <VectorE0+0x160>)
 801735a:	9b01      	ldr	r3, [sp, #4]
 801735c:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 10);
 801735e:	9b01      	ldr	r3, [sp, #4]
 8017360:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8017364:	2b00      	cmp	r3, #0
 8017366:	d014      	beq.n	8017392 <VectorE0+0x52>
 8017368:	4b4e      	ldr	r3, [pc, #312]	; (80174a4 <VectorE0+0x164>)
 801736a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801736e:	2b00      	cmp	r3, #0
 8017370:	d007      	beq.n	8017382 <VectorE0+0x42>
 8017372:	4b4c      	ldr	r3, [pc, #304]	; (80174a4 <VectorE0+0x164>)
 8017374:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8017378:	4a4a      	ldr	r2, [pc, #296]	; (80174a4 <VectorE0+0x164>)
 801737a:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 801737e:	4610      	mov	r0, r2
 8017380:	4798      	blx	r3
 8017382:	f002 fa9d 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017386:	2100      	movs	r1, #0
 8017388:	4847      	ldr	r0, [pc, #284]	; (80174a8 <VectorE0+0x168>)
 801738a:	f002 faa9 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 801738e:	f002 fa9f 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 11);
 8017392:	9b01      	ldr	r3, [sp, #4]
 8017394:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8017398:	2b00      	cmp	r3, #0
 801739a:	d014      	beq.n	80173c6 <VectorE0+0x86>
 801739c:	4b41      	ldr	r3, [pc, #260]	; (80174a4 <VectorE0+0x164>)
 801739e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80173a2:	2b00      	cmp	r3, #0
 80173a4:	d007      	beq.n	80173b6 <VectorE0+0x76>
 80173a6:	4b3f      	ldr	r3, [pc, #252]	; (80174a4 <VectorE0+0x164>)
 80173a8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80173ac:	4a3d      	ldr	r2, [pc, #244]	; (80174a4 <VectorE0+0x164>)
 80173ae:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
 80173b2:	4610      	mov	r0, r2
 80173b4:	4798      	blx	r3
 80173b6:	f002 fa83 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 80173ba:	2100      	movs	r1, #0
 80173bc:	483b      	ldr	r0, [pc, #236]	; (80174ac <VectorE0+0x16c>)
 80173be:	f002 fa8f 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80173c2:	f002 fa85 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 12);
 80173c6:	9b01      	ldr	r3, [sp, #4]
 80173c8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80173cc:	2b00      	cmp	r3, #0
 80173ce:	d014      	beq.n	80173fa <VectorE0+0xba>
 80173d0:	4b34      	ldr	r3, [pc, #208]	; (80174a4 <VectorE0+0x164>)
 80173d2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80173d6:	2b00      	cmp	r3, #0
 80173d8:	d007      	beq.n	80173ea <VectorE0+0xaa>
 80173da:	4b32      	ldr	r3, [pc, #200]	; (80174a4 <VectorE0+0x164>)
 80173dc:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80173e0:	4a30      	ldr	r2, [pc, #192]	; (80174a4 <VectorE0+0x164>)
 80173e2:	f8d2 20cc 	ldr.w	r2, [r2, #204]	; 0xcc
 80173e6:	4610      	mov	r0, r2
 80173e8:	4798      	blx	r3
 80173ea:	f002 fa69 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 80173ee:	2100      	movs	r1, #0
 80173f0:	482f      	ldr	r0, [pc, #188]	; (80174b0 <VectorE0+0x170>)
 80173f2:	f002 fa75 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 80173f6:	f002 fa6b 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 13);
 80173fa:	9b01      	ldr	r3, [sp, #4]
 80173fc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8017400:	2b00      	cmp	r3, #0
 8017402:	d014      	beq.n	801742e <VectorE0+0xee>
 8017404:	4b27      	ldr	r3, [pc, #156]	; (80174a4 <VectorE0+0x164>)
 8017406:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 801740a:	2b00      	cmp	r3, #0
 801740c:	d007      	beq.n	801741e <VectorE0+0xde>
 801740e:	4b25      	ldr	r3, [pc, #148]	; (80174a4 <VectorE0+0x164>)
 8017410:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8017414:	4a23      	ldr	r2, [pc, #140]	; (80174a4 <VectorE0+0x164>)
 8017416:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
 801741a:	4610      	mov	r0, r2
 801741c:	4798      	blx	r3
 801741e:	f002 fa4f 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017422:	2100      	movs	r1, #0
 8017424:	4823      	ldr	r0, [pc, #140]	; (80174b4 <VectorE0+0x174>)
 8017426:	f002 fa5b 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 801742a:	f002 fa51 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 14);
 801742e:	9b01      	ldr	r3, [sp, #4]
 8017430:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8017434:	2b00      	cmp	r3, #0
 8017436:	d014      	beq.n	8017462 <VectorE0+0x122>
 8017438:	4b1a      	ldr	r3, [pc, #104]	; (80174a4 <VectorE0+0x164>)
 801743a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801743e:	2b00      	cmp	r3, #0
 8017440:	d007      	beq.n	8017452 <VectorE0+0x112>
 8017442:	4b18      	ldr	r3, [pc, #96]	; (80174a4 <VectorE0+0x164>)
 8017444:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8017448:	4a16      	ldr	r2, [pc, #88]	; (80174a4 <VectorE0+0x164>)
 801744a:	f8d2 20ec 	ldr.w	r2, [r2, #236]	; 0xec
 801744e:	4610      	mov	r0, r2
 8017450:	4798      	blx	r3
 8017452:	f002 fa35 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 8017456:	2100      	movs	r1, #0
 8017458:	4817      	ldr	r0, [pc, #92]	; (80174b8 <VectorE0+0x178>)
 801745a:	f002 fa41 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 801745e:	f002 fa37 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>
  exti_serve_irq(pr, 15);
 8017462:	9b01      	ldr	r3, [sp, #4]
 8017464:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8017468:	2b00      	cmp	r3, #0
 801746a:	d014      	beq.n	8017496 <VectorE0+0x156>
 801746c:	4b0d      	ldr	r3, [pc, #52]	; (80174a4 <VectorE0+0x164>)
 801746e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8017472:	2b00      	cmp	r3, #0
 8017474:	d007      	beq.n	8017486 <VectorE0+0x146>
 8017476:	4b0b      	ldr	r3, [pc, #44]	; (80174a4 <VectorE0+0x164>)
 8017478:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801747c:	4a09      	ldr	r2, [pc, #36]	; (80174a4 <VectorE0+0x164>)
 801747e:	f8d2 20fc 	ldr.w	r2, [r2, #252]	; 0xfc
 8017482:	4610      	mov	r0, r2
 8017484:	4798      	blx	r3
 8017486:	f002 fa1b 	bl	80198c0 <osalSysLockFromISR.lto_priv.792>
 801748a:	2100      	movs	r1, #0
 801748c:	480b      	ldr	r0, [pc, #44]	; (80174bc <VectorE0+0x17c>)
 801748e:	f002 fa27 	bl	80198e0 <osalThreadDequeueAllI.lto_priv.785>
 8017492:	f002 fa1d 	bl	80198d0 <osalSysUnlockFromISR.lto_priv.790>

  OSAL_IRQ_EPILOGUE();
 8017496:	f7fc f8fb 	bl	8013690 <_port_irq_epilogue>
}
 801749a:	b003      	add	sp, #12
 801749c:	f85d fb04 	ldr.w	pc, [sp], #4
 80174a0:	40013c00 	.word	0x40013c00
 80174a4:	20004f1c 	.word	0x20004f1c
 80174a8:	20004fbc 	.word	0x20004fbc
 80174ac:	20004fcc 	.word	0x20004fcc
 80174b0:	20004fdc 	.word	0x20004fdc
 80174b4:	20004fec 	.word	0x20004fec
 80174b8:	20004ffc 	.word	0x20004ffc
 80174bc:	2000500c 	.word	0x2000500c

080174c0 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 80174c0:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 80174c2:	2106      	movs	r1, #6
 80174c4:	2006      	movs	r0, #6
 80174c6:	f002 f99b 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 80174ca:	2106      	movs	r1, #6
 80174cc:	2007      	movs	r0, #7
 80174ce:	f002 f997 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 80174d2:	2106      	movs	r1, #6
 80174d4:	2008      	movs	r0, #8
 80174d6:	f002 f993 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 80174da:	2106      	movs	r1, #6
 80174dc:	2009      	movs	r0, #9
 80174de:	f002 f98f 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 80174e2:	2106      	movs	r1, #6
 80174e4:	200a      	movs	r0, #10
 80174e6:	f002 f98b 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 80174ea:	2106      	movs	r1, #6
 80174ec:	2017      	movs	r0, #23
 80174ee:	f002 f987 	bl	8019800 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 80174f2:	2106      	movs	r1, #6
 80174f4:	2028      	movs	r0, #40	; 0x28
 80174f6:	f002 f983 	bl	8019800 <nvicEnableVector>
#endif
}
 80174fa:	bd08      	pop	{r3, pc}
 80174fc:	0000      	movs	r0, r0
	...

08017500 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8017500:	4a0d      	ldr	r2, [pc, #52]	; (8017538 <hal_lld_backup_domain_init+0x38>)
 8017502:	4b0d      	ldr	r3, [pc, #52]	; (8017538 <hal_lld_backup_domain_init+0x38>)
 8017504:	681b      	ldr	r3, [r3, #0]
 8017506:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801750a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 801750c:	4b0b      	ldr	r3, [pc, #44]	; (801753c <hal_lld_backup_domain_init+0x3c>)
 801750e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017510:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8017514:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017518:	d006      	beq.n	8017528 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 801751a:	4b08      	ldr	r3, [pc, #32]	; (801753c <hal_lld_backup_domain_init+0x3c>)
 801751c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8017520:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8017522:	4b06      	ldr	r3, [pc, #24]	; (801753c <hal_lld_backup_domain_init+0x3c>)
 8017524:	2200      	movs	r2, #0
 8017526:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8017528:	4a03      	ldr	r2, [pc, #12]	; (8017538 <hal_lld_backup_domain_init+0x38>)
 801752a:	4b03      	ldr	r3, [pc, #12]	; (8017538 <hal_lld_backup_domain_init+0x38>)
 801752c:	685b      	ldr	r3, [r3, #4]
 801752e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8017532:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8017534:	4770      	bx	lr
 8017536:	bf00      	nop
 8017538:	40007000 	.word	0x40007000
 801753c:	40023800 	.word	0x40023800

08017540 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8017540:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8017542:	4a1c      	ldr	r2, [pc, #112]	; (80175b4 <hal_lld_init+0x74>)
 8017544:	4b1b      	ldr	r3, [pc, #108]	; (80175b4 <hal_lld_init+0x74>)
 8017546:	691b      	ldr	r3, [r3, #16]
 8017548:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 801754c:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 8017550:	6113      	str	r3, [r2, #16]
 8017552:	4b18      	ldr	r3, [pc, #96]	; (80175b4 <hal_lld_init+0x74>)
 8017554:	2200      	movs	r2, #0
 8017556:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8017558:	4b16      	ldr	r3, [pc, #88]	; (80175b4 <hal_lld_init+0x74>)
 801755a:	695b      	ldr	r3, [r3, #20]
 801755c:	4b15      	ldr	r3, [pc, #84]	; (80175b4 <hal_lld_init+0x74>)
 801755e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8017562:	615a      	str	r2, [r3, #20]
 8017564:	4b13      	ldr	r3, [pc, #76]	; (80175b4 <hal_lld_init+0x74>)
 8017566:	2200      	movs	r2, #0
 8017568:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 801756a:	4a12      	ldr	r2, [pc, #72]	; (80175b4 <hal_lld_init+0x74>)
 801756c:	4b11      	ldr	r3, [pc, #68]	; (80175b4 <hal_lld_init+0x74>)
 801756e:	6a1b      	ldr	r3, [r3, #32]
 8017570:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8017574:	6213      	str	r3, [r2, #32]
 8017576:	4b0f      	ldr	r3, [pc, #60]	; (80175b4 <hal_lld_init+0x74>)
 8017578:	2200      	movs	r2, #0
 801757a:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 801757c:	4b0d      	ldr	r3, [pc, #52]	; (80175b4 <hal_lld_init+0x74>)
 801757e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017580:	4b0c      	ldr	r3, [pc, #48]	; (80175b4 <hal_lld_init+0x74>)
 8017582:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8017586:	625a      	str	r2, [r3, #36]	; 0x24
 8017588:	4b0a      	ldr	r3, [pc, #40]	; (80175b4 <hal_lld_init+0x74>)
 801758a:	2200      	movs	r2, #0
 801758c:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 801758e:	4a09      	ldr	r2, [pc, #36]	; (80175b4 <hal_lld_init+0x74>)
 8017590:	4b08      	ldr	r3, [pc, #32]	; (80175b4 <hal_lld_init+0x74>)
 8017592:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017594:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8017598:	6413      	str	r3, [r2, #64]	; 0x40
 801759a:	4a06      	ldr	r2, [pc, #24]	; (80175b4 <hal_lld_init+0x74>)
 801759c:	4b05      	ldr	r3, [pc, #20]	; (80175b4 <hal_lld_init+0x74>)
 801759e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80175a0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80175a4:	6613      	str	r3, [r2, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80175a6:	f7ff ffab 	bl	8017500 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80175aa:	f000 fda1 	bl	80180f0 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 80175ae:	f7ff ff87 	bl	80174c0 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80175b2:	bd08      	pop	{r3, pc}
 80175b4:	40023800 	.word	0x40023800
	...

080175c0 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80175c0:	4b44      	ldr	r3, [pc, #272]	; (80176d4 <stm32_clock_init+0x114>)
 80175c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80175c6:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80175c8:	4b43      	ldr	r3, [pc, #268]	; (80176d8 <stm32_clock_init+0x118>)
 80175ca:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80175ce:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80175d0:	4a40      	ldr	r2, [pc, #256]	; (80176d4 <stm32_clock_init+0x114>)
 80175d2:	4b40      	ldr	r3, [pc, #256]	; (80176d4 <stm32_clock_init+0x114>)
 80175d4:	681b      	ldr	r3, [r3, #0]
 80175d6:	f043 0301 	orr.w	r3, r3, #1
 80175da:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80175dc:	4b3d      	ldr	r3, [pc, #244]	; (80176d4 <stm32_clock_init+0x114>)
 80175de:	681b      	ldr	r3, [r3, #0]
 80175e0:	f003 0302 	and.w	r3, r3, #2
 80175e4:	2b00      	cmp	r3, #0
 80175e6:	d0f9      	beq.n	80175dc <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80175e8:	4a3a      	ldr	r2, [pc, #232]	; (80176d4 <stm32_clock_init+0x114>)
 80175ea:	4b3a      	ldr	r3, [pc, #232]	; (80176d4 <stm32_clock_init+0x114>)
 80175ec:	689b      	ldr	r3, [r3, #8]
 80175ee:	f023 0303 	bic.w	r3, r3, #3
 80175f2:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80175f4:	4a37      	ldr	r2, [pc, #220]	; (80176d4 <stm32_clock_init+0x114>)
 80175f6:	4b37      	ldr	r3, [pc, #220]	; (80176d4 <stm32_clock_init+0x114>)
 80175f8:	689b      	ldr	r3, [r3, #8]
 80175fa:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80175fc:	4b35      	ldr	r3, [pc, #212]	; (80176d4 <stm32_clock_init+0x114>)
 80175fe:	689b      	ldr	r3, [r3, #8]
 8017600:	f003 030c 	and.w	r3, r3, #12
 8017604:	2b00      	cmp	r3, #0
 8017606:	d1f9      	bne.n	80175fc <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8017608:	4a32      	ldr	r2, [pc, #200]	; (80176d4 <stm32_clock_init+0x114>)
 801760a:	4b32      	ldr	r3, [pc, #200]	; (80176d4 <stm32_clock_init+0x114>)
 801760c:	681b      	ldr	r3, [r3, #0]
 801760e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8017612:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8017614:	4b2f      	ldr	r3, [pc, #188]	; (80176d4 <stm32_clock_init+0x114>)
 8017616:	2200      	movs	r2, #0
 8017618:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 801761a:	4a2e      	ldr	r2, [pc, #184]	; (80176d4 <stm32_clock_init+0x114>)
 801761c:	4b2d      	ldr	r3, [pc, #180]	; (80176d4 <stm32_clock_init+0x114>)
 801761e:	681b      	ldr	r3, [r3, #0]
 8017620:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8017624:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8017626:	4b2b      	ldr	r3, [pc, #172]	; (80176d4 <stm32_clock_init+0x114>)
 8017628:	681b      	ldr	r3, [r3, #0]
 801762a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 801762e:	2b00      	cmp	r3, #0
 8017630:	d0f9      	beq.n	8017626 <stm32_clock_init+0x66>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8017632:	4a28      	ldr	r2, [pc, #160]	; (80176d4 <stm32_clock_init+0x114>)
 8017634:	4b27      	ldr	r3, [pc, #156]	; (80176d4 <stm32_clock_init+0x114>)
 8017636:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8017638:	f043 0301 	orr.w	r3, r3, #1
 801763c:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 801763e:	4b25      	ldr	r3, [pc, #148]	; (80176d4 <stm32_clock_init+0x114>)
 8017640:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8017642:	f003 0302 	and.w	r3, r3, #2
 8017646:	2b00      	cmp	r3, #0
 8017648:	d0f9      	beq.n	801763e <stm32_clock_init+0x7e>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 801764a:	4b22      	ldr	r3, [pc, #136]	; (80176d4 <stm32_clock_init+0x114>)
 801764c:	4a23      	ldr	r2, [pc, #140]	; (80176dc <stm32_clock_init+0x11c>)
 801764e:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8017650:	4a20      	ldr	r2, [pc, #128]	; (80176d4 <stm32_clock_init+0x114>)
 8017652:	4b20      	ldr	r3, [pc, #128]	; (80176d4 <stm32_clock_init+0x114>)
 8017654:	681b      	ldr	r3, [r3, #0]
 8017656:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 801765a:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 801765c:	4b1e      	ldr	r3, [pc, #120]	; (80176d8 <stm32_clock_init+0x118>)
 801765e:	685b      	ldr	r3, [r3, #4]
 8017660:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8017664:	2b00      	cmp	r3, #0
 8017666:	d0f9      	beq.n	801765c <stm32_clock_init+0x9c>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8017668:	4b1a      	ldr	r3, [pc, #104]	; (80176d4 <stm32_clock_init+0x114>)
 801766a:	681b      	ldr	r3, [r3, #0]
 801766c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8017670:	2b00      	cmp	r3, #0
 8017672:	d0f9      	beq.n	8017668 <stm32_clock_init+0xa8>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8017674:	4b17      	ldr	r3, [pc, #92]	; (80176d4 <stm32_clock_init+0x114>)
 8017676:	4a1a      	ldr	r2, [pc, #104]	; (80176e0 <stm32_clock_init+0x120>)
 8017678:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 801767a:	4b1a      	ldr	r3, [pc, #104]	; (80176e4 <stm32_clock_init+0x124>)
 801767c:	681b      	ldr	r3, [r3, #0]
 801767e:	4a1a      	ldr	r2, [pc, #104]	; (80176e8 <stm32_clock_init+0x128>)
 8017680:	4293      	cmp	r3, r2
 8017682:	d109      	bne.n	8017698 <stm32_clock_init+0xd8>
 8017684:	4b19      	ldr	r3, [pc, #100]	; (80176ec <stm32_clock_init+0x12c>)
 8017686:	681b      	ldr	r3, [r3, #0]
 8017688:	4a19      	ldr	r2, [pc, #100]	; (80176f0 <stm32_clock_init+0x130>)
 801768a:	4293      	cmp	r3, r2
 801768c:	d104      	bne.n	8017698 <stm32_clock_init+0xd8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 801768e:	4b19      	ldr	r3, [pc, #100]	; (80176f4 <stm32_clock_init+0x134>)
 8017690:	f240 1205 	movw	r2, #261	; 0x105
 8017694:	601a      	str	r2, [r3, #0]
 8017696:	e003      	b.n	80176a0 <stm32_clock_init+0xe0>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8017698:	4b16      	ldr	r3, [pc, #88]	; (80176f4 <stm32_clock_init+0x134>)
 801769a:	f240 7205 	movw	r2, #1797	; 0x705
 801769e:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80176a0:	4a0c      	ldr	r2, [pc, #48]	; (80176d4 <stm32_clock_init+0x114>)
 80176a2:	4b0c      	ldr	r3, [pc, #48]	; (80176d4 <stm32_clock_init+0x114>)
 80176a4:	689b      	ldr	r3, [r3, #8]
 80176a6:	f043 0302 	orr.w	r3, r3, #2
 80176aa:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80176ac:	4b09      	ldr	r3, [pc, #36]	; (80176d4 <stm32_clock_init+0x114>)
 80176ae:	689b      	ldr	r3, [r3, #8]
 80176b0:	f003 030c 	and.w	r3, r3, #12
 80176b4:	2b08      	cmp	r3, #8
 80176b6:	d1f9      	bne.n	80176ac <stm32_clock_init+0xec>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80176b8:	4a06      	ldr	r2, [pc, #24]	; (80176d4 <stm32_clock_init+0x114>)
 80176ba:	4b06      	ldr	r3, [pc, #24]	; (80176d4 <stm32_clock_init+0x114>)
 80176bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80176be:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80176c2:	6453      	str	r3, [r2, #68]	; 0x44
 80176c4:	4a03      	ldr	r2, [pc, #12]	; (80176d4 <stm32_clock_init+0x114>)
 80176c6:	4b03      	ldr	r3, [pc, #12]	; (80176d4 <stm32_clock_init+0x114>)
 80176c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80176ca:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80176ce:	6653      	str	r3, [r2, #100]	; 0x64
}
 80176d0:	4770      	bx	lr
 80176d2:	bf00      	nop
 80176d4:	40023800 	.word	0x40023800
 80176d8:	40007000 	.word	0x40007000
 80176dc:	07405410 	.word	0x07405410
 80176e0:	38889400 	.word	0x38889400
 80176e4:	e0042000 	.word	0xe0042000
 80176e8:	20006411 	.word	0x20006411
 80176ec:	e000ed00 	.word	0xe000ed00
 80176f0:	410fc241 	.word	0x410fc241
 80176f4:	40023c00 	.word	0x40023c00
	...

08017700 <port_lock.lto_priv.783>:
static inline void port_lock(void) {
 8017700:	b082      	sub	sp, #8
 8017702:	2320      	movs	r3, #32
 8017704:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017706:	9b01      	ldr	r3, [sp, #4]
 8017708:	f383 8811 	msr	BASEPRI, r3
}
 801770c:	b002      	add	sp, #8
 801770e:	4770      	bx	lr

08017710 <port_unlock.lto_priv.781>:
static inline void port_unlock(void) {
 8017710:	b082      	sub	sp, #8
 8017712:	2300      	movs	r3, #0
 8017714:	9301      	str	r3, [sp, #4]
 8017716:	9b01      	ldr	r3, [sp, #4]
 8017718:	f383 8811 	msr	BASEPRI, r3
}
 801771c:	b002      	add	sp, #8
 801771e:	4770      	bx	lr

08017720 <port_lock_from_isr.lto_priv.779>:
static inline void port_lock_from_isr(void) {
 8017720:	b508      	push	{r3, lr}
  port_lock();
 8017722:	f7ff ffed 	bl	8017700 <port_lock.lto_priv.783>
}
 8017726:	bd08      	pop	{r3, pc}
	...

08017730 <port_unlock_from_isr.lto_priv.777>:
static inline void port_unlock_from_isr(void) {
 8017730:	b508      	push	{r3, lr}
  port_unlock();
 8017732:	f7ff ffed 	bl	8017710 <port_unlock.lto_priv.781>
}
 8017736:	bd08      	pop	{r3, pc}
	...

08017740 <chSysLockFromISR.lto_priv.775>:
static inline void chSysLockFromISR(void) {
 8017740:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8017742:	f7ff ffed 	bl	8017720 <port_lock_from_isr.lto_priv.779>
}
 8017746:	bd08      	pop	{r3, pc}
	...

08017750 <chSysUnlockFromISR.lto_priv.773>:
static inline void chSysUnlockFromISR(void) {
 8017750:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8017752:	f7ff ffed 	bl	8017730 <port_unlock_from_isr.lto_priv.777>
}
 8017756:	bd08      	pop	{r3, pc}
	...

08017760 <osalSysLockFromISR.lto_priv.793>:
static inline void osalSysLockFromISR(void) {
 8017760:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8017762:	f7ff ffed 	bl	8017740 <chSysLockFromISR.lto_priv.775>
}
 8017766:	bd08      	pop	{r3, pc}
	...

08017770 <osalSysUnlockFromISR.lto_priv.791>:
static inline void osalSysUnlockFromISR(void) {
 8017770:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8017772:	f7ff ffed 	bl	8017750 <chSysUnlockFromISR.lto_priv.773>
}
 8017776:	bd08      	pop	{r3, pc}
	...

08017780 <osalThreadDequeueAllI.lto_priv.786>:
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8017780:	b500      	push	{lr}
 8017782:	b083      	sub	sp, #12
 8017784:	9001      	str	r0, [sp, #4]
 8017786:	9100      	str	r1, [sp, #0]
  chThdDequeueAllI(tqp, msg);
 8017788:	9900      	ldr	r1, [sp, #0]
 801778a:	9801      	ldr	r0, [sp, #4]
 801778c:	f7fd f9e0 	bl	8014b50 <chThdDequeueAllI>
}
 8017790:	b003      	add	sp, #12
 8017792:	f85d fb04 	ldr.w	pc, [sp], #4
 8017796:	bf00      	nop
	...

080177a0 <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
 80177a0:	b500      	push	{lr}
 80177a2:	b083      	sub	sp, #12
 80177a4:	9001      	str	r0, [sp, #4]
 80177a6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 80177a8:	9900      	ldr	r1, [sp, #0]
 80177aa:	9801      	ldr	r0, [sp, #4]
 80177ac:	f7fb fc80 	bl	80130b0 <chEvtBroadcastFlagsI>
}
 80177b0:	b003      	add	sp, #12
 80177b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80177b6:	bf00      	nop
	...

080177c0 <can_lld_set_filters>:
 * @notapi
 */
static void can_lld_set_filters(CANDriver* canp,
                                uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {
 80177c0:	b086      	sub	sp, #24
 80177c2:	9003      	str	r0, [sp, #12]
 80177c4:	9102      	str	r1, [sp, #8]
 80177c6:	9201      	str	r2, [sp, #4]
 80177c8:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Temporarily enabling CAN clock.*/
#if STM32_CAN_USE_CAN1
  if(canp == &CAND1) {
 80177ca:	9b03      	ldr	r3, [sp, #12]
 80177cc:	4a7c      	ldr	r2, [pc, #496]	; (80179c0 <can_lld_set_filters+0x200>)
 80177ce:	4293      	cmp	r3, r2
 80177d0:	d126      	bne.n	8017820 <can_lld_set_filters+0x60>
    rccEnableCAN1(true);
 80177d2:	4a7c      	ldr	r2, [pc, #496]	; (80179c4 <can_lld_set_filters+0x204>)
 80177d4:	4b7b      	ldr	r3, [pc, #492]	; (80179c4 <can_lld_set_filters+0x204>)
 80177d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80177d8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80177dc:	6413      	str	r3, [r2, #64]	; 0x40
 80177de:	4a79      	ldr	r2, [pc, #484]	; (80179c4 <can_lld_set_filters+0x204>)
 80177e0:	4b78      	ldr	r3, [pc, #480]	; (80179c4 <can_lld_set_filters+0x204>)
 80177e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80177e4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80177e8:	6613      	str	r3, [r2, #96]	; 0x60
    /* Filters initialization.*/
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 80177ea:	9b03      	ldr	r3, [sp, #12]
 80177ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80177ee:	9b03      	ldr	r3, [sp, #12]
 80177f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80177f2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80177f6:	0c1b      	lsrs	r3, r3, #16
 80177f8:	041b      	lsls	r3, r3, #16
 80177fa:	f043 0301 	orr.w	r3, r3, #1
 80177fe:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 8017802:	9b03      	ldr	r3, [sp, #12]
 8017804:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8017806:	9b03      	ldr	r3, [sp, #12]
 8017808:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801780a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 801780e:	0c1b      	lsrs	r3, r3, #16
 8017810:	041b      	lsls	r3, r3, #16
 8017812:	9902      	ldr	r1, [sp, #8]
 8017814:	0209      	lsls	r1, r1, #8
 8017816:	430b      	orrs	r3, r1
 8017818:	f043 0301 	orr.w	r3, r3, #1
 801781c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    /* Filters initialization.*/
    canp->can->FMR = (canp->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
  }
#endif

  if (num > 0) {
 8017820:	9b01      	ldr	r3, [sp, #4]
 8017822:	2b00      	cmp	r3, #0
 8017824:	f000 8098 	beq.w	8017958 <can_lld_set_filters+0x198>
    uint32_t i, fmask;

    /* All filters cleared.*/
    canp->can->FA1R = 0;
 8017828:	9b03      	ldr	r3, [sp, #12]
 801782a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801782c:	2200      	movs	r2, #0
 801782e:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    canp->can->FM1R = 0;
 8017832:	9b03      	ldr	r3, [sp, #12]
 8017834:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017836:	2200      	movs	r2, #0
 8017838:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    canp->can->FS1R = 0;
 801783c:	9b03      	ldr	r3, [sp, #12]
 801783e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017840:	2200      	movs	r2, #0
 8017842:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    canp->can->FFA1R = 0;
 8017846:	9b03      	ldr	r3, [sp, #12]
 8017848:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801784a:	2200      	movs	r2, #0
 801784c:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214

#if STM32_CAN_USE_CAN1
    if(canp == &CAND1) {
 8017850:	9b03      	ldr	r3, [sp, #12]
 8017852:	4a5b      	ldr	r2, [pc, #364]	; (80179c0 <can_lld_set_filters+0x200>)
 8017854:	4293      	cmp	r3, r2
 8017856:	d117      	bne.n	8017888 <can_lld_set_filters+0xc8>
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 8017858:	2300      	movs	r3, #0
 801785a:	9305      	str	r3, [sp, #20]
 801785c:	e011      	b.n	8017882 <can_lld_set_filters+0xc2>
        canp->can->sFilterRegister[i].FR1 = 0;
 801785e:	9b03      	ldr	r3, [sp, #12]
 8017860:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017862:	9a05      	ldr	r2, [sp, #20]
 8017864:	3248      	adds	r2, #72	; 0x48
 8017866:	2100      	movs	r1, #0
 8017868:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
        canp->can->sFilterRegister[i].FR2 = 0;
 801786c:	9b03      	ldr	r3, [sp, #12]
 801786e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8017870:	9b05      	ldr	r3, [sp, #20]
 8017872:	3348      	adds	r3, #72	; 0x48
 8017874:	00db      	lsls	r3, r3, #3
 8017876:	4413      	add	r3, r2
 8017878:	2200      	movs	r2, #0
 801787a:	605a      	str	r2, [r3, #4]
      for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 801787c:	9b05      	ldr	r3, [sp, #20]
 801787e:	3301      	adds	r3, #1
 8017880:	9305      	str	r3, [sp, #20]
 8017882:	9b05      	ldr	r3, [sp, #20]
 8017884:	2b1b      	cmp	r3, #27
 8017886:	d9ea      	bls.n	801785e <can_lld_set_filters+0x9e>
      }
    }
#endif

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
 8017888:	2300      	movs	r3, #0
 801788a:	9305      	str	r3, [sp, #20]
 801788c:	e05f      	b.n	801794e <can_lld_set_filters+0x18e>
      fmask = 1 << cfp->filter;
 801788e:	9b00      	ldr	r3, [sp, #0]
 8017890:	881b      	ldrh	r3, [r3, #0]
 8017892:	461a      	mov	r2, r3
 8017894:	2301      	movs	r3, #1
 8017896:	4093      	lsls	r3, r2
 8017898:	9304      	str	r3, [sp, #16]
      if (cfp->mode)
 801789a:	9b00      	ldr	r3, [sp, #0]
 801789c:	789b      	ldrb	r3, [r3, #2]
 801789e:	f003 0301 	and.w	r3, r3, #1
 80178a2:	b2db      	uxtb	r3, r3
 80178a4:	2b00      	cmp	r3, #0
 80178a6:	d009      	beq.n	80178bc <can_lld_set_filters+0xfc>
        canp->can->FM1R |= fmask;
 80178a8:	9b03      	ldr	r3, [sp, #12]
 80178aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80178ac:	9a03      	ldr	r2, [sp, #12]
 80178ae:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80178b0:	f8d2 1204 	ldr.w	r1, [r2, #516]	; 0x204
 80178b4:	9a04      	ldr	r2, [sp, #16]
 80178b6:	430a      	orrs	r2, r1
 80178b8:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
      if (cfp->scale)
 80178bc:	9b00      	ldr	r3, [sp, #0]
 80178be:	789b      	ldrb	r3, [r3, #2]
 80178c0:	f003 0302 	and.w	r3, r3, #2
 80178c4:	b2db      	uxtb	r3, r3
 80178c6:	2b00      	cmp	r3, #0
 80178c8:	d009      	beq.n	80178de <can_lld_set_filters+0x11e>
        canp->can->FS1R |= fmask;
 80178ca:	9b03      	ldr	r3, [sp, #12]
 80178cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80178ce:	9a03      	ldr	r2, [sp, #12]
 80178d0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80178d2:	f8d2 120c 	ldr.w	r1, [r2, #524]	; 0x20c
 80178d6:	9a04      	ldr	r2, [sp, #16]
 80178d8:	430a      	orrs	r2, r1
 80178da:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
      if (cfp->assignment)
 80178de:	9b00      	ldr	r3, [sp, #0]
 80178e0:	789b      	ldrb	r3, [r3, #2]
 80178e2:	f003 0304 	and.w	r3, r3, #4
 80178e6:	b2db      	uxtb	r3, r3
 80178e8:	2b00      	cmp	r3, #0
 80178ea:	d009      	beq.n	8017900 <can_lld_set_filters+0x140>
        canp->can->FFA1R |= fmask;
 80178ec:	9b03      	ldr	r3, [sp, #12]
 80178ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80178f0:	9a03      	ldr	r2, [sp, #12]
 80178f2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80178f4:	f8d2 1214 	ldr.w	r1, [r2, #532]	; 0x214
 80178f8:	9a04      	ldr	r2, [sp, #16]
 80178fa:	430a      	orrs	r2, r1
 80178fc:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
      canp->can->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 8017900:	9b03      	ldr	r3, [sp, #12]
 8017902:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017904:	9a00      	ldr	r2, [sp, #0]
 8017906:	8812      	ldrh	r2, [r2, #0]
 8017908:	4610      	mov	r0, r2
 801790a:	9a00      	ldr	r2, [sp, #0]
 801790c:	6851      	ldr	r1, [r2, #4]
 801790e:	f100 0248 	add.w	r2, r0, #72	; 0x48
 8017912:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
      canp->can->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 8017916:	9b03      	ldr	r3, [sp, #12]
 8017918:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801791a:	9b00      	ldr	r3, [sp, #0]
 801791c:	881b      	ldrh	r3, [r3, #0]
 801791e:	4618      	mov	r0, r3
 8017920:	9b00      	ldr	r3, [sp, #0]
 8017922:	689a      	ldr	r2, [r3, #8]
 8017924:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8017928:	00db      	lsls	r3, r3, #3
 801792a:	440b      	add	r3, r1
 801792c:	605a      	str	r2, [r3, #4]
      canp->can->FA1R |= fmask;
 801792e:	9b03      	ldr	r3, [sp, #12]
 8017930:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017932:	9a03      	ldr	r2, [sp, #12]
 8017934:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017936:	f8d2 121c 	ldr.w	r1, [r2, #540]	; 0x21c
 801793a:	9a04      	ldr	r2, [sp, #16]
 801793c:	430a      	orrs	r2, r1
 801793e:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
      cfp++;
 8017942:	9b00      	ldr	r3, [sp, #0]
 8017944:	330c      	adds	r3, #12
 8017946:	9300      	str	r3, [sp, #0]
    for (i = 0; i < num; i++) {
 8017948:	9b05      	ldr	r3, [sp, #20]
 801794a:	3301      	adds	r3, #1
 801794c:	9305      	str	r3, [sp, #20]
 801794e:	9a05      	ldr	r2, [sp, #20]
 8017950:	9b01      	ldr	r3, [sp, #4]
 8017952:	429a      	cmp	r2, r3
 8017954:	d39b      	bcc.n	801788e <can_lld_set_filters+0xce>
 8017956:	e01d      	b.n	8017994 <can_lld_set_filters+0x1d4>
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    canp->can->sFilterRegister[0].FR1 = 0;
 8017958:	9b03      	ldr	r3, [sp, #12]
 801795a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801795c:	2200      	movs	r2, #0
 801795e:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
    canp->can->sFilterRegister[0].FR2 = 0;
 8017962:	9b03      	ldr	r3, [sp, #12]
 8017964:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017966:	2200      	movs	r2, #0
 8017968:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
    if(canp == &CAND1) {
      canp->can->sFilterRegister[can2sb].FR1 = 0;
      canp->can->sFilterRegister[can2sb].FR2 = 0;
    }
#endif
    canp->can->FM1R = 0;
 801796c:	9b03      	ldr	r3, [sp, #12]
 801796e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017970:	2200      	movs	r2, #0
 8017972:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    canp->can->FFA1R = 0;
 8017976:	9b03      	ldr	r3, [sp, #12]
 8017978:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801797a:	2200      	movs	r2, #0
 801797c:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    canp->can->FS1R = 1;
 8017980:	9b03      	ldr	r3, [sp, #12]
 8017982:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017984:	2201      	movs	r2, #1
 8017986:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    canp->can->FA1R = 1;
 801798a:	9b03      	ldr	r3, [sp, #12]
 801798c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801798e:	2201      	movs	r2, #1
 8017990:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
      canp->can->FS1R |= 1 << can2sb;
      canp->can->FA1R |= 1 << can2sb;
    }
#endif
  }
  canp->can->FMR &= ~CAN_FMR_FINIT;
 8017994:	9b03      	ldr	r3, [sp, #12]
 8017996:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017998:	9a03      	ldr	r2, [sp, #12]
 801799a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801799c:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
 80179a0:	f022 0201 	bic.w	r2, r2, #1
 80179a4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  /* Temporarily enabling CAN clock.*/
#if STM32_CAN_USE_CAN1
  if(canp == &CAND1) {
 80179a8:	9b03      	ldr	r3, [sp, #12]
 80179aa:	4a05      	ldr	r2, [pc, #20]	; (80179c0 <can_lld_set_filters+0x200>)
 80179ac:	4293      	cmp	r3, r2
 80179ae:	d105      	bne.n	80179bc <can_lld_set_filters+0x1fc>
    rccDisableCAN1();
 80179b0:	4a04      	ldr	r2, [pc, #16]	; (80179c4 <can_lld_set_filters+0x204>)
 80179b2:	4b04      	ldr	r3, [pc, #16]	; (80179c4 <can_lld_set_filters+0x204>)
 80179b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80179b6:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80179ba:	6413      	str	r3, [r2, #64]	; 0x40
#if STM32_CAN_USE_CAN3
  if(canp == &CAND3) {
    rccDisableCAN3();
  }
#endif
}
 80179bc:	b006      	add	sp, #24
 80179be:	4770      	bx	lr
 80179c0:	20004e68 	.word	0x20004e68
 80179c4:	40023800 	.word	0x40023800
	...

080179d0 <can_lld_tx_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 80179d0:	b500      	push	{lr}
 80179d2:	b085      	sub	sp, #20
 80179d4:	9001      	str	r0, [sp, #4]
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 80179d6:	9b01      	ldr	r3, [sp, #4]
 80179d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80179da:	689b      	ldr	r3, [r3, #8]
 80179dc:	9302      	str	r3, [sp, #8]
  canp->can->TSR = tsr;
 80179de:	9b01      	ldr	r3, [sp, #4]
 80179e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80179e2:	9a02      	ldr	r2, [sp, #8]
 80179e4:	609a      	str	r2, [r3, #8]

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;
 80179e6:	2300      	movs	r3, #0
 80179e8:	9303      	str	r3, [sp, #12]

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 80179ea:	9b02      	ldr	r3, [sp, #8]
 80179ec:	f003 0301 	and.w	r3, r3, #1
 80179f0:	2b00      	cmp	r3, #0
 80179f2:	d00d      	beq.n	8017a10 <can_lld_tx_handler+0x40>
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
 80179f4:	9b02      	ldr	r3, [sp, #8]
 80179f6:	f003 030c 	and.w	r3, r3, #12
 80179fa:	2b00      	cmp	r3, #0
 80179fc:	d004      	beq.n	8017a08 <can_lld_tx_handler+0x38>
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
 80179fe:	9b03      	ldr	r3, [sp, #12]
 8017a00:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8017a04:	9303      	str	r3, [sp, #12]
 8017a06:	e003      	b.n	8017a10 <can_lld_tx_handler+0x40>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(1U);
 8017a08:	9b03      	ldr	r3, [sp, #12]
 8017a0a:	f043 0301 	orr.w	r3, r3, #1
 8017a0e:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 1.*/
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
 8017a10:	9b02      	ldr	r3, [sp, #8]
 8017a12:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8017a16:	2b00      	cmp	r3, #0
 8017a18:	d00d      	beq.n	8017a36 <can_lld_tx_handler+0x66>
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
 8017a1a:	9b02      	ldr	r3, [sp, #8]
 8017a1c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8017a20:	2b00      	cmp	r3, #0
 8017a22:	d004      	beq.n	8017a2e <can_lld_tx_handler+0x5e>
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
 8017a24:	9b03      	ldr	r3, [sp, #12]
 8017a26:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8017a2a:	9303      	str	r3, [sp, #12]
 8017a2c:	e003      	b.n	8017a36 <can_lld_tx_handler+0x66>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(2U);
 8017a2e:	9b03      	ldr	r3, [sp, #12]
 8017a30:	f043 0302 	orr.w	r3, r3, #2
 8017a34:	9303      	str	r3, [sp, #12]
    }
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
 8017a36:	9b02      	ldr	r3, [sp, #8]
 8017a38:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8017a3c:	2b00      	cmp	r3, #0
 8017a3e:	d00d      	beq.n	8017a5c <can_lld_tx_handler+0x8c>
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
 8017a40:	9b02      	ldr	r3, [sp, #8]
 8017a42:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8017a46:	2b00      	cmp	r3, #0
 8017a48:	d004      	beq.n	8017a54 <can_lld_tx_handler+0x84>
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
 8017a4a:	9b03      	ldr	r3, [sp, #12]
 8017a4c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8017a50:	9303      	str	r3, [sp, #12]
 8017a52:	e003      	b.n	8017a5c <can_lld_tx_handler+0x8c>
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(3U);
 8017a54:	9b03      	ldr	r3, [sp, #12]
 8017a56:	f043 0304 	orr.w	r3, r3, #4
 8017a5a:	9303      	str	r3, [sp, #12]
    }
  }

  /* Signaling flags and waking up threads waiting for a transmission slot.*/
  _can_tx_empty_isr(canp, flags);
 8017a5c:	f7ff fe80 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017a60:	9b01      	ldr	r3, [sp, #4]
 8017a62:	3308      	adds	r3, #8
 8017a64:	2100      	movs	r1, #0
 8017a66:	4618      	mov	r0, r3
 8017a68:	f7ff fe8a 	bl	8017780 <osalThreadDequeueAllI.lto_priv.786>
 8017a6c:	9b01      	ldr	r3, [sp, #4]
 8017a6e:	331c      	adds	r3, #28
 8017a70:	9903      	ldr	r1, [sp, #12]
 8017a72:	4618      	mov	r0, r3
 8017a74:	f7ff fe94 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017a78:	f7ff fe7a 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
}
 8017a7c:	b005      	add	sp, #20
 8017a7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8017a82:	bf00      	nop
	...

08017a90 <can_lld_rx0_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8017a90:	b500      	push	{lr}
 8017a92:	b085      	sub	sp, #20
 8017a94:	9001      	str	r0, [sp, #4]
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 8017a96:	9b01      	ldr	r3, [sp, #4]
 8017a98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017a9a:	68db      	ldr	r3, [r3, #12]
 8017a9c:	9303      	str	r3, [sp, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 8017a9e:	9b03      	ldr	r3, [sp, #12]
 8017aa0:	f003 0303 	and.w	r3, r3, #3
 8017aa4:	2b00      	cmp	r3, #0
 8017aa6:	d017      	beq.n	8017ad8 <can_lld_rx0_handler+0x48>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 8017aa8:	9b01      	ldr	r3, [sp, #4]
 8017aaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017aac:	9a01      	ldr	r2, [sp, #4]
 8017aae:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017ab0:	6952      	ldr	r2, [r2, #20]
 8017ab2:	f022 0202 	bic.w	r2, r2, #2
 8017ab6:	615a      	str	r2, [r3, #20]
    _can_rx_full_isr(canp, CAN_MAILBOX_TO_MASK(1U));
 8017ab8:	f7ff fe52 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017abc:	9b01      	ldr	r3, [sp, #4]
 8017abe:	3310      	adds	r3, #16
 8017ac0:	2100      	movs	r1, #0
 8017ac2:	4618      	mov	r0, r3
 8017ac4:	f7ff fe5c 	bl	8017780 <osalThreadDequeueAllI.lto_priv.786>
 8017ac8:	9b01      	ldr	r3, [sp, #4]
 8017aca:	3318      	adds	r3, #24
 8017acc:	2101      	movs	r1, #1
 8017ace:	4618      	mov	r0, r3
 8017ad0:	f7ff fe66 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017ad4:	f7ff fe4c 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 8017ad8:	9b03      	ldr	r3, [sp, #12]
 8017ada:	f003 0310 	and.w	r3, r3, #16
 8017ade:	2b00      	cmp	r3, #0
 8017ae0:	d00d      	beq.n	8017afe <can_lld_rx0_handler+0x6e>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 8017ae2:	9b01      	ldr	r3, [sp, #4]
 8017ae4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017ae6:	2210      	movs	r2, #16
 8017ae8:	60da      	str	r2, [r3, #12]
    _can_error_isr(canp, CAN_OVERFLOW_ERROR);
 8017aea:	f7ff fe39 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017aee:	9b01      	ldr	r3, [sp, #4]
 8017af0:	3320      	adds	r3, #32
 8017af2:	2110      	movs	r1, #16
 8017af4:	4618      	mov	r0, r3
 8017af6:	f7ff fe53 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017afa:	f7ff fe39 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
}
 8017afe:	b005      	add	sp, #20
 8017b00:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08017b10 <can_lld_rx1_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8017b10:	b500      	push	{lr}
 8017b12:	b085      	sub	sp, #20
 8017b14:	9001      	str	r0, [sp, #4]
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 8017b16:	9b01      	ldr	r3, [sp, #4]
 8017b18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017b1a:	691b      	ldr	r3, [r3, #16]
 8017b1c:	9303      	str	r3, [sp, #12]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 8017b1e:	9b03      	ldr	r3, [sp, #12]
 8017b20:	f003 0303 	and.w	r3, r3, #3
 8017b24:	2b00      	cmp	r3, #0
 8017b26:	d017      	beq.n	8017b58 <can_lld_rx1_handler+0x48>
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 8017b28:	9b01      	ldr	r3, [sp, #4]
 8017b2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017b2c:	9a01      	ldr	r2, [sp, #4]
 8017b2e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017b30:	6952      	ldr	r2, [r2, #20]
 8017b32:	f022 0210 	bic.w	r2, r2, #16
 8017b36:	615a      	str	r2, [r3, #20]
    _can_rx_full_isr(canp, CAN_MAILBOX_TO_MASK(2U));
 8017b38:	f7ff fe12 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017b3c:	9b01      	ldr	r3, [sp, #4]
 8017b3e:	3310      	adds	r3, #16
 8017b40:	2100      	movs	r1, #0
 8017b42:	4618      	mov	r0, r3
 8017b44:	f7ff fe1c 	bl	8017780 <osalThreadDequeueAllI.lto_priv.786>
 8017b48:	9b01      	ldr	r3, [sp, #4]
 8017b4a:	3318      	adds	r3, #24
 8017b4c:	2102      	movs	r1, #2
 8017b4e:	4618      	mov	r0, r3
 8017b50:	f7ff fe26 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017b54:	f7ff fe0c 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 8017b58:	9b03      	ldr	r3, [sp, #12]
 8017b5a:	f003 0310 	and.w	r3, r3, #16
 8017b5e:	2b00      	cmp	r3, #0
 8017b60:	d00d      	beq.n	8017b7e <can_lld_rx1_handler+0x6e>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 8017b62:	9b01      	ldr	r3, [sp, #4]
 8017b64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017b66:	2210      	movs	r2, #16
 8017b68:	611a      	str	r2, [r3, #16]
    _can_error_isr(canp, CAN_OVERFLOW_ERROR);
 8017b6a:	f7ff fdf9 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017b6e:	9b01      	ldr	r3, [sp, #4]
 8017b70:	3320      	adds	r3, #32
 8017b72:	2110      	movs	r1, #16
 8017b74:	4618      	mov	r0, r3
 8017b76:	f7ff fe13 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017b7a:	f7ff fdf9 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
}
 8017b7e:	b005      	add	sp, #20
 8017b80:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08017b90 <can_lld_sce_handler>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 8017b90:	b500      	push	{lr}
 8017b92:	b087      	sub	sp, #28
 8017b94:	9001      	str	r0, [sp, #4]
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 8017b96:	9b01      	ldr	r3, [sp, #4]
 8017b98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017b9a:	685b      	ldr	r3, [r3, #4]
 8017b9c:	9305      	str	r3, [sp, #20]
  canp->can->MSR = msr;
 8017b9e:	9b01      	ldr	r3, [sp, #4]
 8017ba0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017ba2:	9a05      	ldr	r2, [sp, #20]
 8017ba4:	605a      	str	r2, [r3, #4]

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 8017ba6:	9b05      	ldr	r3, [sp, #20]
 8017ba8:	f003 0308 	and.w	r3, r3, #8
 8017bac:	2b00      	cmp	r3, #0
 8017bae:	d014      	beq.n	8017bda <can_lld_sce_handler+0x4a>
    canp->state = CAN_READY;
 8017bb0:	9b01      	ldr	r3, [sp, #4]
 8017bb2:	2203      	movs	r2, #3
 8017bb4:	701a      	strb	r2, [r3, #0]
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 8017bb6:	9b01      	ldr	r3, [sp, #4]
 8017bb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017bba:	9a01      	ldr	r2, [sp, #4]
 8017bbc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017bbe:	6812      	ldr	r2, [r2, #0]
 8017bc0:	f022 0202 	bic.w	r2, r2, #2
 8017bc4:	601a      	str	r2, [r3, #0]
    _can_wakeup_isr(canp);
 8017bc6:	f7ff fdcb 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017bca:	9b01      	ldr	r3, [sp, #4]
 8017bcc:	3328      	adds	r3, #40	; 0x28
 8017bce:	2100      	movs	r1, #0
 8017bd0:	4618      	mov	r0, r3
 8017bd2:	f7ff fde5 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017bd6:	f7ff fdcb 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 8017bda:	9b05      	ldr	r3, [sp, #20]
 8017bdc:	f003 0304 	and.w	r3, r3, #4
 8017be0:	2b00      	cmp	r3, #0
 8017be2:	d013      	beq.n	8017c0c <can_lld_sce_handler+0x7c>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 8017be4:	9b01      	ldr	r3, [sp, #4]
 8017be6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017be8:	699b      	ldr	r3, [r3, #24]
 8017bea:	9304      	str	r3, [sp, #16]
#if STM32_CAN_REPORT_ALL_ERRORS
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
#else
    flags = 0;
 8017bec:	2300      	movs	r3, #0
 8017bee:	9303      	str	r3, [sp, #12]
#endif

    /* The content of the ESR register is copied unchanged in the upper
       half word of the listener flags mask.*/
    _can_error_isr(canp, flags | (eventflags_t)(esr << 16U));
 8017bf0:	f7ff fdb6 	bl	8017760 <osalSysLockFromISR.lto_priv.793>
 8017bf4:	9b01      	ldr	r3, [sp, #4]
 8017bf6:	f103 0020 	add.w	r0, r3, #32
 8017bfa:	9b04      	ldr	r3, [sp, #16]
 8017bfc:	041a      	lsls	r2, r3, #16
 8017bfe:	9b03      	ldr	r3, [sp, #12]
 8017c00:	4313      	orrs	r3, r2
 8017c02:	4619      	mov	r1, r3
 8017c04:	f7ff fdcc 	bl	80177a0 <osalEventBroadcastFlagsI>
 8017c08:	f7ff fdb2 	bl	8017770 <osalSysUnlockFromISR.lto_priv.791>
  }
}
 8017c0c:	b007      	add	sp, #28
 8017c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8017c12:	bf00      	nop
	...

08017c20 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8017c20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);
 8017c22:	4803      	ldr	r0, [pc, #12]	; (8017c30 <Vector8C+0x10>)
 8017c24:	f7ff fed4 	bl	80179d0 <can_lld_tx_handler>

  OSAL_IRQ_EPILOGUE();
 8017c28:	f7fb fd32 	bl	8013690 <_port_irq_epilogue>
}
 8017c2c:	bd08      	pop	{r3, pc}
 8017c2e:	bf00      	nop
 8017c30:	20004e68 	.word	0x20004e68
	...

08017c40 <Vector90>:
/**
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 8017c40:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);
 8017c42:	4803      	ldr	r0, [pc, #12]	; (8017c50 <Vector90+0x10>)
 8017c44:	f7ff ff24 	bl	8017a90 <can_lld_rx0_handler>

  OSAL_IRQ_EPILOGUE();
 8017c48:	f7fb fd22 	bl	8013690 <_port_irq_epilogue>
}
 8017c4c:	bd08      	pop	{r3, pc}
 8017c4e:	bf00      	nop
 8017c50:	20004e68 	.word	0x20004e68
	...

08017c60 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 8017c60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);
 8017c62:	4803      	ldr	r0, [pc, #12]	; (8017c70 <Vector94+0x10>)
 8017c64:	f7ff ff54 	bl	8017b10 <can_lld_rx1_handler>

  OSAL_IRQ_EPILOGUE();
 8017c68:	f7fb fd12 	bl	8013690 <_port_irq_epilogue>
}
 8017c6c:	bd08      	pop	{r3, pc}
 8017c6e:	bf00      	nop
 8017c70:	20004e68 	.word	0x20004e68
	...

08017c80 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 8017c80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);
 8017c82:	4803      	ldr	r0, [pc, #12]	; (8017c90 <Vector98+0x10>)
 8017c84:	f7ff ff84 	bl	8017b90 <can_lld_sce_handler>

  OSAL_IRQ_EPILOGUE();
 8017c88:	f7fb fd02 	bl	8013690 <_port_irq_epilogue>
}
 8017c8c:	bd08      	pop	{r3, pc}
 8017c8e:	bf00      	nop
 8017c90:	20004e68 	.word	0x20004e68
	...

08017ca0 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 8017ca0:	b508      	push	{r3, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 8017ca2:	480e      	ldr	r0, [pc, #56]	; (8017cdc <can_lld_init+0x3c>)
 8017ca4:	f002 fae4 	bl	801a270 <canObjectInit>
  CAND1.can = CAN1;
 8017ca8:	4b0c      	ldr	r3, [pc, #48]	; (8017cdc <can_lld_init+0x3c>)
 8017caa:	4a0d      	ldr	r2, [pc, #52]	; (8017ce0 <can_lld_init+0x40>)
 8017cac:	62da      	str	r2, [r3, #44]	; 0x2c
#if defined(STM32_CAN1_UNIFIED_NUMBER)
    nvicEnableVector(STM32_CAN1_UNIFIED_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
#else
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8017cae:	210b      	movs	r1, #11
 8017cb0:	2013      	movs	r0, #19
 8017cb2:	f001 fda5 	bl	8019800 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8017cb6:	210b      	movs	r1, #11
 8017cb8:	2014      	movs	r0, #20
 8017cba:	f001 fda1 	bl	8019800 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8017cbe:	210b      	movs	r1, #11
 8017cc0:	2015      	movs	r0, #21
 8017cc2:	f001 fd9d 	bl	8019800 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8017cc6:	210b      	movs	r1, #11
 8017cc8:	2016      	movs	r0, #22
 8017cca:	f001 fd99 	bl	8019800 <nvicEnableVector>
#endif
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(&CAND1, STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 8017cce:	2300      	movs	r3, #0
 8017cd0:	2200      	movs	r2, #0
 8017cd2:	210e      	movs	r1, #14
 8017cd4:	4801      	ldr	r0, [pc, #4]	; (8017cdc <can_lld_init+0x3c>)
 8017cd6:	f7ff fd73 	bl	80177c0 <can_lld_set_filters>
#if STM32_HAS_CAN3
#if STM32_CAN_USE_CAN3
  can_lld_set_filters(&CAND3, STM32_CAN3_MAX_FILTERS, 0, NULL);
#endif
#endif
}
 8017cda:	bd08      	pop	{r3, pc}
 8017cdc:	20004e68 	.word	0x20004e68
 8017ce0:	40006400 	.word	0x40006400
	...

08017cf0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8017cf0:	b500      	push	{lr}
 8017cf2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8017cf4:	4b0b      	ldr	r3, [pc, #44]	; (8017d24 <Vector6C+0x34>)
 8017cf6:	681b      	ldr	r3, [r3, #0]
 8017cf8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017cfc:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8017cfe:	4a09      	ldr	r2, [pc, #36]	; (8017d24 <Vector6C+0x34>)
 8017d00:	9b01      	ldr	r3, [sp, #4]
 8017d02:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8017d04:	4b08      	ldr	r3, [pc, #32]	; (8017d28 <Vector6C+0x38>)
 8017d06:	681b      	ldr	r3, [r3, #0]
 8017d08:	2b00      	cmp	r3, #0
 8017d0a:	d006      	beq.n	8017d1a <Vector6C+0x2a>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8017d0c:	4b06      	ldr	r3, [pc, #24]	; (8017d28 <Vector6C+0x38>)
 8017d0e:	681b      	ldr	r3, [r3, #0]
 8017d10:	4a05      	ldr	r2, [pc, #20]	; (8017d28 <Vector6C+0x38>)
 8017d12:	6852      	ldr	r2, [r2, #4]
 8017d14:	9901      	ldr	r1, [sp, #4]
 8017d16:	4610      	mov	r0, r2
 8017d18:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017d1a:	f7fb fcb9 	bl	8013690 <_port_irq_epilogue>
}
 8017d1e:	b003      	add	sp, #12
 8017d20:	f85d fb04 	ldr.w	pc, [sp], #4
 8017d24:	40026000 	.word	0x40026000
 8017d28:	20004e9c 	.word	0x20004e9c
 8017d2c:	00000000 	.word	0x00000000

08017d30 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8017d30:	b500      	push	{lr}
 8017d32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8017d34:	4b0c      	ldr	r3, [pc, #48]	; (8017d68 <Vector70+0x38>)
 8017d36:	681b      	ldr	r3, [r3, #0]
 8017d38:	099b      	lsrs	r3, r3, #6
 8017d3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017d3e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8017d40:	4a09      	ldr	r2, [pc, #36]	; (8017d68 <Vector70+0x38>)
 8017d42:	9b01      	ldr	r3, [sp, #4]
 8017d44:	019b      	lsls	r3, r3, #6
 8017d46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8017d48:	4b08      	ldr	r3, [pc, #32]	; (8017d6c <Vector70+0x3c>)
 8017d4a:	689b      	ldr	r3, [r3, #8]
 8017d4c:	2b00      	cmp	r3, #0
 8017d4e:	d006      	beq.n	8017d5e <Vector70+0x2e>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8017d50:	4b06      	ldr	r3, [pc, #24]	; (8017d6c <Vector70+0x3c>)
 8017d52:	689b      	ldr	r3, [r3, #8]
 8017d54:	4a05      	ldr	r2, [pc, #20]	; (8017d6c <Vector70+0x3c>)
 8017d56:	68d2      	ldr	r2, [r2, #12]
 8017d58:	9901      	ldr	r1, [sp, #4]
 8017d5a:	4610      	mov	r0, r2
 8017d5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017d5e:	f7fb fc97 	bl	8013690 <_port_irq_epilogue>
}
 8017d62:	b003      	add	sp, #12
 8017d64:	f85d fb04 	ldr.w	pc, [sp], #4
 8017d68:	40026000 	.word	0x40026000
 8017d6c:	20004e9c 	.word	0x20004e9c

08017d70 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8017d70:	b500      	push	{lr}
 8017d72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8017d74:	4b0c      	ldr	r3, [pc, #48]	; (8017da8 <Vector74+0x38>)
 8017d76:	681b      	ldr	r3, [r3, #0]
 8017d78:	0c1b      	lsrs	r3, r3, #16
 8017d7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017d7e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8017d80:	4a09      	ldr	r2, [pc, #36]	; (8017da8 <Vector74+0x38>)
 8017d82:	9b01      	ldr	r3, [sp, #4]
 8017d84:	041b      	lsls	r3, r3, #16
 8017d86:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8017d88:	4b08      	ldr	r3, [pc, #32]	; (8017dac <Vector74+0x3c>)
 8017d8a:	691b      	ldr	r3, [r3, #16]
 8017d8c:	2b00      	cmp	r3, #0
 8017d8e:	d006      	beq.n	8017d9e <Vector74+0x2e>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8017d90:	4b06      	ldr	r3, [pc, #24]	; (8017dac <Vector74+0x3c>)
 8017d92:	691b      	ldr	r3, [r3, #16]
 8017d94:	4a05      	ldr	r2, [pc, #20]	; (8017dac <Vector74+0x3c>)
 8017d96:	6952      	ldr	r2, [r2, #20]
 8017d98:	9901      	ldr	r1, [sp, #4]
 8017d9a:	4610      	mov	r0, r2
 8017d9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017d9e:	f7fb fc77 	bl	8013690 <_port_irq_epilogue>
}
 8017da2:	b003      	add	sp, #12
 8017da4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017da8:	40026000 	.word	0x40026000
 8017dac:	20004e9c 	.word	0x20004e9c

08017db0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8017db0:	b500      	push	{lr}
 8017db2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8017db4:	4b0c      	ldr	r3, [pc, #48]	; (8017de8 <Vector78+0x38>)
 8017db6:	681b      	ldr	r3, [r3, #0]
 8017db8:	0d9b      	lsrs	r3, r3, #22
 8017dba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017dbe:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8017dc0:	4a09      	ldr	r2, [pc, #36]	; (8017de8 <Vector78+0x38>)
 8017dc2:	9b01      	ldr	r3, [sp, #4]
 8017dc4:	059b      	lsls	r3, r3, #22
 8017dc6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8017dc8:	4b08      	ldr	r3, [pc, #32]	; (8017dec <Vector78+0x3c>)
 8017dca:	699b      	ldr	r3, [r3, #24]
 8017dcc:	2b00      	cmp	r3, #0
 8017dce:	d006      	beq.n	8017dde <Vector78+0x2e>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8017dd0:	4b06      	ldr	r3, [pc, #24]	; (8017dec <Vector78+0x3c>)
 8017dd2:	699b      	ldr	r3, [r3, #24]
 8017dd4:	4a05      	ldr	r2, [pc, #20]	; (8017dec <Vector78+0x3c>)
 8017dd6:	69d2      	ldr	r2, [r2, #28]
 8017dd8:	9901      	ldr	r1, [sp, #4]
 8017dda:	4610      	mov	r0, r2
 8017ddc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017dde:	f7fb fc57 	bl	8013690 <_port_irq_epilogue>
}
 8017de2:	b003      	add	sp, #12
 8017de4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017de8:	40026000 	.word	0x40026000
 8017dec:	20004e9c 	.word	0x20004e9c

08017df0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8017df0:	b500      	push	{lr}
 8017df2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8017df4:	4b0b      	ldr	r3, [pc, #44]	; (8017e24 <Vector7C+0x34>)
 8017df6:	685b      	ldr	r3, [r3, #4]
 8017df8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017dfc:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8017dfe:	4a09      	ldr	r2, [pc, #36]	; (8017e24 <Vector7C+0x34>)
 8017e00:	9b01      	ldr	r3, [sp, #4]
 8017e02:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 8017e04:	4b08      	ldr	r3, [pc, #32]	; (8017e28 <Vector7C+0x38>)
 8017e06:	6a1b      	ldr	r3, [r3, #32]
 8017e08:	2b00      	cmp	r3, #0
 8017e0a:	d006      	beq.n	8017e1a <Vector7C+0x2a>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8017e0c:	4b06      	ldr	r3, [pc, #24]	; (8017e28 <Vector7C+0x38>)
 8017e0e:	6a1b      	ldr	r3, [r3, #32]
 8017e10:	4a05      	ldr	r2, [pc, #20]	; (8017e28 <Vector7C+0x38>)
 8017e12:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8017e14:	9901      	ldr	r1, [sp, #4]
 8017e16:	4610      	mov	r0, r2
 8017e18:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017e1a:	f7fb fc39 	bl	8013690 <_port_irq_epilogue>
}
 8017e1e:	b003      	add	sp, #12
 8017e20:	f85d fb04 	ldr.w	pc, [sp], #4
 8017e24:	40026000 	.word	0x40026000
 8017e28:	20004e9c 	.word	0x20004e9c
 8017e2c:	00000000 	.word	0x00000000

08017e30 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8017e30:	b500      	push	{lr}
 8017e32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8017e34:	4b0c      	ldr	r3, [pc, #48]	; (8017e68 <Vector80+0x38>)
 8017e36:	685b      	ldr	r3, [r3, #4]
 8017e38:	099b      	lsrs	r3, r3, #6
 8017e3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017e3e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 8017e40:	4a09      	ldr	r2, [pc, #36]	; (8017e68 <Vector80+0x38>)
 8017e42:	9b01      	ldr	r3, [sp, #4]
 8017e44:	019b      	lsls	r3, r3, #6
 8017e46:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 8017e48:	4b08      	ldr	r3, [pc, #32]	; (8017e6c <Vector80+0x3c>)
 8017e4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017e4c:	2b00      	cmp	r3, #0
 8017e4e:	d006      	beq.n	8017e5e <Vector80+0x2e>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8017e50:	4b06      	ldr	r3, [pc, #24]	; (8017e6c <Vector80+0x3c>)
 8017e52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017e54:	4a05      	ldr	r2, [pc, #20]	; (8017e6c <Vector80+0x3c>)
 8017e56:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8017e58:	9901      	ldr	r1, [sp, #4]
 8017e5a:	4610      	mov	r0, r2
 8017e5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017e5e:	f7fb fc17 	bl	8013690 <_port_irq_epilogue>
}
 8017e62:	b003      	add	sp, #12
 8017e64:	f85d fb04 	ldr.w	pc, [sp], #4
 8017e68:	40026000 	.word	0x40026000
 8017e6c:	20004e9c 	.word	0x20004e9c

08017e70 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8017e70:	b500      	push	{lr}
 8017e72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8017e74:	4b0c      	ldr	r3, [pc, #48]	; (8017ea8 <Vector84+0x38>)
 8017e76:	685b      	ldr	r3, [r3, #4]
 8017e78:	0c1b      	lsrs	r3, r3, #16
 8017e7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017e7e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8017e80:	4a09      	ldr	r2, [pc, #36]	; (8017ea8 <Vector84+0x38>)
 8017e82:	9b01      	ldr	r3, [sp, #4]
 8017e84:	041b      	lsls	r3, r3, #16
 8017e86:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8017e88:	4b08      	ldr	r3, [pc, #32]	; (8017eac <Vector84+0x3c>)
 8017e8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8017e8c:	2b00      	cmp	r3, #0
 8017e8e:	d006      	beq.n	8017e9e <Vector84+0x2e>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8017e90:	4b06      	ldr	r3, [pc, #24]	; (8017eac <Vector84+0x3c>)
 8017e92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8017e94:	4a05      	ldr	r2, [pc, #20]	; (8017eac <Vector84+0x3c>)
 8017e96:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8017e98:	9901      	ldr	r1, [sp, #4]
 8017e9a:	4610      	mov	r0, r2
 8017e9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017e9e:	f7fb fbf7 	bl	8013690 <_port_irq_epilogue>
}
 8017ea2:	b003      	add	sp, #12
 8017ea4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017ea8:	40026000 	.word	0x40026000
 8017eac:	20004e9c 	.word	0x20004e9c

08017eb0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8017eb0:	b500      	push	{lr}
 8017eb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8017eb4:	4b0c      	ldr	r3, [pc, #48]	; (8017ee8 <VectorFC+0x38>)
 8017eb6:	685b      	ldr	r3, [r3, #4]
 8017eb8:	0d9b      	lsrs	r3, r3, #22
 8017eba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017ebe:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8017ec0:	4a09      	ldr	r2, [pc, #36]	; (8017ee8 <VectorFC+0x38>)
 8017ec2:	9b01      	ldr	r3, [sp, #4]
 8017ec4:	059b      	lsls	r3, r3, #22
 8017ec6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8017ec8:	4b08      	ldr	r3, [pc, #32]	; (8017eec <VectorFC+0x3c>)
 8017eca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8017ecc:	2b00      	cmp	r3, #0
 8017ece:	d006      	beq.n	8017ede <VectorFC+0x2e>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8017ed0:	4b06      	ldr	r3, [pc, #24]	; (8017eec <VectorFC+0x3c>)
 8017ed2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8017ed4:	4a05      	ldr	r2, [pc, #20]	; (8017eec <VectorFC+0x3c>)
 8017ed6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8017ed8:	9901      	ldr	r1, [sp, #4]
 8017eda:	4610      	mov	r0, r2
 8017edc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017ede:	f7fb fbd7 	bl	8013690 <_port_irq_epilogue>
}
 8017ee2:	b003      	add	sp, #12
 8017ee4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017ee8:	40026000 	.word	0x40026000
 8017eec:	20004e9c 	.word	0x20004e9c

08017ef0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8017ef0:	b500      	push	{lr}
 8017ef2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8017ef4:	4b0b      	ldr	r3, [pc, #44]	; (8017f24 <Vector120+0x34>)
 8017ef6:	681b      	ldr	r3, [r3, #0]
 8017ef8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017efc:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 8017efe:	4a09      	ldr	r2, [pc, #36]	; (8017f24 <Vector120+0x34>)
 8017f00:	9b01      	ldr	r3, [sp, #4]
 8017f02:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 8017f04:	4b08      	ldr	r3, [pc, #32]	; (8017f28 <Vector120+0x38>)
 8017f06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017f08:	2b00      	cmp	r3, #0
 8017f0a:	d006      	beq.n	8017f1a <Vector120+0x2a>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8017f0c:	4b06      	ldr	r3, [pc, #24]	; (8017f28 <Vector120+0x38>)
 8017f0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017f10:	4a05      	ldr	r2, [pc, #20]	; (8017f28 <Vector120+0x38>)
 8017f12:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8017f14:	9901      	ldr	r1, [sp, #4]
 8017f16:	4610      	mov	r0, r2
 8017f18:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017f1a:	f7fb fbb9 	bl	8013690 <_port_irq_epilogue>
}
 8017f1e:	b003      	add	sp, #12
 8017f20:	f85d fb04 	ldr.w	pc, [sp], #4
 8017f24:	40026400 	.word	0x40026400
 8017f28:	20004e9c 	.word	0x20004e9c
 8017f2c:	00000000 	.word	0x00000000

08017f30 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8017f30:	b500      	push	{lr}
 8017f32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8017f34:	4b0c      	ldr	r3, [pc, #48]	; (8017f68 <Vector124+0x38>)
 8017f36:	681b      	ldr	r3, [r3, #0]
 8017f38:	099b      	lsrs	r3, r3, #6
 8017f3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017f3e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 8017f40:	4a09      	ldr	r2, [pc, #36]	; (8017f68 <Vector124+0x38>)
 8017f42:	9b01      	ldr	r3, [sp, #4]
 8017f44:	019b      	lsls	r3, r3, #6
 8017f46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 8017f48:	4b08      	ldr	r3, [pc, #32]	; (8017f6c <Vector124+0x3c>)
 8017f4a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017f4c:	2b00      	cmp	r3, #0
 8017f4e:	d006      	beq.n	8017f5e <Vector124+0x2e>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8017f50:	4b06      	ldr	r3, [pc, #24]	; (8017f6c <Vector124+0x3c>)
 8017f52:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017f54:	4a05      	ldr	r2, [pc, #20]	; (8017f6c <Vector124+0x3c>)
 8017f56:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8017f58:	9901      	ldr	r1, [sp, #4]
 8017f5a:	4610      	mov	r0, r2
 8017f5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017f5e:	f7fb fb97 	bl	8013690 <_port_irq_epilogue>
}
 8017f62:	b003      	add	sp, #12
 8017f64:	f85d fb04 	ldr.w	pc, [sp], #4
 8017f68:	40026400 	.word	0x40026400
 8017f6c:	20004e9c 	.word	0x20004e9c

08017f70 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8017f70:	b500      	push	{lr}
 8017f72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8017f74:	4b0c      	ldr	r3, [pc, #48]	; (8017fa8 <Vector128+0x38>)
 8017f76:	681b      	ldr	r3, [r3, #0]
 8017f78:	0c1b      	lsrs	r3, r3, #16
 8017f7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017f7e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8017f80:	4a09      	ldr	r2, [pc, #36]	; (8017fa8 <Vector128+0x38>)
 8017f82:	9b01      	ldr	r3, [sp, #4]
 8017f84:	041b      	lsls	r3, r3, #16
 8017f86:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8017f88:	4b08      	ldr	r3, [pc, #32]	; (8017fac <Vector128+0x3c>)
 8017f8a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017f8c:	2b00      	cmp	r3, #0
 8017f8e:	d006      	beq.n	8017f9e <Vector128+0x2e>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8017f90:	4b06      	ldr	r3, [pc, #24]	; (8017fac <Vector128+0x3c>)
 8017f92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8017f94:	4a05      	ldr	r2, [pc, #20]	; (8017fac <Vector128+0x3c>)
 8017f96:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8017f98:	9901      	ldr	r1, [sp, #4]
 8017f9a:	4610      	mov	r0, r2
 8017f9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017f9e:	f7fb fb77 	bl	8013690 <_port_irq_epilogue>
}
 8017fa2:	b003      	add	sp, #12
 8017fa4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017fa8:	40026400 	.word	0x40026400
 8017fac:	20004e9c 	.word	0x20004e9c

08017fb0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8017fb0:	b500      	push	{lr}
 8017fb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8017fb4:	4b0c      	ldr	r3, [pc, #48]	; (8017fe8 <Vector12C+0x38>)
 8017fb6:	681b      	ldr	r3, [r3, #0]
 8017fb8:	0d9b      	lsrs	r3, r3, #22
 8017fba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017fbe:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8017fc0:	4a09      	ldr	r2, [pc, #36]	; (8017fe8 <Vector12C+0x38>)
 8017fc2:	9b01      	ldr	r3, [sp, #4]
 8017fc4:	059b      	lsls	r3, r3, #22
 8017fc6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8017fc8:	4b08      	ldr	r3, [pc, #32]	; (8017fec <Vector12C+0x3c>)
 8017fca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017fcc:	2b00      	cmp	r3, #0
 8017fce:	d006      	beq.n	8017fde <Vector12C+0x2e>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8017fd0:	4b06      	ldr	r3, [pc, #24]	; (8017fec <Vector12C+0x3c>)
 8017fd2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017fd4:	4a05      	ldr	r2, [pc, #20]	; (8017fec <Vector12C+0x3c>)
 8017fd6:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8017fd8:	9901      	ldr	r1, [sp, #4]
 8017fda:	4610      	mov	r0, r2
 8017fdc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8017fde:	f7fb fb57 	bl	8013690 <_port_irq_epilogue>
}
 8017fe2:	b003      	add	sp, #12
 8017fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8017fe8:	40026400 	.word	0x40026400
 8017fec:	20004e9c 	.word	0x20004e9c

08017ff0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8017ff0:	b500      	push	{lr}
 8017ff2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8017ff4:	4b0b      	ldr	r3, [pc, #44]	; (8018024 <Vector130+0x34>)
 8017ff6:	685b      	ldr	r3, [r3, #4]
 8017ff8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8017ffc:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 8017ffe:	4a09      	ldr	r2, [pc, #36]	; (8018024 <Vector130+0x34>)
 8018000:	9b01      	ldr	r3, [sp, #4]
 8018002:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 8018004:	4b08      	ldr	r3, [pc, #32]	; (8018028 <Vector130+0x38>)
 8018006:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8018008:	2b00      	cmp	r3, #0
 801800a:	d006      	beq.n	801801a <Vector130+0x2a>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 801800c:	4b06      	ldr	r3, [pc, #24]	; (8018028 <Vector130+0x38>)
 801800e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8018010:	4a05      	ldr	r2, [pc, #20]	; (8018028 <Vector130+0x38>)
 8018012:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8018014:	9901      	ldr	r1, [sp, #4]
 8018016:	4610      	mov	r0, r2
 8018018:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 801801a:	f7fb fb39 	bl	8013690 <_port_irq_epilogue>
}
 801801e:	b003      	add	sp, #12
 8018020:	f85d fb04 	ldr.w	pc, [sp], #4
 8018024:	40026400 	.word	0x40026400
 8018028:	20004e9c 	.word	0x20004e9c
 801802c:	00000000 	.word	0x00000000

08018030 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8018030:	b500      	push	{lr}
 8018032:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8018034:	4b0c      	ldr	r3, [pc, #48]	; (8018068 <Vector150+0x38>)
 8018036:	685b      	ldr	r3, [r3, #4]
 8018038:	099b      	lsrs	r3, r3, #6
 801803a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 801803e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8018040:	4a09      	ldr	r2, [pc, #36]	; (8018068 <Vector150+0x38>)
 8018042:	9b01      	ldr	r3, [sp, #4]
 8018044:	019b      	lsls	r3, r3, #6
 8018046:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8018048:	4b08      	ldr	r3, [pc, #32]	; (801806c <Vector150+0x3c>)
 801804a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801804c:	2b00      	cmp	r3, #0
 801804e:	d006      	beq.n	801805e <Vector150+0x2e>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8018050:	4b06      	ldr	r3, [pc, #24]	; (801806c <Vector150+0x3c>)
 8018052:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8018054:	4a05      	ldr	r2, [pc, #20]	; (801806c <Vector150+0x3c>)
 8018056:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8018058:	9901      	ldr	r1, [sp, #4]
 801805a:	4610      	mov	r0, r2
 801805c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 801805e:	f7fb fb17 	bl	8013690 <_port_irq_epilogue>
}
 8018062:	b003      	add	sp, #12
 8018064:	f85d fb04 	ldr.w	pc, [sp], #4
 8018068:	40026400 	.word	0x40026400
 801806c:	20004e9c 	.word	0x20004e9c

08018070 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8018070:	b500      	push	{lr}
 8018072:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8018074:	4b0c      	ldr	r3, [pc, #48]	; (80180a8 <Vector154+0x38>)
 8018076:	685b      	ldr	r3, [r3, #4]
 8018078:	0c1b      	lsrs	r3, r3, #16
 801807a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 801807e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8018080:	4a09      	ldr	r2, [pc, #36]	; (80180a8 <Vector154+0x38>)
 8018082:	9b01      	ldr	r3, [sp, #4]
 8018084:	041b      	lsls	r3, r3, #16
 8018086:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 8018088:	4b08      	ldr	r3, [pc, #32]	; (80180ac <Vector154+0x3c>)
 801808a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801808c:	2b00      	cmp	r3, #0
 801808e:	d006      	beq.n	801809e <Vector154+0x2e>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8018090:	4b06      	ldr	r3, [pc, #24]	; (80180ac <Vector154+0x3c>)
 8018092:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8018094:	4a05      	ldr	r2, [pc, #20]	; (80180ac <Vector154+0x3c>)
 8018096:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8018098:	9901      	ldr	r1, [sp, #4]
 801809a:	4610      	mov	r0, r2
 801809c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 801809e:	f7fb faf7 	bl	8013690 <_port_irq_epilogue>
}
 80180a2:	b003      	add	sp, #12
 80180a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80180a8:	40026400 	.word	0x40026400
 80180ac:	20004e9c 	.word	0x20004e9c

080180b0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80180b0:	b500      	push	{lr}
 80180b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80180b4:	4b0c      	ldr	r3, [pc, #48]	; (80180e8 <Vector158+0x38>)
 80180b6:	685b      	ldr	r3, [r3, #4]
 80180b8:	0d9b      	lsrs	r3, r3, #22
 80180ba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80180be:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 80180c0:	4a09      	ldr	r2, [pc, #36]	; (80180e8 <Vector158+0x38>)
 80180c2:	9b01      	ldr	r3, [sp, #4]
 80180c4:	059b      	lsls	r3, r3, #22
 80180c6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 80180c8:	4b08      	ldr	r3, [pc, #32]	; (80180ec <Vector158+0x3c>)
 80180ca:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80180cc:	2b00      	cmp	r3, #0
 80180ce:	d006      	beq.n	80180de <Vector158+0x2e>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 80180d0:	4b06      	ldr	r3, [pc, #24]	; (80180ec <Vector158+0x3c>)
 80180d2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80180d4:	4a05      	ldr	r2, [pc, #20]	; (80180ec <Vector158+0x3c>)
 80180d6:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 80180d8:	9901      	ldr	r1, [sp, #4]
 80180da:	4610      	mov	r0, r2
 80180dc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80180de:	f7fb fad7 	bl	8013690 <_port_irq_epilogue>
}
 80180e2:	b003      	add	sp, #12
 80180e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80180e8:	40026400 	.word	0x40026400
 80180ec:	20004e9c 	.word	0x20004e9c

080180f0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80180f0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
 80180f2:	4b16      	ldr	r3, [pc, #88]	; (801814c <dmaInit+0x5c>)
 80180f4:	2200      	movs	r2, #0
 80180f6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80180f8:	2300      	movs	r3, #0
 80180fa:	9301      	str	r3, [sp, #4]
 80180fc:	e011      	b.n	8018122 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
 80180fe:	4914      	ldr	r1, [pc, #80]	; (8018150 <dmaInit+0x60>)
 8018100:	9a01      	ldr	r2, [sp, #4]
 8018102:	4613      	mov	r3, r2
 8018104:	005b      	lsls	r3, r3, #1
 8018106:	4413      	add	r3, r2
 8018108:	009b      	lsls	r3, r3, #2
 801810a:	440b      	add	r3, r1
 801810c:	681b      	ldr	r3, [r3, #0]
 801810e:	2200      	movs	r2, #0
 8018110:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8018112:	4a10      	ldr	r2, [pc, #64]	; (8018154 <dmaInit+0x64>)
 8018114:	9b01      	ldr	r3, [sp, #4]
 8018116:	2100      	movs	r1, #0
 8018118:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 801811c:	9b01      	ldr	r3, [sp, #4]
 801811e:	3301      	adds	r3, #1
 8018120:	9301      	str	r3, [sp, #4]
 8018122:	9b01      	ldr	r3, [sp, #4]
 8018124:	2b0f      	cmp	r3, #15
 8018126:	d9ea      	bls.n	80180fe <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8018128:	4b0b      	ldr	r3, [pc, #44]	; (8018158 <dmaInit+0x68>)
 801812a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801812e:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8018130:	4b09      	ldr	r3, [pc, #36]	; (8018158 <dmaInit+0x68>)
 8018132:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8018136:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8018138:	4b08      	ldr	r3, [pc, #32]	; (801815c <dmaInit+0x6c>)
 801813a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801813e:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8018140:	4b06      	ldr	r3, [pc, #24]	; (801815c <dmaInit+0x6c>)
 8018142:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8018146:	60da      	str	r2, [r3, #12]
}
 8018148:	b002      	add	sp, #8
 801814a:	4770      	bx	lr
 801814c:	20004e98 	.word	0x20004e98
 8018150:	08022ff0 	.word	0x08022ff0
 8018154:	20004e9c 	.word	0x20004e9c
 8018158:	40026000 	.word	0x40026000
 801815c:	40026400 	.word	0x40026400

08018160 <queue_init>:
static inline void queue_init(threads_queue_t *tqp) {
 8018160:	b082      	sub	sp, #8
 8018162:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8018164:	9b01      	ldr	r3, [sp, #4]
 8018166:	9a01      	ldr	r2, [sp, #4]
 8018168:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 801816a:	9b01      	ldr	r3, [sp, #4]
 801816c:	9a01      	ldr	r2, [sp, #4]
 801816e:	605a      	str	r2, [r3, #4]
}
 8018170:	b002      	add	sp, #8
 8018172:	4770      	bx	lr
	...

08018180 <chThdQueueObjectInit>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8018180:	b500      	push	{lr}
 8018182:	b083      	sub	sp, #12
 8018184:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8018186:	9801      	ldr	r0, [sp, #4]
 8018188:	f7ff ffea 	bl	8018160 <queue_init>
}
 801818c:	b003      	add	sp, #12
 801818e:	f85d fb04 	ldr.w	pc, [sp], #4
 8018192:	bf00      	nop
	...

080181a0 <osalThreadQueueObjectInit>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80181a0:	b500      	push	{lr}
 80181a2:	b083      	sub	sp, #12
 80181a4:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 80181a6:	9801      	ldr	r0, [sp, #4]
 80181a8:	f7ff ffea 	bl	8018180 <chThdQueueObjectInit>
}
 80181ac:	b003      	add	sp, #12
 80181ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80181b2:	bf00      	nop
	...

080181c0 <_pal_lld_init>:
/**
 * @brief   PAL driver initialization.
 *
 * @notapi
 */
void _pal_lld_init(void) {
 80181c0:	b500      	push	{lr}
 80181c2:	b083      	sub	sp, #12

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
 80181c4:	2300      	movs	r3, #0
 80181c6:	9301      	str	r3, [sp, #4]
 80181c8:	e017      	b.n	80181fa <_pal_lld_init+0x3a>
    _pal_init_event(i);
 80181ca:	9b01      	ldr	r3, [sp, #4]
 80181cc:	011b      	lsls	r3, r3, #4
 80181ce:	4a0e      	ldr	r2, [pc, #56]	; (8018208 <_pal_lld_init+0x48>)
 80181d0:	4413      	add	r3, r2
 80181d2:	4618      	mov	r0, r3
 80181d4:	f7ff ffe4 	bl	80181a0 <osalThreadQueueObjectInit>
 80181d8:	4a0b      	ldr	r2, [pc, #44]	; (8018208 <_pal_lld_init+0x48>)
 80181da:	9b01      	ldr	r3, [sp, #4]
 80181dc:	011b      	lsls	r3, r3, #4
 80181de:	4413      	add	r3, r2
 80181e0:	3308      	adds	r3, #8
 80181e2:	2200      	movs	r2, #0
 80181e4:	601a      	str	r2, [r3, #0]
 80181e6:	4a08      	ldr	r2, [pc, #32]	; (8018208 <_pal_lld_init+0x48>)
 80181e8:	9b01      	ldr	r3, [sp, #4]
 80181ea:	011b      	lsls	r3, r3, #4
 80181ec:	4413      	add	r3, r2
 80181ee:	330c      	adds	r3, #12
 80181f0:	2200      	movs	r2, #0
 80181f2:	601a      	str	r2, [r3, #0]
  for (i = 0; i < 16; i++) {
 80181f4:	9b01      	ldr	r3, [sp, #4]
 80181f6:	3301      	adds	r3, #1
 80181f8:	9301      	str	r3, [sp, #4]
 80181fa:	9b01      	ldr	r3, [sp, #4]
 80181fc:	2b0f      	cmp	r3, #15
 80181fe:	d9e4      	bls.n	80181ca <_pal_lld_init+0xa>
  }
#endif
}
 8018200:	b003      	add	sp, #12
 8018202:	f85d fb04 	ldr.w	pc, [sp], #4
 8018206:	bf00      	nop
 8018208:	20004f1c 	.word	0x20004f1c
 801820c:	00000000 	.word	0x00000000

08018210 <port_lock.lto_priv.784>:
static inline void port_lock(void) {
 8018210:	b082      	sub	sp, #8
 8018212:	2320      	movs	r3, #32
 8018214:	9301      	str	r3, [sp, #4]
 8018216:	9b01      	ldr	r3, [sp, #4]
 8018218:	f383 8811 	msr	BASEPRI, r3
}
 801821c:	b002      	add	sp, #8
 801821e:	4770      	bx	lr

08018220 <port_unlock.lto_priv.782>:
static inline void port_unlock(void) {
 8018220:	b082      	sub	sp, #8
 8018222:	2300      	movs	r3, #0
 8018224:	9301      	str	r3, [sp, #4]
 8018226:	9b01      	ldr	r3, [sp, #4]
 8018228:	f383 8811 	msr	BASEPRI, r3
}
 801822c:	b002      	add	sp, #8
 801822e:	4770      	bx	lr

08018230 <port_lock_from_isr.lto_priv.780>:
static inline void port_lock_from_isr(void) {
 8018230:	b508      	push	{r3, lr}
  port_lock();
 8018232:	f7ff ffed 	bl	8018210 <port_lock.lto_priv.784>
}
 8018236:	bd08      	pop	{r3, pc}
	...

08018240 <port_unlock_from_isr.lto_priv.778>:
static inline void port_unlock_from_isr(void) {
 8018240:	b508      	push	{r3, lr}
  port_unlock();
 8018242:	f7ff ffed 	bl	8018220 <port_unlock.lto_priv.782>
}
 8018246:	bd08      	pop	{r3, pc}
	...

08018250 <chSysLockFromISR.lto_priv.776>:
static inline void chSysLockFromISR(void) {
 8018250:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8018252:	f7ff ffed 	bl	8018230 <port_lock_from_isr.lto_priv.780>
}
 8018256:	bd08      	pop	{r3, pc}
	...

08018260 <chSysUnlockFromISR.lto_priv.774>:
static inline void chSysUnlockFromISR(void) {
 8018260:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8018262:	f7ff ffed 	bl	8018240 <port_unlock_from_isr.lto_priv.778>
}
 8018266:	bd08      	pop	{r3, pc}
	...

08018270 <osalSysLockFromISR.lto_priv.747>:
static inline void osalSysLockFromISR(void) {
 8018270:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8018272:	f7ff ffed 	bl	8018250 <chSysLockFromISR.lto_priv.776>
}
 8018276:	bd08      	pop	{r3, pc}
	...

08018280 <osalSysUnlockFromISR.lto_priv.743>:
static inline void osalSysUnlockFromISR(void) {
 8018280:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8018282:	f7ff ffed 	bl	8018260 <chSysUnlockFromISR.lto_priv.774>
}
 8018286:	bd08      	pop	{r3, pc}
	...

08018290 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8018290:	b500      	push	{lr}
 8018292:	b083      	sub	sp, #12
 8018294:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8018296:	9801      	ldr	r0, [sp, #4]
 8018298:	f7fb fe3a 	bl	8013f10 <chSysPolledDelayX>
}
 801829c:	b003      	add	sp, #12
 801829e:	f85d fb04 	ldr.w	pc, [sp], #4
 80182a2:	bf00      	nop
	...

080182b0 <osalThreadResumeI.lto_priv.759>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80182b0:	b500      	push	{lr}
 80182b2:	b083      	sub	sp, #12
 80182b4:	9001      	str	r0, [sp, #4]
 80182b6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 80182b8:	9900      	ldr	r1, [sp, #0]
 80182ba:	9801      	ldr	r0, [sp, #4]
 80182bc:	f7fc fbf8 	bl	8014ab0 <chThdResumeI>
}
 80182c0:	b003      	add	sp, #12
 80182c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80182c6:	bf00      	nop
	...

080182d0 <otg_disable_ep.lto_priv.765>:
static void otg_disable_ep(USBDriver *usbp) {
 80182d0:	b084      	sub	sp, #16
 80182d2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80182d4:	9b01      	ldr	r3, [sp, #4]
 80182d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80182d8:	9302      	str	r3, [sp, #8]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80182da:	2300      	movs	r3, #0
 80182dc:	9303      	str	r3, [sp, #12]
 80182de:	e032      	b.n	8018346 <otg_disable_ep.lto_priv.765+0x76>
    otgp->ie[i].DIEPCTL = 0;
 80182e0:	9a02      	ldr	r2, [sp, #8]
 80182e2:	9b03      	ldr	r3, [sp, #12]
 80182e4:	3348      	adds	r3, #72	; 0x48
 80182e6:	015b      	lsls	r3, r3, #5
 80182e8:	4413      	add	r3, r2
 80182ea:	2200      	movs	r2, #0
 80182ec:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 80182ee:	9a02      	ldr	r2, [sp, #8]
 80182f0:	9b03      	ldr	r3, [sp, #12]
 80182f2:	015b      	lsls	r3, r3, #5
 80182f4:	4413      	add	r3, r2
 80182f6:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80182fa:	2200      	movs	r2, #0
 80182fc:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80182fe:	9a02      	ldr	r2, [sp, #8]
 8018300:	9b03      	ldr	r3, [sp, #12]
 8018302:	015b      	lsls	r3, r3, #5
 8018304:	4413      	add	r3, r2
 8018306:	f603 1308 	addw	r3, r3, #2312	; 0x908
 801830a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801830e:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = 0;
 8018310:	9a02      	ldr	r2, [sp, #8]
 8018312:	9b03      	ldr	r3, [sp, #12]
 8018314:	3358      	adds	r3, #88	; 0x58
 8018316:	015b      	lsls	r3, r3, #5
 8018318:	4413      	add	r3, r2
 801831a:	2200      	movs	r2, #0
 801831c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 801831e:	9a02      	ldr	r2, [sp, #8]
 8018320:	9b03      	ldr	r3, [sp, #12]
 8018322:	015b      	lsls	r3, r3, #5
 8018324:	4413      	add	r3, r2
 8018326:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 801832a:	2200      	movs	r2, #0
 801832c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 801832e:	9a02      	ldr	r2, [sp, #8]
 8018330:	9b03      	ldr	r3, [sp, #12]
 8018332:	015b      	lsls	r3, r3, #5
 8018334:	4413      	add	r3, r2
 8018336:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 801833a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801833e:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8018340:	9b03      	ldr	r3, [sp, #12]
 8018342:	3301      	adds	r3, #1
 8018344:	9303      	str	r3, [sp, #12]
 8018346:	9b01      	ldr	r3, [sp, #4]
 8018348:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801834a:	689a      	ldr	r2, [r3, #8]
 801834c:	9b03      	ldr	r3, [sp, #12]
 801834e:	429a      	cmp	r2, r3
 8018350:	d2c6      	bcs.n	80182e0 <otg_disable_ep.lto_priv.765+0x10>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8018352:	9b02      	ldr	r3, [sp, #8]
 8018354:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8018358:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 801835c:	b004      	add	sp, #16
 801835e:	4770      	bx	lr

08018360 <otg_rxfifo_flush.lto_priv.769>:
static void otg_rxfifo_flush(USBDriver *usbp) {
 8018360:	b500      	push	{lr}
 8018362:	b085      	sub	sp, #20
 8018364:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8018366:	9b01      	ldr	r3, [sp, #4]
 8018368:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801836a:	9303      	str	r3, [sp, #12]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 801836c:	9b03      	ldr	r3, [sp, #12]
 801836e:	2210      	movs	r2, #16
 8018370:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8018372:	9b03      	ldr	r3, [sp, #12]
 8018374:	691b      	ldr	r3, [r3, #16]
 8018376:	f003 0310 	and.w	r3, r3, #16
 801837a:	2b00      	cmp	r3, #0
 801837c:	d1f9      	bne.n	8018372 <otg_rxfifo_flush.lto_priv.769+0x12>
  osalSysPolledDelayX(18);
 801837e:	2012      	movs	r0, #18
 8018380:	f7ff ff86 	bl	8018290 <osalSysPolledDelayX>
}
 8018384:	b005      	add	sp, #20
 8018386:	f85d fb04 	ldr.w	pc, [sp], #4
 801838a:	bf00      	nop
 801838c:	0000      	movs	r0, r0
	...

08018390 <otg_txfifo_flush.lto_priv.767>:
static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8018390:	b500      	push	{lr}
 8018392:	b085      	sub	sp, #20
 8018394:	9001      	str	r0, [sp, #4]
 8018396:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 8018398:	9b01      	ldr	r3, [sp, #4]
 801839a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801839c:	9303      	str	r3, [sp, #12]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 801839e:	9b00      	ldr	r3, [sp, #0]
 80183a0:	019b      	lsls	r3, r3, #6
 80183a2:	f043 0220 	orr.w	r2, r3, #32
 80183a6:	9b03      	ldr	r3, [sp, #12]
 80183a8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80183aa:	9b03      	ldr	r3, [sp, #12]
 80183ac:	691b      	ldr	r3, [r3, #16]
 80183ae:	f003 0320 	and.w	r3, r3, #32
 80183b2:	2b00      	cmp	r3, #0
 80183b4:	d1f9      	bne.n	80183aa <otg_txfifo_flush.lto_priv.767+0x1a>
  osalSysPolledDelayX(18);
 80183b6:	2012      	movs	r0, #18
 80183b8:	f7ff ff6a 	bl	8018290 <osalSysPolledDelayX>
}
 80183bc:	b005      	add	sp, #20
 80183be:	f85d fb04 	ldr.w	pc, [sp], #4
 80183c2:	bf00      	nop
	...

080183d0 <otg_ram_reset.lto_priv.766>:
static void otg_ram_reset(USBDriver *usbp) {
 80183d0:	b082      	sub	sp, #8
 80183d2:	9001      	str	r0, [sp, #4]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80183d4:	9b01      	ldr	r3, [sp, #4]
 80183d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80183d8:	681a      	ldr	r2, [r3, #0]
 80183da:	9b01      	ldr	r3, [sp, #4]
 80183dc:	65da      	str	r2, [r3, #92]	; 0x5c
}
 80183de:	b002      	add	sp, #8
 80183e0:	4770      	bx	lr
 80183e2:	bf00      	nop
	...

080183f0 <otg_ram_alloc.lto_priv.768>:
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 80183f0:	b084      	sub	sp, #16
 80183f2:	9001      	str	r0, [sp, #4]
 80183f4:	9100      	str	r1, [sp, #0]
  next = usbp->pmnext;
 80183f6:	9b01      	ldr	r3, [sp, #4]
 80183f8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80183fa:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 80183fc:	9b01      	ldr	r3, [sp, #4]
 80183fe:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8018400:	9b00      	ldr	r3, [sp, #0]
 8018402:	441a      	add	r2, r3
 8018404:	9b01      	ldr	r3, [sp, #4]
 8018406:	65da      	str	r2, [r3, #92]	; 0x5c
  return next;
 8018408:	9b03      	ldr	r3, [sp, #12]
}
 801840a:	4618      	mov	r0, r3
 801840c:	b004      	add	sp, #16
 801840e:	4770      	bx	lr

08018410 <otg_fifo_write_from_buffer>:
                                       size_t n) {
 8018410:	b084      	sub	sp, #16
 8018412:	9003      	str	r0, [sp, #12]
 8018414:	9102      	str	r1, [sp, #8]
 8018416:	9201      	str	r2, [sp, #4]
    *fifop = *((uint32_t *)buf);
 8018418:	9b02      	ldr	r3, [sp, #8]
 801841a:	681a      	ldr	r2, [r3, #0]
 801841c:	9b03      	ldr	r3, [sp, #12]
 801841e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8018420:	9b01      	ldr	r3, [sp, #4]
 8018422:	2b04      	cmp	r3, #4
 8018424:	d906      	bls.n	8018434 <otg_fifo_write_from_buffer+0x24>
    n -= 4;
 8018426:	9b01      	ldr	r3, [sp, #4]
 8018428:	3b04      	subs	r3, #4
 801842a:	9301      	str	r3, [sp, #4]
    buf += 4;
 801842c:	9b02      	ldr	r3, [sp, #8]
 801842e:	3304      	adds	r3, #4
 8018430:	9302      	str	r3, [sp, #8]
 8018432:	e7f1      	b.n	8018418 <otg_fifo_write_from_buffer+0x8>
}
 8018434:	b004      	add	sp, #16
 8018436:	4770      	bx	lr
	...

08018440 <otg_fifo_read_to_buffer>:
                                    size_t max) {
 8018440:	b086      	sub	sp, #24
 8018442:	9003      	str	r0, [sp, #12]
 8018444:	9102      	str	r1, [sp, #8]
 8018446:	9201      	str	r2, [sp, #4]
 8018448:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 801844a:	2300      	movs	r3, #0
 801844c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 801844e:	2300      	movs	r3, #0
 8018450:	9304      	str	r3, [sp, #16]
 8018452:	e017      	b.n	8018484 <otg_fifo_read_to_buffer+0x44>
    if ((i & 3) == 0){
 8018454:	9b04      	ldr	r3, [sp, #16]
 8018456:	f003 0303 	and.w	r3, r3, #3
 801845a:	2b00      	cmp	r3, #0
 801845c:	d102      	bne.n	8018464 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 801845e:	9b03      	ldr	r3, [sp, #12]
 8018460:	681b      	ldr	r3, [r3, #0]
 8018462:	9305      	str	r3, [sp, #20]
    if (i < max) {
 8018464:	9a04      	ldr	r2, [sp, #16]
 8018466:	9b00      	ldr	r3, [sp, #0]
 8018468:	429a      	cmp	r2, r3
 801846a:	d208      	bcs.n	801847e <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 801846c:	9b02      	ldr	r3, [sp, #8]
 801846e:	1c5a      	adds	r2, r3, #1
 8018470:	9202      	str	r2, [sp, #8]
 8018472:	9a05      	ldr	r2, [sp, #20]
 8018474:	b2d2      	uxtb	r2, r2
 8018476:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 8018478:	9b05      	ldr	r3, [sp, #20]
 801847a:	0a1b      	lsrs	r3, r3, #8
 801847c:	9305      	str	r3, [sp, #20]
    i++;
 801847e:	9b04      	ldr	r3, [sp, #16]
 8018480:	3301      	adds	r3, #1
 8018482:	9304      	str	r3, [sp, #16]
  while (i < n) {
 8018484:	9a04      	ldr	r2, [sp, #16]
 8018486:	9b01      	ldr	r3, [sp, #4]
 8018488:	429a      	cmp	r2, r3
 801848a:	d3e3      	bcc.n	8018454 <otg_fifo_read_to_buffer+0x14>
}
 801848c:	b006      	add	sp, #24
 801848e:	4770      	bx	lr

08018490 <otg_rxfifo_handler.lto_priv.771>:
static void otg_rxfifo_handler(USBDriver *usbp) {
 8018490:	b510      	push	{r4, lr}
 8018492:	b086      	sub	sp, #24
 8018494:	9001      	str	r0, [sp, #4]
  sts = usbp->otg->GRXSTSP;
 8018496:	9b01      	ldr	r3, [sp, #4]
 8018498:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801849a:	6a1b      	ldr	r3, [r3, #32]
 801849c:	9305      	str	r3, [sp, #20]
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 801849e:	9b05      	ldr	r3, [sp, #20]
 80184a0:	091b      	lsrs	r3, r3, #4
 80184a2:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80184a6:	9304      	str	r3, [sp, #16]
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80184a8:	9b05      	ldr	r3, [sp, #20]
 80184aa:	f003 030f 	and.w	r3, r3, #15
 80184ae:	9303      	str	r3, [sp, #12]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80184b0:	9b05      	ldr	r3, [sp, #20]
 80184b2:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80184b6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 80184ba:	d064      	beq.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
 80184bc:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 80184c0:	d806      	bhi.n	80184d0 <otg_rxfifo_handler.lto_priv.771+0x40>
 80184c2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80184c6:	d05e      	beq.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
 80184c8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80184cc:	d016      	beq.n	80184fc <otg_rxfifo_handler.lto_priv.771+0x6c>
 80184ce:	e05a      	b.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
 80184d0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80184d4:	d057      	beq.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
 80184d6:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80184da:	d154      	bne.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 80184dc:	9b01      	ldr	r3, [sp, #4]
 80184de:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80184e0:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 80184e4:	9a01      	ldr	r2, [sp, #4]
 80184e6:	9b03      	ldr	r3, [sp, #12]
 80184e8:	3302      	adds	r3, #2
 80184ea:	009b      	lsls	r3, r3, #2
 80184ec:	4413      	add	r3, r2
 80184ee:	685b      	ldr	r3, [r3, #4]
 80184f0:	6a19      	ldr	r1, [r3, #32]
 80184f2:	2308      	movs	r3, #8
 80184f4:	9a04      	ldr	r2, [sp, #16]
 80184f6:	f7ff ffa3 	bl	8018440 <otg_fifo_read_to_buffer>
 80184fa:	e044      	b.n	8018586 <otg_rxfifo_handler.lto_priv.771+0xf6>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80184fc:	9b01      	ldr	r3, [sp, #4]
 80184fe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8018500:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 8018504:	9a01      	ldr	r2, [sp, #4]
 8018506:	9b03      	ldr	r3, [sp, #12]
 8018508:	3302      	adds	r3, #2
 801850a:	009b      	lsls	r3, r3, #2
 801850c:	4413      	add	r3, r2
 801850e:	685b      	ldr	r3, [r3, #4]
 8018510:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8018512:	689c      	ldr	r4, [r3, #8]
                            usbp->epc[ep]->out_state->rxsize -
 8018514:	9a01      	ldr	r2, [sp, #4]
 8018516:	9b03      	ldr	r3, [sp, #12]
 8018518:	3302      	adds	r3, #2
 801851a:	009b      	lsls	r3, r3, #2
 801851c:	4413      	add	r3, r2
 801851e:	685b      	ldr	r3, [r3, #4]
 8018520:	699b      	ldr	r3, [r3, #24]
 8018522:	681a      	ldr	r2, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 8018524:	9901      	ldr	r1, [sp, #4]
 8018526:	9b03      	ldr	r3, [sp, #12]
 8018528:	3302      	adds	r3, #2
 801852a:	009b      	lsls	r3, r3, #2
 801852c:	440b      	add	r3, r1
 801852e:	685b      	ldr	r3, [r3, #4]
 8018530:	699b      	ldr	r3, [r3, #24]
 8018532:	685b      	ldr	r3, [r3, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8018534:	1ad3      	subs	r3, r2, r3
 8018536:	9a04      	ldr	r2, [sp, #16]
 8018538:	4621      	mov	r1, r4
 801853a:	f7ff ff81 	bl	8018440 <otg_fifo_read_to_buffer>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 801853e:	9a01      	ldr	r2, [sp, #4]
 8018540:	9b03      	ldr	r3, [sp, #12]
 8018542:	3302      	adds	r3, #2
 8018544:	009b      	lsls	r3, r3, #2
 8018546:	4413      	add	r3, r2
 8018548:	685b      	ldr	r3, [r3, #4]
 801854a:	699a      	ldr	r2, [r3, #24]
 801854c:	9901      	ldr	r1, [sp, #4]
 801854e:	9b03      	ldr	r3, [sp, #12]
 8018550:	3302      	adds	r3, #2
 8018552:	009b      	lsls	r3, r3, #2
 8018554:	440b      	add	r3, r1
 8018556:	685b      	ldr	r3, [r3, #4]
 8018558:	699b      	ldr	r3, [r3, #24]
 801855a:	6899      	ldr	r1, [r3, #8]
 801855c:	9b04      	ldr	r3, [sp, #16]
 801855e:	440b      	add	r3, r1
 8018560:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8018562:	9a01      	ldr	r2, [sp, #4]
 8018564:	9b03      	ldr	r3, [sp, #12]
 8018566:	3302      	adds	r3, #2
 8018568:	009b      	lsls	r3, r3, #2
 801856a:	4413      	add	r3, r2
 801856c:	685b      	ldr	r3, [r3, #4]
 801856e:	699a      	ldr	r2, [r3, #24]
 8018570:	9901      	ldr	r1, [sp, #4]
 8018572:	9b03      	ldr	r3, [sp, #12]
 8018574:	3302      	adds	r3, #2
 8018576:	009b      	lsls	r3, r3, #2
 8018578:	440b      	add	r3, r1
 801857a:	685b      	ldr	r3, [r3, #4]
 801857c:	699b      	ldr	r3, [r3, #24]
 801857e:	6859      	ldr	r1, [r3, #4]
 8018580:	9b04      	ldr	r3, [sp, #16]
 8018582:	440b      	add	r3, r1
 8018584:	6053      	str	r3, [r2, #4]
}
 8018586:	b006      	add	sp, #24
 8018588:	bd10      	pop	{r4, pc}
 801858a:	bf00      	nop
 801858c:	0000      	movs	r0, r0
	...

08018590 <otg_txfifo_handler.lto_priv.772>:
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8018590:	b500      	push	{lr}
 8018592:	b085      	sub	sp, #20
 8018594:	9001      	str	r0, [sp, #4]
 8018596:	460b      	mov	r3, r1
 8018598:	f88d 3003 	strb.w	r3, [sp, #3]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 801859c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80185a0:	9a01      	ldr	r2, [sp, #4]
 80185a2:	3302      	adds	r3, #2
 80185a4:	009b      	lsls	r3, r3, #2
 80185a6:	4413      	add	r3, r2
 80185a8:	685b      	ldr	r3, [r3, #4]
 80185aa:	695b      	ldr	r3, [r3, #20]
 80185ac:	685a      	ldr	r2, [r3, #4]
 80185ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80185b2:	9901      	ldr	r1, [sp, #4]
 80185b4:	3302      	adds	r3, #2
 80185b6:	009b      	lsls	r3, r3, #2
 80185b8:	440b      	add	r3, r1
 80185ba:	685b      	ldr	r3, [r3, #4]
 80185bc:	695b      	ldr	r3, [r3, #20]
 80185be:	681b      	ldr	r3, [r3, #0]
 80185c0:	429a      	cmp	r2, r3
 80185c2:	d310      	bcc.n	80185e6 <otg_txfifo_handler.lto_priv.772+0x56>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 80185c4:	9b01      	ldr	r3, [sp, #4]
 80185c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80185c8:	9a01      	ldr	r2, [sp, #4]
 80185ca:	6d52      	ldr	r2, [r2, #84]	; 0x54
 80185cc:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 80185d0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80185d4:	2001      	movs	r0, #1
 80185d6:	fa00 f202 	lsl.w	r2, r0, r2
 80185da:	43d2      	mvns	r2, r2
 80185dc:	400a      	ands	r2, r1
 80185de:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      return true;
 80185e2:	2301      	movs	r3, #1
 80185e4:	e075      	b.n	80186d2 <otg_txfifo_handler.lto_priv.772+0x142>
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80185e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80185ea:	9a01      	ldr	r2, [sp, #4]
 80185ec:	3302      	adds	r3, #2
 80185ee:	009b      	lsls	r3, r3, #2
 80185f0:	4413      	add	r3, r2
 80185f2:	685b      	ldr	r3, [r3, #4]
 80185f4:	695b      	ldr	r3, [r3, #20]
 80185f6:	681a      	ldr	r2, [r3, #0]
 80185f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80185fc:	9901      	ldr	r1, [sp, #4]
 80185fe:	3302      	adds	r3, #2
 8018600:	009b      	lsls	r3, r3, #2
 8018602:	440b      	add	r3, r1
 8018604:	685b      	ldr	r3, [r3, #4]
 8018606:	695b      	ldr	r3, [r3, #20]
 8018608:	685b      	ldr	r3, [r3, #4]
 801860a:	1ad3      	subs	r3, r2, r3
 801860c:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 801860e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8018612:	9a01      	ldr	r2, [sp, #4]
 8018614:	3302      	adds	r3, #2
 8018616:	009b      	lsls	r3, r3, #2
 8018618:	4413      	add	r3, r2
 801861a:	685b      	ldr	r3, [r3, #4]
 801861c:	8a1b      	ldrh	r3, [r3, #16]
 801861e:	461a      	mov	r2, r3
 8018620:	9b03      	ldr	r3, [sp, #12]
 8018622:	429a      	cmp	r2, r3
 8018624:	d208      	bcs.n	8018638 <otg_txfifo_handler.lto_priv.772+0xa8>
      n = usbp->epc[ep]->in_maxsize;
 8018626:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801862a:	9a01      	ldr	r2, [sp, #4]
 801862c:	3302      	adds	r3, #2
 801862e:	009b      	lsls	r3, r3, #2
 8018630:	4413      	add	r3, r2
 8018632:	685b      	ldr	r3, [r3, #4]
 8018634:	8a1b      	ldrh	r3, [r3, #16]
 8018636:	9303      	str	r3, [sp, #12]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8018638:	9b01      	ldr	r3, [sp, #4]
 801863a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801863c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8018640:	015b      	lsls	r3, r3, #5
 8018642:	4413      	add	r3, r2
 8018644:	f603 1318 	addw	r3, r3, #2328	; 0x918
 8018648:	681b      	ldr	r3, [r3, #0]
 801864a:	b29b      	uxth	r3, r3
 801864c:	009a      	lsls	r2, r3, #2
 801864e:	9b03      	ldr	r3, [sp, #12]
 8018650:	429a      	cmp	r2, r3
 8018652:	d201      	bcs.n	8018658 <otg_txfifo_handler.lto_priv.772+0xc8>
      return false;
 8018654:	2300      	movs	r3, #0
 8018656:	e03c      	b.n	80186d2 <otg_txfifo_handler.lto_priv.772+0x142>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8018658:	9b01      	ldr	r3, [sp, #4]
 801865a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801865c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8018660:	3301      	adds	r3, #1
 8018662:	031b      	lsls	r3, r3, #12
 8018664:	18d0      	adds	r0, r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 8018666:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801866a:	9a01      	ldr	r2, [sp, #4]
 801866c:	3302      	adds	r3, #2
 801866e:	009b      	lsls	r3, r3, #2
 8018670:	4413      	add	r3, r2
 8018672:	685b      	ldr	r3, [r3, #4]
 8018674:	695b      	ldr	r3, [r3, #20]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8018676:	689b      	ldr	r3, [r3, #8]
 8018678:	9a03      	ldr	r2, [sp, #12]
 801867a:	4619      	mov	r1, r3
 801867c:	f7ff fec8 	bl	8018410 <otg_fifo_write_from_buffer>
    usbp->epc[ep]->in_state->txbuf += n;
 8018680:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8018684:	9a01      	ldr	r2, [sp, #4]
 8018686:	3302      	adds	r3, #2
 8018688:	009b      	lsls	r3, r3, #2
 801868a:	4413      	add	r3, r2
 801868c:	685b      	ldr	r3, [r3, #4]
 801868e:	695a      	ldr	r2, [r3, #20]
 8018690:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8018694:	9901      	ldr	r1, [sp, #4]
 8018696:	3302      	adds	r3, #2
 8018698:	009b      	lsls	r3, r3, #2
 801869a:	440b      	add	r3, r1
 801869c:	685b      	ldr	r3, [r3, #4]
 801869e:	695b      	ldr	r3, [r3, #20]
 80186a0:	6899      	ldr	r1, [r3, #8]
 80186a2:	9b03      	ldr	r3, [sp, #12]
 80186a4:	440b      	add	r3, r1
 80186a6:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 80186a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80186ac:	9a01      	ldr	r2, [sp, #4]
 80186ae:	3302      	adds	r3, #2
 80186b0:	009b      	lsls	r3, r3, #2
 80186b2:	4413      	add	r3, r2
 80186b4:	685b      	ldr	r3, [r3, #4]
 80186b6:	695a      	ldr	r2, [r3, #20]
 80186b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80186bc:	9901      	ldr	r1, [sp, #4]
 80186be:	3302      	adds	r3, #2
 80186c0:	009b      	lsls	r3, r3, #2
 80186c2:	440b      	add	r3, r1
 80186c4:	685b      	ldr	r3, [r3, #4]
 80186c6:	695b      	ldr	r3, [r3, #20]
 80186c8:	6859      	ldr	r1, [r3, #4]
 80186ca:	9b03      	ldr	r3, [sp, #12]
 80186cc:	440b      	add	r3, r1
 80186ce:	6053      	str	r3, [r2, #4]
 80186d0:	e764      	b.n	801859c <otg_txfifo_handler.lto_priv.772+0xc>
}
 80186d2:	4618      	mov	r0, r3
 80186d4:	b005      	add	sp, #20
 80186d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80186da:	bf00      	nop
 80186dc:	0000      	movs	r0, r0
	...

080186e0 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 80186e0:	b500      	push	{lr}
 80186e2:	b083      	sub	sp, #12
 80186e4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 80186e6:	f001 fe13 	bl	801a310 <osalSysLock.lto_priv.828>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 80186ea:	9b01      	ldr	r3, [sp, #4]
 80186ec:	791b      	ldrb	r3, [r3, #4]
 80186ee:	2b02      	cmp	r3, #2
 80186f0:	d103      	bne.n	80186fa <sdcDisconnect+0x1a>
    osalSysUnlock();
 80186f2:	f001 fe15 	bl	801a320 <osalSysUnlock.lto_priv.824>
    return HAL_SUCCESS;
 80186f6:	2300      	movs	r3, #0
 80186f8:	e019      	b.n	801872e <sdcDisconnect+0x4e>
  }
  sdcp->state = BLK_DISCONNECTING;
 80186fa:	9b01      	ldr	r3, [sp, #4]
 80186fc:	2204      	movs	r2, #4
 80186fe:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8018700:	f001 fe0e 	bl	801a320 <osalSysUnlock.lto_priv.824>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8018704:	9801      	ldr	r0, [sp, #4]
 8018706:	f002 f8eb 	bl	801a8e0 <_sdc_wait_for_transfer_state>
 801870a:	4603      	mov	r3, r0
 801870c:	2b00      	cmp	r3, #0
 801870e:	d007      	beq.n	8018720 <sdcDisconnect+0x40>
    sdc_lld_stop_clk(sdcp);
 8018710:	9801      	ldr	r0, [sp, #4]
 8018712:	f7fd fd45 	bl	80161a0 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8018716:	9b01      	ldr	r3, [sp, #4]
 8018718:	2202      	movs	r2, #2
 801871a:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 801871c:	2301      	movs	r3, #1
 801871e:	e006      	b.n	801872e <sdcDisconnect+0x4e>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8018720:	9801      	ldr	r0, [sp, #4]
 8018722:	f7fd fd3d 	bl	80161a0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8018726:	9b01      	ldr	r3, [sp, #4]
 8018728:	2202      	movs	r2, #2
 801872a:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 801872c:	2300      	movs	r3, #0
}
 801872e:	4618      	mov	r0, r3
 8018730:	b003      	add	sp, #12
 8018732:	f85d fb04 	ldr.w	pc, [sp], #4
 8018736:	bf00      	nop
	...

08018740 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8018740:	b500      	push	{lr}
 8018742:	b087      	sub	sp, #28
 8018744:	9003      	str	r0, [sp, #12]
 8018746:	9102      	str	r1, [sp, #8]
 8018748:	9201      	str	r2, [sp, #4]
 801874a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity) {
 801874c:	9a02      	ldr	r2, [sp, #8]
 801874e:	9b00      	ldr	r3, [sp, #0]
 8018750:	4413      	add	r3, r2
 8018752:	1e5a      	subs	r2, r3, #1
 8018754:	9b03      	ldr	r3, [sp, #12]
 8018756:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018758:	429a      	cmp	r2, r3
 801875a:	d907      	bls.n	801876c <sdcRead+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 801875c:	9b03      	ldr	r3, [sp, #12]
 801875e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8018760:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8018764:	9b03      	ldr	r3, [sp, #12]
 8018766:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8018768:	2301      	movs	r3, #1
 801876a:	e010      	b.n	801878e <sdcRead+0x4e>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 801876c:	9b03      	ldr	r3, [sp, #12]
 801876e:	2206      	movs	r2, #6
 8018770:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 8018772:	9b00      	ldr	r3, [sp, #0]
 8018774:	9a01      	ldr	r2, [sp, #4]
 8018776:	9902      	ldr	r1, [sp, #8]
 8018778:	9803      	ldr	r0, [sp, #12]
 801877a:	f7fd ff41 	bl	8016600 <sdc_lld_read>
 801877e:	4603      	mov	r3, r0
 8018780:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 8018784:	9b03      	ldr	r3, [sp, #12]
 8018786:	2205      	movs	r2, #5
 8018788:	711a      	strb	r2, [r3, #4]
  return status;
 801878a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 801878e:	4618      	mov	r0, r3
 8018790:	b007      	add	sp, #28
 8018792:	f85d fb04 	ldr.w	pc, [sp], #4
 8018796:	bf00      	nop
	...

080187a0 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 80187a0:	b500      	push	{lr}
 80187a2:	b087      	sub	sp, #28
 80187a4:	9003      	str	r0, [sp, #12]
 80187a6:	9102      	str	r1, [sp, #8]
 80187a8:	9201      	str	r2, [sp, #4]
 80187aa:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity) {
 80187ac:	9a02      	ldr	r2, [sp, #8]
 80187ae:	9b00      	ldr	r3, [sp, #0]
 80187b0:	4413      	add	r3, r2
 80187b2:	1e5a      	subs	r2, r3, #1
 80187b4:	9b03      	ldr	r3, [sp, #12]
 80187b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80187b8:	429a      	cmp	r2, r3
 80187ba:	d907      	bls.n	80187cc <sdcWrite+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 80187bc:	9b03      	ldr	r3, [sp, #12]
 80187be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80187c0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80187c4:	9b03      	ldr	r3, [sp, #12]
 80187c6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 80187c8:	2301      	movs	r3, #1
 80187ca:	e010      	b.n	80187ee <sdcWrite+0x4e>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 80187cc:	9b03      	ldr	r3, [sp, #12]
 80187ce:	2207      	movs	r2, #7
 80187d0:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 80187d2:	9b00      	ldr	r3, [sp, #0]
 80187d4:	9a01      	ldr	r2, [sp, #4]
 80187d6:	9902      	ldr	r1, [sp, #8]
 80187d8:	9803      	ldr	r0, [sp, #12]
 80187da:	f7fd ff51 	bl	8016680 <sdc_lld_write>
 80187de:	4603      	mov	r3, r0
 80187e0:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 80187e4:	9b03      	ldr	r3, [sp, #12]
 80187e6:	2205      	movs	r2, #5
 80187e8:	711a      	strb	r2, [r3, #4]
  return status;
 80187ea:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 80187ee:	4618      	mov	r0, r3
 80187f0:	b007      	add	sp, #28
 80187f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80187f6:	bf00      	nop
	...

08018800 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 8018800:	b500      	push	{lr}
 8018802:	b085      	sub	sp, #20
 8018804:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8018806:	9b01      	ldr	r3, [sp, #4]
 8018808:	791b      	ldrb	r3, [r3, #4]
 801880a:	2b05      	cmp	r3, #5
 801880c:	d001      	beq.n	8018812 <sdcSync+0x12>
    return HAL_FAILED;
 801880e:	2301      	movs	r3, #1
 8018810:	e00d      	b.n	801882e <sdcSync+0x2e>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 8018812:	9b01      	ldr	r3, [sp, #4]
 8018814:	2208      	movs	r2, #8
 8018816:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 8018818:	9801      	ldr	r0, [sp, #4]
 801881a:	f7fd ff71 	bl	8016700 <sdc_lld_sync>
 801881e:	4603      	mov	r3, r0
 8018820:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 8018824:	9b01      	ldr	r3, [sp, #4]
 8018826:	2205      	movs	r2, #5
 8018828:	711a      	strb	r2, [r3, #4]
  return result;
 801882a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 801882e:	4618      	mov	r0, r3
 8018830:	b005      	add	sp, #20
 8018832:	f85d fb04 	ldr.w	pc, [sp], #4
 8018836:	bf00      	nop
	...

08018840 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 8018840:	b082      	sub	sp, #8
 8018842:	9001      	str	r0, [sp, #4]
 8018844:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8018846:	9b01      	ldr	r3, [sp, #4]
 8018848:	791b      	ldrb	r3, [r3, #4]
 801884a:	2b05      	cmp	r3, #5
 801884c:	d001      	beq.n	8018852 <sdcGetInfo+0x12>
    return HAL_FAILED;
 801884e:	2301      	movs	r3, #1
 8018850:	e008      	b.n	8018864 <sdcGetInfo+0x24>
  }

  bdip->blk_num = sdcp->capacity;
 8018852:	9b01      	ldr	r3, [sp, #4]
 8018854:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018856:	9b00      	ldr	r3, [sp, #0]
 8018858:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 801885a:	9b00      	ldr	r3, [sp, #0]
 801885c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8018860:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8018862:	2300      	movs	r3, #0
}
 8018864:	4618      	mov	r0, r3
 8018866:	b002      	add	sp, #8
 8018868:	4770      	bx	lr
 801886a:	bf00      	nop
 801886c:	0000      	movs	r0, r0
	...

08018870 <port_lock.lto_priv.810>:
static inline void port_lock(void) {
 8018870:	b082      	sub	sp, #8
 8018872:	2320      	movs	r3, #32
 8018874:	9301      	str	r3, [sp, #4]
 8018876:	9b01      	ldr	r3, [sp, #4]
 8018878:	f383 8811 	msr	BASEPRI, r3
}
 801887c:	b002      	add	sp, #8
 801887e:	4770      	bx	lr

08018880 <port_unlock.lto_priv.806>:
static inline void port_unlock(void) {
 8018880:	b082      	sub	sp, #8
 8018882:	2300      	movs	r3, #0
 8018884:	9301      	str	r3, [sp, #4]
 8018886:	9b01      	ldr	r3, [sp, #4]
 8018888:	f383 8811 	msr	BASEPRI, r3
}
 801888c:	b002      	add	sp, #8
 801888e:	4770      	bx	lr

08018890 <chSysLock.lto_priv.835>:
static inline void chSysLock(void) {
 8018890:	b508      	push	{r3, lr}
  port_lock();
 8018892:	f7ff ffed 	bl	8018870 <port_lock.lto_priv.810>
}
 8018896:	bd08      	pop	{r3, pc}
	...

080188a0 <chSysUnlock.lto_priv.832>:
static inline void chSysUnlock(void) {
 80188a0:	b508      	push	{r3, lr}
  port_unlock();
 80188a2:	f7ff ffed 	bl	8018880 <port_unlock.lto_priv.806>
}
 80188a6:	bd08      	pop	{r3, pc}
	...

080188b0 <chEvtObjectInit.lto_priv.843>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80188b0:	b082      	sub	sp, #8
 80188b2:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 80188b4:	9b01      	ldr	r3, [sp, #4]
 80188b6:	9a01      	ldr	r2, [sp, #4]
 80188b8:	601a      	str	r2, [r3, #0]
}
 80188ba:	b002      	add	sp, #8
 80188bc:	4770      	bx	lr
 80188be:	bf00      	nop

080188c0 <osalSysLock.lto_priv.829>:
static inline void osalSysLock(void) {
 80188c0:	b508      	push	{r3, lr}
  chSysLock();
 80188c2:	f7ff ffe5 	bl	8018890 <chSysLock.lto_priv.835>
}
 80188c6:	bd08      	pop	{r3, pc}
	...

080188d0 <osalSysUnlock.lto_priv.825>:
static inline void osalSysUnlock(void) {
 80188d0:	b508      	push	{r3, lr}
  chSysUnlock();
 80188d2:	f7ff ffe5 	bl	80188a0 <chSysUnlock.lto_priv.832>
}
 80188d6:	bd08      	pop	{r3, pc}
	...

080188e0 <osalEventObjectInit.lto_priv.841>:
static inline void osalEventObjectInit(event_source_t *esp) {
 80188e0:	b500      	push	{lr}
 80188e2:	b083      	sub	sp, #12
 80188e4:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 80188e6:	9801      	ldr	r0, [sp, #4]
 80188e8:	f7ff ffe2 	bl	80188b0 <chEvtObjectInit.lto_priv.843>
}
 80188ec:	b003      	add	sp, #12
 80188ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80188f2:	bf00      	nop
	...

08018900 <osalEventBroadcastFlagsI.lto_priv.839>:
                                            eventflags_t flags) {
 8018900:	b500      	push	{lr}
 8018902:	b083      	sub	sp, #12
 8018904:	9001      	str	r0, [sp, #4]
 8018906:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8018908:	9900      	ldr	r1, [sp, #0]
 801890a:	9801      	ldr	r0, [sp, #4]
 801890c:	f7fa fbd0 	bl	80130b0 <chEvtBroadcastFlagsI>
}
 8018910:	b003      	add	sp, #12
 8018912:	f85d fb04 	ldr.w	pc, [sp], #4
 8018916:	bf00      	nop
	...

08018920 <_write.lto_priv.163>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8018920:	b500      	push	{lr}
 8018922:	b085      	sub	sp, #20
 8018924:	9003      	str	r0, [sp, #12]
 8018926:	9102      	str	r1, [sp, #8]
 8018928:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 801892a:	9b03      	ldr	r3, [sp, #12]
 801892c:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8018930:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8018934:	9a01      	ldr	r2, [sp, #4]
 8018936:	9902      	ldr	r1, [sp, #8]
 8018938:	f001 fb7a 	bl	801a030 <oqWriteTimeout>
 801893c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 801893e:	4618      	mov	r0, r3
 8018940:	b005      	add	sp, #20
 8018942:	f85d fb04 	ldr.w	pc, [sp], #4
 8018946:	bf00      	nop
	...

08018950 <_read.lto_priv.165>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8018950:	b500      	push	{lr}
 8018952:	b085      	sub	sp, #20
 8018954:	9003      	str	r0, [sp, #12]
 8018956:	9102      	str	r1, [sp, #8]
 8018958:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 801895a:	9b03      	ldr	r3, [sp, #12]
 801895c:	f103 000c 	add.w	r0, r3, #12
 8018960:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8018964:	9a01      	ldr	r2, [sp, #4]
 8018966:	9902      	ldr	r1, [sp, #8]
 8018968:	f001 fa72 	bl	8019e50 <iqReadTimeout>
 801896c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 801896e:	4618      	mov	r0, r3
 8018970:	b005      	add	sp, #20
 8018972:	f85d fb04 	ldr.w	pc, [sp], #4
 8018976:	bf00      	nop
	...

08018980 <_put.lto_priv.156>:

static msg_t _put(void *ip, uint8_t b) {
 8018980:	b500      	push	{lr}
 8018982:	b083      	sub	sp, #12
 8018984:	9001      	str	r0, [sp, #4]
 8018986:	460b      	mov	r3, r1
 8018988:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 801898c:	9b01      	ldr	r3, [sp, #4]
 801898e:	3330      	adds	r3, #48	; 0x30
 8018990:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8018994:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8018998:	4618      	mov	r0, r3
 801899a:	f001 fac1 	bl	8019f20 <oqPutTimeout>
 801899e:	4603      	mov	r3, r0
}
 80189a0:	4618      	mov	r0, r3
 80189a2:	b003      	add	sp, #12
 80189a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080189b0 <_get.lto_priv.159>:

static msg_t _get(void *ip) {
 80189b0:	b500      	push	{lr}
 80189b2:	b083      	sub	sp, #12
 80189b4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80189b6:	9b01      	ldr	r3, [sp, #4]
 80189b8:	330c      	adds	r3, #12
 80189ba:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80189be:	4618      	mov	r0, r3
 80189c0:	f001 fa06 	bl	8019dd0 <iqGetTimeout>
 80189c4:	4603      	mov	r3, r0
}
 80189c6:	4618      	mov	r0, r3
 80189c8:	b003      	add	sp, #12
 80189ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80189ce:	bf00      	nop

080189d0 <_putt.lto_priv.167>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80189d0:	b500      	push	{lr}
 80189d2:	b085      	sub	sp, #20
 80189d4:	9003      	str	r0, [sp, #12]
 80189d6:	460b      	mov	r3, r1
 80189d8:	9201      	str	r2, [sp, #4]
 80189da:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80189de:	9b03      	ldr	r3, [sp, #12]
 80189e0:	3330      	adds	r3, #48	; 0x30
 80189e2:	f89d 100b 	ldrb.w	r1, [sp, #11]
 80189e6:	9a01      	ldr	r2, [sp, #4]
 80189e8:	4618      	mov	r0, r3
 80189ea:	f001 fa99 	bl	8019f20 <oqPutTimeout>
 80189ee:	4603      	mov	r3, r0
}
 80189f0:	4618      	mov	r0, r3
 80189f2:	b005      	add	sp, #20
 80189f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08018a00 <_gett.lto_priv.169>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 8018a00:	b500      	push	{lr}
 8018a02:	b083      	sub	sp, #12
 8018a04:	9001      	str	r0, [sp, #4]
 8018a06:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8018a08:	9b01      	ldr	r3, [sp, #4]
 8018a0a:	330c      	adds	r3, #12
 8018a0c:	9900      	ldr	r1, [sp, #0]
 8018a0e:	4618      	mov	r0, r3
 8018a10:	f001 f9de 	bl	8019dd0 <iqGetTimeout>
 8018a14:	4603      	mov	r3, r0
}
 8018a16:	4618      	mov	r0, r3
 8018a18:	b003      	add	sp, #12
 8018a1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8018a1e:	bf00      	nop

08018a20 <_writet.lto_priv.171>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 8018a20:	b500      	push	{lr}
 8018a22:	b085      	sub	sp, #20
 8018a24:	9003      	str	r0, [sp, #12]
 8018a26:	9102      	str	r1, [sp, #8]
 8018a28:	9201      	str	r2, [sp, #4]
 8018a2a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8018a2c:	9b03      	ldr	r3, [sp, #12]
 8018a2e:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8018a32:	9b00      	ldr	r3, [sp, #0]
 8018a34:	9a01      	ldr	r2, [sp, #4]
 8018a36:	9902      	ldr	r1, [sp, #8]
 8018a38:	f001 fafa 	bl	801a030 <oqWriteTimeout>
 8018a3c:	4603      	mov	r3, r0
}
 8018a3e:	4618      	mov	r0, r3
 8018a40:	b005      	add	sp, #20
 8018a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8018a46:	bf00      	nop
	...

08018a50 <_readt.lto_priv.173>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8018a50:	b500      	push	{lr}
 8018a52:	b085      	sub	sp, #20
 8018a54:	9003      	str	r0, [sp, #12]
 8018a56:	9102      	str	r1, [sp, #8]
 8018a58:	9201      	str	r2, [sp, #4]
 8018a5a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8018a5c:	9b03      	ldr	r3, [sp, #12]
 8018a5e:	f103 000c 	add.w	r0, r3, #12
 8018a62:	9b00      	ldr	r3, [sp, #0]
 8018a64:	9a01      	ldr	r2, [sp, #4]
 8018a66:	9902      	ldr	r1, [sp, #8]
 8018a68:	f001 f9f2 	bl	8019e50 <iqReadTimeout>
 8018a6c:	4603      	mov	r3, r0
}
 8018a6e:	4618      	mov	r0, r3
 8018a70:	b005      	add	sp, #20
 8018a72:	f85d fb04 	ldr.w	pc, [sp], #4
 8018a76:	bf00      	nop
	...

08018a80 <_ctl.lto_priv.175>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8018a80:	b086      	sub	sp, #24
 8018a82:	9003      	str	r0, [sp, #12]
 8018a84:	9102      	str	r1, [sp, #8]
 8018a86:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
 8018a88:	9b03      	ldr	r3, [sp, #12]
 8018a8a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);

  switch (operation) {
 8018a8c:	9b02      	ldr	r3, [sp, #8]
 8018a8e:	2b00      	cmp	r3, #0
 8018a90:	d000      	beq.n	8018a94 <_ctl.lto_priv.175+0x14>
 8018a92:	2b01      	cmp	r3, #1
    return sd_lld_control(sdp, operation, arg);
#else
    break;
#endif
  }
  return MSG_OK;
 8018a94:	2300      	movs	r3, #0
}
 8018a96:	4618      	mov	r0, r3
 8018a98:	b006      	add	sp, #24
 8018a9a:	4770      	bx	lr
 8018a9c:	0000      	movs	r0, r0
	...

08018aa0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8018aa0:	b508      	push	{r3, lr}

  sd_lld_init();
 8018aa2:	f7fe f895 	bl	8016bd0 <sd_lld_init>
}
 8018aa6:	bd08      	pop	{r3, pc}
	...

08018ab0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8018ab0:	b500      	push	{lr}
 8018ab2:	b087      	sub	sp, #28
 8018ab4:	9005      	str	r0, [sp, #20]
 8018ab6:	9104      	str	r1, [sp, #16]
 8018ab8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8018aba:	9b05      	ldr	r3, [sp, #20]
 8018abc:	4a13      	ldr	r2, [pc, #76]	; (8018b0c <sdObjectInit+0x5c>)
 8018abe:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8018ac0:	9b05      	ldr	r3, [sp, #20]
 8018ac2:	3304      	adds	r3, #4
 8018ac4:	4618      	mov	r0, r3
 8018ac6:	f7ff ff0b 	bl	80188e0 <osalEventObjectInit.lto_priv.841>
  sdp->state = SD_STOP;
 8018aca:	9b05      	ldr	r3, [sp, #20]
 8018acc:	2201      	movs	r2, #1
 8018ace:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8018ad0:	9b05      	ldr	r3, [sp, #20]
 8018ad2:	f103 000c 	add.w	r0, r3, #12
 8018ad6:	9b05      	ldr	r3, [sp, #20]
 8018ad8:	f103 0154 	add.w	r1, r3, #84	; 0x54
 8018adc:	9b05      	ldr	r3, [sp, #20]
 8018ade:	9300      	str	r3, [sp, #0]
 8018ae0:	9b04      	ldr	r3, [sp, #16]
 8018ae2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8018ae6:	f001 f90b 	bl	8019d00 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8018aea:	9b05      	ldr	r3, [sp, #20]
 8018aec:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8018af0:	9b05      	ldr	r3, [sp, #20]
 8018af2:	f203 4154 	addw	r1, r3, #1108	; 0x454
 8018af6:	9b05      	ldr	r3, [sp, #20]
 8018af8:	9300      	str	r3, [sp, #0]
 8018afa:	9b03      	ldr	r3, [sp, #12]
 8018afc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8018b00:	f001 f9e6 	bl	8019ed0 <oqObjectInit>
}
 8018b04:	b007      	add	sp, #28
 8018b06:	f85d fb04 	ldr.w	pc, [sp], #4
 8018b0a:	bf00      	nop
 8018b0c:	08022fc0 	.word	0x08022fc0

08018b10 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8018b10:	b500      	push	{lr}
 8018b12:	b083      	sub	sp, #12
 8018b14:	9001      	str	r0, [sp, #4]
 8018b16:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8018b18:	f7ff fed2 	bl	80188c0 <osalSysLock.lto_priv.829>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8018b1c:	9900      	ldr	r1, [sp, #0]
 8018b1e:	9801      	ldr	r0, [sp, #4]
 8018b20:	f7fe f86e 	bl	8016c00 <sd_lld_start>
  sdp->state = SD_READY;
 8018b24:	9b01      	ldr	r3, [sp, #4]
 8018b26:	2202      	movs	r2, #2
 8018b28:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8018b2a:	f7ff fed1 	bl	80188d0 <osalSysUnlock.lto_priv.825>
}
 8018b2e:	b003      	add	sp, #12
 8018b30:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08018b40 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8018b40:	b500      	push	{lr}
 8018b42:	b083      	sub	sp, #12
 8018b44:	9001      	str	r0, [sp, #4]
 8018b46:	460b      	mov	r3, r1
 8018b48:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8018b4c:	9b01      	ldr	r3, [sp, #4]
 8018b4e:	695b      	ldr	r3, [r3, #20]
 8018b50:	2b00      	cmp	r3, #0
 8018b52:	d105      	bne.n	8018b60 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8018b54:	9b01      	ldr	r3, [sp, #4]
 8018b56:	3304      	adds	r3, #4
 8018b58:	2104      	movs	r1, #4
 8018b5a:	4618      	mov	r0, r3
 8018b5c:	f7ff fed0 	bl	8018900 <osalEventBroadcastFlagsI.lto_priv.839>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8018b60:	9b01      	ldr	r3, [sp, #4]
 8018b62:	330c      	adds	r3, #12
 8018b64:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8018b68:	4611      	mov	r1, r2
 8018b6a:	4618      	mov	r0, r3
 8018b6c:	f001 f8f0 	bl	8019d50 <iqPutI>
 8018b70:	4603      	mov	r3, r0
 8018b72:	2b00      	cmp	r3, #0
 8018b74:	da06      	bge.n	8018b84 <sdIncomingDataI+0x44>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8018b76:	9b01      	ldr	r3, [sp, #4]
 8018b78:	3304      	adds	r3, #4
 8018b7a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8018b7e:	4618      	mov	r0, r3
 8018b80:	f7ff febe 	bl	8018900 <osalEventBroadcastFlagsI.lto_priv.839>
}
 8018b84:	b003      	add	sp, #12
 8018b86:	f85d fb04 	ldr.w	pc, [sp], #4
 8018b8a:	bf00      	nop
 8018b8c:	0000      	movs	r0, r0
	...

08018b90 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 8018b90:	4770      	bx	lr
 8018b92:	bf00      	nop
	...

08018ba0 <port_lock.lto_priv.812>:
static inline void port_lock(void) {
 8018ba0:	b082      	sub	sp, #8
 8018ba2:	2320      	movs	r3, #32
 8018ba4:	9301      	str	r3, [sp, #4]
 8018ba6:	9b01      	ldr	r3, [sp, #4]
 8018ba8:	f383 8811 	msr	BASEPRI, r3
}
 8018bac:	b002      	add	sp, #8
 8018bae:	4770      	bx	lr

08018bb0 <port_unlock.lto_priv.808>:
static inline void port_unlock(void) {
 8018bb0:	b082      	sub	sp, #8
 8018bb2:	2300      	movs	r3, #0
 8018bb4:	9301      	str	r3, [sp, #4]
 8018bb6:	9b01      	ldr	r3, [sp, #4]
 8018bb8:	f383 8811 	msr	BASEPRI, r3
}
 8018bbc:	b002      	add	sp, #8
 8018bbe:	4770      	bx	lr

08018bc0 <port_lock_from_isr.lto_priv.804>:
static inline void port_lock_from_isr(void) {
 8018bc0:	b508      	push	{r3, lr}
  port_lock();
 8018bc2:	f7ff ffed 	bl	8018ba0 <port_lock.lto_priv.812>
}
 8018bc6:	bd08      	pop	{r3, pc}
	...

08018bd0 <port_unlock_from_isr.lto_priv.801>:
static inline void port_unlock_from_isr(void) {
 8018bd0:	b508      	push	{r3, lr}
  port_unlock();
 8018bd2:	f7ff ffed 	bl	8018bb0 <port_unlock.lto_priv.808>
}
 8018bd6:	bd08      	pop	{r3, pc}
	...

08018be0 <chSysLockFromISR.lto_priv.798>:
static inline void chSysLockFromISR(void) {
 8018be0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8018be2:	f7ff ffed 	bl	8018bc0 <port_lock_from_isr.lto_priv.804>
}
 8018be6:	bd08      	pop	{r3, pc}
	...

08018bf0 <chSysUnlockFromISR.lto_priv.795>:
static inline void chSysUnlockFromISR(void) {
 8018bf0:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 8018bf2:	f7ff ffed 	bl	8018bd0 <port_unlock_from_isr.lto_priv.801>
}
 8018bf6:	bd08      	pop	{r3, pc}
	...

08018c00 <osalSysLockFromISR.lto_priv.823>:
static inline void osalSysLockFromISR(void) {
 8018c00:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8018c02:	f7ff ffed 	bl	8018be0 <chSysLockFromISR.lto_priv.798>
}
 8018c06:	bd08      	pop	{r3, pc}
	...

08018c10 <osalSysUnlockFromISR.lto_priv.821>:
static inline void osalSysUnlockFromISR(void) {
 8018c10:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8018c12:	f7ff ffed 	bl	8018bf0 <chSysUnlockFromISR.lto_priv.795>
}
 8018c16:	bd08      	pop	{r3, pc}
	...

08018c20 <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8018c20:	b500      	push	{lr}
 8018c22:	b083      	sub	sp, #12
 8018c24:	9001      	str	r0, [sp, #4]
 8018c26:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8018c28:	9900      	ldr	r1, [sp, #0]
 8018c2a:	9801      	ldr	r0, [sp, #4]
 8018c2c:	f7fb ff40 	bl	8014ab0 <chThdResumeI>
}
 8018c30:	b003      	add	sp, #12
 8018c32:	f85d fb04 	ldr.w	pc, [sp], #4
 8018c36:	bf00      	nop
	...

08018c40 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8018c40:	b084      	sub	sp, #16
 8018c42:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8018c44:	9b01      	ldr	r3, [sp, #4]
 8018c46:	1c5a      	adds	r2, r3, #1
 8018c48:	9201      	str	r2, [sp, #4]
 8018c4a:	781b      	ldrb	r3, [r3, #0]
 8018c4c:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8018c50:	9b01      	ldr	r3, [sp, #4]
 8018c52:	781b      	ldrb	r3, [r3, #0]
 8018c54:	021b      	lsls	r3, r3, #8
 8018c56:	b21a      	sxth	r2, r3
 8018c58:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
 8018c5c:	4313      	orrs	r3, r2
 8018c5e:	b21b      	sxth	r3, r3
 8018c60:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8018c64:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8018c68:	4618      	mov	r0, r3
 8018c6a:	b004      	add	sp, #16
 8018c6c:	4770      	bx	lr
 8018c6e:	bf00      	nop

08018c70 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8018c70:	b500      	push	{lr}
 8018c72:	b083      	sub	sp, #12
 8018c74:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8018c76:	9b01      	ldr	r3, [sp, #4]
 8018c78:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
 8018c7c:	9b01      	ldr	r3, [sp, #4]
 8018c7e:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
  usb_lld_set_address(usbp);
 8018c82:	9801      	ldr	r0, [sp, #4]
 8018c84:	f7fc fd94 	bl	80157b0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8018c88:	9b01      	ldr	r3, [sp, #4]
 8018c8a:	685b      	ldr	r3, [r3, #4]
 8018c8c:	681b      	ldr	r3, [r3, #0]
 8018c8e:	2b00      	cmp	r3, #0
 8018c90:	d005      	beq.n	8018c9e <set_address+0x2e>
 8018c92:	9b01      	ldr	r3, [sp, #4]
 8018c94:	685b      	ldr	r3, [r3, #4]
 8018c96:	681b      	ldr	r3, [r3, #0]
 8018c98:	2101      	movs	r1, #1
 8018c9a:	9801      	ldr	r0, [sp, #4]
 8018c9c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8018c9e:	9b01      	ldr	r3, [sp, #4]
 8018ca0:	2203      	movs	r2, #3
 8018ca2:	701a      	strb	r2, [r3, #0]
}
 8018ca4:	b003      	add	sp, #12
 8018ca6:	f85d fb04 	ldr.w	pc, [sp], #4
 8018caa:	bf00      	nop
 8018cac:	0000      	movs	r0, r0
	...

08018cb0 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8018cb0:	b570      	push	{r4, r5, r6, lr}
 8018cb2:	b084      	sub	sp, #16
 8018cb4:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8018cb6:	9b01      	ldr	r3, [sp, #4]
 8018cb8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8018cbc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8018cc0:	9b01      	ldr	r3, [sp, #4]
 8018cc2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8018cc6:	021b      	lsls	r3, r3, #8
                                        USB_RTYPE_TYPE_MASK)) |
 8018cc8:	4313      	orrs	r3, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8018cca:	f240 3202 	movw	r2, #770	; 0x302
 8018cce:	4293      	cmp	r3, r2
 8018cd0:	f000 819f 	beq.w	8019012 <default_handler+0x362>
 8018cd4:	f240 3202 	movw	r2, #770	; 0x302
 8018cd8:	4293      	cmp	r3, r2
 8018cda:	d815      	bhi.n	8018d08 <default_handler+0x58>
 8018cdc:	2b02      	cmp	r3, #2
 8018cde:	f000 810e 	beq.w	8018efe <default_handler+0x24e>
 8018ce2:	2b02      	cmp	r3, #2
 8018ce4:	d805      	bhi.n	8018cf2 <default_handler+0x42>
 8018ce6:	2b00      	cmp	r3, #0
 8018ce8:	d027      	beq.n	8018d3a <default_handler+0x8a>
 8018cea:	2b01      	cmp	r3, #1
 8018cec:	f000 80fc 	beq.w	8018ee8 <default_handler+0x238>
 8018cf0:	e1c3      	b.n	801907a <default_handler+0x3ca>
 8018cf2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8018cf6:	f000 8158 	beq.w	8018faa <default_handler+0x2fa>
 8018cfa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8018cfe:	d044      	beq.n	8018d8a <default_handler+0xda>
 8018d00:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8018d04:	d026      	beq.n	8018d54 <default_handler+0xa4>
 8018d06:	e1b8      	b.n	801907a <default_handler+0x3ca>
 8018d08:	f240 6201 	movw	r2, #1537	; 0x601
 8018d0c:	4293      	cmp	r3, r2
 8018d0e:	d806      	bhi.n	8018d1e <default_handler+0x6e>
 8018d10:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8018d14:	d26c      	bcs.n	8018df0 <default_handler+0x140>
 8018d16:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8018d1a:	d051      	beq.n	8018dc0 <default_handler+0x110>
 8018d1c:	e1ad      	b.n	801907a <default_handler+0x3ca>
 8018d1e:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8018d22:	f000 8098 	beq.w	8018e56 <default_handler+0x1a6>
 8018d26:	f640 4202 	movw	r2, #3074	; 0xc02
 8018d2a:	4293      	cmp	r3, r2
 8018d2c:	f000 80dc 	beq.w	8018ee8 <default_handler+0x238>
 8018d30:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8018d34:	f000 8082 	beq.w	8018e3c <default_handler+0x18c>
 8018d38:	e19f      	b.n	801907a <default_handler+0x3ca>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8018d3a:	9b01      	ldr	r3, [sp, #4]
 8018d3c:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8018d40:	9b01      	ldr	r3, [sp, #4]
 8018d42:	639a      	str	r2, [r3, #56]	; 0x38
 8018d44:	9b01      	ldr	r3, [sp, #4]
 8018d46:	2202      	movs	r2, #2
 8018d48:	63da      	str	r2, [r3, #60]	; 0x3c
 8018d4a:	9b01      	ldr	r3, [sp, #4]
 8018d4c:	2200      	movs	r2, #0
 8018d4e:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8018d50:	2301      	movs	r3, #1
 8018d52:	e193      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8018d54:	9b01      	ldr	r3, [sp, #4]
 8018d56:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8018d5a:	2b01      	cmp	r3, #1
 8018d5c:	d113      	bne.n	8018d86 <default_handler+0xd6>
      usbp->status &= ~2U;
 8018d5e:	9b01      	ldr	r3, [sp, #4]
 8018d60:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 8018d64:	f023 0302 	bic.w	r3, r3, #2
 8018d68:	b29a      	uxth	r2, r3
 8018d6a:	9b01      	ldr	r3, [sp, #4]
 8018d6c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8018d70:	9b01      	ldr	r3, [sp, #4]
 8018d72:	2200      	movs	r2, #0
 8018d74:	639a      	str	r2, [r3, #56]	; 0x38
 8018d76:	9b01      	ldr	r3, [sp, #4]
 8018d78:	2200      	movs	r2, #0
 8018d7a:	63da      	str	r2, [r3, #60]	; 0x3c
 8018d7c:	9b01      	ldr	r3, [sp, #4]
 8018d7e:	2200      	movs	r2, #0
 8018d80:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8018d82:	2301      	movs	r3, #1
 8018d84:	e17a      	b.n	801907c <default_handler+0x3cc>
    }
    return false;
 8018d86:	2300      	movs	r3, #0
 8018d88:	e178      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8018d8a:	9b01      	ldr	r3, [sp, #4]
 8018d8c:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8018d90:	2b01      	cmp	r3, #1
 8018d92:	d113      	bne.n	8018dbc <default_handler+0x10c>
      usbp->status |= 2U;
 8018d94:	9b01      	ldr	r3, [sp, #4]
 8018d96:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 8018d9a:	f043 0302 	orr.w	r3, r3, #2
 8018d9e:	b29a      	uxth	r2, r3
 8018da0:	9b01      	ldr	r3, [sp, #4]
 8018da2:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8018da6:	9b01      	ldr	r3, [sp, #4]
 8018da8:	2200      	movs	r2, #0
 8018daa:	639a      	str	r2, [r3, #56]	; 0x38
 8018dac:	9b01      	ldr	r3, [sp, #4]
 8018dae:	2200      	movs	r2, #0
 8018db0:	63da      	str	r2, [r3, #60]	; 0x3c
 8018db2:	9b01      	ldr	r3, [sp, #4]
 8018db4:	2200      	movs	r2, #0
 8018db6:	641a      	str	r2, [r3, #64]	; 0x40
      return true;
 8018db8:	2301      	movs	r3, #1
 8018dba:	e15f      	b.n	801907c <default_handler+0x3cc>
    }
    return false;
 8018dbc:	2300      	movs	r3, #0
 8018dbe:	e15d      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8018dc0:	9b01      	ldr	r3, [sp, #4]
 8018dc2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8018dc6:	2b00      	cmp	r3, #0
 8018dc8:	d107      	bne.n	8018dda <default_handler+0x12a>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8018dca:	9b01      	ldr	r3, [sp, #4]
 8018dcc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8018dd0:	2b05      	cmp	r3, #5
 8018dd2:	d102      	bne.n	8018dda <default_handler+0x12a>
      set_address(usbp);
 8018dd4:	9801      	ldr	r0, [sp, #4]
 8018dd6:	f7ff ff4b 	bl	8018c70 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8018dda:	9b01      	ldr	r3, [sp, #4]
 8018ddc:	2200      	movs	r2, #0
 8018dde:	639a      	str	r2, [r3, #56]	; 0x38
 8018de0:	9b01      	ldr	r3, [sp, #4]
 8018de2:	2200      	movs	r2, #0
 8018de4:	63da      	str	r2, [r3, #60]	; 0x3c
 8018de6:	9b01      	ldr	r3, [sp, #4]
 8018de8:	2200      	movs	r2, #0
 8018dea:	641a      	str	r2, [r3, #64]	; 0x40
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8018dec:	2301      	movs	r3, #1
 8018dee:	e145      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8018df0:	9b01      	ldr	r3, [sp, #4]
 8018df2:	685b      	ldr	r3, [r3, #4]
 8018df4:	685c      	ldr	r4, [r3, #4]
 8018df6:	9b01      	ldr	r3, [sp, #4]
 8018df8:	f893 5047 	ldrb.w	r5, [r3, #71]	; 0x47
 8018dfc:	9b01      	ldr	r3, [sp, #4]
 8018dfe:	f893 6046 	ldrb.w	r6, [r3, #70]	; 0x46
 8018e02:	9b01      	ldr	r3, [sp, #4]
 8018e04:	3348      	adds	r3, #72	; 0x48
 8018e06:	4618      	mov	r0, r3
 8018e08:	f7ff ff1a 	bl	8018c40 <get_hword>
 8018e0c:	4603      	mov	r3, r0
 8018e0e:	4632      	mov	r2, r6
 8018e10:	4629      	mov	r1, r5
 8018e12:	9801      	ldr	r0, [sp, #4]
 8018e14:	47a0      	blx	r4
 8018e16:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8018e18:	9b03      	ldr	r3, [sp, #12]
 8018e1a:	2b00      	cmp	r3, #0
 8018e1c:	d101      	bne.n	8018e22 <default_handler+0x172>
      return false;
 8018e1e:	2300      	movs	r3, #0
 8018e20:	e12c      	b.n	801907c <default_handler+0x3cc>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8018e22:	9b03      	ldr	r3, [sp, #12]
 8018e24:	685a      	ldr	r2, [r3, #4]
 8018e26:	9b01      	ldr	r3, [sp, #4]
 8018e28:	639a      	str	r2, [r3, #56]	; 0x38
 8018e2a:	9b03      	ldr	r3, [sp, #12]
 8018e2c:	681a      	ldr	r2, [r3, #0]
 8018e2e:	9b01      	ldr	r3, [sp, #4]
 8018e30:	63da      	str	r2, [r3, #60]	; 0x3c
 8018e32:	9b01      	ldr	r3, [sp, #4]
 8018e34:	2200      	movs	r2, #0
 8018e36:	641a      	str	r2, [r3, #64]	; 0x40
    /*lint -restore*/
    return true;
 8018e38:	2301      	movs	r3, #1
 8018e3a:	e11f      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8018e3c:	9b01      	ldr	r3, [sp, #4]
 8018e3e:	f103 024f 	add.w	r2, r3, #79	; 0x4f
 8018e42:	9b01      	ldr	r3, [sp, #4]
 8018e44:	639a      	str	r2, [r3, #56]	; 0x38
 8018e46:	9b01      	ldr	r3, [sp, #4]
 8018e48:	2201      	movs	r2, #1
 8018e4a:	63da      	str	r2, [r3, #60]	; 0x3c
 8018e4c:	9b01      	ldr	r3, [sp, #4]
 8018e4e:	2200      	movs	r2, #0
 8018e50:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8018e52:	2301      	movs	r3, #1
 8018e54:	e112      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8018e56:	9b01      	ldr	r3, [sp, #4]
 8018e58:	f893 204f 	ldrb.w	r2, [r3, #79]	; 0x4f
 8018e5c:	9b01      	ldr	r3, [sp, #4]
 8018e5e:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8018e62:	429a      	cmp	r2, r3
 8018e64:	d035      	beq.n	8018ed2 <default_handler+0x222>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8018e66:	9b01      	ldr	r3, [sp, #4]
 8018e68:	781b      	ldrb	r3, [r3, #0]
 8018e6a:	2b04      	cmp	r3, #4
 8018e6c:	d118      	bne.n	8018ea0 <default_handler+0x1f0>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 8018e6e:	f7ff fec7 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
        usbDisableEndpointsI(usbp);
 8018e72:	9801      	ldr	r0, [sp, #4]
 8018e74:	f000 f93c 	bl	80190f0 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8018e78:	f7ff feca 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
        usbp->configuration = 0U;
 8018e7c:	9b01      	ldr	r3, [sp, #4]
 8018e7e:	2200      	movs	r2, #0
 8018e80:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
        usbp->state = USB_SELECTED;
 8018e84:	9b01      	ldr	r3, [sp, #4]
 8018e86:	2203      	movs	r2, #3
 8018e88:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8018e8a:	9b01      	ldr	r3, [sp, #4]
 8018e8c:	685b      	ldr	r3, [r3, #4]
 8018e8e:	681b      	ldr	r3, [r3, #0]
 8018e90:	2b00      	cmp	r3, #0
 8018e92:	d005      	beq.n	8018ea0 <default_handler+0x1f0>
 8018e94:	9b01      	ldr	r3, [sp, #4]
 8018e96:	685b      	ldr	r3, [r3, #4]
 8018e98:	681b      	ldr	r3, [r3, #0]
 8018e9a:	2103      	movs	r1, #3
 8018e9c:	9801      	ldr	r0, [sp, #4]
 8018e9e:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 8018ea0:	9b01      	ldr	r3, [sp, #4]
 8018ea2:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8018ea6:	2b00      	cmp	r3, #0
 8018ea8:	d013      	beq.n	8018ed2 <default_handler+0x222>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8018eaa:	9b01      	ldr	r3, [sp, #4]
 8018eac:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
 8018eb0:	9b01      	ldr	r3, [sp, #4]
 8018eb2:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
        usbp->state = USB_ACTIVE;
 8018eb6:	9b01      	ldr	r3, [sp, #4]
 8018eb8:	2204      	movs	r2, #4
 8018eba:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8018ebc:	9b01      	ldr	r3, [sp, #4]
 8018ebe:	685b      	ldr	r3, [r3, #4]
 8018ec0:	681b      	ldr	r3, [r3, #0]
 8018ec2:	2b00      	cmp	r3, #0
 8018ec4:	d005      	beq.n	8018ed2 <default_handler+0x222>
 8018ec6:	9b01      	ldr	r3, [sp, #4]
 8018ec8:	685b      	ldr	r3, [r3, #4]
 8018eca:	681b      	ldr	r3, [r3, #0]
 8018ecc:	2102      	movs	r1, #2
 8018ece:	9801      	ldr	r0, [sp, #4]
 8018ed0:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8018ed2:	9b01      	ldr	r3, [sp, #4]
 8018ed4:	2200      	movs	r2, #0
 8018ed6:	639a      	str	r2, [r3, #56]	; 0x38
 8018ed8:	9b01      	ldr	r3, [sp, #4]
 8018eda:	2200      	movs	r2, #0
 8018edc:	63da      	str	r2, [r3, #60]	; 0x3c
 8018ede:	9b01      	ldr	r3, [sp, #4]
 8018ee0:	2200      	movs	r2, #0
 8018ee2:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8018ee4:	2301      	movs	r3, #1
 8018ee6:	e0c9      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8018ee8:	9b01      	ldr	r3, [sp, #4]
 8018eea:	4a66      	ldr	r2, [pc, #408]	; (8019084 <default_handler+0x3d4>)
 8018eec:	639a      	str	r2, [r3, #56]	; 0x38
 8018eee:	9b01      	ldr	r3, [sp, #4]
 8018ef0:	2202      	movs	r2, #2
 8018ef2:	63da      	str	r2, [r3, #60]	; 0x3c
 8018ef4:	9b01      	ldr	r3, [sp, #4]
 8018ef6:	2200      	movs	r2, #0
 8018ef8:	641a      	str	r2, [r3, #64]	; 0x40
    /*lint -restore*/
    return true;
 8018efa:	2301      	movs	r3, #1
 8018efc:	e0be      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8018efe:	9b01      	ldr	r3, [sp, #4]
 8018f00:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018f04:	b25b      	sxtb	r3, r3
 8018f06:	2b00      	cmp	r3, #0
 8018f08:	da27      	bge.n	8018f5a <default_handler+0x2aa>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8018f0a:	9b01      	ldr	r3, [sp, #4]
 8018f0c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018f10:	f003 030f 	and.w	r3, r3, #15
 8018f14:	b2db      	uxtb	r3, r3
 8018f16:	4619      	mov	r1, r3
 8018f18:	9801      	ldr	r0, [sp, #4]
 8018f1a:	f7fc fc91 	bl	8015840 <usb_lld_get_status_in>
 8018f1e:	4603      	mov	r3, r0
 8018f20:	2b01      	cmp	r3, #1
 8018f22:	d002      	beq.n	8018f2a <default_handler+0x27a>
 8018f24:	2b02      	cmp	r3, #2
 8018f26:	d00b      	beq.n	8018f40 <default_handler+0x290>
 8018f28:	e015      	b.n	8018f56 <default_handler+0x2a6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8018f2a:	9b01      	ldr	r3, [sp, #4]
 8018f2c:	4a56      	ldr	r2, [pc, #344]	; (8019088 <default_handler+0x3d8>)
 8018f2e:	639a      	str	r2, [r3, #56]	; 0x38
 8018f30:	9b01      	ldr	r3, [sp, #4]
 8018f32:	2202      	movs	r2, #2
 8018f34:	63da      	str	r2, [r3, #60]	; 0x3c
 8018f36:	9b01      	ldr	r3, [sp, #4]
 8018f38:	2200      	movs	r2, #0
 8018f3a:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8018f3c:	2301      	movs	r3, #1
 8018f3e:	e09d      	b.n	801907c <default_handler+0x3cc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8018f40:	9b01      	ldr	r3, [sp, #4]
 8018f42:	4a52      	ldr	r2, [pc, #328]	; (801908c <default_handler+0x3dc>)
 8018f44:	639a      	str	r2, [r3, #56]	; 0x38
 8018f46:	9b01      	ldr	r3, [sp, #4]
 8018f48:	2202      	movs	r2, #2
 8018f4a:	63da      	str	r2, [r3, #60]	; 0x3c
 8018f4c:	9b01      	ldr	r3, [sp, #4]
 8018f4e:	2200      	movs	r2, #0
 8018f50:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8018f52:	2301      	movs	r3, #1
 8018f54:	e092      	b.n	801907c <default_handler+0x3cc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8018f56:	2300      	movs	r3, #0
 8018f58:	e090      	b.n	801907c <default_handler+0x3cc>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8018f5a:	9b01      	ldr	r3, [sp, #4]
 8018f5c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018f60:	f003 030f 	and.w	r3, r3, #15
 8018f64:	b2db      	uxtb	r3, r3
 8018f66:	4619      	mov	r1, r3
 8018f68:	9801      	ldr	r0, [sp, #4]
 8018f6a:	f7fc fc49 	bl	8015800 <usb_lld_get_status_out>
 8018f6e:	4603      	mov	r3, r0
 8018f70:	2b01      	cmp	r3, #1
 8018f72:	d002      	beq.n	8018f7a <default_handler+0x2ca>
 8018f74:	2b02      	cmp	r3, #2
 8018f76:	d00b      	beq.n	8018f90 <default_handler+0x2e0>
 8018f78:	e015      	b.n	8018fa6 <default_handler+0x2f6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8018f7a:	9b01      	ldr	r3, [sp, #4]
 8018f7c:	4a42      	ldr	r2, [pc, #264]	; (8019088 <default_handler+0x3d8>)
 8018f7e:	639a      	str	r2, [r3, #56]	; 0x38
 8018f80:	9b01      	ldr	r3, [sp, #4]
 8018f82:	2202      	movs	r2, #2
 8018f84:	63da      	str	r2, [r3, #60]	; 0x3c
 8018f86:	9b01      	ldr	r3, [sp, #4]
 8018f88:	2200      	movs	r2, #0
 8018f8a:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8018f8c:	2301      	movs	r3, #1
 8018f8e:	e075      	b.n	801907c <default_handler+0x3cc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8018f90:	9b01      	ldr	r3, [sp, #4]
 8018f92:	4a3e      	ldr	r2, [pc, #248]	; (801908c <default_handler+0x3dc>)
 8018f94:	639a      	str	r2, [r3, #56]	; 0x38
 8018f96:	9b01      	ldr	r3, [sp, #4]
 8018f98:	2202      	movs	r2, #2
 8018f9a:	63da      	str	r2, [r3, #60]	; 0x3c
 8018f9c:	9b01      	ldr	r3, [sp, #4]
 8018f9e:	2200      	movs	r2, #0
 8018fa0:	641a      	str	r2, [r3, #64]	; 0x40
        /*lint -restore*/
        return true;
 8018fa2:	2301      	movs	r3, #1
 8018fa4:	e06a      	b.n	801907c <default_handler+0x3cc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8018fa6:	2300      	movs	r3, #0
 8018fa8:	e068      	b.n	801907c <default_handler+0x3cc>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8018faa:	9b01      	ldr	r3, [sp, #4]
 8018fac:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8018fb0:	2b00      	cmp	r3, #0
 8018fb2:	d001      	beq.n	8018fb8 <default_handler+0x308>
      return false;
 8018fb4:	2300      	movs	r3, #0
 8018fb6:	e061      	b.n	801907c <default_handler+0x3cc>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8018fb8:	9b01      	ldr	r3, [sp, #4]
 8018fba:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018fbe:	f003 030f 	and.w	r3, r3, #15
 8018fc2:	2b00      	cmp	r3, #0
 8018fc4:	d01a      	beq.n	8018ffc <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8018fc6:	9b01      	ldr	r3, [sp, #4]
 8018fc8:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018fcc:	b25b      	sxtb	r3, r3
 8018fce:	2b00      	cmp	r3, #0
 8018fd0:	da0a      	bge.n	8018fe8 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8018fd2:	9b01      	ldr	r3, [sp, #4]
 8018fd4:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018fd8:	f003 030f 	and.w	r3, r3, #15
 8018fdc:	b2db      	uxtb	r3, r3
 8018fde:	4619      	mov	r1, r3
 8018fe0:	9801      	ldr	r0, [sp, #4]
 8018fe2:	f7fc fe15 	bl	8015c10 <usb_lld_clear_in>
 8018fe6:	e009      	b.n	8018ffc <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8018fe8:	9b01      	ldr	r3, [sp, #4]
 8018fea:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8018fee:	f003 030f 	and.w	r3, r3, #15
 8018ff2:	b2db      	uxtb	r3, r3
 8018ff4:	4619      	mov	r1, r3
 8018ff6:	9801      	ldr	r0, [sp, #4]
 8018ff8:	f7fc fdea 	bl	8015bd0 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8018ffc:	9b01      	ldr	r3, [sp, #4]
 8018ffe:	2200      	movs	r2, #0
 8019000:	639a      	str	r2, [r3, #56]	; 0x38
 8019002:	9b01      	ldr	r3, [sp, #4]
 8019004:	2200      	movs	r2, #0
 8019006:	63da      	str	r2, [r3, #60]	; 0x3c
 8019008:	9b01      	ldr	r3, [sp, #4]
 801900a:	2200      	movs	r2, #0
 801900c:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 801900e:	2301      	movs	r3, #1
 8019010:	e034      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8019012:	9b01      	ldr	r3, [sp, #4]
 8019014:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8019018:	2b00      	cmp	r3, #0
 801901a:	d001      	beq.n	8019020 <default_handler+0x370>
      return false;
 801901c:	2300      	movs	r3, #0
 801901e:	e02d      	b.n	801907c <default_handler+0x3cc>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8019020:	9b01      	ldr	r3, [sp, #4]
 8019022:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8019026:	f003 030f 	and.w	r3, r3, #15
 801902a:	2b00      	cmp	r3, #0
 801902c:	d01a      	beq.n	8019064 <default_handler+0x3b4>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 801902e:	9b01      	ldr	r3, [sp, #4]
 8019030:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8019034:	b25b      	sxtb	r3, r3
 8019036:	2b00      	cmp	r3, #0
 8019038:	da0a      	bge.n	8019050 <default_handler+0x3a0>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 801903a:	9b01      	ldr	r3, [sp, #4]
 801903c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8019040:	f003 030f 	and.w	r3, r3, #15
 8019044:	b2db      	uxtb	r3, r3
 8019046:	4619      	mov	r1, r3
 8019048:	9801      	ldr	r0, [sp, #4]
 801904a:	f7fc fda1 	bl	8015b90 <usb_lld_stall_in>
 801904e:	e009      	b.n	8019064 <default_handler+0x3b4>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8019050:	9b01      	ldr	r3, [sp, #4]
 8019052:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8019056:	f003 030f 	and.w	r3, r3, #15
 801905a:	b2db      	uxtb	r3, r3
 801905c:	4619      	mov	r1, r3
 801905e:	9801      	ldr	r0, [sp, #4]
 8019060:	f7fc fd76 	bl	8015b50 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8019064:	9b01      	ldr	r3, [sp, #4]
 8019066:	2200      	movs	r2, #0
 8019068:	639a      	str	r2, [r3, #56]	; 0x38
 801906a:	9b01      	ldr	r3, [sp, #4]
 801906c:	2200      	movs	r2, #0
 801906e:	63da      	str	r2, [r3, #60]	; 0x3c
 8019070:	9b01      	ldr	r3, [sp, #4]
 8019072:	2200      	movs	r2, #0
 8019074:	641a      	str	r2, [r3, #64]	; 0x40
    return true;
 8019076:	2301      	movs	r3, #1
 8019078:	e000      	b.n	801907c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 801907a:	2300      	movs	r3, #0
  }
}
 801907c:	4618      	mov	r0, r3
 801907e:	b004      	add	sp, #16
 8019080:	bd70      	pop	{r4, r5, r6, pc}
 8019082:	bf00      	nop
 8019084:	08022fe4 	.word	0x08022fe4
 8019088:	08022fec 	.word	0x08022fec
 801908c:	08022fe8 	.word	0x08022fe8

08019090 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8019090:	b508      	push	{r3, lr}

  usb_lld_init();
 8019092:	f7fc fae5 	bl	8015660 <usb_lld_init>
}
 8019096:	bd08      	pop	{r3, pc}
	...

080190a0 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 80190a0:	b084      	sub	sp, #16
 80190a2:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 80190a4:	9b01      	ldr	r3, [sp, #4]
 80190a6:	2201      	movs	r2, #1
 80190a8:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 80190aa:	9b01      	ldr	r3, [sp, #4]
 80190ac:	2200      	movs	r2, #0
 80190ae:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80190b0:	2300      	movs	r3, #0
 80190b2:	9303      	str	r3, [sp, #12]
 80190b4:	e00f      	b.n	80190d6 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 80190b6:	9a01      	ldr	r2, [sp, #4]
 80190b8:	9b03      	ldr	r3, [sp, #12]
 80190ba:	3306      	adds	r3, #6
 80190bc:	009b      	lsls	r3, r3, #2
 80190be:	4413      	add	r3, r2
 80190c0:	2200      	movs	r2, #0
 80190c2:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 80190c4:	9b01      	ldr	r3, [sp, #4]
 80190c6:	9a03      	ldr	r2, [sp, #12]
 80190c8:	320a      	adds	r2, #10
 80190ca:	2100      	movs	r1, #0
 80190cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80190d0:	9b03      	ldr	r3, [sp, #12]
 80190d2:	3301      	adds	r3, #1
 80190d4:	9303      	str	r3, [sp, #12]
 80190d6:	9b03      	ldr	r3, [sp, #12]
 80190d8:	2b02      	cmp	r3, #2
 80190da:	d9ec      	bls.n	80190b6 <usbObjectInit+0x16>
  }
  usbp->transmitting = 0;
 80190dc:	9b01      	ldr	r3, [sp, #4]
 80190de:	2200      	movs	r2, #0
 80190e0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 80190e2:	9b01      	ldr	r3, [sp, #4]
 80190e4:	2200      	movs	r2, #0
 80190e6:	815a      	strh	r2, [r3, #10]
}
 80190e8:	b004      	add	sp, #16
 80190ea:	4770      	bx	lr
 80190ec:	0000      	movs	r0, r0
	...

080190f0 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 80190f0:	b500      	push	{lr}
 80190f2:	b085      	sub	sp, #20
 80190f4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 80190f6:	9b01      	ldr	r3, [sp, #4]
 80190f8:	891b      	ldrh	r3, [r3, #8]
 80190fa:	f003 0301 	and.w	r3, r3, #1
 80190fe:	b29a      	uxth	r2, r3
 8019100:	9b01      	ldr	r3, [sp, #4]
 8019102:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 8019104:	9b01      	ldr	r3, [sp, #4]
 8019106:	895b      	ldrh	r3, [r3, #10]
 8019108:	f003 0301 	and.w	r3, r3, #1
 801910c:	b29a      	uxth	r2, r3
 801910e:	9b01      	ldr	r3, [sp, #4]
 8019110:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8019112:	2301      	movs	r3, #1
 8019114:	9303      	str	r3, [sp, #12]
 8019116:	e03d      	b.n	8019194 <usbDisableEndpointsI+0xa4>
#if USB_USE_WAIT == TRUE
    /* Signaling the event to threads waiting on endpoints.*/
    if (usbp->epc[i] != NULL) {
 8019118:	9a01      	ldr	r2, [sp, #4]
 801911a:	9b03      	ldr	r3, [sp, #12]
 801911c:	3302      	adds	r3, #2
 801911e:	009b      	lsls	r3, r3, #2
 8019120:	4413      	add	r3, r2
 8019122:	685b      	ldr	r3, [r3, #4]
 8019124:	2b00      	cmp	r3, #0
 8019126:	d02b      	beq.n	8019180 <usbDisableEndpointsI+0x90>
      if (usbp->epc[i]->in_state != NULL) {
 8019128:	9a01      	ldr	r2, [sp, #4]
 801912a:	9b03      	ldr	r3, [sp, #12]
 801912c:	3302      	adds	r3, #2
 801912e:	009b      	lsls	r3, r3, #2
 8019130:	4413      	add	r3, r2
 8019132:	685b      	ldr	r3, [r3, #4]
 8019134:	695b      	ldr	r3, [r3, #20]
 8019136:	2b00      	cmp	r3, #0
 8019138:	d00c      	beq.n	8019154 <usbDisableEndpointsI+0x64>
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 801913a:	9a01      	ldr	r2, [sp, #4]
 801913c:	9b03      	ldr	r3, [sp, #12]
 801913e:	3302      	adds	r3, #2
 8019140:	009b      	lsls	r3, r3, #2
 8019142:	4413      	add	r3, r2
 8019144:	685b      	ldr	r3, [r3, #4]
 8019146:	695b      	ldr	r3, [r3, #20]
 8019148:	330c      	adds	r3, #12
 801914a:	f06f 0101 	mvn.w	r1, #1
 801914e:	4618      	mov	r0, r3
 8019150:	f7ff fd66 	bl	8018c20 <osalThreadResumeI>
      }
      if (usbp->epc[i]->out_state != NULL) {
 8019154:	9a01      	ldr	r2, [sp, #4]
 8019156:	9b03      	ldr	r3, [sp, #12]
 8019158:	3302      	adds	r3, #2
 801915a:	009b      	lsls	r3, r3, #2
 801915c:	4413      	add	r3, r2
 801915e:	685b      	ldr	r3, [r3, #4]
 8019160:	699b      	ldr	r3, [r3, #24]
 8019162:	2b00      	cmp	r3, #0
 8019164:	d00c      	beq.n	8019180 <usbDisableEndpointsI+0x90>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 8019166:	9a01      	ldr	r2, [sp, #4]
 8019168:	9b03      	ldr	r3, [sp, #12]
 801916a:	3302      	adds	r3, #2
 801916c:	009b      	lsls	r3, r3, #2
 801916e:	4413      	add	r3, r2
 8019170:	685b      	ldr	r3, [r3, #4]
 8019172:	699b      	ldr	r3, [r3, #24]
 8019174:	330c      	adds	r3, #12
 8019176:	f06f 0101 	mvn.w	r1, #1
 801917a:	4618      	mov	r0, r3
 801917c:	f7ff fd50 	bl	8018c20 <osalThreadResumeI>
      }
    }
#endif
    usbp->epc[i] = NULL;
 8019180:	9a01      	ldr	r2, [sp, #4]
 8019182:	9b03      	ldr	r3, [sp, #12]
 8019184:	3302      	adds	r3, #2
 8019186:	009b      	lsls	r3, r3, #2
 8019188:	4413      	add	r3, r2
 801918a:	2200      	movs	r2, #0
 801918c:	605a      	str	r2, [r3, #4]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 801918e:	9b03      	ldr	r3, [sp, #12]
 8019190:	3301      	adds	r3, #1
 8019192:	9303      	str	r3, [sp, #12]
 8019194:	9b03      	ldr	r3, [sp, #12]
 8019196:	2b03      	cmp	r3, #3
 8019198:	d9be      	bls.n	8019118 <usbDisableEndpointsI+0x28>
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 801919a:	9801      	ldr	r0, [sp, #4]
 801919c:	f7fc fb20 	bl	80157e0 <usb_lld_disable_endpoints>
}
 80191a0:	b005      	add	sp, #20
 80191a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80191a6:	bf00      	nop
	...

080191b0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 80191b0:	b500      	push	{lr}
 80191b2:	b087      	sub	sp, #28
 80191b4:	9003      	str	r0, [sp, #12]
 80191b6:	9201      	str	r2, [sp, #4]
 80191b8:	9300      	str	r3, [sp, #0]
 80191ba:	460b      	mov	r3, r1
 80191bc:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80191c0:	9b03      	ldr	r3, [sp, #12]
 80191c2:	895a      	ldrh	r2, [r3, #10]
 80191c4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80191c8:	2101      	movs	r1, #1
 80191ca:	fa01 f303 	lsl.w	r3, r1, r3
 80191ce:	b29b      	uxth	r3, r3
 80191d0:	4313      	orrs	r3, r2
 80191d2:	b29a      	uxth	r2, r3
 80191d4:	9b03      	ldr	r3, [sp, #12]
 80191d6:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80191d8:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80191dc:	9a03      	ldr	r2, [sp, #12]
 80191de:	3302      	adds	r3, #2
 80191e0:	009b      	lsls	r3, r3, #2
 80191e2:	4413      	add	r3, r2
 80191e4:	685b      	ldr	r3, [r3, #4]
 80191e6:	699b      	ldr	r3, [r3, #24]
 80191e8:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 80191ea:	9b05      	ldr	r3, [sp, #20]
 80191ec:	9a01      	ldr	r2, [sp, #4]
 80191ee:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 80191f0:	9b05      	ldr	r3, [sp, #20]
 80191f2:	9a00      	ldr	r2, [sp, #0]
 80191f4:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 80191f6:	9b05      	ldr	r3, [sp, #20]
 80191f8:	2200      	movs	r2, #0
 80191fa:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
 80191fc:	9b05      	ldr	r3, [sp, #20]
 80191fe:	2200      	movs	r2, #0
 8019200:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8019202:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8019206:	4619      	mov	r1, r3
 8019208:	9803      	ldr	r0, [sp, #12]
 801920a:	f7fc fb51 	bl	80158b0 <usb_lld_start_out>
}
 801920e:	b007      	add	sp, #28
 8019210:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019220 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8019220:	b500      	push	{lr}
 8019222:	b087      	sub	sp, #28
 8019224:	9003      	str	r0, [sp, #12]
 8019226:	9201      	str	r2, [sp, #4]
 8019228:	9300      	str	r3, [sp, #0]
 801922a:	460b      	mov	r3, r1
 801922c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8019230:	9b03      	ldr	r3, [sp, #12]
 8019232:	891a      	ldrh	r2, [r3, #8]
 8019234:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8019238:	2101      	movs	r1, #1
 801923a:	fa01 f303 	lsl.w	r3, r1, r3
 801923e:	b29b      	uxth	r3, r3
 8019240:	4313      	orrs	r3, r2
 8019242:	b29a      	uxth	r2, r3
 8019244:	9b03      	ldr	r3, [sp, #12]
 8019246:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8019248:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801924c:	9a03      	ldr	r2, [sp, #12]
 801924e:	3302      	adds	r3, #2
 8019250:	009b      	lsls	r3, r3, #2
 8019252:	4413      	add	r3, r2
 8019254:	685b      	ldr	r3, [r3, #4]
 8019256:	695b      	ldr	r3, [r3, #20]
 8019258:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 801925a:	9b05      	ldr	r3, [sp, #20]
 801925c:	9a01      	ldr	r2, [sp, #4]
 801925e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8019260:	9b05      	ldr	r3, [sp, #20]
 8019262:	9a00      	ldr	r2, [sp, #0]
 8019264:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8019266:	9b05      	ldr	r3, [sp, #20]
 8019268:	2200      	movs	r2, #0
 801926a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
 801926c:	9b05      	ldr	r3, [sp, #20]
 801926e:	2200      	movs	r2, #0
 8019270:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8019272:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8019276:	4619      	mov	r1, r3
 8019278:	9803      	ldr	r0, [sp, #12]
 801927a:	f7fc fbb9 	bl	80159f0 <usb_lld_start_in>
}
 801927e:	b007      	add	sp, #28
 8019280:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019290 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8019290:	b500      	push	{lr}
 8019292:	b085      	sub	sp, #20
 8019294:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8019296:	9b01      	ldr	r3, [sp, #4]
 8019298:	2202      	movs	r2, #2
 801929a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 801929c:	9b01      	ldr	r3, [sp, #4]
 801929e:	2200      	movs	r2, #0
 80192a0:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  usbp->address       = 0;
 80192a4:	9b01      	ldr	r3, [sp, #4]
 80192a6:	2200      	movs	r2, #0
 80192a8:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
  usbp->configuration = 0;
 80192ac:	9b01      	ldr	r3, [sp, #4]
 80192ae:	2200      	movs	r2, #0
 80192b0:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
  usbp->transmitting  = 0;
 80192b4:	9b01      	ldr	r3, [sp, #4]
 80192b6:	2200      	movs	r2, #0
 80192b8:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 80192ba:	9b01      	ldr	r3, [sp, #4]
 80192bc:	2200      	movs	r2, #0
 80192be:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80192c0:	2300      	movs	r3, #0
 80192c2:	9303      	str	r3, [sp, #12]
 80192c4:	e041      	b.n	801934a <_usb_reset+0xba>
#if USB_USE_WAIT == TRUE
    /* Signaling the event to threads waiting on endpoints.*/
    if (usbp->epc[i] != NULL) {
 80192c6:	9a01      	ldr	r2, [sp, #4]
 80192c8:	9b03      	ldr	r3, [sp, #12]
 80192ca:	3302      	adds	r3, #2
 80192cc:	009b      	lsls	r3, r3, #2
 80192ce:	4413      	add	r3, r2
 80192d0:	685b      	ldr	r3, [r3, #4]
 80192d2:	2b00      	cmp	r3, #0
 80192d4:	d02f      	beq.n	8019336 <_usb_reset+0xa6>
      osalSysLockFromISR();
 80192d6:	f7ff fc93 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      if (usbp->epc[i]->in_state != NULL) {
 80192da:	9a01      	ldr	r2, [sp, #4]
 80192dc:	9b03      	ldr	r3, [sp, #12]
 80192de:	3302      	adds	r3, #2
 80192e0:	009b      	lsls	r3, r3, #2
 80192e2:	4413      	add	r3, r2
 80192e4:	685b      	ldr	r3, [r3, #4]
 80192e6:	695b      	ldr	r3, [r3, #20]
 80192e8:	2b00      	cmp	r3, #0
 80192ea:	d00c      	beq.n	8019306 <_usb_reset+0x76>
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 80192ec:	9a01      	ldr	r2, [sp, #4]
 80192ee:	9b03      	ldr	r3, [sp, #12]
 80192f0:	3302      	adds	r3, #2
 80192f2:	009b      	lsls	r3, r3, #2
 80192f4:	4413      	add	r3, r2
 80192f6:	685b      	ldr	r3, [r3, #4]
 80192f8:	695b      	ldr	r3, [r3, #20]
 80192fa:	330c      	adds	r3, #12
 80192fc:	f06f 0101 	mvn.w	r1, #1
 8019300:	4618      	mov	r0, r3
 8019302:	f7ff fc8d 	bl	8018c20 <osalThreadResumeI>
      }
      if (usbp->epc[i]->out_state != NULL) {
 8019306:	9a01      	ldr	r2, [sp, #4]
 8019308:	9b03      	ldr	r3, [sp, #12]
 801930a:	3302      	adds	r3, #2
 801930c:	009b      	lsls	r3, r3, #2
 801930e:	4413      	add	r3, r2
 8019310:	685b      	ldr	r3, [r3, #4]
 8019312:	699b      	ldr	r3, [r3, #24]
 8019314:	2b00      	cmp	r3, #0
 8019316:	d00c      	beq.n	8019332 <_usb_reset+0xa2>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 8019318:	9a01      	ldr	r2, [sp, #4]
 801931a:	9b03      	ldr	r3, [sp, #12]
 801931c:	3302      	adds	r3, #2
 801931e:	009b      	lsls	r3, r3, #2
 8019320:	4413      	add	r3, r2
 8019322:	685b      	ldr	r3, [r3, #4]
 8019324:	699b      	ldr	r3, [r3, #24]
 8019326:	330c      	adds	r3, #12
 8019328:	f06f 0101 	mvn.w	r1, #1
 801932c:	4618      	mov	r0, r3
 801932e:	f7ff fc77 	bl	8018c20 <osalThreadResumeI>
      }
      osalSysUnlockFromISR();
 8019332:	f7ff fc6d 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
    }
#endif
    usbp->epc[i] = NULL;
 8019336:	9a01      	ldr	r2, [sp, #4]
 8019338:	9b03      	ldr	r3, [sp, #12]
 801933a:	3302      	adds	r3, #2
 801933c:	009b      	lsls	r3, r3, #2
 801933e:	4413      	add	r3, r2
 8019340:	2200      	movs	r2, #0
 8019342:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8019344:	9b03      	ldr	r3, [sp, #12]
 8019346:	3301      	adds	r3, #1
 8019348:	9303      	str	r3, [sp, #12]
 801934a:	9b03      	ldr	r3, [sp, #12]
 801934c:	2b03      	cmp	r3, #3
 801934e:	d9ba      	bls.n	80192c6 <_usb_reset+0x36>
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;
 8019350:	9b01      	ldr	r3, [sp, #4]
 8019352:	2200      	movs	r2, #0
 8019354:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8019358:	9801      	ldr	r0, [sp, #4]
 801935a:	f7fc f991 	bl	8015680 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 801935e:	9b01      	ldr	r3, [sp, #4]
 8019360:	685b      	ldr	r3, [r3, #4]
 8019362:	681b      	ldr	r3, [r3, #0]
 8019364:	2b00      	cmp	r3, #0
 8019366:	d005      	beq.n	8019374 <_usb_reset+0xe4>
 8019368:	9b01      	ldr	r3, [sp, #4]
 801936a:	685b      	ldr	r3, [r3, #4]
 801936c:	681b      	ldr	r3, [r3, #0]
 801936e:	2100      	movs	r1, #0
 8019370:	9801      	ldr	r0, [sp, #4]
 8019372:	4798      	blx	r3
}
 8019374:	b005      	add	sp, #20
 8019376:	f85d fb04 	ldr.w	pc, [sp], #4
 801937a:	bf00      	nop
 801937c:	0000      	movs	r0, r0
	...

08019380 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8019380:	b500      	push	{lr}
 8019382:	b085      	sub	sp, #20
 8019384:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8019386:	9b01      	ldr	r3, [sp, #4]
 8019388:	781a      	ldrb	r2, [r3, #0]
 801938a:	9b01      	ldr	r3, [sp, #4]
 801938c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  usbp->state       = USB_SUSPENDED;
 8019390:	9b01      	ldr	r3, [sp, #4]
 8019392:	2205      	movs	r2, #5
 8019394:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8019396:	9b01      	ldr	r3, [sp, #4]
 8019398:	685b      	ldr	r3, [r3, #4]
 801939a:	681b      	ldr	r3, [r3, #0]
 801939c:	2b00      	cmp	r3, #0
 801939e:	d005      	beq.n	80193ac <_usb_suspend+0x2c>
 80193a0:	9b01      	ldr	r3, [sp, #4]
 80193a2:	685b      	ldr	r3, [r3, #4]
 80193a4:	681b      	ldr	r3, [r3, #0]
 80193a6:	2104      	movs	r1, #4
 80193a8:	9801      	ldr	r0, [sp, #4]
 80193aa:	4798      	blx	r3
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  {
    unsigned i;

    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80193ac:	2300      	movs	r3, #0
 80193ae:	9303      	str	r3, [sp, #12]
 80193b0:	e03a      	b.n	8019428 <_usb_suspend+0xa8>
      if (usbp->epc[i] != NULL) {
 80193b2:	9a01      	ldr	r2, [sp, #4]
 80193b4:	9b03      	ldr	r3, [sp, #12]
 80193b6:	3302      	adds	r3, #2
 80193b8:	009b      	lsls	r3, r3, #2
 80193ba:	4413      	add	r3, r2
 80193bc:	685b      	ldr	r3, [r3, #4]
 80193be:	2b00      	cmp	r3, #0
 80193c0:	d02f      	beq.n	8019422 <_usb_suspend+0xa2>
        osalSysLockFromISR();
 80193c2:	f7ff fc1d 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
        if (usbp->epc[i]->in_state != NULL) {
 80193c6:	9a01      	ldr	r2, [sp, #4]
 80193c8:	9b03      	ldr	r3, [sp, #12]
 80193ca:	3302      	adds	r3, #2
 80193cc:	009b      	lsls	r3, r3, #2
 80193ce:	4413      	add	r3, r2
 80193d0:	685b      	ldr	r3, [r3, #4]
 80193d2:	695b      	ldr	r3, [r3, #20]
 80193d4:	2b00      	cmp	r3, #0
 80193d6:	d00c      	beq.n	80193f2 <_usb_suspend+0x72>
          osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 80193d8:	9a01      	ldr	r2, [sp, #4]
 80193da:	9b03      	ldr	r3, [sp, #12]
 80193dc:	3302      	adds	r3, #2
 80193de:	009b      	lsls	r3, r3, #2
 80193e0:	4413      	add	r3, r2
 80193e2:	685b      	ldr	r3, [r3, #4]
 80193e4:	695b      	ldr	r3, [r3, #20]
 80193e6:	330c      	adds	r3, #12
 80193e8:	f06f 0101 	mvn.w	r1, #1
 80193ec:	4618      	mov	r0, r3
 80193ee:	f7ff fc17 	bl	8018c20 <osalThreadResumeI>
        }
        if (usbp->epc[i]->out_state != NULL) {
 80193f2:	9a01      	ldr	r2, [sp, #4]
 80193f4:	9b03      	ldr	r3, [sp, #12]
 80193f6:	3302      	adds	r3, #2
 80193f8:	009b      	lsls	r3, r3, #2
 80193fa:	4413      	add	r3, r2
 80193fc:	685b      	ldr	r3, [r3, #4]
 80193fe:	699b      	ldr	r3, [r3, #24]
 8019400:	2b00      	cmp	r3, #0
 8019402:	d00c      	beq.n	801941e <_usb_suspend+0x9e>
          osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 8019404:	9a01      	ldr	r2, [sp, #4]
 8019406:	9b03      	ldr	r3, [sp, #12]
 8019408:	3302      	adds	r3, #2
 801940a:	009b      	lsls	r3, r3, #2
 801940c:	4413      	add	r3, r2
 801940e:	685b      	ldr	r3, [r3, #4]
 8019410:	699b      	ldr	r3, [r3, #24]
 8019412:	330c      	adds	r3, #12
 8019414:	f06f 0101 	mvn.w	r1, #1
 8019418:	4618      	mov	r0, r3
 801941a:	f7ff fc01 	bl	8018c20 <osalThreadResumeI>
        }
        osalSysUnlockFromISR();
 801941e:	f7ff fbf7 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8019422:	9b03      	ldr	r3, [sp, #12]
 8019424:	3301      	adds	r3, #1
 8019426:	9303      	str	r3, [sp, #12]
 8019428:	9b03      	ldr	r3, [sp, #12]
 801942a:	2b03      	cmp	r3, #3
 801942c:	d9c1      	bls.n	80193b2 <_usb_suspend+0x32>
      }
    }
  }
#endif
}
 801942e:	b005      	add	sp, #20
 8019430:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019440 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8019440:	b500      	push	{lr}
 8019442:	b083      	sub	sp, #12
 8019444:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8019446:	9b01      	ldr	r3, [sp, #4]
 8019448:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 801944c:	9b01      	ldr	r3, [sp, #4]
 801944e:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8019450:	9b01      	ldr	r3, [sp, #4]
 8019452:	685b      	ldr	r3, [r3, #4]
 8019454:	681b      	ldr	r3, [r3, #0]
 8019456:	2b00      	cmp	r3, #0
 8019458:	d005      	beq.n	8019466 <_usb_wakeup+0x26>
 801945a:	9b01      	ldr	r3, [sp, #4]
 801945c:	685b      	ldr	r3, [r3, #4]
 801945e:	681b      	ldr	r3, [r3, #0]
 8019460:	2105      	movs	r1, #5
 8019462:	9801      	ldr	r0, [sp, #4]
 8019464:	4798      	blx	r3
}
 8019466:	b003      	add	sp, #12
 8019468:	f85d fb04 	ldr.w	pc, [sp], #4
 801946c:	0000      	movs	r0, r0
	...

08019470 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8019470:	b500      	push	{lr}
 8019472:	b085      	sub	sp, #20
 8019474:	9001      	str	r0, [sp, #4]
 8019476:	460b      	mov	r3, r1
 8019478:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 801947c:	9b01      	ldr	r3, [sp, #4]
 801947e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8019482:	2b00      	cmp	r3, #0
 8019484:	d003      	beq.n	801948e <_usb_ep0setup+0x1e>
    /* This is unexpected could require handling with a warning event.*/
    /* TODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 8019486:	9b01      	ldr	r3, [sp, #4]
 8019488:	2200      	movs	r2, #0
 801948a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 801948e:	9b01      	ldr	r3, [sp, #4]
 8019490:	f103 0244 	add.w	r2, r3, #68	; 0x44
 8019494:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8019498:	4619      	mov	r1, r3
 801949a:	9801      	ldr	r0, [sp, #4]
 801949c:	f7fc f9f0 	bl	8015880 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80194a0:	9b01      	ldr	r3, [sp, #4]
 80194a2:	685b      	ldr	r3, [r3, #4]
 80194a4:	689b      	ldr	r3, [r3, #8]
 80194a6:	2b00      	cmp	r3, #0
 80194a8:	d00a      	beq.n	80194c0 <_usb_ep0setup+0x50>
      !(usbp->config->requests_hook_cb(usbp))) {
 80194aa:	9b01      	ldr	r3, [sp, #4]
 80194ac:	685b      	ldr	r3, [r3, #4]
 80194ae:	689b      	ldr	r3, [r3, #8]
 80194b0:	9801      	ldr	r0, [sp, #4]
 80194b2:	4798      	blx	r3
 80194b4:	4603      	mov	r3, r0
 80194b6:	f083 0301 	eor.w	r3, r3, #1
 80194ba:	b2db      	uxtb	r3, r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 80194bc:	2b00      	cmp	r3, #0
 80194be:	d027      	beq.n	8019510 <_usb_ep0setup+0xa0>
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80194c0:	9b01      	ldr	r3, [sp, #4]
 80194c2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80194c6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80194ca:	2b00      	cmp	r3, #0
 80194cc:	d108      	bne.n	80194e0 <_usb_ep0setup+0x70>
        !default_handler(usbp)) {
 80194ce:	9801      	ldr	r0, [sp, #4]
 80194d0:	f7ff fbee 	bl	8018cb0 <default_handler>
 80194d4:	4603      	mov	r3, r0
 80194d6:	f083 0301 	eor.w	r3, r3, #1
 80194da:	b2db      	uxtb	r3, r3
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80194dc:	2b00      	cmp	r3, #0
 80194de:	d017      	beq.n	8019510 <_usb_ep0setup+0xa0>
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 80194e0:	2100      	movs	r1, #0
 80194e2:	9801      	ldr	r0, [sp, #4]
 80194e4:	f7fc fb54 	bl	8015b90 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 80194e8:	2100      	movs	r1, #0
 80194ea:	9801      	ldr	r0, [sp, #4]
 80194ec:	f7fc fb30 	bl	8015b50 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80194f0:	9b01      	ldr	r3, [sp, #4]
 80194f2:	685b      	ldr	r3, [r3, #4]
 80194f4:	681b      	ldr	r3, [r3, #0]
 80194f6:	2b00      	cmp	r3, #0
 80194f8:	d005      	beq.n	8019506 <_usb_ep0setup+0x96>
 80194fa:	9b01      	ldr	r3, [sp, #4]
 80194fc:	685b      	ldr	r3, [r3, #4]
 80194fe:	681b      	ldr	r3, [r3, #0]
 8019500:	2106      	movs	r1, #6
 8019502:	9801      	ldr	r0, [sp, #4]
 8019504:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8019506:	9b01      	ldr	r3, [sp, #4]
 8019508:	2206      	movs	r2, #6
 801950a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 801950e:	e05b      	b.n	80195c8 <_usb_ep0setup+0x158>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8019510:	9b01      	ldr	r3, [sp, #4]
 8019512:	334a      	adds	r3, #74	; 0x4a
 8019514:	4618      	mov	r0, r3
 8019516:	f7ff fb93 	bl	8018c40 <get_hword>
 801951a:	4603      	mov	r3, r0
 801951c:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 801951e:	9b01      	ldr	r3, [sp, #4]
 8019520:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8019522:	9b03      	ldr	r3, [sp, #12]
 8019524:	429a      	cmp	r2, r3
 8019526:	d902      	bls.n	801952e <_usb_ep0setup+0xbe>
    usbp->ep0n = max;
 8019528:	9b01      	ldr	r3, [sp, #4]
 801952a:	9a03      	ldr	r2, [sp, #12]
 801952c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 801952e:	9b01      	ldr	r3, [sp, #4]
 8019530:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8019534:	b25b      	sxtb	r3, r3
 8019536:	2b00      	cmp	r3, #0
 8019538:	da23      	bge.n	8019582 <_usb_ep0setup+0x112>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 801953a:	9b01      	ldr	r3, [sp, #4]
 801953c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801953e:	2b00      	cmp	r3, #0
 8019540:	d010      	beq.n	8019564 <_usb_ep0setup+0xf4>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_IN_TX;
 8019542:	9b01      	ldr	r3, [sp, #4]
 8019544:	2209      	movs	r2, #9
 8019546:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      osalSysLockFromISR();
 801954a:	f7ff fb59 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 801954e:	9b01      	ldr	r3, [sp, #4]
 8019550:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8019552:	9b01      	ldr	r3, [sp, #4]
 8019554:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8019556:	2100      	movs	r1, #0
 8019558:	9801      	ldr	r0, [sp, #4]
 801955a:	f7ff fe61 	bl	8019220 <usbStartTransmitI>
      osalSysUnlockFromISR();
 801955e:	f7ff fb57 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
         packet.*/
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
      osalSysUnlockFromISR();
 8019562:	e031      	b.n	80195c8 <_usb_ep0setup+0x158>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8019564:	9b01      	ldr	r3, [sp, #4]
 8019566:	2214      	movs	r2, #20
 8019568:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      osalSysLockFromISR();
 801956c:	f7ff fb48 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8019570:	2300      	movs	r3, #0
 8019572:	2200      	movs	r2, #0
 8019574:	2100      	movs	r1, #0
 8019576:	9801      	ldr	r0, [sp, #4]
 8019578:	f7ff fe1a 	bl	80191b0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 801957c:	f7ff fb48 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
 8019580:	e022      	b.n	80195c8 <_usb_ep0setup+0x158>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8019582:	9b01      	ldr	r3, [sp, #4]
 8019584:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8019586:	2b00      	cmp	r3, #0
 8019588:	d010      	beq.n	80195ac <_usb_ep0setup+0x13c>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 801958a:	9b01      	ldr	r3, [sp, #4]
 801958c:	2215      	movs	r2, #21
 801958e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      osalSysLockFromISR();
 8019592:	f7ff fb35 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8019596:	9b01      	ldr	r3, [sp, #4]
 8019598:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801959a:	9b01      	ldr	r3, [sp, #4]
 801959c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801959e:	2100      	movs	r1, #0
 80195a0:	9801      	ldr	r0, [sp, #4]
 80195a2:	f7ff fe05 	bl	80191b0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 80195a6:	f7ff fb33 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
 80195aa:	e00d      	b.n	80195c8 <_usb_ep0setup+0x158>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80195ac:	9b01      	ldr	r3, [sp, #4]
 80195ae:	220b      	movs	r2, #11
 80195b0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 80195b4:	f7ff fb24 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80195b8:	2300      	movs	r3, #0
 80195ba:	2200      	movs	r2, #0
 80195bc:	2100      	movs	r1, #0
 80195be:	9801      	ldr	r0, [sp, #4]
 80195c0:	f7ff fe2e 	bl	8019220 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80195c4:	f7ff fb24 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 80195c8:	b005      	add	sp, #20
 80195ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80195ce:	bf00      	nop

080195d0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80195d0:	b500      	push	{lr}
 80195d2:	b085      	sub	sp, #20
 80195d4:	9001      	str	r0, [sp, #4]
 80195d6:	460b      	mov	r3, r1
 80195d8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80195dc:	9b01      	ldr	r3, [sp, #4]
 80195de:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80195e2:	2b15      	cmp	r3, #21
 80195e4:	f200 808a 	bhi.w	80196fc <_usb_ep0in+0x12c>
 80195e8:	a201      	add	r2, pc, #4	; (adr r2, 80195f0 <_usb_ep0in+0x20>)
 80195ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80195ee:	bf00      	nop
 80195f0:	080196cf 	.word	0x080196cf
 80195f4:	080196fd 	.word	0x080196fd
 80195f8:	080196fd 	.word	0x080196fd
 80195fc:	080196fd 	.word	0x080196fd
 8019600:	080196fd 	.word	0x080196fd
 8019604:	080196fd 	.word	0x080196fd
 8019608:	080196cf 	.word	0x080196cf
 801960c:	080196fd 	.word	0x080196fd
 8019610:	080196fd 	.word	0x080196fd
 8019614:	08019649 	.word	0x08019649
 8019618:	08019697 	.word	0x08019697
 801961c:	080196b5 	.word	0x080196b5
 8019620:	080196fd 	.word	0x080196fd
 8019624:	080196fd 	.word	0x080196fd
 8019628:	080196fd 	.word	0x080196fd
 801962c:	080196fd 	.word	0x080196fd
 8019630:	080196fd 	.word	0x080196fd
 8019634:	080196fd 	.word	0x080196fd
 8019638:	080196fd 	.word	0x080196fd
 801963c:	080196fd 	.word	0x080196fd
 8019640:	080196cf 	.word	0x080196cf
 8019644:	080196cf 	.word	0x080196cf
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8019648:	9b01      	ldr	r3, [sp, #4]
 801964a:	334a      	adds	r3, #74	; 0x4a
 801964c:	4618      	mov	r0, r3
 801964e:	f7ff faf7 	bl	8018c40 <get_hword>
 8019652:	4603      	mov	r3, r0
 8019654:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8019656:	9b01      	ldr	r3, [sp, #4]
 8019658:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 801965a:	9b03      	ldr	r3, [sp, #12]
 801965c:	429a      	cmp	r2, r3
 801965e:	d21a      	bcs.n	8019696 <_usb_ep0in+0xc6>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8019660:	9b01      	ldr	r3, [sp, #4]
 8019662:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8019664:	9a01      	ldr	r2, [sp, #4]
 8019666:	68d2      	ldr	r2, [r2, #12]
 8019668:	8a12      	ldrh	r2, [r2, #16]
 801966a:	fbb3 f1f2 	udiv	r1, r3, r2
 801966e:	fb02 f201 	mul.w	r2, r2, r1
 8019672:	1a9b      	subs	r3, r3, r2
    if ((usbp->ep0n < max) &&
 8019674:	2b00      	cmp	r3, #0
 8019676:	d10e      	bne.n	8019696 <_usb_ep0in+0xc6>
      osalSysLockFromISR();
 8019678:	f7ff fac2 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
      usbStartTransmitI(usbp, 0, NULL, 0);
 801967c:	2300      	movs	r3, #0
 801967e:	2200      	movs	r2, #0
 8019680:	2100      	movs	r1, #0
 8019682:	9801      	ldr	r0, [sp, #4]
 8019684:	f7ff fdcc 	bl	8019220 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8019688:	f7ff fac2 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 801968c:	9b01      	ldr	r3, [sp, #4]
 801968e:	220a      	movs	r2, #10
 8019690:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 8019694:	e032      	b.n	80196fc <_usb_ep0in+0x12c>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8019696:	9b01      	ldr	r3, [sp, #4]
 8019698:	2214      	movs	r2, #20
 801969a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 801969e:	f7ff faaf 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
    usbStartReceiveI(usbp, 0, NULL, 0);
 80196a2:	2300      	movs	r3, #0
 80196a4:	2200      	movs	r2, #0
 80196a6:	2100      	movs	r1, #0
 80196a8:	9801      	ldr	r0, [sp, #4]
 80196aa:	f7ff fd81 	bl	80191b0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 80196ae:	f7ff faaf 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
 80196b2:	e023      	b.n	80196fc <_usb_ep0in+0x12c>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_IN_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 80196b4:	9b01      	ldr	r3, [sp, #4]
 80196b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80196b8:	2b00      	cmp	r3, #0
 80196ba:	d003      	beq.n	80196c4 <_usb_ep0in+0xf4>
      usbp->ep0endcb(usbp);
 80196bc:	9b01      	ldr	r3, [sp, #4]
 80196be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80196c0:	9801      	ldr	r0, [sp, #4]
 80196c2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 80196c4:	9b01      	ldr	r3, [sp, #4]
 80196c6:	2200      	movs	r2, #0
 80196c8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 80196cc:	e016      	b.n	80196fc <_usb_ep0in+0x12c>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80196ce:	2100      	movs	r1, #0
 80196d0:	9801      	ldr	r0, [sp, #4]
 80196d2:	f7fc fa5d 	bl	8015b90 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80196d6:	2100      	movs	r1, #0
 80196d8:	9801      	ldr	r0, [sp, #4]
 80196da:	f7fc fa39 	bl	8015b50 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80196de:	9b01      	ldr	r3, [sp, #4]
 80196e0:	685b      	ldr	r3, [r3, #4]
 80196e2:	681b      	ldr	r3, [r3, #0]
 80196e4:	2b00      	cmp	r3, #0
 80196e6:	d005      	beq.n	80196f4 <_usb_ep0in+0x124>
 80196e8:	9b01      	ldr	r3, [sp, #4]
 80196ea:	685b      	ldr	r3, [r3, #4]
 80196ec:	681b      	ldr	r3, [r3, #0]
 80196ee:	2106      	movs	r1, #6
 80196f0:	9801      	ldr	r0, [sp, #4]
 80196f2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80196f4:	9b01      	ldr	r3, [sp, #4]
 80196f6:	2206      	movs	r2, #6
 80196f8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 80196fc:	b005      	add	sp, #20
 80196fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8019702:	bf00      	nop
	...

08019710 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8019710:	b500      	push	{lr}
 8019712:	b083      	sub	sp, #12
 8019714:	9001      	str	r0, [sp, #4]
 8019716:	460b      	mov	r3, r1
 8019718:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 801971c:	9b01      	ldr	r3, [sp, #4]
 801971e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8019722:	2b15      	cmp	r3, #21
 8019724:	d867      	bhi.n	80197f6 <_usb_ep0out+0xe6>
 8019726:	a201      	add	r2, pc, #4	; (adr r2, 801972c <_usb_ep0out+0x1c>)
 8019728:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801972c:	080197c9 	.word	0x080197c9
 8019730:	080197f7 	.word	0x080197f7
 8019734:	080197f7 	.word	0x080197f7
 8019738:	080197f7 	.word	0x080197f7
 801973c:	080197f7 	.word	0x080197f7
 8019740:	080197f7 	.word	0x080197f7
 8019744:	080197c9 	.word	0x080197c9
 8019748:	080197f7 	.word	0x080197f7
 801974c:	080197f7 	.word	0x080197f7
 8019750:	080197c9 	.word	0x080197c9
 8019754:	080197c9 	.word	0x080197c9
 8019758:	080197c9 	.word	0x080197c9
 801975c:	080197f7 	.word	0x080197f7
 8019760:	080197f7 	.word	0x080197f7
 8019764:	080197f7 	.word	0x080197f7
 8019768:	080197f7 	.word	0x080197f7
 801976c:	080197f7 	.word	0x080197f7
 8019770:	080197f7 	.word	0x080197f7
 8019774:	080197f7 	.word	0x080197f7
 8019778:	080197f7 	.word	0x080197f7
 801977c:	080197a3 	.word	0x080197a3
 8019780:	08019785 	.word	0x08019785
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8019784:	9b01      	ldr	r3, [sp, #4]
 8019786:	220b      	movs	r2, #11
 8019788:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 801978c:	f7ff fa38 	bl	8018c00 <osalSysLockFromISR.lto_priv.823>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8019790:	2300      	movs	r3, #0
 8019792:	2200      	movs	r2, #0
 8019794:	2100      	movs	r1, #0
 8019796:	9801      	ldr	r0, [sp, #4]
 8019798:	f7ff fd42 	bl	8019220 <usbStartTransmitI>
    osalSysUnlockFromISR();
 801979c:	f7ff fa38 	bl	8018c10 <osalSysUnlockFromISR.lto_priv.821>
 80197a0:	e029      	b.n	80197f6 <_usb_ep0out+0xe6>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80197a2:	9b01      	ldr	r3, [sp, #4]
 80197a4:	68db      	ldr	r3, [r3, #12]
 80197a6:	699b      	ldr	r3, [r3, #24]
 80197a8:	685b      	ldr	r3, [r3, #4]
 80197aa:	2b00      	cmp	r3, #0
 80197ac:	d123      	bne.n	80197f6 <_usb_ep0out+0xe6>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80197ae:	9b01      	ldr	r3, [sp, #4]
 80197b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80197b2:	2b00      	cmp	r3, #0
 80197b4:	d003      	beq.n	80197be <_usb_ep0out+0xae>
      usbp->ep0endcb(usbp);
 80197b6:	9b01      	ldr	r3, [sp, #4]
 80197b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80197ba:	9801      	ldr	r0, [sp, #4]
 80197bc:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 80197be:	9b01      	ldr	r3, [sp, #4]
 80197c0:	2200      	movs	r2, #0
 80197c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 80197c6:	e016      	b.n	80197f6 <_usb_ep0out+0xe6>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80197c8:	2100      	movs	r1, #0
 80197ca:	9801      	ldr	r0, [sp, #4]
 80197cc:	f7fc f9e0 	bl	8015b90 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80197d0:	2100      	movs	r1, #0
 80197d2:	9801      	ldr	r0, [sp, #4]
 80197d4:	f7fc f9bc 	bl	8015b50 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80197d8:	9b01      	ldr	r3, [sp, #4]
 80197da:	685b      	ldr	r3, [r3, #4]
 80197dc:	681b      	ldr	r3, [r3, #0]
 80197de:	2b00      	cmp	r3, #0
 80197e0:	d005      	beq.n	80197ee <_usb_ep0out+0xde>
 80197e2:	9b01      	ldr	r3, [sp, #4]
 80197e4:	685b      	ldr	r3, [r3, #4]
 80197e6:	681b      	ldr	r3, [r3, #0]
 80197e8:	2106      	movs	r1, #6
 80197ea:	9801      	ldr	r0, [sp, #4]
 80197ec:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80197ee:	9b01      	ldr	r3, [sp, #4]
 80197f0:	2206      	movs	r2, #6
 80197f2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 80197f6:	b003      	add	sp, #12
 80197f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80197fc:	0000      	movs	r0, r0
	...

08019800 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8019800:	b082      	sub	sp, #8
 8019802:	9001      	str	r0, [sp, #4]
 8019804:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8019806:	4a12      	ldr	r2, [pc, #72]	; (8019850 <nvicEnableVector+0x50>)
 8019808:	9b00      	ldr	r3, [sp, #0]
 801980a:	b2db      	uxtb	r3, r3
 801980c:	011b      	lsls	r3, r3, #4
 801980e:	b2d9      	uxtb	r1, r3
 8019810:	9b01      	ldr	r3, [sp, #4]
 8019812:	4413      	add	r3, r2
 8019814:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8019818:	460a      	mov	r2, r1
 801981a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 801981c:	490c      	ldr	r1, [pc, #48]	; (8019850 <nvicEnableVector+0x50>)
 801981e:	9b01      	ldr	r3, [sp, #4]
 8019820:	095b      	lsrs	r3, r3, #5
 8019822:	9a01      	ldr	r2, [sp, #4]
 8019824:	f002 021f 	and.w	r2, r2, #31
 8019828:	2001      	movs	r0, #1
 801982a:	fa00 f202 	lsl.w	r2, r0, r2
 801982e:	3360      	adds	r3, #96	; 0x60
 8019830:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8019834:	4906      	ldr	r1, [pc, #24]	; (8019850 <nvicEnableVector+0x50>)
 8019836:	9b01      	ldr	r3, [sp, #4]
 8019838:	095b      	lsrs	r3, r3, #5
 801983a:	9a01      	ldr	r2, [sp, #4]
 801983c:	f002 021f 	and.w	r2, r2, #31
 8019840:	2001      	movs	r0, #1
 8019842:	fa00 f202 	lsl.w	r2, r0, r2
 8019846:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 801984a:	b002      	add	sp, #8
 801984c:	4770      	bx	lr
 801984e:	bf00      	nop
 8019850:	e000e100 	.word	0xe000e100
	...

08019860 <port_lock.lto_priv.813>:
static inline void port_lock(void) {
 8019860:	b082      	sub	sp, #8
 8019862:	2320      	movs	r3, #32
 8019864:	9301      	str	r3, [sp, #4]
 8019866:	9b01      	ldr	r3, [sp, #4]
 8019868:	f383 8811 	msr	BASEPRI, r3
}
 801986c:	b002      	add	sp, #8
 801986e:	4770      	bx	lr

08019870 <port_unlock.lto_priv.809>:
static inline void port_unlock(void) {
 8019870:	b082      	sub	sp, #8
 8019872:	2300      	movs	r3, #0
 8019874:	9301      	str	r3, [sp, #4]
 8019876:	9b01      	ldr	r3, [sp, #4]
 8019878:	f383 8811 	msr	BASEPRI, r3
}
 801987c:	b002      	add	sp, #8
 801987e:	4770      	bx	lr

08019880 <port_lock_from_isr.lto_priv.805>:
static inline void port_lock_from_isr(void) {
 8019880:	b508      	push	{r3, lr}
  port_lock();
 8019882:	f7ff ffed 	bl	8019860 <port_lock.lto_priv.813>
}
 8019886:	bd08      	pop	{r3, pc}
	...

08019890 <port_unlock_from_isr.lto_priv.802>:
static inline void port_unlock_from_isr(void) {
 8019890:	b508      	push	{r3, lr}
  port_unlock();
 8019892:	f7ff ffed 	bl	8019870 <port_unlock.lto_priv.809>
}
 8019896:	bd08      	pop	{r3, pc}
	...

080198a0 <chSysLockFromISR.lto_priv.799>:
static inline void chSysLockFromISR(void) {
 80198a0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 80198a2:	f7ff ffed 	bl	8019880 <port_lock_from_isr.lto_priv.805>
}
 80198a6:	bd08      	pop	{r3, pc}
	...

080198b0 <chSysUnlockFromISR.lto_priv.796>:
static inline void chSysUnlockFromISR(void) {
 80198b0:	b508      	push	{r3, lr}
  port_unlock_from_isr();
 80198b2:	f7ff ffed 	bl	8019890 <port_unlock_from_isr.lto_priv.802>
}
 80198b6:	bd08      	pop	{r3, pc}
	...

080198c0 <osalSysLockFromISR.lto_priv.792>:
static inline void osalSysLockFromISR(void) {
 80198c0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80198c2:	f7ff ffed 	bl	80198a0 <chSysLockFromISR.lto_priv.799>
}
 80198c6:	bd08      	pop	{r3, pc}
	...

080198d0 <osalSysUnlockFromISR.lto_priv.790>:
static inline void osalSysUnlockFromISR(void) {
 80198d0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80198d2:	f7ff ffed 	bl	80198b0 <chSysUnlockFromISR.lto_priv.796>
}
 80198d6:	bd08      	pop	{r3, pc}
	...

080198e0 <osalThreadDequeueAllI.lto_priv.785>:
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80198e0:	b500      	push	{lr}
 80198e2:	b083      	sub	sp, #12
 80198e4:	9001      	str	r0, [sp, #4]
 80198e6:	9100      	str	r1, [sp, #0]
  chThdDequeueAllI(tqp, msg);
 80198e8:	9900      	ldr	r1, [sp, #0]
 80198ea:	9801      	ldr	r0, [sp, #4]
 80198ec:	f7fb f930 	bl	8014b50 <chThdDequeueAllI>
}
 80198f0:	b003      	add	sp, #12
 80198f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80198f6:	bf00      	nop
	...

08019900 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8019900:	4770      	bx	lr
 8019902:	bf00      	nop
	...

08019910 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8019910:	4770      	bx	lr
 8019912:	bf00      	nop
	...

08019920 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8019920:	e7fe      	b.n	8019920 <__default_exit>
 8019922:	bf00      	nop
	...

08019930 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8019930:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8019932:	4b16      	ldr	r3, [pc, #88]	; (801998c <__init_ram_areas+0x5c>)
 8019934:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8019936:	9b03      	ldr	r3, [sp, #12]
 8019938:	681b      	ldr	r3, [r3, #0]
 801993a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 801993c:	9b03      	ldr	r3, [sp, #12]
 801993e:	685b      	ldr	r3, [r3, #4]
 8019940:	9301      	str	r3, [sp, #4]
 8019942:	e009      	b.n	8019958 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8019944:	9b02      	ldr	r3, [sp, #8]
 8019946:	681a      	ldr	r2, [r3, #0]
 8019948:	9b01      	ldr	r3, [sp, #4]
 801994a:	601a      	str	r2, [r3, #0]
      p++;
 801994c:	9b01      	ldr	r3, [sp, #4]
 801994e:	3304      	adds	r3, #4
 8019950:	9301      	str	r3, [sp, #4]
      tp++;
 8019952:	9b02      	ldr	r3, [sp, #8]
 8019954:	3304      	adds	r3, #4
 8019956:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8019958:	9b03      	ldr	r3, [sp, #12]
 801995a:	689a      	ldr	r2, [r3, #8]
 801995c:	9b01      	ldr	r3, [sp, #4]
 801995e:	429a      	cmp	r2, r3
 8019960:	d8f0      	bhi.n	8019944 <__init_ram_areas+0x14>
 8019962:	e005      	b.n	8019970 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8019964:	9b01      	ldr	r3, [sp, #4]
 8019966:	2200      	movs	r2, #0
 8019968:	601a      	str	r2, [r3, #0]
      p++;
 801996a:	9b01      	ldr	r3, [sp, #4]
 801996c:	3304      	adds	r3, #4
 801996e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8019970:	9b03      	ldr	r3, [sp, #12]
 8019972:	68da      	ldr	r2, [r3, #12]
 8019974:	9b01      	ldr	r3, [sp, #4]
 8019976:	429a      	cmp	r2, r3
 8019978:	d8f4      	bhi.n	8019964 <__init_ram_areas+0x34>
    }
    rap++;
 801997a:	9b03      	ldr	r3, [sp, #12]
 801997c:	3310      	adds	r3, #16
 801997e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8019980:	9b03      	ldr	r3, [sp, #12]
 8019982:	4a03      	ldr	r2, [pc, #12]	; (8019990 <__init_ram_areas+0x60>)
 8019984:	4293      	cmp	r3, r2
 8019986:	d3d6      	bcc.n	8019936 <__init_ram_areas+0x6>
#endif
}
 8019988:	b004      	add	sp, #16
 801998a:	4770      	bx	lr
 801998c:	08022f20 	.word	0x08022f20
 8019990:	08022fa0 	.word	0x08022fa0
	...

080199a0 <osalInit>:
}
 80199a0:	4770      	bx	lr
 80199a2:	bf00      	nop
	...

080199b0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80199b0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80199b2:	f7ff fff5 	bl	80199a0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80199b6:	f7fd fdc3 	bl	8017540 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 80199ba:	f7fe fc01 	bl	80181c0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 80199be:	f000 fc4f 	bl	801a260 <canInit>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80199c2:	f7ff f86d 	bl	8018aa0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 80199c6:	f000 ffbb 	bl	801a940 <sdcInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 80199ca:	f7ff fb61 	bl	8019090 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 80199ce:	f7ff f8df 	bl	8018b90 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80199d2:	f7fd f9ed 	bl	8016db0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80199d6:	f000 f823 	bl	8019a20 <stInit>
#endif
}
 80199da:	bd08      	pop	{r3, pc}
 80199dc:	0000      	movs	r0, r0
	...

080199e0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 80199e0:	b082      	sub	sp, #8
 80199e2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80199e4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80199e8:	9b01      	ldr	r3, [sp, #4]
 80199ea:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80199ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80199f0:	2200      	movs	r2, #0
 80199f2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80199f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80199f8:	2202      	movs	r2, #2
 80199fa:	60da      	str	r2, [r3, #12]
}
 80199fc:	b002      	add	sp, #8
 80199fe:	4770      	bx	lr

08019a00 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8019a00:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8019a04:	2200      	movs	r2, #0
 8019a06:	60da      	str	r2, [r3, #12]
}
 8019a08:	4770      	bx	lr
 8019a0a:	bf00      	nop
 8019a0c:	0000      	movs	r0, r0
	...

08019a10 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8019a10:	b082      	sub	sp, #8
 8019a12:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8019a14:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8019a18:	9b01      	ldr	r3, [sp, #4]
 8019a1a:	6353      	str	r3, [r2, #52]	; 0x34
}
 8019a1c:	b002      	add	sp, #8
 8019a1e:	4770      	bx	lr

08019a20 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8019a20:	b508      	push	{r3, lr}

  st_lld_init();
 8019a22:	f7fc fed5 	bl	80167d0 <st_lld_init>
}
 8019a26:	bd08      	pop	{r3, pc}
	...

08019a30 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8019a30:	b500      	push	{lr}
 8019a32:	b083      	sub	sp, #12
 8019a34:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8019a36:	9801      	ldr	r0, [sp, #4]
 8019a38:	f7ff ffd2 	bl	80199e0 <st_lld_start_alarm>
}
 8019a3c:	b003      	add	sp, #12
 8019a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8019a42:	bf00      	nop
	...

08019a50 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8019a50:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8019a52:	f7ff ffd5 	bl	8019a00 <st_lld_stop_alarm>
}
 8019a56:	bd08      	pop	{r3, pc}
	...

08019a60 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8019a60:	b500      	push	{lr}
 8019a62:	b083      	sub	sp, #12
 8019a64:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8019a66:	9801      	ldr	r0, [sp, #4]
 8019a68:	f7ff ffd2 	bl	8019a10 <st_lld_set_alarm>
}
 8019a6c:	b003      	add	sp, #12
 8019a6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8019a72:	bf00      	nop
	...

08019a80 <port_lock.lto_priv.862>:
static inline void port_lock(void) {
 8019a80:	b082      	sub	sp, #8
 8019a82:	2320      	movs	r3, #32
 8019a84:	9301      	str	r3, [sp, #4]
 8019a86:	9b01      	ldr	r3, [sp, #4]
 8019a88:	f383 8811 	msr	BASEPRI, r3
}
 8019a8c:	b002      	add	sp, #8
 8019a8e:	4770      	bx	lr

08019a90 <port_unlock.lto_priv.857>:
static inline void port_unlock(void) {
 8019a90:	b082      	sub	sp, #8
 8019a92:	2300      	movs	r3, #0
 8019a94:	9301      	str	r3, [sp, #4]
 8019a96:	9b01      	ldr	r3, [sp, #4]
 8019a98:	f383 8811 	msr	BASEPRI, r3
}
 8019a9c:	b002      	add	sp, #8
 8019a9e:	4770      	bx	lr

08019aa0 <queue_init.lto_priv.888>:
static inline void queue_init(threads_queue_t *tqp) {
 8019aa0:	b082      	sub	sp, #8
 8019aa2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8019aa4:	9b01      	ldr	r3, [sp, #4]
 8019aa6:	9a01      	ldr	r2, [sp, #4]
 8019aa8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8019aaa:	9b01      	ldr	r3, [sp, #4]
 8019aac:	9a01      	ldr	r2, [sp, #4]
 8019aae:	605a      	str	r2, [r3, #4]
}
 8019ab0:	b002      	add	sp, #8
 8019ab2:	4770      	bx	lr
	...

08019ac0 <chSysLock.lto_priv.852>:
static inline void chSysLock(void) {
 8019ac0:	b508      	push	{r3, lr}
  port_lock();
 8019ac2:	f7ff ffdd 	bl	8019a80 <port_lock.lto_priv.862>
}
 8019ac6:	bd08      	pop	{r3, pc}
	...

08019ad0 <chSysUnlock.lto_priv.847>:
static inline void chSysUnlock(void) {
 8019ad0:	b508      	push	{r3, lr}
  port_unlock();
 8019ad2:	f7ff ffdd 	bl	8019a90 <port_unlock.lto_priv.857>
}
 8019ad6:	bd08      	pop	{r3, pc}
	...

08019ae0 <chThdQueueObjectInit.lto_priv.885>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8019ae0:	b500      	push	{lr}
 8019ae2:	b083      	sub	sp, #12
 8019ae4:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8019ae6:	9801      	ldr	r0, [sp, #4]
 8019ae8:	f7ff ffda 	bl	8019aa0 <queue_init.lto_priv.888>
}
 8019aec:	b003      	add	sp, #12
 8019aee:	f85d fb04 	ldr.w	pc, [sp], #4
 8019af2:	bf00      	nop
	...

08019b00 <osalSysLock.lto_priv.875>:
static inline void osalSysLock(void) {
 8019b00:	b508      	push	{r3, lr}
  chSysLock();
 8019b02:	f7ff ffdd 	bl	8019ac0 <chSysLock.lto_priv.852>
}
 8019b06:	bd08      	pop	{r3, pc}
	...

08019b10 <osalSysUnlock.lto_priv.871>:
static inline void osalSysUnlock(void) {
 8019b10:	b508      	push	{r3, lr}
  chSysUnlock();
 8019b12:	f7ff ffdd 	bl	8019ad0 <chSysUnlock.lto_priv.847>
}
 8019b16:	bd08      	pop	{r3, pc}
	...

08019b20 <osalThreadQueueObjectInit.lto_priv.882>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8019b20:	b500      	push	{lr}
 8019b22:	b083      	sub	sp, #12
 8019b24:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 8019b26:	9801      	ldr	r0, [sp, #4]
 8019b28:	f7ff ffda 	bl	8019ae0 <chThdQueueObjectInit.lto_priv.885>
}
 8019b2c:	b003      	add	sp, #12
 8019b2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8019b32:	bf00      	nop
	...

08019b40 <osalThreadEnqueueTimeoutS.lto_priv.867>:
                                              sysinterval_t timeout) {
 8019b40:	b500      	push	{lr}
 8019b42:	b083      	sub	sp, #12
 8019b44:	9001      	str	r0, [sp, #4]
 8019b46:	9100      	str	r1, [sp, #0]
  return chThdEnqueueTimeoutS(tqp, timeout);
 8019b48:	9900      	ldr	r1, [sp, #0]
 8019b4a:	9801      	ldr	r0, [sp, #4]
 8019b4c:	f7fa ffc8 	bl	8014ae0 <chThdEnqueueTimeoutS>
 8019b50:	4603      	mov	r3, r0
}
 8019b52:	4618      	mov	r0, r3
 8019b54:	b003      	add	sp, #12
 8019b56:	f85d fb04 	ldr.w	pc, [sp], #4
 8019b5a:	bf00      	nop
 8019b5c:	0000      	movs	r0, r0
	...

08019b60 <osalThreadDequeueNextI.lto_priv.891>:
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8019b60:	b500      	push	{lr}
 8019b62:	b083      	sub	sp, #12
 8019b64:	9001      	str	r0, [sp, #4]
 8019b66:	9100      	str	r1, [sp, #0]
  chThdDequeueNextI(tqp, msg);
 8019b68:	9900      	ldr	r1, [sp, #0]
 8019b6a:	9801      	ldr	r0, [sp, #4]
 8019b6c:	f7fa ffd8 	bl	8014b20 <chThdDequeueNextI>
}
 8019b70:	b003      	add	sp, #12
 8019b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8019b76:	bf00      	nop
	...

08019b80 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8019b80:	b500      	push	{lr}
 8019b82:	b087      	sub	sp, #28
 8019b84:	9003      	str	r0, [sp, #12]
 8019b86:	9102      	str	r1, [sp, #8]
 8019b88:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8019b8a:	9b03      	ldr	r3, [sp, #12]
 8019b8c:	689a      	ldr	r2, [r3, #8]
 8019b8e:	9b01      	ldr	r3, [sp, #4]
 8019b90:	429a      	cmp	r2, r3
 8019b92:	d202      	bcs.n	8019b9a <iq_read+0x1a>
    n = iqGetFullI(iqp);
 8019b94:	9b03      	ldr	r3, [sp, #12]
 8019b96:	689b      	ldr	r3, [r3, #8]
 8019b98:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8019b9a:	9b03      	ldr	r3, [sp, #12]
 8019b9c:	691b      	ldr	r3, [r3, #16]
 8019b9e:	461a      	mov	r2, r3
 8019ba0:	9b03      	ldr	r3, [sp, #12]
 8019ba2:	699b      	ldr	r3, [r3, #24]
 8019ba4:	1ad3      	subs	r3, r2, r3
 8019ba6:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8019ba8:	9a01      	ldr	r2, [sp, #4]
 8019baa:	9b05      	ldr	r3, [sp, #20]
 8019bac:	429a      	cmp	r2, r3
 8019bae:	d20d      	bcs.n	8019bcc <iq_read+0x4c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8019bb0:	9b03      	ldr	r3, [sp, #12]
 8019bb2:	699b      	ldr	r3, [r3, #24]
 8019bb4:	9a01      	ldr	r2, [sp, #4]
 8019bb6:	4619      	mov	r1, r3
 8019bb8:	9802      	ldr	r0, [sp, #8]
 8019bba:	f7ea fdaf 	bl	800471c <memcpy>
    iqp->q_rdptr += n;
 8019bbe:	9b03      	ldr	r3, [sp, #12]
 8019bc0:	699a      	ldr	r2, [r3, #24]
 8019bc2:	9b01      	ldr	r3, [sp, #4]
 8019bc4:	441a      	add	r2, r3
 8019bc6:	9b03      	ldr	r3, [sp, #12]
 8019bc8:	619a      	str	r2, [r3, #24]
 8019bca:	e02b      	b.n	8019c24 <iq_read+0xa4>
  }
  else if (n > s1) {
 8019bcc:	9a01      	ldr	r2, [sp, #4]
 8019bce:	9b05      	ldr	r3, [sp, #20]
 8019bd0:	429a      	cmp	r2, r3
 8019bd2:	d91c      	bls.n	8019c0e <iq_read+0x8e>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8019bd4:	9b03      	ldr	r3, [sp, #12]
 8019bd6:	699b      	ldr	r3, [r3, #24]
 8019bd8:	9a05      	ldr	r2, [sp, #20]
 8019bda:	4619      	mov	r1, r3
 8019bdc:	9802      	ldr	r0, [sp, #8]
 8019bde:	f7ea fd9d 	bl	800471c <memcpy>
    bp += s1;
 8019be2:	9a02      	ldr	r2, [sp, #8]
 8019be4:	9b05      	ldr	r3, [sp, #20]
 8019be6:	4413      	add	r3, r2
 8019be8:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8019bea:	9a01      	ldr	r2, [sp, #4]
 8019bec:	9b05      	ldr	r3, [sp, #20]
 8019bee:	1ad3      	subs	r3, r2, r3
 8019bf0:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8019bf2:	9b03      	ldr	r3, [sp, #12]
 8019bf4:	68db      	ldr	r3, [r3, #12]
 8019bf6:	9a04      	ldr	r2, [sp, #16]
 8019bf8:	4619      	mov	r1, r3
 8019bfa:	9802      	ldr	r0, [sp, #8]
 8019bfc:	f7ea fd8e 	bl	800471c <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8019c00:	9b03      	ldr	r3, [sp, #12]
 8019c02:	68da      	ldr	r2, [r3, #12]
 8019c04:	9b04      	ldr	r3, [sp, #16]
 8019c06:	441a      	add	r2, r3
 8019c08:	9b03      	ldr	r3, [sp, #12]
 8019c0a:	619a      	str	r2, [r3, #24]
 8019c0c:	e00a      	b.n	8019c24 <iq_read+0xa4>
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8019c0e:	9b03      	ldr	r3, [sp, #12]
 8019c10:	699b      	ldr	r3, [r3, #24]
 8019c12:	9a01      	ldr	r2, [sp, #4]
 8019c14:	4619      	mov	r1, r3
 8019c16:	9802      	ldr	r0, [sp, #8]
 8019c18:	f7ea fd80 	bl	800471c <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8019c1c:	9b03      	ldr	r3, [sp, #12]
 8019c1e:	68da      	ldr	r2, [r3, #12]
 8019c20:	9b03      	ldr	r3, [sp, #12]
 8019c22:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
 8019c24:	9b03      	ldr	r3, [sp, #12]
 8019c26:	689a      	ldr	r2, [r3, #8]
 8019c28:	9b01      	ldr	r3, [sp, #4]
 8019c2a:	1ad2      	subs	r2, r2, r3
 8019c2c:	9b03      	ldr	r3, [sp, #12]
 8019c2e:	609a      	str	r2, [r3, #8]
  return n;
 8019c30:	9b01      	ldr	r3, [sp, #4]
}
 8019c32:	4618      	mov	r0, r3
 8019c34:	b007      	add	sp, #28
 8019c36:	f85d fb04 	ldr.w	pc, [sp], #4
 8019c3a:	bf00      	nop
 8019c3c:	0000      	movs	r0, r0
	...

08019c40 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8019c40:	b500      	push	{lr}
 8019c42:	b087      	sub	sp, #28
 8019c44:	9003      	str	r0, [sp, #12]
 8019c46:	9102      	str	r1, [sp, #8]
 8019c48:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8019c4a:	9b03      	ldr	r3, [sp, #12]
 8019c4c:	689a      	ldr	r2, [r3, #8]
 8019c4e:	9b01      	ldr	r3, [sp, #4]
 8019c50:	429a      	cmp	r2, r3
 8019c52:	d202      	bcs.n	8019c5a <oq_write+0x1a>
    n = oqGetEmptyI(oqp);
 8019c54:	9b03      	ldr	r3, [sp, #12]
 8019c56:	689b      	ldr	r3, [r3, #8]
 8019c58:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8019c5a:	9b03      	ldr	r3, [sp, #12]
 8019c5c:	691b      	ldr	r3, [r3, #16]
 8019c5e:	461a      	mov	r2, r3
 8019c60:	9b03      	ldr	r3, [sp, #12]
 8019c62:	695b      	ldr	r3, [r3, #20]
 8019c64:	1ad3      	subs	r3, r2, r3
 8019c66:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8019c68:	9a01      	ldr	r2, [sp, #4]
 8019c6a:	9b05      	ldr	r3, [sp, #20]
 8019c6c:	429a      	cmp	r2, r3
 8019c6e:	d20d      	bcs.n	8019c8c <oq_write+0x4c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8019c70:	9b03      	ldr	r3, [sp, #12]
 8019c72:	695b      	ldr	r3, [r3, #20]
 8019c74:	9a01      	ldr	r2, [sp, #4]
 8019c76:	9902      	ldr	r1, [sp, #8]
 8019c78:	4618      	mov	r0, r3
 8019c7a:	f7ea fd4f 	bl	800471c <memcpy>
    oqp->q_wrptr += n;
 8019c7e:	9b03      	ldr	r3, [sp, #12]
 8019c80:	695a      	ldr	r2, [r3, #20]
 8019c82:	9b01      	ldr	r3, [sp, #4]
 8019c84:	441a      	add	r2, r3
 8019c86:	9b03      	ldr	r3, [sp, #12]
 8019c88:	615a      	str	r2, [r3, #20]
 8019c8a:	e02b      	b.n	8019ce4 <oq_write+0xa4>
  }
  else if (n > s1) {
 8019c8c:	9a01      	ldr	r2, [sp, #4]
 8019c8e:	9b05      	ldr	r3, [sp, #20]
 8019c90:	429a      	cmp	r2, r3
 8019c92:	d91c      	bls.n	8019cce <oq_write+0x8e>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8019c94:	9b03      	ldr	r3, [sp, #12]
 8019c96:	695b      	ldr	r3, [r3, #20]
 8019c98:	9a05      	ldr	r2, [sp, #20]
 8019c9a:	9902      	ldr	r1, [sp, #8]
 8019c9c:	4618      	mov	r0, r3
 8019c9e:	f7ea fd3d 	bl	800471c <memcpy>
    bp += s1;
 8019ca2:	9a02      	ldr	r2, [sp, #8]
 8019ca4:	9b05      	ldr	r3, [sp, #20]
 8019ca6:	4413      	add	r3, r2
 8019ca8:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8019caa:	9a01      	ldr	r2, [sp, #4]
 8019cac:	9b05      	ldr	r3, [sp, #20]
 8019cae:	1ad3      	subs	r3, r2, r3
 8019cb0:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8019cb2:	9b03      	ldr	r3, [sp, #12]
 8019cb4:	68db      	ldr	r3, [r3, #12]
 8019cb6:	9a04      	ldr	r2, [sp, #16]
 8019cb8:	9902      	ldr	r1, [sp, #8]
 8019cba:	4618      	mov	r0, r3
 8019cbc:	f7ea fd2e 	bl	800471c <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8019cc0:	9b03      	ldr	r3, [sp, #12]
 8019cc2:	68da      	ldr	r2, [r3, #12]
 8019cc4:	9b04      	ldr	r3, [sp, #16]
 8019cc6:	441a      	add	r2, r3
 8019cc8:	9b03      	ldr	r3, [sp, #12]
 8019cca:	615a      	str	r2, [r3, #20]
 8019ccc:	e00a      	b.n	8019ce4 <oq_write+0xa4>
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8019cce:	9b03      	ldr	r3, [sp, #12]
 8019cd0:	695b      	ldr	r3, [r3, #20]
 8019cd2:	9a01      	ldr	r2, [sp, #4]
 8019cd4:	9902      	ldr	r1, [sp, #8]
 8019cd6:	4618      	mov	r0, r3
 8019cd8:	f7ea fd20 	bl	800471c <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8019cdc:	9b03      	ldr	r3, [sp, #12]
 8019cde:	68da      	ldr	r2, [r3, #12]
 8019ce0:	9b03      	ldr	r3, [sp, #12]
 8019ce2:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
 8019ce4:	9b03      	ldr	r3, [sp, #12]
 8019ce6:	689a      	ldr	r2, [r3, #8]
 8019ce8:	9b01      	ldr	r3, [sp, #4]
 8019cea:	1ad2      	subs	r2, r2, r3
 8019cec:	9b03      	ldr	r3, [sp, #12]
 8019cee:	609a      	str	r2, [r3, #8]
  return n;
 8019cf0:	9b01      	ldr	r3, [sp, #4]
}
 8019cf2:	4618      	mov	r0, r3
 8019cf4:	b007      	add	sp, #28
 8019cf6:	f85d fb04 	ldr.w	pc, [sp], #4
 8019cfa:	bf00      	nop
 8019cfc:	0000      	movs	r0, r0
	...

08019d00 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8019d00:	b500      	push	{lr}
 8019d02:	b085      	sub	sp, #20
 8019d04:	9003      	str	r0, [sp, #12]
 8019d06:	9102      	str	r1, [sp, #8]
 8019d08:	9201      	str	r2, [sp, #4]
 8019d0a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8019d0c:	9b03      	ldr	r3, [sp, #12]
 8019d0e:	4618      	mov	r0, r3
 8019d10:	f7ff ff06 	bl	8019b20 <osalThreadQueueObjectInit.lto_priv.882>
  iqp->q_counter = 0;
 8019d14:	9b03      	ldr	r3, [sp, #12]
 8019d16:	2200      	movs	r2, #0
 8019d18:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8019d1a:	9b03      	ldr	r3, [sp, #12]
 8019d1c:	9a02      	ldr	r2, [sp, #8]
 8019d1e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8019d20:	9b03      	ldr	r3, [sp, #12]
 8019d22:	9a02      	ldr	r2, [sp, #8]
 8019d24:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8019d26:	9b03      	ldr	r3, [sp, #12]
 8019d28:	9a02      	ldr	r2, [sp, #8]
 8019d2a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8019d2c:	9a02      	ldr	r2, [sp, #8]
 8019d2e:	9b01      	ldr	r3, [sp, #4]
 8019d30:	441a      	add	r2, r3
 8019d32:	9b03      	ldr	r3, [sp, #12]
 8019d34:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8019d36:	9b03      	ldr	r3, [sp, #12]
 8019d38:	9a00      	ldr	r2, [sp, #0]
 8019d3a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8019d3c:	9b03      	ldr	r3, [sp, #12]
 8019d3e:	9a06      	ldr	r2, [sp, #24]
 8019d40:	621a      	str	r2, [r3, #32]
}
 8019d42:	b005      	add	sp, #20
 8019d44:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019d50 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8019d50:	b500      	push	{lr}
 8019d52:	b083      	sub	sp, #12
 8019d54:	9001      	str	r0, [sp, #4]
 8019d56:	460b      	mov	r3, r1
 8019d58:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8019d5c:	9b01      	ldr	r3, [sp, #4]
 8019d5e:	695a      	ldr	r2, [r3, #20]
 8019d60:	9b01      	ldr	r3, [sp, #4]
 8019d62:	699b      	ldr	r3, [r3, #24]
 8019d64:	429a      	cmp	r2, r3
 8019d66:	d105      	bne.n	8019d74 <iqPutI+0x24>
 8019d68:	9b01      	ldr	r3, [sp, #4]
 8019d6a:	689b      	ldr	r3, [r3, #8]
 8019d6c:	2b00      	cmp	r3, #0
 8019d6e:	d001      	beq.n	8019d74 <iqPutI+0x24>
 8019d70:	2301      	movs	r3, #1
 8019d72:	e000      	b.n	8019d76 <iqPutI+0x26>
 8019d74:	2300      	movs	r3, #0
 8019d76:	f003 0301 	and.w	r3, r3, #1
 8019d7a:	b2db      	uxtb	r3, r3
 8019d7c:	f083 0301 	eor.w	r3, r3, #1
 8019d80:	b2db      	uxtb	r3, r3
 8019d82:	2b00      	cmp	r3, #0
 8019d84:	d01d      	beq.n	8019dc2 <iqPutI+0x72>
    iqp->q_counter++;
 8019d86:	9b01      	ldr	r3, [sp, #4]
 8019d88:	689b      	ldr	r3, [r3, #8]
 8019d8a:	1c5a      	adds	r2, r3, #1
 8019d8c:	9b01      	ldr	r3, [sp, #4]
 8019d8e:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
 8019d90:	9b01      	ldr	r3, [sp, #4]
 8019d92:	695b      	ldr	r3, [r3, #20]
 8019d94:	1c59      	adds	r1, r3, #1
 8019d96:	9a01      	ldr	r2, [sp, #4]
 8019d98:	6151      	str	r1, [r2, #20]
 8019d9a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8019d9e:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8019da0:	9b01      	ldr	r3, [sp, #4]
 8019da2:	695a      	ldr	r2, [r3, #20]
 8019da4:	9b01      	ldr	r3, [sp, #4]
 8019da6:	691b      	ldr	r3, [r3, #16]
 8019da8:	429a      	cmp	r2, r3
 8019daa:	d303      	bcc.n	8019db4 <iqPutI+0x64>
      iqp->q_wrptr = iqp->q_buffer;
 8019dac:	9b01      	ldr	r3, [sp, #4]
 8019dae:	68da      	ldr	r2, [r3, #12]
 8019db0:	9b01      	ldr	r3, [sp, #4]
 8019db2:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8019db4:	9b01      	ldr	r3, [sp, #4]
 8019db6:	2100      	movs	r1, #0
 8019db8:	4618      	mov	r0, r3
 8019dba:	f7ff fed1 	bl	8019b60 <osalThreadDequeueNextI.lto_priv.891>

    return MSG_OK;
 8019dbe:	2300      	movs	r3, #0
 8019dc0:	e001      	b.n	8019dc6 <iqPutI+0x76>
  }

  return MSG_TIMEOUT;
 8019dc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8019dc6:	4618      	mov	r0, r3
 8019dc8:	b003      	add	sp, #12
 8019dca:	f85d fb04 	ldr.w	pc, [sp], #4
 8019dce:	bf00      	nop

08019dd0 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8019dd0:	b500      	push	{lr}
 8019dd2:	b085      	sub	sp, #20
 8019dd4:	9001      	str	r0, [sp, #4]
 8019dd6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8019dd8:	f7ff fe92 	bl	8019b00 <osalSysLock.lto_priv.875>
 8019ddc:	e00c      	b.n	8019df8 <iqGetTimeout+0x28>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8019dde:	9b01      	ldr	r3, [sp, #4]
 8019de0:	9900      	ldr	r1, [sp, #0]
 8019de2:	4618      	mov	r0, r3
 8019de4:	f7ff feac 	bl	8019b40 <osalThreadEnqueueTimeoutS.lto_priv.867>
 8019de8:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8019dea:	9b03      	ldr	r3, [sp, #12]
 8019dec:	2b00      	cmp	r3, #0
 8019dee:	da03      	bge.n	8019df8 <iqGetTimeout+0x28>
      osalSysUnlock();
 8019df0:	f7ff fe8e 	bl	8019b10 <osalSysUnlock.lto_priv.871>
      return msg;
 8019df4:	9b03      	ldr	r3, [sp, #12]
 8019df6:	e026      	b.n	8019e46 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
 8019df8:	9b01      	ldr	r3, [sp, #4]
 8019dfa:	689b      	ldr	r3, [r3, #8]
 8019dfc:	2b00      	cmp	r3, #0
 8019dfe:	d0ee      	beq.n	8019dde <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8019e00:	9b01      	ldr	r3, [sp, #4]
 8019e02:	689b      	ldr	r3, [r3, #8]
 8019e04:	1e5a      	subs	r2, r3, #1
 8019e06:	9b01      	ldr	r3, [sp, #4]
 8019e08:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8019e0a:	9b01      	ldr	r3, [sp, #4]
 8019e0c:	699b      	ldr	r3, [r3, #24]
 8019e0e:	1c59      	adds	r1, r3, #1
 8019e10:	9a01      	ldr	r2, [sp, #4]
 8019e12:	6191      	str	r1, [r2, #24]
 8019e14:	781b      	ldrb	r3, [r3, #0]
 8019e16:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 8019e1a:	9b01      	ldr	r3, [sp, #4]
 8019e1c:	699a      	ldr	r2, [r3, #24]
 8019e1e:	9b01      	ldr	r3, [sp, #4]
 8019e20:	691b      	ldr	r3, [r3, #16]
 8019e22:	429a      	cmp	r2, r3
 8019e24:	d303      	bcc.n	8019e2e <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 8019e26:	9b01      	ldr	r3, [sp, #4]
 8019e28:	68da      	ldr	r2, [r3, #12]
 8019e2a:	9b01      	ldr	r3, [sp, #4]
 8019e2c:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8019e2e:	9b01      	ldr	r3, [sp, #4]
 8019e30:	69db      	ldr	r3, [r3, #28]
 8019e32:	2b00      	cmp	r3, #0
 8019e34:	d003      	beq.n	8019e3e <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 8019e36:	9b01      	ldr	r3, [sp, #4]
 8019e38:	69db      	ldr	r3, [r3, #28]
 8019e3a:	9801      	ldr	r0, [sp, #4]
 8019e3c:	4798      	blx	r3
  }

  osalSysUnlock();
 8019e3e:	f7ff fe67 	bl	8019b10 <osalSysUnlock.lto_priv.871>

  return (msg_t)b;
 8019e42:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8019e46:	4618      	mov	r0, r3
 8019e48:	b005      	add	sp, #20
 8019e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8019e4e:	bf00      	nop

08019e50 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8019e50:	b500      	push	{lr}
 8019e52:	b089      	sub	sp, #36	; 0x24
 8019e54:	9003      	str	r0, [sp, #12]
 8019e56:	9102      	str	r1, [sp, #8]
 8019e58:	9201      	str	r2, [sp, #4]
 8019e5a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 8019e5c:	9b03      	ldr	r3, [sp, #12]
 8019e5e:	69db      	ldr	r3, [r3, #28]
 8019e60:	9306      	str	r3, [sp, #24]
  size_t rd = 0;
 8019e62:	2300      	movs	r3, #0
 8019e64:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);

  osalSysLock();
 8019e66:	f7ff fe4b 	bl	8019b00 <osalSysLock.lto_priv.875>
 8019e6a:	e024      	b.n	8019eb6 <iqReadTimeout+0x66>

  while (rd < n) {
    size_t done;

    done = iq_read(iqp, bp, n);
 8019e6c:	9a01      	ldr	r2, [sp, #4]
 8019e6e:	9902      	ldr	r1, [sp, #8]
 8019e70:	9803      	ldr	r0, [sp, #12]
 8019e72:	f7ff fe85 	bl	8019b80 <iq_read>
 8019e76:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8019e78:	9b05      	ldr	r3, [sp, #20]
 8019e7a:	2b00      	cmp	r3, #0
 8019e7c:	d109      	bne.n	8019e92 <iqReadTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8019e7e:	9b03      	ldr	r3, [sp, #12]
 8019e80:	9900      	ldr	r1, [sp, #0]
 8019e82:	4618      	mov	r0, r3
 8019e84:	f7ff fe5c 	bl	8019b40 <osalThreadEnqueueTimeoutS.lto_priv.867>
 8019e88:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8019e8a:	9b04      	ldr	r3, [sp, #16]
 8019e8c:	2b00      	cmp	r3, #0
 8019e8e:	d116      	bne.n	8019ebe <iqReadTimeout+0x6e>
 8019e90:	e011      	b.n	8019eb6 <iqReadTimeout+0x66>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 8019e92:	9b06      	ldr	r3, [sp, #24]
 8019e94:	2b00      	cmp	r3, #0
 8019e96:	d002      	beq.n	8019e9e <iqReadTimeout+0x4e>
        nfy(iqp);
 8019e98:	9b06      	ldr	r3, [sp, #24]
 8019e9a:	9803      	ldr	r0, [sp, #12]
 8019e9c:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8019e9e:	f7ff fe37 	bl	8019b10 <osalSysUnlock.lto_priv.871>

      rd += done;
 8019ea2:	9a07      	ldr	r2, [sp, #28]
 8019ea4:	9b05      	ldr	r3, [sp, #20]
 8019ea6:	4413      	add	r3, r2
 8019ea8:	9307      	str	r3, [sp, #28]
      bp += done;
 8019eaa:	9a02      	ldr	r2, [sp, #8]
 8019eac:	9b05      	ldr	r3, [sp, #20]
 8019eae:	4413      	add	r3, r2
 8019eb0:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8019eb2:	f7ff fe25 	bl	8019b00 <osalSysLock.lto_priv.875>
  while (rd < n) {
 8019eb6:	9a07      	ldr	r2, [sp, #28]
 8019eb8:	9b01      	ldr	r3, [sp, #4]
 8019eba:	429a      	cmp	r2, r3
 8019ebc:	d3d6      	bcc.n	8019e6c <iqReadTimeout+0x1c>
    }
  }

  osalSysUnlock();
 8019ebe:	f7ff fe27 	bl	8019b10 <osalSysUnlock.lto_priv.871>
  return rd;
 8019ec2:	9b07      	ldr	r3, [sp, #28]
}
 8019ec4:	4618      	mov	r0, r3
 8019ec6:	b009      	add	sp, #36	; 0x24
 8019ec8:	f85d fb04 	ldr.w	pc, [sp], #4
 8019ecc:	0000      	movs	r0, r0
	...

08019ed0 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8019ed0:	b500      	push	{lr}
 8019ed2:	b085      	sub	sp, #20
 8019ed4:	9003      	str	r0, [sp, #12]
 8019ed6:	9102      	str	r1, [sp, #8]
 8019ed8:	9201      	str	r2, [sp, #4]
 8019eda:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8019edc:	9b03      	ldr	r3, [sp, #12]
 8019ede:	4618      	mov	r0, r3
 8019ee0:	f7ff fe1e 	bl	8019b20 <osalThreadQueueObjectInit.lto_priv.882>
  oqp->q_counter = size;
 8019ee4:	9b03      	ldr	r3, [sp, #12]
 8019ee6:	9a01      	ldr	r2, [sp, #4]
 8019ee8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8019eea:	9b03      	ldr	r3, [sp, #12]
 8019eec:	9a02      	ldr	r2, [sp, #8]
 8019eee:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8019ef0:	9b03      	ldr	r3, [sp, #12]
 8019ef2:	9a02      	ldr	r2, [sp, #8]
 8019ef4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8019ef6:	9b03      	ldr	r3, [sp, #12]
 8019ef8:	9a02      	ldr	r2, [sp, #8]
 8019efa:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8019efc:	9a02      	ldr	r2, [sp, #8]
 8019efe:	9b01      	ldr	r3, [sp, #4]
 8019f00:	441a      	add	r2, r3
 8019f02:	9b03      	ldr	r3, [sp, #12]
 8019f04:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8019f06:	9b03      	ldr	r3, [sp, #12]
 8019f08:	9a00      	ldr	r2, [sp, #0]
 8019f0a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8019f0c:	9b03      	ldr	r3, [sp, #12]
 8019f0e:	9a06      	ldr	r2, [sp, #24]
 8019f10:	621a      	str	r2, [r3, #32]
}
 8019f12:	b005      	add	sp, #20
 8019f14:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019f20 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8019f20:	b500      	push	{lr}
 8019f22:	b087      	sub	sp, #28
 8019f24:	9003      	str	r0, [sp, #12]
 8019f26:	460b      	mov	r3, r1
 8019f28:	9201      	str	r2, [sp, #4]
 8019f2a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 8019f2e:	f7ff fde7 	bl	8019b00 <osalSysLock.lto_priv.875>
 8019f32:	e00c      	b.n	8019f4e <oqPutTimeout+0x2e>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8019f34:	9b03      	ldr	r3, [sp, #12]
 8019f36:	9901      	ldr	r1, [sp, #4]
 8019f38:	4618      	mov	r0, r3
 8019f3a:	f7ff fe01 	bl	8019b40 <osalThreadEnqueueTimeoutS.lto_priv.867>
 8019f3e:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 8019f40:	9b05      	ldr	r3, [sp, #20]
 8019f42:	2b00      	cmp	r3, #0
 8019f44:	da03      	bge.n	8019f4e <oqPutTimeout+0x2e>
      osalSysUnlock();
 8019f46:	f7ff fde3 	bl	8019b10 <osalSysUnlock.lto_priv.871>
      return msg;
 8019f4a:	9b05      	ldr	r3, [sp, #20]
 8019f4c:	e025      	b.n	8019f9a <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
 8019f4e:	9b03      	ldr	r3, [sp, #12]
 8019f50:	689b      	ldr	r3, [r3, #8]
 8019f52:	2b00      	cmp	r3, #0
 8019f54:	d0ee      	beq.n	8019f34 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8019f56:	9b03      	ldr	r3, [sp, #12]
 8019f58:	689b      	ldr	r3, [r3, #8]
 8019f5a:	1e5a      	subs	r2, r3, #1
 8019f5c:	9b03      	ldr	r3, [sp, #12]
 8019f5e:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8019f60:	9b03      	ldr	r3, [sp, #12]
 8019f62:	695b      	ldr	r3, [r3, #20]
 8019f64:	1c59      	adds	r1, r3, #1
 8019f66:	9a03      	ldr	r2, [sp, #12]
 8019f68:	6151      	str	r1, [r2, #20]
 8019f6a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8019f6e:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8019f70:	9b03      	ldr	r3, [sp, #12]
 8019f72:	695a      	ldr	r2, [r3, #20]
 8019f74:	9b03      	ldr	r3, [sp, #12]
 8019f76:	691b      	ldr	r3, [r3, #16]
 8019f78:	429a      	cmp	r2, r3
 8019f7a:	d303      	bcc.n	8019f84 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 8019f7c:	9b03      	ldr	r3, [sp, #12]
 8019f7e:	68da      	ldr	r2, [r3, #12]
 8019f80:	9b03      	ldr	r3, [sp, #12]
 8019f82:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8019f84:	9b03      	ldr	r3, [sp, #12]
 8019f86:	69db      	ldr	r3, [r3, #28]
 8019f88:	2b00      	cmp	r3, #0
 8019f8a:	d003      	beq.n	8019f94 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 8019f8c:	9b03      	ldr	r3, [sp, #12]
 8019f8e:	69db      	ldr	r3, [r3, #28]
 8019f90:	9803      	ldr	r0, [sp, #12]
 8019f92:	4798      	blx	r3
  }

  osalSysUnlock();
 8019f94:	f7ff fdbc 	bl	8019b10 <osalSysUnlock.lto_priv.871>

  return MSG_OK;
 8019f98:	2300      	movs	r3, #0
}
 8019f9a:	4618      	mov	r0, r3
 8019f9c:	b007      	add	sp, #28
 8019f9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8019fa2:	bf00      	nop
	...

08019fb0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8019fb0:	b500      	push	{lr}
 8019fb2:	b085      	sub	sp, #20
 8019fb4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8019fb6:	9b01      	ldr	r3, [sp, #4]
 8019fb8:	695a      	ldr	r2, [r3, #20]
 8019fba:	9b01      	ldr	r3, [sp, #4]
 8019fbc:	699b      	ldr	r3, [r3, #24]
 8019fbe:	429a      	cmp	r2, r3
 8019fc0:	d105      	bne.n	8019fce <oqGetI+0x1e>
 8019fc2:	9b01      	ldr	r3, [sp, #4]
 8019fc4:	689b      	ldr	r3, [r3, #8]
 8019fc6:	2b00      	cmp	r3, #0
 8019fc8:	d001      	beq.n	8019fce <oqGetI+0x1e>
 8019fca:	2301      	movs	r3, #1
 8019fcc:	e000      	b.n	8019fd0 <oqGetI+0x20>
 8019fce:	2300      	movs	r3, #0
 8019fd0:	f003 0301 	and.w	r3, r3, #1
 8019fd4:	b2db      	uxtb	r3, r3
 8019fd6:	f083 0301 	eor.w	r3, r3, #1
 8019fda:	b2db      	uxtb	r3, r3
 8019fdc:	2b00      	cmp	r3, #0
 8019fde:	d01e      	beq.n	801a01e <oqGetI+0x6e>
    uint8_t b;

    oqp->q_counter++;
 8019fe0:	9b01      	ldr	r3, [sp, #4]
 8019fe2:	689b      	ldr	r3, [r3, #8]
 8019fe4:	1c5a      	adds	r2, r3, #1
 8019fe6:	9b01      	ldr	r3, [sp, #4]
 8019fe8:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
 8019fea:	9b01      	ldr	r3, [sp, #4]
 8019fec:	699b      	ldr	r3, [r3, #24]
 8019fee:	1c59      	adds	r1, r3, #1
 8019ff0:	9a01      	ldr	r2, [sp, #4]
 8019ff2:	6191      	str	r1, [r2, #24]
 8019ff4:	781b      	ldrb	r3, [r3, #0]
 8019ff6:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
 8019ffa:	9b01      	ldr	r3, [sp, #4]
 8019ffc:	699a      	ldr	r2, [r3, #24]
 8019ffe:	9b01      	ldr	r3, [sp, #4]
 801a000:	691b      	ldr	r3, [r3, #16]
 801a002:	429a      	cmp	r2, r3
 801a004:	d303      	bcc.n	801a00e <oqGetI+0x5e>
      oqp->q_rdptr = oqp->q_buffer;
 801a006:	9b01      	ldr	r3, [sp, #4]
 801a008:	68da      	ldr	r2, [r3, #12]
 801a00a:	9b01      	ldr	r3, [sp, #4]
 801a00c:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 801a00e:	9b01      	ldr	r3, [sp, #4]
 801a010:	2100      	movs	r1, #0
 801a012:	4618      	mov	r0, r3
 801a014:	f7ff fda4 	bl	8019b60 <osalThreadDequeueNextI.lto_priv.891>

    return (msg_t)b;
 801a018:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801a01c:	e001      	b.n	801a022 <oqGetI+0x72>
  }

  return MSG_TIMEOUT;
 801a01e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 801a022:	4618      	mov	r0, r3
 801a024:	b005      	add	sp, #20
 801a026:	f85d fb04 	ldr.w	pc, [sp], #4
 801a02a:	bf00      	nop
 801a02c:	0000      	movs	r0, r0
	...

0801a030 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 801a030:	b500      	push	{lr}
 801a032:	b089      	sub	sp, #36	; 0x24
 801a034:	9003      	str	r0, [sp, #12]
 801a036:	9102      	str	r1, [sp, #8]
 801a038:	9201      	str	r2, [sp, #4]
 801a03a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 801a03c:	9b03      	ldr	r3, [sp, #12]
 801a03e:	69db      	ldr	r3, [r3, #28]
 801a040:	9306      	str	r3, [sp, #24]
  size_t wr = 0;
 801a042:	2300      	movs	r3, #0
 801a044:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);

  osalSysLock();
 801a046:	f7ff fd5b 	bl	8019b00 <osalSysLock.lto_priv.875>
 801a04a:	e024      	b.n	801a096 <oqWriteTimeout+0x66>

  while (wr < n) {
    size_t done;

    done = oq_write(oqp, bp, n);
 801a04c:	9a01      	ldr	r2, [sp, #4]
 801a04e:	9902      	ldr	r1, [sp, #8]
 801a050:	9803      	ldr	r0, [sp, #12]
 801a052:	f7ff fdf5 	bl	8019c40 <oq_write>
 801a056:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 801a058:	9b05      	ldr	r3, [sp, #20]
 801a05a:	2b00      	cmp	r3, #0
 801a05c:	d109      	bne.n	801a072 <oqWriteTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 801a05e:	9b03      	ldr	r3, [sp, #12]
 801a060:	9900      	ldr	r1, [sp, #0]
 801a062:	4618      	mov	r0, r3
 801a064:	f7ff fd6c 	bl	8019b40 <osalThreadEnqueueTimeoutS.lto_priv.867>
 801a068:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 801a06a:	9b04      	ldr	r3, [sp, #16]
 801a06c:	2b00      	cmp	r3, #0
 801a06e:	d116      	bne.n	801a09e <oqWriteTimeout+0x6e>
 801a070:	e011      	b.n	801a096 <oqWriteTimeout+0x66>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 801a072:	9b06      	ldr	r3, [sp, #24]
 801a074:	2b00      	cmp	r3, #0
 801a076:	d002      	beq.n	801a07e <oqWriteTimeout+0x4e>
        nfy(oqp);
 801a078:	9b06      	ldr	r3, [sp, #24]
 801a07a:	9803      	ldr	r0, [sp, #12]
 801a07c:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 801a07e:	f7ff fd47 	bl	8019b10 <osalSysUnlock.lto_priv.871>

      wr += done;
 801a082:	9a07      	ldr	r2, [sp, #28]
 801a084:	9b05      	ldr	r3, [sp, #20]
 801a086:	4413      	add	r3, r2
 801a088:	9307      	str	r3, [sp, #28]
      bp += done;
 801a08a:	9a02      	ldr	r2, [sp, #8]
 801a08c:	9b05      	ldr	r3, [sp, #20]
 801a08e:	4413      	add	r3, r2
 801a090:	9302      	str	r3, [sp, #8]

      osalSysLock();
 801a092:	f7ff fd35 	bl	8019b00 <osalSysLock.lto_priv.875>
  while (wr < n) {
 801a096:	9a07      	ldr	r2, [sp, #28]
 801a098:	9b01      	ldr	r3, [sp, #4]
 801a09a:	429a      	cmp	r2, r3
 801a09c:	d3d6      	bcc.n	801a04c <oqWriteTimeout+0x1c>
    }
  }

  osalSysUnlock();
 801a09e:	f7ff fd37 	bl	8019b10 <osalSysUnlock.lto_priv.871>
  return wr;
 801a0a2:	9b07      	ldr	r3, [sp, #28]
}
 801a0a4:	4618      	mov	r0, r3
 801a0a6:	b009      	add	sp, #36	; 0x24
 801a0a8:	f85d fb04 	ldr.w	pc, [sp], #4
 801a0ac:	0000      	movs	r0, r0
	...

0801a0b0 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 801a0b0:	b088      	sub	sp, #32
 801a0b2:	9003      	str	r0, [sp, #12]
 801a0b4:	9102      	str	r1, [sp, #8]
 801a0b6:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 801a0b8:	9b01      	ldr	r3, [sp, #4]
 801a0ba:	095b      	lsrs	r3, r3, #5
 801a0bc:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 801a0be:	9b01      	ldr	r3, [sp, #4]
 801a0c0:	f003 031f 	and.w	r3, r3, #31
 801a0c4:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 801a0c6:	9b02      	ldr	r3, [sp, #8]
 801a0c8:	095b      	lsrs	r3, r3, #5
 801a0ca:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 801a0cc:	9b02      	ldr	r3, [sp, #8]
 801a0ce:	f003 031f 	and.w	r3, r3, #31
 801a0d2:	3301      	adds	r3, #1
 801a0d4:	2201      	movs	r2, #1
 801a0d6:	fa02 f303 	lsl.w	r3, r2, r3
 801a0da:	3b01      	subs	r3, #1
 801a0dc:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 801a0de:	9a07      	ldr	r2, [sp, #28]
 801a0e0:	9b05      	ldr	r3, [sp, #20]
 801a0e2:	429a      	cmp	r2, r3
 801a0e4:	d214      	bcs.n	801a110 <_mmcsd_get_slice+0x60>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 801a0e6:	9b07      	ldr	r3, [sp, #28]
 801a0e8:	009b      	lsls	r3, r3, #2
 801a0ea:	9a03      	ldr	r2, [sp, #12]
 801a0ec:	4413      	add	r3, r2
 801a0ee:	681a      	ldr	r2, [r3, #0]
 801a0f0:	9b06      	ldr	r3, [sp, #24]
 801a0f2:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 801a0f4:	9b05      	ldr	r3, [sp, #20]
 801a0f6:	009b      	lsls	r3, r3, #2
 801a0f8:	9903      	ldr	r1, [sp, #12]
 801a0fa:	440b      	add	r3, r1
 801a0fc:	6819      	ldr	r1, [r3, #0]
 801a0fe:	9b04      	ldr	r3, [sp, #16]
 801a100:	4019      	ands	r1, r3
 801a102:	9b06      	ldr	r3, [sp, #24]
 801a104:	f1c3 0320 	rsb	r3, r3, #32
 801a108:	fa01 f303 	lsl.w	r3, r1, r3
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 801a10c:	4313      	orrs	r3, r2
 801a10e:	e009      	b.n	801a124 <_mmcsd_get_slice+0x74>
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 801a110:	9b07      	ldr	r3, [sp, #28]
 801a112:	009b      	lsls	r3, r3, #2
 801a114:	9a03      	ldr	r2, [sp, #12]
 801a116:	4413      	add	r3, r2
 801a118:	681a      	ldr	r2, [r3, #0]
 801a11a:	9b04      	ldr	r3, [sp, #16]
 801a11c:	401a      	ands	r2, r3
 801a11e:	9b06      	ldr	r3, [sp, #24]
 801a120:	fa22 f303 	lsr.w	r3, r2, r3
}
 801a124:	4618      	mov	r0, r3
 801a126:	b008      	add	sp, #32
 801a128:	4770      	bx	lr
 801a12a:	bf00      	nop
 801a12c:	0000      	movs	r0, r0
	...

0801a130 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 801a130:	b500      	push	{lr}
 801a132:	b087      	sub	sp, #28
 801a134:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 801a136:	227e      	movs	r2, #126	; 0x7e
 801a138:	217f      	movs	r1, #127	; 0x7f
 801a13a:	9801      	ldr	r0, [sp, #4]
 801a13c:	f7ff ffb8 	bl	801a0b0 <_mmcsd_get_slice>
 801a140:	4603      	mov	r3, r0
 801a142:	2b00      	cmp	r3, #0
 801a144:	d002      	beq.n	801a14c <_mmcsd_get_capacity+0x1c>
 801a146:	2b01      	cmp	r3, #1
 801a148:	d01c      	beq.n	801a184 <_mmcsd_get_capacity+0x54>
 801a14a:	e024      	b.n	801a196 <_mmcsd_get_capacity+0x66>
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 801a14c:	223e      	movs	r2, #62	; 0x3e
 801a14e:	2149      	movs	r1, #73	; 0x49
 801a150:	9801      	ldr	r0, [sp, #4]
 801a152:	f7ff ffad 	bl	801a0b0 <_mmcsd_get_slice>
 801a156:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 801a158:	222f      	movs	r2, #47	; 0x2f
 801a15a:	2131      	movs	r1, #49	; 0x31
 801a15c:	9801      	ldr	r0, [sp, #4]
 801a15e:	f7ff ffa7 	bl	801a0b0 <_mmcsd_get_slice>
 801a162:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 801a164:	2250      	movs	r2, #80	; 0x50
 801a166:	2153      	movs	r1, #83	; 0x53
 801a168:	9801      	ldr	r0, [sp, #4]
 801a16a:	f7ff ffa1 	bl	801a0b0 <_mmcsd_get_slice>
 801a16e:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 801a170:	9b05      	ldr	r3, [sp, #20]
 801a172:	1c5a      	adds	r2, r3, #1
 801a174:	9b04      	ldr	r3, [sp, #16]
 801a176:	3302      	adds	r3, #2
 801a178:	409a      	lsls	r2, r3
 801a17a:	9b03      	ldr	r3, [sp, #12]
 801a17c:	3b09      	subs	r3, #9
 801a17e:	fa02 f303 	lsl.w	r3, r2, r3
 801a182:	e009      	b.n	801a198 <_mmcsd_get_capacity+0x68>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 801a184:	2230      	movs	r2, #48	; 0x30
 801a186:	2145      	movs	r1, #69	; 0x45
 801a188:	9801      	ldr	r0, [sp, #4]
 801a18a:	f7ff ff91 	bl	801a0b0 <_mmcsd_get_slice>
 801a18e:	4603      	mov	r3, r0
 801a190:	3301      	adds	r3, #1
 801a192:	029b      	lsls	r3, r3, #10
 801a194:	e000      	b.n	801a198 <_mmcsd_get_capacity+0x68>
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
 801a196:	2300      	movs	r3, #0
}
 801a198:	4618      	mov	r0, r3
 801a19a:	b007      	add	sp, #28
 801a19c:	f85d fb04 	ldr.w	pc, [sp], #4

0801a1a0 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 801a1a0:	b082      	sub	sp, #8
 801a1a2:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 801a1a4:	9b01      	ldr	r3, [sp, #4]
 801a1a6:	33d7      	adds	r3, #215	; 0xd7
 801a1a8:	781b      	ldrb	r3, [r3, #0]
 801a1aa:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 801a1ac:	9b01      	ldr	r3, [sp, #4]
 801a1ae:	33d6      	adds	r3, #214	; 0xd6
 801a1b0:	781b      	ldrb	r3, [r3, #0]
 801a1b2:	041b      	lsls	r3, r3, #16
  return ((uint32_t)ext_csd[215] << 24U) +
 801a1b4:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
 801a1b6:	9b01      	ldr	r3, [sp, #4]
 801a1b8:	33d5      	adds	r3, #213	; 0xd5
 801a1ba:	781b      	ldrb	r3, [r3, #0]
 801a1bc:	021b      	lsls	r3, r3, #8
         ((uint32_t)ext_csd[214] << 16U) +
 801a1be:	4413      	add	r3, r2
         (uint32_t)ext_csd[212];
 801a1c0:	9a01      	ldr	r2, [sp, #4]
 801a1c2:	32d4      	adds	r2, #212	; 0xd4
 801a1c4:	7812      	ldrb	r2, [r2, #0]
         ((uint32_t)ext_csd[213] << 8U)  +
 801a1c6:	4413      	add	r3, r2
}
 801a1c8:	4618      	mov	r0, r3
 801a1ca:	b002      	add	sp, #8
 801a1cc:	4770      	bx	lr
 801a1ce:	bf00      	nop

0801a1d0 <queue_init.lto_priv.889>:
static inline void queue_init(threads_queue_t *tqp) {
 801a1d0:	b082      	sub	sp, #8
 801a1d2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 801a1d4:	9b01      	ldr	r3, [sp, #4]
 801a1d6:	9a01      	ldr	r2, [sp, #4]
 801a1d8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 801a1da:	9b01      	ldr	r3, [sp, #4]
 801a1dc:	9a01      	ldr	r2, [sp, #4]
 801a1de:	605a      	str	r2, [r3, #4]
}
 801a1e0:	b002      	add	sp, #8
 801a1e2:	4770      	bx	lr
	...

0801a1f0 <chThdQueueObjectInit.lto_priv.886>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 801a1f0:	b500      	push	{lr}
 801a1f2:	b083      	sub	sp, #12
 801a1f4:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 801a1f6:	9801      	ldr	r0, [sp, #4]
 801a1f8:	f7ff ffea 	bl	801a1d0 <queue_init.lto_priv.889>
}
 801a1fc:	b003      	add	sp, #12
 801a1fe:	f85d fb04 	ldr.w	pc, [sp], #4
 801a202:	bf00      	nop
	...

0801a210 <chEvtObjectInit>:
static inline void chEvtObjectInit(event_source_t *esp) {
 801a210:	b082      	sub	sp, #8
 801a212:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 801a214:	9b01      	ldr	r3, [sp, #4]
 801a216:	9a01      	ldr	r2, [sp, #4]
 801a218:	601a      	str	r2, [r3, #0]
}
 801a21a:	b002      	add	sp, #8
 801a21c:	4770      	bx	lr
 801a21e:	bf00      	nop

0801a220 <osalThreadQueueObjectInit.lto_priv.883>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 801a220:	b500      	push	{lr}
 801a222:	b083      	sub	sp, #12
 801a224:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 801a226:	9801      	ldr	r0, [sp, #4]
 801a228:	f7ff ffe2 	bl	801a1f0 <chThdQueueObjectInit.lto_priv.886>
}
 801a22c:	b003      	add	sp, #12
 801a22e:	f85d fb04 	ldr.w	pc, [sp], #4
 801a232:	bf00      	nop
	...

0801a240 <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {
 801a240:	b500      	push	{lr}
 801a242:	b083      	sub	sp, #12
 801a244:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 801a246:	9801      	ldr	r0, [sp, #4]
 801a248:	f7ff ffe2 	bl	801a210 <chEvtObjectInit>
}
 801a24c:	b003      	add	sp, #12
 801a24e:	f85d fb04 	ldr.w	pc, [sp], #4
 801a252:	bf00      	nop
	...

0801a260 <canInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void canInit(void) {
 801a260:	b508      	push	{r3, lr}

  can_lld_init();
 801a262:	f7fd fd1d 	bl	8017ca0 <can_lld_init>
}
 801a266:	bd08      	pop	{r3, pc}
	...

0801a270 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 801a270:	b500      	push	{lr}
 801a272:	b083      	sub	sp, #12
 801a274:	9001      	str	r0, [sp, #4]

  canp->state       = CAN_STOP;
 801a276:	9b01      	ldr	r3, [sp, #4]
 801a278:	2201      	movs	r2, #1
 801a27a:	701a      	strb	r2, [r3, #0]
  canp->config      = NULL;
 801a27c:	9b01      	ldr	r3, [sp, #4]
 801a27e:	2200      	movs	r2, #0
 801a280:	605a      	str	r2, [r3, #4]
  osalThreadQueueObjectInit(&canp->txqueue);
 801a282:	9b01      	ldr	r3, [sp, #4]
 801a284:	3308      	adds	r3, #8
 801a286:	4618      	mov	r0, r3
 801a288:	f7ff ffca 	bl	801a220 <osalThreadQueueObjectInit.lto_priv.883>
  osalThreadQueueObjectInit(&canp->rxqueue);
 801a28c:	9b01      	ldr	r3, [sp, #4]
 801a28e:	3310      	adds	r3, #16
 801a290:	4618      	mov	r0, r3
 801a292:	f7ff ffc5 	bl	801a220 <osalThreadQueueObjectInit.lto_priv.883>
#if !defined(CAN_ENFORCE_USE_CALLBACKS)
  osalEventObjectInit(&canp->rxfull_event);
 801a296:	9b01      	ldr	r3, [sp, #4]
 801a298:	3318      	adds	r3, #24
 801a29a:	4618      	mov	r0, r3
 801a29c:	f7ff ffd0 	bl	801a240 <osalEventObjectInit>
  osalEventObjectInit(&canp->txempty_event);
 801a2a0:	9b01      	ldr	r3, [sp, #4]
 801a2a2:	331c      	adds	r3, #28
 801a2a4:	4618      	mov	r0, r3
 801a2a6:	f7ff ffcb 	bl	801a240 <osalEventObjectInit>
  osalEventObjectInit(&canp->error_event);
 801a2aa:	9b01      	ldr	r3, [sp, #4]
 801a2ac:	3320      	adds	r3, #32
 801a2ae:	4618      	mov	r0, r3
 801a2b0:	f7ff ffc6 	bl	801a240 <osalEventObjectInit>
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 801a2b4:	9b01      	ldr	r3, [sp, #4]
 801a2b6:	3324      	adds	r3, #36	; 0x24
 801a2b8:	4618      	mov	r0, r3
 801a2ba:	f7ff ffc1 	bl	801a240 <osalEventObjectInit>
  osalEventObjectInit(&canp->wakeup_event);
 801a2be:	9b01      	ldr	r3, [sp, #4]
 801a2c0:	3328      	adds	r3, #40	; 0x28
 801a2c2:	4618      	mov	r0, r3
 801a2c4:	f7ff ffbc 	bl	801a240 <osalEventObjectInit>
  canp->error_cb    = NULL;
#if CAN_USE_SLEEP_MODE == TRUE
  canp->wakeup_cb   = NULL;
#endif
#endif /* defined(CAN_ENFORCE_USE_CALLBACKS) */
}
 801a2c8:	b003      	add	sp, #12
 801a2ca:	f85d fb04 	ldr.w	pc, [sp], #4
 801a2ce:	bf00      	nop

0801a2d0 <port_lock.lto_priv.865>:
static inline void port_lock(void) {
 801a2d0:	b082      	sub	sp, #8
 801a2d2:	2320      	movs	r3, #32
 801a2d4:	9301      	str	r3, [sp, #4]
 801a2d6:	9b01      	ldr	r3, [sp, #4]
 801a2d8:	f383 8811 	msr	BASEPRI, r3
}
 801a2dc:	b002      	add	sp, #8
 801a2de:	4770      	bx	lr

0801a2e0 <port_unlock.lto_priv.860>:
static inline void port_unlock(void) {
 801a2e0:	b082      	sub	sp, #8
 801a2e2:	2300      	movs	r3, #0
 801a2e4:	9301      	str	r3, [sp, #4]
 801a2e6:	9b01      	ldr	r3, [sp, #4]
 801a2e8:	f383 8811 	msr	BASEPRI, r3
}
 801a2ec:	b002      	add	sp, #8
 801a2ee:	4770      	bx	lr

0801a2f0 <chSysLock.lto_priv.855>:
static inline void chSysLock(void) {
 801a2f0:	b508      	push	{r3, lr}
  port_lock();
 801a2f2:	f7ff ffed 	bl	801a2d0 <port_lock.lto_priv.865>
}
 801a2f6:	bd08      	pop	{r3, pc}
	...

0801a300 <chSysUnlock.lto_priv.850>:
static inline void chSysUnlock(void) {
 801a300:	b508      	push	{r3, lr}
  port_unlock();
 801a302:	f7ff ffed 	bl	801a2e0 <port_unlock.lto_priv.860>
}
 801a306:	bd08      	pop	{r3, pc}
	...

0801a310 <osalSysLock.lto_priv.828>:
static inline void osalSysLock(void) {
 801a310:	b508      	push	{r3, lr}
  chSysLock();
 801a312:	f7ff ffed 	bl	801a2f0 <chSysLock.lto_priv.855>
}
 801a316:	bd08      	pop	{r3, pc}
	...

0801a320 <osalSysUnlock.lto_priv.824>:
static inline void osalSysUnlock(void) {
 801a320:	b508      	push	{r3, lr}
  chSysUnlock();
 801a322:	f7ff ffed 	bl	801a300 <chSysUnlock.lto_priv.850>
}
 801a326:	bd08      	pop	{r3, pc}
	...

0801a330 <osalThreadSleep>:
static inline void osalThreadSleep(sysinterval_t delay) {
 801a330:	b500      	push	{lr}
 801a332:	b083      	sub	sp, #12
 801a334:	9001      	str	r0, [sp, #4]
  chThdSleep(delay);
 801a336:	9801      	ldr	r0, [sp, #4]
 801a338:	f7fa fb8a 	bl	8014a50 <chThdSleep>
}
 801a33c:	b003      	add	sp, #12
 801a33e:	f85d fb04 	ldr.w	pc, [sp], #4
 801a342:	bf00      	nop
	...

0801a350 <mode_detect>:
static bool mode_detect(SDCDriver *sdcp) {
 801a350:	b500      	push	{lr}
 801a352:	b085      	sub	sp, #20
 801a354:	9001      	str	r0, [sp, #4]
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 801a356:	ab03      	add	r3, sp, #12
 801a358:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 801a35c:	2108      	movs	r1, #8
 801a35e:	9801      	ldr	r0, [sp, #4]
 801a360:	f7fb ffb6 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a364:	4603      	mov	r3, r0
 801a366:	f083 0301 	eor.w	r3, r3, #1
 801a36a:	b2db      	uxtb	r3, r3
 801a36c:	2b00      	cmp	r3, #0
 801a36e:	d01a      	beq.n	801a3a6 <mode_detect+0x56>
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 801a370:	9b01      	ldr	r3, [sp, #4]
 801a372:	2201      	movs	r2, #1
 801a374:	631a      	str	r2, [r3, #48]	; 0x30
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 801a376:	9b03      	ldr	r3, [sp, #12]
 801a378:	0a1b      	lsrs	r3, r3, #8
 801a37a:	f003 030f 	and.w	r3, r3, #15
 801a37e:	2b01      	cmp	r3, #1
 801a380:	d001      	beq.n	801a386 <mode_detect+0x36>
      return HAL_FAILED;
 801a382:	2301      	movs	r3, #1
 801a384:	e02a      	b.n	801a3dc <mode_detect+0x8c>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a386:	ab03      	add	r3, sp, #12
 801a388:	2200      	movs	r2, #0
 801a38a:	2137      	movs	r1, #55	; 0x37
 801a38c:	9801      	ldr	r0, [sp, #4]
 801a38e:	f7fb ff9f 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a392:	4603      	mov	r3, r0
 801a394:	2b00      	cmp	r3, #0
 801a396:	d104      	bne.n	801a3a2 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 801a398:	9a03      	ldr	r2, [sp, #12]
 801a39a:	4b12      	ldr	r3, [pc, #72]	; (801a3e4 <mode_detect+0x94>)
 801a39c:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a39e:	2b00      	cmp	r3, #0
 801a3a0:	d01b      	beq.n	801a3da <mode_detect+0x8a>
      return HAL_FAILED;
 801a3a2:	2301      	movs	r3, #1
 801a3a4:	e01a      	b.n	801a3dc <mode_detect+0x8c>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a3a6:	ab03      	add	r3, sp, #12
 801a3a8:	2200      	movs	r2, #0
 801a3aa:	2137      	movs	r1, #55	; 0x37
 801a3ac:	9801      	ldr	r0, [sp, #4]
 801a3ae:	f7fb ff8f 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a3b2:	4603      	mov	r3, r0
 801a3b4:	2b00      	cmp	r3, #0
 801a3b6:	d104      	bne.n	801a3c2 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 801a3b8:	9a03      	ldr	r2, [sp, #12]
 801a3ba:	4b0a      	ldr	r3, [pc, #40]	; (801a3e4 <mode_detect+0x94>)
 801a3bc:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a3be:	2b00      	cmp	r3, #0
 801a3c0:	d003      	beq.n	801a3ca <mode_detect+0x7a>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 801a3c2:	9b01      	ldr	r3, [sp, #4]
 801a3c4:	2202      	movs	r2, #2
 801a3c6:	631a      	str	r2, [r3, #48]	; 0x30
 801a3c8:	e007      	b.n	801a3da <mode_detect+0x8a>
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 801a3ca:	9b01      	ldr	r3, [sp, #4]
 801a3cc:	2200      	movs	r2, #0
 801a3ce:	631a      	str	r2, [r3, #48]	; 0x30
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 801a3d0:	2200      	movs	r2, #0
 801a3d2:	2100      	movs	r1, #0
 801a3d4:	9801      	ldr	r0, [sp, #4]
 801a3d6:	f7fb ff1b 	bl	8016210 <sdc_lld_send_cmd_none>
  return HAL_SUCCESS;
 801a3da:	2300      	movs	r3, #0
}
 801a3dc:	4618      	mov	r0, r3
 801a3de:	b005      	add	sp, #20
 801a3e0:	f85d fb04 	ldr.w	pc, [sp], #4
 801a3e4:	fdffe008 	.word	0xfdffe008
	...

0801a3f0 <mmc_init>:
static bool mmc_init(SDCDriver *sdcp) {
 801a3f0:	b500      	push	{lr}
 801a3f2:	b087      	sub	sp, #28
 801a3f4:	9001      	str	r0, [sp, #4]
  ocr = 0xC0FF8000U;
 801a3f6:	4b17      	ldr	r3, [pc, #92]	; (801a454 <mmc_init+0x64>)
 801a3f8:	9304      	str	r3, [sp, #16]
  i = 0;
 801a3fa:	2300      	movs	r3, #0
 801a3fc:	9305      	str	r3, [sp, #20]
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 801a3fe:	ab03      	add	r3, sp, #12
 801a400:	9a04      	ldr	r2, [sp, #16]
 801a402:	2101      	movs	r1, #1
 801a404:	9801      	ldr	r0, [sp, #4]
 801a406:	f7fb ff23 	bl	8016250 <sdc_lld_send_cmd_short>
 801a40a:	4603      	mov	r3, r0
 801a40c:	2b00      	cmp	r3, #0
 801a40e:	d001      	beq.n	801a414 <mmc_init+0x24>
      return HAL_FAILED;
 801a410:	2301      	movs	r3, #1
 801a412:	e01b      	b.n	801a44c <mmc_init+0x5c>
    if ((resp[0] & 0x80000000U) != 0U) {
 801a414:	9b03      	ldr	r3, [sp, #12]
 801a416:	2b00      	cmp	r3, #0
 801a418:	da0c      	bge.n	801a434 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 801a41a:	9b03      	ldr	r3, [sp, #12]
 801a41c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 801a420:	2b00      	cmp	r3, #0
 801a422:	d005      	beq.n	801a430 <mmc_init+0x40>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 801a424:	9b01      	ldr	r3, [sp, #4]
 801a426:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a428:	f043 0210 	orr.w	r2, r3, #16
 801a42c:	9b01      	ldr	r3, [sp, #4]
 801a42e:	631a      	str	r2, [r3, #48]	; 0x30
  return HAL_SUCCESS;
 801a430:	2300      	movs	r3, #0
 801a432:	e00b      	b.n	801a44c <mmc_init+0x5c>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 801a434:	9b05      	ldr	r3, [sp, #20]
 801a436:	3301      	adds	r3, #1
 801a438:	9305      	str	r3, [sp, #20]
 801a43a:	9b05      	ldr	r3, [sp, #20]
 801a43c:	2b63      	cmp	r3, #99	; 0x63
 801a43e:	d901      	bls.n	801a444 <mmc_init+0x54>
      return HAL_FAILED;
 801a440:	2301      	movs	r3, #1
 801a442:	e003      	b.n	801a44c <mmc_init+0x5c>
    osalThreadSleepMilliseconds(10);
 801a444:	2064      	movs	r0, #100	; 0x64
 801a446:	f7ff ff73 	bl	801a330 <osalThreadSleep>
 801a44a:	e7d8      	b.n	801a3fe <mmc_init+0xe>
}
 801a44c:	4618      	mov	r0, r3
 801a44e:	b007      	add	sp, #28
 801a450:	f85d fb04 	ldr.w	pc, [sp], #4
 801a454:	c0ff8000 	.word	0xc0ff8000
	...

0801a460 <sdc_init>:
static bool sdc_init(SDCDriver *sdcp) {
 801a460:	b500      	push	{lr}
 801a462:	b087      	sub	sp, #28
 801a464:	9001      	str	r0, [sp, #4]
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 801a466:	9b01      	ldr	r3, [sp, #4]
 801a468:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a46a:	f003 030f 	and.w	r3, r3, #15
 801a46e:	2b01      	cmp	r3, #1
 801a470:	d102      	bne.n	801a478 <sdc_init+0x18>
    ocr = SDC_INIT_OCR_V20;
 801a472:	4b21      	ldr	r3, [pc, #132]	; (801a4f8 <sdc_init+0x98>)
 801a474:	9304      	str	r3, [sp, #16]
 801a476:	e001      	b.n	801a47c <sdc_init+0x1c>
    ocr = SDC_INIT_OCR;
 801a478:	4b20      	ldr	r3, [pc, #128]	; (801a4fc <sdc_init+0x9c>)
 801a47a:	9304      	str	r3, [sp, #16]
  i = 0;
 801a47c:	2300      	movs	r3, #0
 801a47e:	9305      	str	r3, [sp, #20]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a480:	ab03      	add	r3, sp, #12
 801a482:	2200      	movs	r2, #0
 801a484:	2137      	movs	r1, #55	; 0x37
 801a486:	9801      	ldr	r0, [sp, #4]
 801a488:	f7fb ff22 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a48c:	4603      	mov	r3, r0
 801a48e:	2b00      	cmp	r3, #0
 801a490:	d104      	bne.n	801a49c <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 801a492:	9a03      	ldr	r2, [sp, #12]
 801a494:	4b1a      	ldr	r3, [pc, #104]	; (801a500 <sdc_init+0xa0>)
 801a496:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 801a498:	2b00      	cmp	r3, #0
 801a49a:	d001      	beq.n	801a4a0 <sdc_init+0x40>
      return HAL_FAILED;
 801a49c:	2301      	movs	r3, #1
 801a49e:	e026      	b.n	801a4ee <sdc_init+0x8e>
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 801a4a0:	ab03      	add	r3, sp, #12
 801a4a2:	9a04      	ldr	r2, [sp, #16]
 801a4a4:	2129      	movs	r1, #41	; 0x29
 801a4a6:	9801      	ldr	r0, [sp, #4]
 801a4a8:	f7fb fed2 	bl	8016250 <sdc_lld_send_cmd_short>
 801a4ac:	4603      	mov	r3, r0
 801a4ae:	2b00      	cmp	r3, #0
 801a4b0:	d001      	beq.n	801a4b6 <sdc_init+0x56>
      return HAL_FAILED;
 801a4b2:	2301      	movs	r3, #1
 801a4b4:	e01b      	b.n	801a4ee <sdc_init+0x8e>
    if ((resp[0] & 0x80000000U) != 0U) {
 801a4b6:	9b03      	ldr	r3, [sp, #12]
 801a4b8:	2b00      	cmp	r3, #0
 801a4ba:	da0c      	bge.n	801a4d6 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 801a4bc:	9b03      	ldr	r3, [sp, #12]
 801a4be:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 801a4c2:	2b00      	cmp	r3, #0
 801a4c4:	d005      	beq.n	801a4d2 <sdc_init+0x72>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 801a4c6:	9b01      	ldr	r3, [sp, #4]
 801a4c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a4ca:	f043 0210 	orr.w	r2, r3, #16
 801a4ce:	9b01      	ldr	r3, [sp, #4]
 801a4d0:	631a      	str	r2, [r3, #48]	; 0x30
  return HAL_SUCCESS;
 801a4d2:	2300      	movs	r3, #0
 801a4d4:	e00b      	b.n	801a4ee <sdc_init+0x8e>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 801a4d6:	9b05      	ldr	r3, [sp, #20]
 801a4d8:	3301      	adds	r3, #1
 801a4da:	9305      	str	r3, [sp, #20]
 801a4dc:	9b05      	ldr	r3, [sp, #20]
 801a4de:	2b63      	cmp	r3, #99	; 0x63
 801a4e0:	d901      	bls.n	801a4e6 <sdc_init+0x86>
      return HAL_FAILED;
 801a4e2:	2301      	movs	r3, #1
 801a4e4:	e003      	b.n	801a4ee <sdc_init+0x8e>
    osalThreadSleepMilliseconds(10);
 801a4e6:	2064      	movs	r0, #100	; 0x64
 801a4e8:	f7ff ff22 	bl	801a330 <osalThreadSleep>
 801a4ec:	e7c8      	b.n	801a480 <sdc_init+0x20>
}
 801a4ee:	4618      	mov	r0, r3
 801a4f0:	b007      	add	sp, #28
 801a4f2:	f85d fb04 	ldr.w	pc, [sp], #4
 801a4f6:	bf00      	nop
 801a4f8:	50ff8000 	.word	0x50ff8000
 801a4fc:	80100000 	.word	0x80100000
 801a500:	fdffe008 	.word	0xfdffe008
	...

0801a510 <mmc_cmd6_construct>:
                                   uint32_t value, uint32_t cmd_set) {
 801a510:	b084      	sub	sp, #16
 801a512:	9102      	str	r1, [sp, #8]
 801a514:	9201      	str	r2, [sp, #4]
 801a516:	9300      	str	r3, [sp, #0]
 801a518:	4603      	mov	r3, r0
 801a51a:	f88d 300f 	strb.w	r3, [sp, #15]
  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 801a51e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801a522:	061a      	lsls	r2, r3, #24
 801a524:	9b02      	ldr	r3, [sp, #8]
 801a526:	041b      	lsls	r3, r3, #16
 801a528:	431a      	orrs	r2, r3
 801a52a:	9b01      	ldr	r3, [sp, #4]
 801a52c:	021b      	lsls	r3, r3, #8
 801a52e:	431a      	orrs	r2, r3
 801a530:	9b00      	ldr	r3, [sp, #0]
 801a532:	4313      	orrs	r3, r2
}
 801a534:	4618      	mov	r0, r3
 801a536:	b004      	add	sp, #16
 801a538:	4770      	bx	lr
 801a53a:	bf00      	nop
 801a53c:	0000      	movs	r0, r0
	...

0801a540 <sdc_cmd6_construct>:
                                   uint32_t value) {
 801a540:	b084      	sub	sp, #16
 801a542:	4603      	mov	r3, r0
 801a544:	9200      	str	r2, [sp, #0]
 801a546:	f88d 3007 	strb.w	r3, [sp, #7]
 801a54a:	460b      	mov	r3, r1
 801a54c:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 801a550:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 801a554:	9303      	str	r3, [sp, #12]
  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 801a556:	f89d 3006 	ldrb.w	r3, [sp, #6]
 801a55a:	009b      	lsls	r3, r3, #2
 801a55c:	220f      	movs	r2, #15
 801a55e:	fa02 f303 	lsl.w	r3, r2, r3
 801a562:	43db      	mvns	r3, r3
 801a564:	9a03      	ldr	r2, [sp, #12]
 801a566:	4013      	ands	r3, r2
 801a568:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 801a56a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 801a56e:	009b      	lsls	r3, r3, #2
 801a570:	9a00      	ldr	r2, [sp, #0]
 801a572:	fa02 f303 	lsl.w	r3, r2, r3
 801a576:	9a03      	ldr	r2, [sp, #12]
 801a578:	4313      	orrs	r3, r2
 801a57a:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 801a57c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a580:	07da      	lsls	r2, r3, #31
 801a582:	9b03      	ldr	r3, [sp, #12]
 801a584:	4313      	orrs	r3, r2
}
 801a586:	4618      	mov	r0, r3
 801a588:	b004      	add	sp, #16
 801a58a:	4770      	bx	lr
 801a58c:	0000      	movs	r0, r0
	...

0801a590 <sdc_cmd6_extract_info>:
                                      const uint8_t *buf) {
 801a590:	b084      	sub	sp, #16
 801a592:	4603      	mov	r3, r0
 801a594:	9100      	str	r1, [sp, #0]
 801a596:	f88d 3007 	strb.w	r3, [sp, #7]
  unsigned start = 12U - ((unsigned)function * 2U);
 801a59a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 801a59e:	4613      	mov	r3, r2
 801a5a0:	07db      	lsls	r3, r3, #31
 801a5a2:	1a9b      	subs	r3, r3, r2
 801a5a4:	005b      	lsls	r3, r3, #1
 801a5a6:	330c      	adds	r3, #12
 801a5a8:	9303      	str	r3, [sp, #12]
  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 801a5aa:	9a00      	ldr	r2, [sp, #0]
 801a5ac:	9b03      	ldr	r3, [sp, #12]
 801a5ae:	4413      	add	r3, r2
 801a5b0:	781b      	ldrb	r3, [r3, #0]
 801a5b2:	021b      	lsls	r3, r3, #8
 801a5b4:	b21a      	sxth	r2, r3
 801a5b6:	9b03      	ldr	r3, [sp, #12]
 801a5b8:	3301      	adds	r3, #1
 801a5ba:	9900      	ldr	r1, [sp, #0]
 801a5bc:	440b      	add	r3, r1
 801a5be:	781b      	ldrb	r3, [r3, #0]
 801a5c0:	b21b      	sxth	r3, r3
 801a5c2:	4313      	orrs	r3, r2
 801a5c4:	b21b      	sxth	r3, r3
 801a5c6:	b29b      	uxth	r3, r3
}
 801a5c8:	4618      	mov	r0, r3
 801a5ca:	b004      	add	sp, #16
 801a5cc:	4770      	bx	lr
 801a5ce:	bf00      	nop

0801a5d0 <sdc_cmd6_check_status>:
                                 const uint8_t *buf) {
 801a5d0:	b084      	sub	sp, #16
 801a5d2:	4603      	mov	r3, r0
 801a5d4:	9100      	str	r1, [sp, #0]
 801a5d6:	f88d 3007 	strb.w	r3, [sp, #7]
  tmp = ((uint32_t)buf[14] << 16U) |
 801a5da:	9b00      	ldr	r3, [sp, #0]
 801a5dc:	330e      	adds	r3, #14
 801a5de:	781b      	ldrb	r3, [r3, #0]
 801a5e0:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 801a5e2:	9b00      	ldr	r3, [sp, #0]
 801a5e4:	330f      	adds	r3, #15
 801a5e6:	781b      	ldrb	r3, [r3, #0]
 801a5e8:	021b      	lsls	r3, r3, #8
  tmp = ((uint32_t)buf[14] << 16U) |
 801a5ea:	4313      	orrs	r3, r2
        (uint32_t)buf[16];
 801a5ec:	9a00      	ldr	r2, [sp, #0]
 801a5ee:	3210      	adds	r2, #16
 801a5f0:	7812      	ldrb	r2, [r2, #0]
  tmp = ((uint32_t)buf[14] << 16U) |
 801a5f2:	4313      	orrs	r3, r2
 801a5f4:	9303      	str	r3, [sp, #12]
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 801a5f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801a5fa:	009b      	lsls	r3, r3, #2
 801a5fc:	9a03      	ldr	r2, [sp, #12]
 801a5fe:	fa22 f303 	lsr.w	r3, r2, r3
 801a602:	f003 030f 	and.w	r3, r3, #15
 801a606:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 801a608:	9b02      	ldr	r3, [sp, #8]
 801a60a:	2b0f      	cmp	r3, #15
 801a60c:	d001      	beq.n	801a612 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 801a60e:	2300      	movs	r3, #0
 801a610:	e000      	b.n	801a614 <sdc_cmd6_check_status+0x44>
  return HAL_FAILED;
 801a612:	2301      	movs	r3, #1
}
 801a614:	4618      	mov	r0, r3
 801a616:	b004      	add	sp, #16
 801a618:	4770      	bx	lr
 801a61a:	bf00      	nop
 801a61c:	0000      	movs	r0, r0
	...

0801a620 <sdc_detect_bus_clk>:
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 801a620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a624:	b088      	sub	sp, #32
 801a626:	af02      	add	r7, sp, #8
 801a628:	6078      	str	r0, [r7, #4]
 801a62a:	6039      	str	r1, [r7, #0]
 801a62c:	466a      	mov	r2, sp
 801a62e:	4690      	mov	r8, r2
  const size_t N = 64;
 801a630:	2240      	movs	r2, #64	; 0x40
 801a632:	617a      	str	r2, [r7, #20]
  uint8_t tmp[N];
 801a634:	697a      	ldr	r2, [r7, #20]
 801a636:	3a01      	subs	r2, #1
 801a638:	613a      	str	r2, [r7, #16]
 801a63a:	697a      	ldr	r2, [r7, #20]
 801a63c:	4611      	mov	r1, r2
 801a63e:	f04f 0200 	mov.w	r2, #0
 801a642:	00d6      	lsls	r6, r2, #3
 801a644:	ea46 7651 	orr.w	r6, r6, r1, lsr #29
 801a648:	00cd      	lsls	r5, r1, #3
 801a64a:	697a      	ldr	r2, [r7, #20]
 801a64c:	4611      	mov	r1, r2
 801a64e:	f04f 0200 	mov.w	r2, #0
 801a652:	00d4      	lsls	r4, r2, #3
 801a654:	ea44 7451 	orr.w	r4, r4, r1, lsr #29
 801a658:	00cb      	lsls	r3, r1, #3
 801a65a:	697b      	ldr	r3, [r7, #20]
 801a65c:	3307      	adds	r3, #7
 801a65e:	08db      	lsrs	r3, r3, #3
 801a660:	00db      	lsls	r3, r3, #3
 801a662:	ebad 0d03 	sub.w	sp, sp, r3
 801a666:	ab02      	add	r3, sp, #8
 801a668:	3300      	adds	r3, #0
 801a66a:	60fb      	str	r3, [r7, #12]
  *clk = SDC_CLK_25MHz;
 801a66c:	683b      	ldr	r3, [r7, #0]
 801a66e:	2200      	movs	r2, #0
 801a670:	701a      	strb	r2, [r3, #0]
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 801a672:	687b      	ldr	r3, [r7, #4]
 801a674:	3318      	adds	r3, #24
 801a676:	227e      	movs	r2, #126	; 0x7e
 801a678:	217f      	movs	r1, #127	; 0x7f
 801a67a:	4618      	mov	r0, r3
 801a67c:	f7ff fd18 	bl	801a0b0 <_mmcsd_get_slice>
 801a680:	4603      	mov	r3, r0
 801a682:	2b00      	cmp	r3, #0
 801a684:	d104      	bne.n	801a690 <sdc_detect_bus_clk+0x70>
    *clk = SDC_CLK_25MHz;
 801a686:	683b      	ldr	r3, [r7, #0]
 801a688:	2200      	movs	r2, #0
 801a68a:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 801a68c:	2300      	movs	r3, #0
 801a68e:	e03c      	b.n	801a70a <sdc_detect_bus_clk+0xea>
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 801a690:	68f9      	ldr	r1, [r7, #12]
 801a692:	2300      	movs	r3, #0
 801a694:	9300      	str	r3, [sp, #0]
 801a696:	2306      	movs	r3, #6
 801a698:	697a      	ldr	r2, [r7, #20]
 801a69a:	6878      	ldr	r0, [r7, #4]
 801a69c:	f7fb fea8 	bl	80163f0 <sdc_lld_read_special>
 801a6a0:	4603      	mov	r3, r0
 801a6a2:	2b00      	cmp	r3, #0
 801a6a4:	d001      	beq.n	801a6aa <sdc_detect_bus_clk+0x8a>
    return HAL_FAILED;
 801a6a6:	2301      	movs	r3, #1
 801a6a8:	e02f      	b.n	801a70a <sdc_detect_bus_clk+0xea>
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 801a6aa:	68fb      	ldr	r3, [r7, #12]
 801a6ac:	4619      	mov	r1, r3
 801a6ae:	2000      	movs	r0, #0
 801a6b0:	f7ff ff6e 	bl	801a590 <sdc_cmd6_extract_info>
 801a6b4:	4603      	mov	r3, r0
 801a6b6:	f003 0302 	and.w	r3, r3, #2
 801a6ba:	2b02      	cmp	r3, #2
 801a6bc:	d124      	bne.n	801a708 <sdc_detect_bus_clk+0xe8>
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 801a6be:	2201      	movs	r2, #1
 801a6c0:	2100      	movs	r1, #0
 801a6c2:	2001      	movs	r0, #1
 801a6c4:	f7ff ff3c 	bl	801a540 <sdc_cmd6_construct>
 801a6c8:	60b8      	str	r0, [r7, #8]
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 801a6ca:	68f9      	ldr	r1, [r7, #12]
 801a6cc:	68bb      	ldr	r3, [r7, #8]
 801a6ce:	9300      	str	r3, [sp, #0]
 801a6d0:	2306      	movs	r3, #6
 801a6d2:	697a      	ldr	r2, [r7, #20]
 801a6d4:	6878      	ldr	r0, [r7, #4]
 801a6d6:	f7fb fe8b 	bl	80163f0 <sdc_lld_read_special>
 801a6da:	4603      	mov	r3, r0
 801a6dc:	2b00      	cmp	r3, #0
 801a6de:	d001      	beq.n	801a6e4 <sdc_detect_bus_clk+0xc4>
      return HAL_FAILED;
 801a6e0:	2301      	movs	r3, #1
 801a6e2:	e012      	b.n	801a70a <sdc_detect_bus_clk+0xea>
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 801a6e4:	68fb      	ldr	r3, [r7, #12]
 801a6e6:	4619      	mov	r1, r3
 801a6e8:	2000      	movs	r0, #0
 801a6ea:	f7ff ff71 	bl	801a5d0 <sdc_cmd6_check_status>
 801a6ee:	4603      	mov	r3, r0
 801a6f0:	f083 0301 	eor.w	r3, r3, #1
 801a6f4:	b2db      	uxtb	r3, r3
 801a6f6:	2b00      	cmp	r3, #0
 801a6f8:	d003      	beq.n	801a702 <sdc_detect_bus_clk+0xe2>
      *clk = SDC_CLK_50MHz;
 801a6fa:	683b      	ldr	r3, [r7, #0]
 801a6fc:	2201      	movs	r2, #1
 801a6fe:	701a      	strb	r2, [r3, #0]
 801a700:	e002      	b.n	801a708 <sdc_detect_bus_clk+0xe8>
      *clk = SDC_CLK_25MHz;
 801a702:	683b      	ldr	r3, [r7, #0]
 801a704:	2200      	movs	r2, #0
 801a706:	701a      	strb	r2, [r3, #0]
  return HAL_SUCCESS;
 801a708:	2300      	movs	r3, #0
 801a70a:	46c5      	mov	sp, r8
}
 801a70c:	4618      	mov	r0, r3
 801a70e:	3718      	adds	r7, #24
 801a710:	46bd      	mov	sp, r7
 801a712:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a716:	bf00      	nop
	...

0801a720 <mmc_detect_bus_clk>:
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 801a720:	b500      	push	{lr}
 801a722:	b087      	sub	sp, #28
 801a724:	9001      	str	r0, [sp, #4]
 801a726:	9100      	str	r1, [sp, #0]
  uint8_t *scratchpad = sdcp->config->scratchpad;
 801a728:	9b01      	ldr	r3, [sp, #4]
 801a72a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a72c:	681b      	ldr	r3, [r3, #0]
 801a72e:	9305      	str	r3, [sp, #20]
  *clk = SDC_CLK_25MHz;
 801a730:	9b00      	ldr	r3, [sp, #0]
 801a732:	2200      	movs	r2, #0
 801a734:	701a      	strb	r2, [r3, #0]
  if (NULL == scratchpad) {
 801a736:	9b05      	ldr	r3, [sp, #20]
 801a738:	2b00      	cmp	r3, #0
 801a73a:	d101      	bne.n	801a740 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 801a73c:	2300      	movs	r3, #0
 801a73e:	e01b      	b.n	801a778 <mmc_detect_bus_clk+0x58>
  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 801a740:	2300      	movs	r3, #0
 801a742:	2201      	movs	r2, #1
 801a744:	21b9      	movs	r1, #185	; 0xb9
 801a746:	2003      	movs	r0, #3
 801a748:	f7ff fee2 	bl	801a510 <mmc_cmd6_construct>
 801a74c:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 801a74e:	ab03      	add	r3, sp, #12
 801a750:	9a04      	ldr	r2, [sp, #16]
 801a752:	2106      	movs	r1, #6
 801a754:	9801      	ldr	r0, [sp, #4]
 801a756:	f7fb fdbb 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a75a:	4603      	mov	r3, r0
 801a75c:	f083 0301 	eor.w	r3, r3, #1
 801a760:	b2db      	uxtb	r3, r3
 801a762:	2b00      	cmp	r3, #0
 801a764:	d007      	beq.n	801a776 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 801a766:	9a03      	ldr	r2, [sp, #12]
 801a768:	4b05      	ldr	r3, [pc, #20]	; (801a780 <mmc_detect_bus_clk+0x60>)
 801a76a:	4013      	ands	r3, r2
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 801a76c:	2b00      	cmp	r3, #0
 801a76e:	d102      	bne.n	801a776 <mmc_detect_bus_clk+0x56>
    *clk = SDC_CLK_50MHz;
 801a770:	9b00      	ldr	r3, [sp, #0]
 801a772:	2201      	movs	r2, #1
 801a774:	701a      	strb	r2, [r3, #0]
  return HAL_SUCCESS;
 801a776:	2300      	movs	r3, #0
}
 801a778:	4618      	mov	r0, r3
 801a77a:	b007      	add	sp, #28
 801a77c:	f85d fb04 	ldr.w	pc, [sp], #4
 801a780:	fdffe008 	.word	0xfdffe008
	...

0801a790 <detect_bus_clk>:
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 801a790:	b500      	push	{lr}
 801a792:	b083      	sub	sp, #12
 801a794:	9001      	str	r0, [sp, #4]
 801a796:	9100      	str	r1, [sp, #0]
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 801a798:	9b01      	ldr	r3, [sp, #4]
 801a79a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a79c:	f003 030f 	and.w	r3, r3, #15
 801a7a0:	2b02      	cmp	r3, #2
 801a7a2:	d105      	bne.n	801a7b0 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 801a7a4:	9900      	ldr	r1, [sp, #0]
 801a7a6:	9801      	ldr	r0, [sp, #4]
 801a7a8:	f7ff ffba 	bl	801a720 <mmc_detect_bus_clk>
 801a7ac:	4603      	mov	r3, r0
 801a7ae:	e004      	b.n	801a7ba <detect_bus_clk+0x2a>
  return sdc_detect_bus_clk(sdcp, clk);
 801a7b0:	9900      	ldr	r1, [sp, #0]
 801a7b2:	9801      	ldr	r0, [sp, #4]
 801a7b4:	f7ff ff34 	bl	801a620 <sdc_detect_bus_clk>
 801a7b8:	4603      	mov	r3, r0
}
 801a7ba:	4618      	mov	r0, r3
 801a7bc:	b003      	add	sp, #12
 801a7be:	f85d fb04 	ldr.w	pc, [sp], #4
 801a7c2:	bf00      	nop
	...

0801a7d0 <sdc_set_bus_width>:
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 801a7d0:	b500      	push	{lr}
 801a7d2:	b085      	sub	sp, #20
 801a7d4:	9001      	str	r0, [sp, #4]
  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 801a7d6:	9b01      	ldr	r3, [sp, #4]
 801a7d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a7da:	791b      	ldrb	r3, [r3, #4]
 801a7dc:	2b00      	cmp	r3, #0
 801a7de:	d101      	bne.n	801a7e4 <sdc_set_bus_width+0x14>
    return HAL_SUCCESS;
 801a7e0:	2300      	movs	r3, #0
 801a7e2:	e02c      	b.n	801a83e <sdc_set_bus_width+0x6e>
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 801a7e4:	9b01      	ldr	r3, [sp, #4]
 801a7e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a7e8:	791b      	ldrb	r3, [r3, #4]
 801a7ea:	2b01      	cmp	r3, #1
 801a7ec:	d124      	bne.n	801a838 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 801a7ee:	2101      	movs	r1, #1
 801a7f0:	9801      	ldr	r0, [sp, #4]
 801a7f2:	f7fb fce5 	bl	80161c0 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 801a7f6:	9b01      	ldr	r3, [sp, #4]
 801a7f8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801a7fa:	ab03      	add	r3, sp, #12
 801a7fc:	2137      	movs	r1, #55	; 0x37
 801a7fe:	9801      	ldr	r0, [sp, #4]
 801a800:	f7fb fd66 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a804:	4603      	mov	r3, r0
 801a806:	2b00      	cmp	r3, #0
 801a808:	d104      	bne.n	801a814 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 801a80a:	9a03      	ldr	r2, [sp, #12]
 801a80c:	4b0e      	ldr	r3, [pc, #56]	; (801a848 <sdc_set_bus_width+0x78>)
 801a80e:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 801a810:	2b00      	cmp	r3, #0
 801a812:	d001      	beq.n	801a818 <sdc_set_bus_width+0x48>
      return HAL_FAILED;
 801a814:	2301      	movs	r3, #1
 801a816:	e012      	b.n	801a83e <sdc_set_bus_width+0x6e>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 801a818:	ab03      	add	r3, sp, #12
 801a81a:	2202      	movs	r2, #2
 801a81c:	2106      	movs	r1, #6
 801a81e:	9801      	ldr	r0, [sp, #4]
 801a820:	f7fb fd56 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a824:	4603      	mov	r3, r0
 801a826:	2b00      	cmp	r3, #0
 801a828:	d104      	bne.n	801a834 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 801a82a:	9a03      	ldr	r2, [sp, #12]
 801a82c:	4b06      	ldr	r3, [pc, #24]	; (801a848 <sdc_set_bus_width+0x78>)
 801a82e:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 801a830:	2b00      	cmp	r3, #0
 801a832:	d003      	beq.n	801a83c <sdc_set_bus_width+0x6c>
      return HAL_FAILED;
 801a834:	2301      	movs	r3, #1
 801a836:	e002      	b.n	801a83e <sdc_set_bus_width+0x6e>
    return HAL_FAILED;
 801a838:	2301      	movs	r3, #1
 801a83a:	e000      	b.n	801a83e <sdc_set_bus_width+0x6e>
  return HAL_SUCCESS;
 801a83c:	2300      	movs	r3, #0
}
 801a83e:	4618      	mov	r0, r3
 801a840:	b005      	add	sp, #20
 801a842:	f85d fb04 	ldr.w	pc, [sp], #4
 801a846:	bf00      	nop
 801a848:	fdffe008 	.word	0xfdffe008
 801a84c:	00000000 	.word	0x00000000

0801a850 <mmc_set_bus_width>:
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 801a850:	b500      	push	{lr}
 801a852:	b085      	sub	sp, #20
 801a854:	9001      	str	r0, [sp, #4]
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 801a856:	2300      	movs	r3, #0
 801a858:	2200      	movs	r2, #0
 801a85a:	21b7      	movs	r1, #183	; 0xb7
 801a85c:	2003      	movs	r0, #3
 801a85e:	f7ff fe57 	bl	801a510 <mmc_cmd6_construct>
 801a862:	9003      	str	r0, [sp, #12]
  switch (sdcp->config->bus_width) {
 801a864:	9b01      	ldr	r3, [sp, #4]
 801a866:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a868:	791b      	ldrb	r3, [r3, #4]
 801a86a:	2b01      	cmp	r3, #1
 801a86c:	d005      	beq.n	801a87a <mmc_set_bus_width+0x2a>
 801a86e:	2b02      	cmp	r3, #2
 801a870:	d00b      	beq.n	801a88a <mmc_set_bus_width+0x3a>
 801a872:	2b00      	cmp	r3, #0
 801a874:	d110      	bne.n	801a898 <mmc_set_bus_width+0x48>
    return HAL_SUCCESS;
 801a876:	2300      	movs	r3, #0
 801a878:	e026      	b.n	801a8c8 <mmc_set_bus_width+0x78>
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 801a87a:	2300      	movs	r3, #0
 801a87c:	2201      	movs	r2, #1
 801a87e:	21b7      	movs	r1, #183	; 0xb7
 801a880:	2003      	movs	r0, #3
 801a882:	f7ff fe45 	bl	801a510 <mmc_cmd6_construct>
 801a886:	9003      	str	r0, [sp, #12]
 801a888:	e006      	b.n	801a898 <mmc_set_bus_width+0x48>
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 801a88a:	2300      	movs	r3, #0
 801a88c:	2202      	movs	r2, #2
 801a88e:	21b7      	movs	r1, #183	; 0xb7
 801a890:	2003      	movs	r0, #3
 801a892:	f7ff fe3d 	bl	801a510 <mmc_cmd6_construct>
 801a896:	9003      	str	r0, [sp, #12]
  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 801a898:	9b01      	ldr	r3, [sp, #4]
 801a89a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a89c:	791b      	ldrb	r3, [r3, #4]
 801a89e:	4619      	mov	r1, r3
 801a8a0:	9801      	ldr	r0, [sp, #4]
 801a8a2:	f7fb fc8d 	bl	80161c0 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 801a8a6:	ab02      	add	r3, sp, #8
 801a8a8:	9a03      	ldr	r2, [sp, #12]
 801a8aa:	2106      	movs	r1, #6
 801a8ac:	9801      	ldr	r0, [sp, #4]
 801a8ae:	f7fb fd0f 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a8b2:	4603      	mov	r3, r0
 801a8b4:	2b00      	cmp	r3, #0
 801a8b6:	d104      	bne.n	801a8c2 <mmc_set_bus_width+0x72>
      MMCSD_R1_ERROR(resp[0])) {
 801a8b8:	9a02      	ldr	r2, [sp, #8]
 801a8ba:	4b05      	ldr	r3, [pc, #20]	; (801a8d0 <mmc_set_bus_width+0x80>)
 801a8bc:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 801a8be:	2b00      	cmp	r3, #0
 801a8c0:	d001      	beq.n	801a8c6 <mmc_set_bus_width+0x76>
    return HAL_FAILED;
 801a8c2:	2301      	movs	r3, #1
 801a8c4:	e000      	b.n	801a8c8 <mmc_set_bus_width+0x78>
  return HAL_SUCCESS;
 801a8c6:	2300      	movs	r3, #0
}
 801a8c8:	4618      	mov	r0, r3
 801a8ca:	b005      	add	sp, #20
 801a8cc:	f85d fb04 	ldr.w	pc, [sp], #4
 801a8d0:	fdffe008 	.word	0xfdffe008
	...

0801a8e0 <_sdc_wait_for_transfer_state>:
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 801a8e0:	b500      	push	{lr}
 801a8e2:	b085      	sub	sp, #20
 801a8e4:	9001      	str	r0, [sp, #4]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 801a8e6:	9b01      	ldr	r3, [sp, #4]
 801a8e8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801a8ea:	ab03      	add	r3, sp, #12
 801a8ec:	210d      	movs	r1, #13
 801a8ee:	9801      	ldr	r0, [sp, #4]
 801a8f0:	f7fb fcee 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a8f4:	4603      	mov	r3, r0
 801a8f6:	2b00      	cmp	r3, #0
 801a8f8:	d104      	bne.n	801a904 <_sdc_wait_for_transfer_state+0x24>
        MMCSD_R1_ERROR(resp[0])) {
 801a8fa:	9a03      	ldr	r2, [sp, #12]
 801a8fc:	4b0d      	ldr	r3, [pc, #52]	; (801a934 <_sdc_wait_for_transfer_state+0x54>)
 801a8fe:	4013      	ands	r3, r2
                                   sdcp->rca, resp) ||
 801a900:	2b00      	cmp	r3, #0
 801a902:	d001      	beq.n	801a908 <_sdc_wait_for_transfer_state+0x28>
      return HAL_FAILED;
 801a904:	2301      	movs	r3, #1
 801a906:	e011      	b.n	801a92c <_sdc_wait_for_transfer_state+0x4c>
    switch (MMCSD_R1_STS(resp[0])) {
 801a908:	9b03      	ldr	r3, [sp, #12]
 801a90a:	0a5b      	lsrs	r3, r3, #9
 801a90c:	f003 030f 	and.w	r3, r3, #15
 801a910:	2b04      	cmp	r3, #4
 801a912:	d004      	beq.n	801a91e <_sdc_wait_for_transfer_state+0x3e>
 801a914:	2b04      	cmp	r3, #4
 801a916:	d308      	bcc.n	801a92a <_sdc_wait_for_transfer_state+0x4a>
 801a918:	2b07      	cmp	r3, #7
 801a91a:	d806      	bhi.n	801a92a <_sdc_wait_for_transfer_state+0x4a>
 801a91c:	e001      	b.n	801a922 <_sdc_wait_for_transfer_state+0x42>
      return HAL_SUCCESS;
 801a91e:	2300      	movs	r3, #0
 801a920:	e004      	b.n	801a92c <_sdc_wait_for_transfer_state+0x4c>
      osalThreadSleepMilliseconds(1);
 801a922:	200a      	movs	r0, #10
 801a924:	f7ff fd04 	bl	801a330 <osalThreadSleep>
 801a928:	e7dd      	b.n	801a8e6 <_sdc_wait_for_transfer_state+0x6>
      return HAL_FAILED;
 801a92a:	2301      	movs	r3, #1
}
 801a92c:	4618      	mov	r0, r3
 801a92e:	b005      	add	sp, #20
 801a930:	f85d fb04 	ldr.w	pc, [sp], #4
 801a934:	fdffe008 	.word	0xfdffe008
	...

0801a940 <sdcInit>:
void sdcInit(void) {
 801a940:	b508      	push	{r3, lr}
  sdc_lld_init();
 801a942:	f7fb fbe5 	bl	8016110 <sdc_lld_init>
}
 801a946:	bd08      	pop	{r3, pc}
	...

0801a950 <sdcObjectInit>:
void sdcObjectInit(SDCDriver *sdcp) {
 801a950:	b082      	sub	sp, #8
 801a952:	9001      	str	r0, [sp, #4]
  sdcp->vmt      = &sdc_vmt;
 801a954:	9b01      	ldr	r3, [sp, #4]
 801a956:	4a08      	ldr	r2, [pc, #32]	; (801a978 <sdcObjectInit+0x28>)
 801a958:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 801a95a:	9b01      	ldr	r3, [sp, #4]
 801a95c:	2201      	movs	r2, #1
 801a95e:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 801a960:	9b01      	ldr	r3, [sp, #4]
 801a962:	2200      	movs	r2, #0
 801a964:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 801a966:	9b01      	ldr	r3, [sp, #4]
 801a968:	2200      	movs	r2, #0
 801a96a:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 801a96c:	9b01      	ldr	r3, [sp, #4]
 801a96e:	2200      	movs	r2, #0
 801a970:	629a      	str	r2, [r3, #40]	; 0x28
}
 801a972:	b002      	add	sp, #8
 801a974:	4770      	bx	lr
 801a976:	bf00      	nop
 801a978:	08022fa0 	.word	0x08022fa0
 801a97c:	00000000 	.word	0x00000000

0801a980 <sdcConnect>:
bool sdcConnect(SDCDriver *sdcp) {
 801a980:	b500      	push	{lr}
 801a982:	b089      	sub	sp, #36	; 0x24
 801a984:	9003      	str	r0, [sp, #12]
  sdcbusclk_t clk = SDC_CLK_25MHz;
 801a986:	2300      	movs	r3, #0
 801a988:	f88d 3017 	strb.w	r3, [sp, #23]
  sdcp->state = BLK_CONNECTING;
 801a98c:	9b03      	ldr	r3, [sp, #12]
 801a98e:	2203      	movs	r2, #3
 801a990:	711a      	strb	r2, [r3, #4]
  sdc_lld_start_clk(sdcp);
 801a992:	9803      	ldr	r0, [sp, #12]
 801a994:	f7fb fbd4 	bl	8016140 <sdc_lld_start_clk>
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 801a998:	2200      	movs	r2, #0
 801a99a:	2100      	movs	r1, #0
 801a99c:	9803      	ldr	r0, [sp, #12]
 801a99e:	f7fb fc37 	bl	8016210 <sdc_lld_send_cmd_none>
  if (HAL_FAILED == mode_detect(sdcp)) {
 801a9a2:	9803      	ldr	r0, [sp, #12]
 801a9a4:	f7ff fcd4 	bl	801a350 <mode_detect>
 801a9a8:	4603      	mov	r3, r0
 801a9aa:	2b00      	cmp	r3, #0
 801a9ac:	f040 80b4 	bne.w	801ab18 <sdcConnect+0x198>
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 801a9b0:	9b03      	ldr	r3, [sp, #12]
 801a9b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a9b4:	f003 030f 	and.w	r3, r3, #15
 801a9b8:	2b02      	cmp	r3, #2
 801a9ba:	d107      	bne.n	801a9cc <sdcConnect+0x4c>
    if (HAL_FAILED == mmc_init(sdcp)) {
 801a9bc:	9803      	ldr	r0, [sp, #12]
 801a9be:	f7ff fd17 	bl	801a3f0 <mmc_init>
 801a9c2:	4603      	mov	r3, r0
 801a9c4:	2b00      	cmp	r3, #0
 801a9c6:	f040 80a7 	bne.w	801ab18 <sdcConnect+0x198>
 801a9ca:	e006      	b.n	801a9da <sdcConnect+0x5a>
    if (HAL_FAILED == sdc_init(sdcp)) {
 801a9cc:	9803      	ldr	r0, [sp, #12]
 801a9ce:	f7ff fd47 	bl	801a460 <sdc_init>
 801a9d2:	4603      	mov	r3, r0
 801a9d4:	2b00      	cmp	r3, #0
 801a9d6:	f040 809f 	bne.w	801ab18 <sdcConnect+0x198>
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 801a9da:	9b03      	ldr	r3, [sp, #12]
 801a9dc:	3308      	adds	r3, #8
 801a9de:	2200      	movs	r2, #0
 801a9e0:	2102      	movs	r1, #2
 801a9e2:	9803      	ldr	r0, [sp, #12]
 801a9e4:	f7fb fcb4 	bl	8016350 <sdc_lld_send_cmd_long_crc>
 801a9e8:	4603      	mov	r3, r0
 801a9ea:	2b00      	cmp	r3, #0
 801a9ec:	f040 8094 	bne.w	801ab18 <sdcConnect+0x198>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 801a9f0:	9b03      	ldr	r3, [sp, #12]
 801a9f2:	3338      	adds	r3, #56	; 0x38
 801a9f4:	2200      	movs	r2, #0
 801a9f6:	2103      	movs	r1, #3
 801a9f8:	9803      	ldr	r0, [sp, #12]
 801a9fa:	f7fb fc69 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801a9fe:	4603      	mov	r3, r0
 801aa00:	2b00      	cmp	r3, #0
 801aa02:	f040 8089 	bne.w	801ab18 <sdcConnect+0x198>
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 801aa06:	9b03      	ldr	r3, [sp, #12]
 801aa08:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 801aa0a:	9b03      	ldr	r3, [sp, #12]
 801aa0c:	3318      	adds	r3, #24
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 801aa0e:	2109      	movs	r1, #9
 801aa10:	9803      	ldr	r0, [sp, #12]
 801aa12:	f7fb fc9d 	bl	8016350 <sdc_lld_send_cmd_long_crc>
 801aa16:	4603      	mov	r3, r0
 801aa18:	2b00      	cmp	r3, #0
 801aa1a:	d17d      	bne.n	801ab18 <sdcConnect+0x198>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 801aa1c:	9b03      	ldr	r3, [sp, #12]
 801aa1e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801aa20:	ab06      	add	r3, sp, #24
 801aa22:	2107      	movs	r1, #7
 801aa24:	9803      	ldr	r0, [sp, #12]
 801aa26:	f7fb fc53 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801aa2a:	4603      	mov	r3, r0
 801aa2c:	2b00      	cmp	r3, #0
 801aa2e:	d173      	bne.n	801ab18 <sdcConnect+0x198>
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 801aa30:	f10d 0317 	add.w	r3, sp, #23
 801aa34:	4619      	mov	r1, r3
 801aa36:	9803      	ldr	r0, [sp, #12]
 801aa38:	f7ff feaa 	bl	801a790 <detect_bus_clk>
 801aa3c:	4603      	mov	r3, r0
 801aa3e:	2b00      	cmp	r3, #0
 801aa40:	d16a      	bne.n	801ab18 <sdcConnect+0x198>
  sdc_lld_set_data_clk(sdcp, clk);
 801aa42:	f89d 3017 	ldrb.w	r3, [sp, #23]
 801aa46:	4619      	mov	r1, r3
 801aa48:	9803      	ldr	r0, [sp, #12]
 801aa4a:	f7fb fb99 	bl	8016180 <sdc_lld_set_data_clk>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 801aa4e:	9b03      	ldr	r3, [sp, #12]
 801aa50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801aa52:	f003 030f 	and.w	r3, r3, #15
 801aa56:	2b02      	cmp	r3, #2
 801aa58:	d12c      	bne.n	801aab4 <sdcConnect+0x134>
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 801aa5a:	9b03      	ldr	r3, [sp, #12]
 801aa5c:	3318      	adds	r3, #24
 801aa5e:	227e      	movs	r2, #126	; 0x7e
 801aa60:	217f      	movs	r1, #127	; 0x7f
 801aa62:	4618      	mov	r0, r3
 801aa64:	f7ff fb24 	bl	801a0b0 <_mmcsd_get_slice>
 801aa68:	4603      	mov	r3, r0
 801aa6a:	2b01      	cmp	r3, #1
 801aa6c:	d919      	bls.n	801aaa2 <sdcConnect+0x122>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 801aa6e:	9b03      	ldr	r3, [sp, #12]
 801aa70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801aa72:	681b      	ldr	r3, [r3, #0]
 801aa74:	9307      	str	r3, [sp, #28]
      if (NULL == ext_csd) {
 801aa76:	9b07      	ldr	r3, [sp, #28]
 801aa78:	2b00      	cmp	r3, #0
 801aa7a:	d04d      	beq.n	801ab18 <sdcConnect+0x198>
      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 801aa7c:	2300      	movs	r3, #0
 801aa7e:	9300      	str	r3, [sp, #0]
 801aa80:	2308      	movs	r3, #8
 801aa82:	f44f 7200 	mov.w	r2, #512	; 0x200
 801aa86:	9907      	ldr	r1, [sp, #28]
 801aa88:	9803      	ldr	r0, [sp, #12]
 801aa8a:	f7fb fcb1 	bl	80163f0 <sdc_lld_read_special>
 801aa8e:	4603      	mov	r3, r0
 801aa90:	2b00      	cmp	r3, #0
 801aa92:	d141      	bne.n	801ab18 <sdcConnect+0x198>
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 801aa94:	9807      	ldr	r0, [sp, #28]
 801aa96:	f7ff fb83 	bl	801a1a0 <_mmcsd_get_capacity_ext>
 801aa9a:	4602      	mov	r2, r0
 801aa9c:	9b03      	ldr	r3, [sp, #12]
 801aa9e:	629a      	str	r2, [r3, #40]	; 0x28
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 801aaa0:	e010      	b.n	801aac4 <sdcConnect+0x144>
 801aaa2:	9b03      	ldr	r3, [sp, #12]
 801aaa4:	3318      	adds	r3, #24
 801aaa6:	4618      	mov	r0, r3
 801aaa8:	f7ff fb42 	bl	801a130 <_mmcsd_get_capacity>
 801aaac:	4602      	mov	r2, r0
 801aaae:	9b03      	ldr	r3, [sp, #12]
 801aab0:	629a      	str	r2, [r3, #40]	; 0x28
 801aab2:	e007      	b.n	801aac4 <sdcConnect+0x144>
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 801aab4:	9b03      	ldr	r3, [sp, #12]
 801aab6:	3318      	adds	r3, #24
 801aab8:	4618      	mov	r0, r3
 801aaba:	f7ff fb39 	bl	801a130 <_mmcsd_get_capacity>
 801aabe:	4602      	mov	r2, r0
 801aac0:	9b03      	ldr	r3, [sp, #12]
 801aac2:	629a      	str	r2, [r3, #40]	; 0x28
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 801aac4:	ab06      	add	r3, sp, #24
 801aac6:	f44f 7200 	mov.w	r2, #512	; 0x200
 801aaca:	2110      	movs	r1, #16
 801aacc:	9803      	ldr	r0, [sp, #12]
 801aace:	f7fb fbff 	bl	80162d0 <sdc_lld_send_cmd_short_crc>
 801aad2:	4603      	mov	r3, r0
 801aad4:	2b00      	cmp	r3, #0
 801aad6:	d11f      	bne.n	801ab18 <sdcConnect+0x198>
      MMCSD_R1_ERROR(resp[0])) {
 801aad8:	9a06      	ldr	r2, [sp, #24]
 801aada:	4b15      	ldr	r3, [pc, #84]	; (801ab30 <sdcConnect+0x1b0>)
 801aadc:	4013      	ands	r3, r2
                                 MMCSD_BLOCK_SIZE, resp) ||
 801aade:	2b00      	cmp	r3, #0
 801aae0:	d11a      	bne.n	801ab18 <sdcConnect+0x198>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 801aae2:	9b03      	ldr	r3, [sp, #12]
 801aae4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801aae6:	f003 030f 	and.w	r3, r3, #15
 801aaea:	2b01      	cmp	r3, #1
 801aaec:	d902      	bls.n	801aaf4 <sdcConnect+0x174>
 801aaee:	2b02      	cmp	r3, #2
 801aaf0:	d007      	beq.n	801ab02 <sdcConnect+0x182>
 801aaf2:	e011      	b.n	801ab18 <sdcConnect+0x198>
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 801aaf4:	9803      	ldr	r0, [sp, #12]
 801aaf6:	f7ff fe6b 	bl	801a7d0 <sdc_set_bus_width>
 801aafa:	4603      	mov	r3, r0
 801aafc:	2b00      	cmp	r3, #0
 801aafe:	d10b      	bne.n	801ab18 <sdcConnect+0x198>
 801ab00:	e005      	b.n	801ab0e <sdcConnect+0x18e>
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 801ab02:	9803      	ldr	r0, [sp, #12]
 801ab04:	f7ff fea4 	bl	801a850 <mmc_set_bus_width>
 801ab08:	4603      	mov	r3, r0
 801ab0a:	2b00      	cmp	r3, #0
 801ab0c:	d104      	bne.n	801ab18 <sdcConnect+0x198>
  sdcp->state = BLK_READY;
 801ab0e:	9b03      	ldr	r3, [sp, #12]
 801ab10:	2205      	movs	r2, #5
 801ab12:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 801ab14:	2300      	movs	r3, #0
 801ab16:	e006      	b.n	801ab26 <sdcConnect+0x1a6>
  sdc_lld_stop_clk(sdcp);
 801ab18:	9803      	ldr	r0, [sp, #12]
 801ab1a:	f7fb fb41 	bl	80161a0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 801ab1e:	9b03      	ldr	r3, [sp, #12]
 801ab20:	2202      	movs	r2, #2
 801ab22:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 801ab24:	2301      	movs	r3, #1
}
 801ab26:	4618      	mov	r0, r3
 801ab28:	b009      	add	sp, #36	; 0x24
 801ab2a:	f85d fb04 	ldr.w	pc, [sp], #4
 801ab2e:	bf00      	nop
 801ab30:	fdffe008 	.word	0xfdffe008

0801ab34 <__locale_mb_cur_max>:
 801ab34:	4b04      	ldr	r3, [pc, #16]	; (801ab48 <__locale_mb_cur_max+0x14>)
 801ab36:	4a05      	ldr	r2, [pc, #20]	; (801ab4c <__locale_mb_cur_max+0x18>)
 801ab38:	681b      	ldr	r3, [r3, #0]
 801ab3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801ab3c:	2b00      	cmp	r3, #0
 801ab3e:	bf08      	it	eq
 801ab40:	4613      	moveq	r3, r2
 801ab42:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 801ab46:	4770      	bx	lr
 801ab48:	20004474 	.word	0x20004474
 801ab4c:	200048a0 	.word	0x200048a0

0801ab50 <__locale_ctype_ptr_l>:
 801ab50:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 801ab54:	4770      	bx	lr
 801ab56:	bf00      	nop

0801ab58 <__locale_ctype_ptr>:
 801ab58:	4b04      	ldr	r3, [pc, #16]	; (801ab6c <__locale_ctype_ptr+0x14>)
 801ab5a:	4a05      	ldr	r2, [pc, #20]	; (801ab70 <__locale_ctype_ptr+0x18>)
 801ab5c:	681b      	ldr	r3, [r3, #0]
 801ab5e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801ab60:	2b00      	cmp	r3, #0
 801ab62:	bf08      	it	eq
 801ab64:	4613      	moveq	r3, r2
 801ab66:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 801ab6a:	4770      	bx	lr
 801ab6c:	20004474 	.word	0x20004474
 801ab70:	200048a0 	.word	0x200048a0

0801ab74 <__ascii_mbtowc>:
 801ab74:	b082      	sub	sp, #8
 801ab76:	b149      	cbz	r1, 801ab8c <__ascii_mbtowc+0x18>
 801ab78:	b15a      	cbz	r2, 801ab92 <__ascii_mbtowc+0x1e>
 801ab7a:	b16b      	cbz	r3, 801ab98 <__ascii_mbtowc+0x24>
 801ab7c:	7813      	ldrb	r3, [r2, #0]
 801ab7e:	600b      	str	r3, [r1, #0]
 801ab80:	7812      	ldrb	r2, [r2, #0]
 801ab82:	1c10      	adds	r0, r2, #0
 801ab84:	bf18      	it	ne
 801ab86:	2001      	movne	r0, #1
 801ab88:	b002      	add	sp, #8
 801ab8a:	4770      	bx	lr
 801ab8c:	a901      	add	r1, sp, #4
 801ab8e:	2a00      	cmp	r2, #0
 801ab90:	d1f3      	bne.n	801ab7a <__ascii_mbtowc+0x6>
 801ab92:	4610      	mov	r0, r2
 801ab94:	b002      	add	sp, #8
 801ab96:	4770      	bx	lr
 801ab98:	f06f 0001 	mvn.w	r0, #1
 801ab9c:	e7f4      	b.n	801ab88 <__ascii_mbtowc+0x14>
 801ab9e:	bf00      	nop

0801aba0 <match_string>:
 801aba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801aba4:	4607      	mov	r7, r0
 801aba6:	6808      	ldr	r0, [r1, #0]
 801aba8:	b1c0      	cbz	r0, 801abdc <match_string+0x3c>
 801abaa:	460c      	mov	r4, r1
 801abac:	4690      	mov	r8, r2
 801abae:	2500      	movs	r5, #0
 801abb0:	e003      	b.n	801abba <match_string+0x1a>
 801abb2:	f854 0f04 	ldr.w	r0, [r4, #4]!
 801abb6:	3501      	adds	r5, #1
 801abb8:	b180      	cbz	r0, 801abdc <match_string+0x3c>
 801abba:	f7e9 fd41 	bl	8004640 <strlen>
 801abbe:	4643      	mov	r3, r8
 801abc0:	4606      	mov	r6, r0
 801abc2:	4602      	mov	r2, r0
 801abc4:	6821      	ldr	r1, [r4, #0]
 801abc6:	6838      	ldr	r0, [r7, #0]
 801abc8:	f001 fc36 	bl	801c438 <strncasecmp_l>
 801abcc:	2800      	cmp	r0, #0
 801abce:	d1f0      	bne.n	801abb2 <match_string+0x12>
 801abd0:	683b      	ldr	r3, [r7, #0]
 801abd2:	441e      	add	r6, r3
 801abd4:	603e      	str	r6, [r7, #0]
 801abd6:	4628      	mov	r0, r5
 801abd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801abdc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 801abe0:	4628      	mov	r0, r5
 801abe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801abe6:	bf00      	nop

0801abe8 <strptime_l>:
 801abe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801abec:	b085      	sub	sp, #20
 801abee:	f891 8000 	ldrb.w	r8, [r1]
 801abf2:	9001      	str	r0, [sp, #4]
 801abf4:	f1b8 0f00 	cmp.w	r8, #0
 801abf8:	d040      	beq.n	801ac7c <strptime_l+0x94>
 801abfa:	460d      	mov	r5, r1
 801abfc:	4616      	mov	r6, r2
 801abfe:	461c      	mov	r4, r3
 801ac00:	f8df a590 	ldr.w	sl, [pc, #1424]	; 801b194 <strptime_l+0x5ac>
 801ac04:	f8df b590 	ldr.w	fp, [pc, #1424]	; 801b198 <strptime_l+0x5b0>
 801ac08:	2700      	movs	r7, #0
 801ac0a:	e00f      	b.n	801ac2c <strptime_l+0x44>
 801ac0c:	f1b8 0f25 	cmp.w	r8, #37	; 0x25
 801ac10:	d038      	beq.n	801ac84 <strptime_l+0x9c>
 801ac12:	9b01      	ldr	r3, [sp, #4]
 801ac14:	781a      	ldrb	r2, [r3, #0]
 801ac16:	4542      	cmp	r2, r8
 801ac18:	f040 8147 	bne.w	801aeaa <strptime_l+0x2c2>
 801ac1c:	3301      	adds	r3, #1
 801ac1e:	9301      	str	r3, [sp, #4]
 801ac20:	f895 8001 	ldrb.w	r8, [r5, #1]
 801ac24:	3501      	adds	r5, #1
 801ac26:	f1b8 0f00 	cmp.w	r8, #0
 801ac2a:	d018      	beq.n	801ac5e <strptime_l+0x76>
 801ac2c:	4620      	mov	r0, r4
 801ac2e:	f7ff ff8f 	bl	801ab50 <__locale_ctype_ptr_l>
 801ac32:	4440      	add	r0, r8
 801ac34:	7843      	ldrb	r3, [r0, #1]
 801ac36:	0719      	lsls	r1, r3, #28
 801ac38:	d401      	bmi.n	801ac3e <strptime_l+0x56>
 801ac3a:	e7e7      	b.n	801ac0c <strptime_l+0x24>
 801ac3c:	9301      	str	r3, [sp, #4]
 801ac3e:	4620      	mov	r0, r4
 801ac40:	f7ff ff86 	bl	801ab50 <__locale_ctype_ptr_l>
 801ac44:	9b01      	ldr	r3, [sp, #4]
 801ac46:	781a      	ldrb	r2, [r3, #0]
 801ac48:	4410      	add	r0, r2
 801ac4a:	3301      	adds	r3, #1
 801ac4c:	7842      	ldrb	r2, [r0, #1]
 801ac4e:	0712      	lsls	r2, r2, #28
 801ac50:	d4f4      	bmi.n	801ac3c <strptime_l+0x54>
 801ac52:	f895 8001 	ldrb.w	r8, [r5, #1]
 801ac56:	3501      	adds	r5, #1
 801ac58:	f1b8 0f00 	cmp.w	r8, #0
 801ac5c:	d1e6      	bne.n	801ac2c <strptime_l+0x44>
 801ac5e:	f007 0307 	and.w	r3, r7, #7
 801ac62:	2b07      	cmp	r3, #7
 801ac64:	f000 815d 	beq.w	801af22 <strptime_l+0x33a>
 801ac68:	f007 0314 	and.w	r3, r7, #20
 801ac6c:	2b14      	cmp	r3, #20
 801ac6e:	f007 021c 	and.w	r2, r7, #28
 801ac72:	f000 83b3 	beq.w	801b3dc <strptime_l+0x7f4>
 801ac76:	2a14      	cmp	r2, #20
 801ac78:	f000 811b 	beq.w	801aeb2 <strptime_l+0x2ca>
 801ac7c:	9801      	ldr	r0, [sp, #4]
 801ac7e:	b005      	add	sp, #20
 801ac80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ac84:	786b      	ldrb	r3, [r5, #1]
 801ac86:	2b00      	cmp	r3, #0
 801ac88:	d0c3      	beq.n	801ac12 <strptime_l+0x2a>
 801ac8a:	2b45      	cmp	r3, #69	; 0x45
 801ac8c:	f000 80fe 	beq.w	801ae8c <strptime_l+0x2a4>
 801ac90:	2b4f      	cmp	r3, #79	; 0x4f
 801ac92:	f000 80fb 	beq.w	801ae8c <strptime_l+0x2a4>
 801ac96:	3501      	adds	r5, #1
 801ac98:	2b79      	cmp	r3, #121	; 0x79
 801ac9a:	f200 837a 	bhi.w	801b392 <strptime_l+0x7aa>
 801ac9e:	a201      	add	r2, pc, #4	; (adr r2, 801aca4 <strptime_l+0xbc>)
 801aca0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801aca4:	0801af2f 	.word	0x0801af2f
 801aca8:	0801b393 	.word	0x0801b393
 801acac:	0801b393 	.word	0x0801b393
 801acb0:	0801b393 	.word	0x0801b393
 801acb4:	0801b393 	.word	0x0801b393
 801acb8:	0801b393 	.word	0x0801b393
 801acbc:	0801b393 	.word	0x0801b393
 801acc0:	0801b393 	.word	0x0801b393
 801acc4:	0801b393 	.word	0x0801b393
 801acc8:	0801b393 	.word	0x0801b393
 801accc:	0801b393 	.word	0x0801b393
 801acd0:	0801b393 	.word	0x0801b393
 801acd4:	0801b393 	.word	0x0801b393
 801acd8:	0801b393 	.word	0x0801b393
 801acdc:	0801b393 	.word	0x0801b393
 801ace0:	0801b393 	.word	0x0801b393
 801ace4:	0801b393 	.word	0x0801b393
 801ace8:	0801b393 	.word	0x0801b393
 801acec:	0801b393 	.word	0x0801b393
 801acf0:	0801b393 	.word	0x0801b393
 801acf4:	0801b393 	.word	0x0801b393
 801acf8:	0801b393 	.word	0x0801b393
 801acfc:	0801b393 	.word	0x0801b393
 801ad00:	0801b393 	.word	0x0801b393
 801ad04:	0801b393 	.word	0x0801b393
 801ad08:	0801b393 	.word	0x0801b393
 801ad0c:	0801b393 	.word	0x0801b393
 801ad10:	0801b393 	.word	0x0801b393
 801ad14:	0801b393 	.word	0x0801b393
 801ad18:	0801b393 	.word	0x0801b393
 801ad1c:	0801b393 	.word	0x0801b393
 801ad20:	0801b393 	.word	0x0801b393
 801ad24:	0801b393 	.word	0x0801b393
 801ad28:	0801b393 	.word	0x0801b393
 801ad2c:	0801b393 	.word	0x0801b393
 801ad30:	0801b393 	.word	0x0801b393
 801ad34:	0801b393 	.word	0x0801b393
 801ad38:	0801af31 	.word	0x0801af31
 801ad3c:	0801b393 	.word	0x0801b393
 801ad40:	0801b393 	.word	0x0801b393
 801ad44:	0801b393 	.word	0x0801b393
 801ad48:	0801b393 	.word	0x0801b393
 801ad4c:	0801b393 	.word	0x0801b393
 801ad50:	0801b393 	.word	0x0801b393
 801ad54:	0801b393 	.word	0x0801b393
 801ad58:	0801b393 	.word	0x0801b393
 801ad5c:	0801b393 	.word	0x0801b393
 801ad60:	0801b393 	.word	0x0801b393
 801ad64:	0801b393 	.word	0x0801b393
 801ad68:	0801b393 	.word	0x0801b393
 801ad6c:	0801b393 	.word	0x0801b393
 801ad70:	0801b393 	.word	0x0801b393
 801ad74:	0801b393 	.word	0x0801b393
 801ad78:	0801b393 	.word	0x0801b393
 801ad7c:	0801b393 	.word	0x0801b393
 801ad80:	0801b393 	.word	0x0801b393
 801ad84:	0801b393 	.word	0x0801b393
 801ad88:	0801b393 	.word	0x0801b393
 801ad8c:	0801b393 	.word	0x0801b393
 801ad90:	0801b393 	.word	0x0801b393
 801ad94:	0801b393 	.word	0x0801b393
 801ad98:	0801b393 	.word	0x0801b393
 801ad9c:	0801b393 	.word	0x0801b393
 801ada0:	0801b393 	.word	0x0801b393
 801ada4:	0801b393 	.word	0x0801b393
 801ada8:	0801af61 	.word	0x0801af61
 801adac:	0801af77 	.word	0x0801af77
 801adb0:	0801af8d 	.word	0x0801af8d
 801adb4:	0801afb5 	.word	0x0801afb5
 801adb8:	0801b393 	.word	0x0801b393
 801adbc:	0801b393 	.word	0x0801b393
 801adc0:	0801b393 	.word	0x0801b393
 801adc4:	0801afd1 	.word	0x0801afd1
 801adc8:	0801afeb 	.word	0x0801afeb
 801adcc:	0801b393 	.word	0x0801b393
 801add0:	0801b393 	.word	0x0801b393
 801add4:	0801b393 	.word	0x0801b393
 801add8:	0801b00b 	.word	0x0801b00b
 801addc:	0801b393 	.word	0x0801b393
 801ade0:	0801b393 	.word	0x0801b393
 801ade4:	0801b393 	.word	0x0801b393
 801ade8:	0801b393 	.word	0x0801b393
 801adec:	0801b027 	.word	0x0801b027
 801adf0:	0801b03f 	.word	0x0801b03f
 801adf4:	0801b05b 	.word	0x0801b05b
 801adf8:	0801b06f 	.word	0x0801b06f
 801adfc:	0801b0f9 	.word	0x0801b0f9
 801ae00:	0801b19d 	.word	0x0801b19d
 801ae04:	0801ae93 	.word	0x0801ae93
 801ae08:	0801b225 	.word	0x0801b225
 801ae0c:	0801ac21 	.word	0x0801ac21
 801ae10:	0801b393 	.word	0x0801b393
 801ae14:	0801b393 	.word	0x0801b393
 801ae18:	0801b393 	.word	0x0801b393
 801ae1c:	0801b393 	.word	0x0801b393
 801ae20:	0801b393 	.word	0x0801b393
 801ae24:	0801b393 	.word	0x0801b393
 801ae28:	0801b249 	.word	0x0801b249
 801ae2c:	0801b25b 	.word	0x0801b25b
 801ae30:	0801b26d 	.word	0x0801b26d
 801ae34:	0801b28d 	.word	0x0801b28d
 801ae38:	0801b28d 	.word	0x0801b28d
 801ae3c:	0801b393 	.word	0x0801b393
 801ae40:	0801b393 	.word	0x0801b393
 801ae44:	0801b25b 	.word	0x0801b25b
 801ae48:	0801b393 	.word	0x0801b393
 801ae4c:	0801b2ad 	.word	0x0801b2ad
 801ae50:	0801afd1 	.word	0x0801afd1
 801ae54:	0801afeb 	.word	0x0801afeb
 801ae58:	0801b2cf 	.word	0x0801b2cf
 801ae5c:	0801b2f1 	.word	0x0801b2f1
 801ae60:	0801b393 	.word	0x0801b393
 801ae64:	0801b2fd 	.word	0x0801b2fd
 801ae68:	0801b393 	.word	0x0801b393
 801ae6c:	0801b321 	.word	0x0801b321
 801ae70:	0801b393 	.word	0x0801b393
 801ae74:	0801b32b 	.word	0x0801b32b
 801ae78:	0801b337 	.word	0x0801b337
 801ae7c:	0801b393 	.word	0x0801b393
 801ae80:	0801b359 	.word	0x0801b359
 801ae84:	0801b379 	.word	0x0801b379
 801ae88:	0801af3d 	.word	0x0801af3d
 801ae8c:	78ab      	ldrb	r3, [r5, #2]
 801ae8e:	3502      	adds	r5, #2
 801ae90:	e702      	b.n	801ac98 <strptime_l+0xb0>
 801ae92:	4bba      	ldr	r3, [pc, #744]	; (801b17c <strptime_l+0x594>)
 801ae94:	9801      	ldr	r0, [sp, #4]
 801ae96:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
 801ae9a:	4623      	mov	r3, r4
 801ae9c:	4632      	mov	r2, r6
 801ae9e:	f7ff fea3 	bl	801abe8 <strptime_l>
 801aea2:	9003      	str	r0, [sp, #12]
 801aea4:	2800      	cmp	r0, #0
 801aea6:	f040 80c8 	bne.w	801b03a <strptime_l+0x452>
 801aeaa:	2000      	movs	r0, #0
 801aeac:	b005      	add	sp, #20
 801aeae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801aeb2:	6974      	ldr	r4, [r6, #20]
 801aeb4:	f240 75b1 	movw	r5, #1969	; 0x7b1
 801aeb8:	f204 746b 	addw	r4, r4, #1899	; 0x76b
 801aebc:	42ac      	cmp	r4, r5
 801aebe:	f340 8278 	ble.w	801b3b2 <strptime_l+0x7ca>
 801aec2:	f8df c2d4 	ldr.w	ip, [pc, #724]	; 801b198 <strptime_l+0x5b0>
 801aec6:	f8df e2cc 	ldr.w	lr, [pc, #716]	; 801b194 <strptime_l+0x5ac>
 801aeca:	2304      	movs	r3, #4
 801aecc:	2764      	movs	r7, #100	; 0x64
 801aece:	f44f 78c8 	mov.w	r8, #400	; 0x190
 801aed2:	e018      	b.n	801af06 <strptime_l+0x31e>
 801aed4:	ebc2 13e9 	rsb	r3, r2, r9, asr #7
 801aed8:	fb08 4313 	mls	r3, r8, r3, r4
 801aedc:	fab3 f383 	clz	r3, r3
 801aee0:	2800      	cmp	r0, #0
 801aee2:	f040 8264 	bne.w	801b3ae <strptime_l+0x7c6>
 801aee6:	095b      	lsrs	r3, r3, #5
 801aee8:	18ca      	adds	r2, r1, r3
 801aeea:	fb8e 1302 	smull	r1, r3, lr, r2
 801aeee:	1899      	adds	r1, r3, r2
 801aef0:	17d3      	asrs	r3, r2, #31
 801aef2:	ebc3 03a1 	rsb	r3, r3, r1, asr #2
 801aef6:	3c01      	subs	r4, #1
 801aef8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801aefc:	42ac      	cmp	r4, r5
 801aefe:	eba2 0303 	sub.w	r3, r2, r3
 801af02:	f000 8257 	beq.w	801b3b4 <strptime_l+0x7cc>
 801af06:	fb8c 2904 	smull	r2, r9, ip, r4
 801af0a:	17e2      	asrs	r2, r4, #31
 801af0c:	ebc2 1069 	rsb	r0, r2, r9, asr #5
 801af10:	f014 0f03 	tst.w	r4, #3
 801af14:	f203 116d 	addw	r1, r3, #365	; 0x16d
 801af18:	fb07 4010 	mls	r0, r7, r0, r4
 801af1c:	d0da      	beq.n	801aed4 <strptime_l+0x2ec>
 801af1e:	2300      	movs	r3, #0
 801af20:	e7e2      	b.n	801aee8 <strptime_l+0x300>
 801af22:	06f8      	lsls	r0, r7, #27
 801af24:	f140 8284 	bpl.w	801b430 <strptime_l+0x848>
 801af28:	f007 021c 	and.w	r2, r7, #28
 801af2c:	e6a3      	b.n	801ac76 <strptime_l+0x8e>
 801af2e:	3d01      	subs	r5, #1
 801af30:	9b01      	ldr	r3, [sp, #4]
 801af32:	781a      	ldrb	r2, [r3, #0]
 801af34:	2a25      	cmp	r2, #37	; 0x25
 801af36:	f43f ae71 	beq.w	801ac1c <strptime_l+0x34>
 801af3a:	e7b6      	b.n	801aeaa <strptime_l+0x2c2>
 801af3c:	4623      	mov	r3, r4
 801af3e:	220a      	movs	r2, #10
 801af40:	a903      	add	r1, sp, #12
 801af42:	9801      	ldr	r0, [sp, #4]
 801af44:	f000 fc06 	bl	801b754 <strtol_l>
 801af48:	9b03      	ldr	r3, [sp, #12]
 801af4a:	9a01      	ldr	r2, [sp, #4]
 801af4c:	4293      	cmp	r3, r2
 801af4e:	d0ac      	beq.n	801aeaa <strptime_l+0x2c2>
 801af50:	2845      	cmp	r0, #69	; 0x45
 801af52:	bfd8      	it	le
 801af54:	3064      	addle	r0, #100	; 0x64
 801af56:	6170      	str	r0, [r6, #20]
 801af58:	9301      	str	r3, [sp, #4]
 801af5a:	f047 0704 	orr.w	r7, r7, #4
 801af5e:	e65f      	b.n	801ac20 <strptime_l+0x38>
 801af60:	4622      	mov	r2, r4
 801af62:	4987      	ldr	r1, [pc, #540]	; (801b180 <strptime_l+0x598>)
 801af64:	a801      	add	r0, sp, #4
 801af66:	f7ff fe1b 	bl	801aba0 <match_string>
 801af6a:	2800      	cmp	r0, #0
 801af6c:	db9d      	blt.n	801aeaa <strptime_l+0x2c2>
 801af6e:	61b0      	str	r0, [r6, #24]
 801af70:	f047 0708 	orr.w	r7, r7, #8
 801af74:	e654      	b.n	801ac20 <strptime_l+0x38>
 801af76:	4622      	mov	r2, r4
 801af78:	4982      	ldr	r1, [pc, #520]	; (801b184 <strptime_l+0x59c>)
 801af7a:	a801      	add	r0, sp, #4
 801af7c:	f7ff fe10 	bl	801aba0 <match_string>
 801af80:	2800      	cmp	r0, #0
 801af82:	db92      	blt.n	801aeaa <strptime_l+0x2c2>
 801af84:	6130      	str	r0, [r6, #16]
 801af86:	f047 0702 	orr.w	r7, r7, #2
 801af8a:	e649      	b.n	801ac20 <strptime_l+0x38>
 801af8c:	4623      	mov	r3, r4
 801af8e:	220a      	movs	r2, #10
 801af90:	a903      	add	r1, sp, #12
 801af92:	9801      	ldr	r0, [sp, #4]
 801af94:	f000 fbde 	bl	801b754 <strtol_l>
 801af98:	9a03      	ldr	r2, [sp, #12]
 801af9a:	9b01      	ldr	r3, [sp, #4]
 801af9c:	429a      	cmp	r2, r3
 801af9e:	d084      	beq.n	801aeaa <strptime_l+0x2c2>
 801afa0:	2364      	movs	r3, #100	; 0x64
 801afa2:	fb03 f300 	mul.w	r3, r3, r0
 801afa6:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 801afaa:	9201      	str	r2, [sp, #4]
 801afac:	f047 0704 	orr.w	r7, r7, #4
 801afb0:	6173      	str	r3, [r6, #20]
 801afb2:	e635      	b.n	801ac20 <strptime_l+0x38>
 801afb4:	4623      	mov	r3, r4
 801afb6:	4632      	mov	r2, r6
 801afb8:	4973      	ldr	r1, [pc, #460]	; (801b188 <strptime_l+0x5a0>)
 801afba:	9801      	ldr	r0, [sp, #4]
 801afbc:	f7ff fe14 	bl	801abe8 <strptime_l>
 801afc0:	9003      	str	r0, [sp, #12]
 801afc2:	2800      	cmp	r0, #0
 801afc4:	f43f af71 	beq.w	801aeaa <strptime_l+0x2c2>
 801afc8:	9001      	str	r0, [sp, #4]
 801afca:	f047 0707 	orr.w	r7, r7, #7
 801afce:	e627      	b.n	801ac20 <strptime_l+0x38>
 801afd0:	4623      	mov	r3, r4
 801afd2:	220a      	movs	r2, #10
 801afd4:	a903      	add	r1, sp, #12
 801afd6:	9801      	ldr	r0, [sp, #4]
 801afd8:	f000 fbbc 	bl	801b754 <strtol_l>
 801afdc:	9b03      	ldr	r3, [sp, #12]
 801afde:	9a01      	ldr	r2, [sp, #4]
 801afe0:	4293      	cmp	r3, r2
 801afe2:	f43f af62 	beq.w	801aeaa <strptime_l+0x2c2>
 801afe6:	60b0      	str	r0, [r6, #8]
 801afe8:	e619      	b.n	801ac1e <strptime_l+0x36>
 801afea:	4623      	mov	r3, r4
 801afec:	220a      	movs	r2, #10
 801afee:	a903      	add	r1, sp, #12
 801aff0:	9801      	ldr	r0, [sp, #4]
 801aff2:	f000 fbaf 	bl	801b754 <strtol_l>
 801aff6:	9b03      	ldr	r3, [sp, #12]
 801aff8:	9a01      	ldr	r2, [sp, #4]
 801affa:	4293      	cmp	r3, r2
 801affc:	f43f af55 	beq.w	801aeaa <strptime_l+0x2c2>
 801b000:	280c      	cmp	r0, #12
 801b002:	d1f0      	bne.n	801afe6 <strptime_l+0x3fe>
 801b004:	2200      	movs	r2, #0
 801b006:	60b2      	str	r2, [r6, #8]
 801b008:	e609      	b.n	801ac1e <strptime_l+0x36>
 801b00a:	4623      	mov	r3, r4
 801b00c:	220a      	movs	r2, #10
 801b00e:	a903      	add	r1, sp, #12
 801b010:	9801      	ldr	r0, [sp, #4]
 801b012:	f000 fb9f 	bl	801b754 <strtol_l>
 801b016:	9b03      	ldr	r3, [sp, #12]
 801b018:	9a01      	ldr	r2, [sp, #4]
 801b01a:	4293      	cmp	r3, r2
 801b01c:	f43f af45 	beq.w	801aeaa <strptime_l+0x2c2>
 801b020:	6070      	str	r0, [r6, #4]
 801b022:	9301      	str	r3, [sp, #4]
 801b024:	e5fc      	b.n	801ac20 <strptime_l+0x38>
 801b026:	4623      	mov	r3, r4
 801b028:	4632      	mov	r2, r6
 801b02a:	4958      	ldr	r1, [pc, #352]	; (801b18c <strptime_l+0x5a4>)
 801b02c:	9801      	ldr	r0, [sp, #4]
 801b02e:	f7ff fddb 	bl	801abe8 <strptime_l>
 801b032:	9003      	str	r0, [sp, #12]
 801b034:	2800      	cmp	r0, #0
 801b036:	f43f af38 	beq.w	801aeaa <strptime_l+0x2c2>
 801b03a:	9001      	str	r0, [sp, #4]
 801b03c:	e5f0      	b.n	801ac20 <strptime_l+0x38>
 801b03e:	4623      	mov	r3, r4
 801b040:	220a      	movs	r2, #10
 801b042:	a903      	add	r1, sp, #12
 801b044:	9801      	ldr	r0, [sp, #4]
 801b046:	f000 fb85 	bl	801b754 <strtol_l>
 801b04a:	9b03      	ldr	r3, [sp, #12]
 801b04c:	9a01      	ldr	r2, [sp, #4]
 801b04e:	4293      	cmp	r3, r2
 801b050:	f43f af2b 	beq.w	801aeaa <strptime_l+0x2c2>
 801b054:	6030      	str	r0, [r6, #0]
 801b056:	9301      	str	r3, [sp, #4]
 801b058:	e5e2      	b.n	801ac20 <strptime_l+0x38>
 801b05a:	4623      	mov	r3, r4
 801b05c:	4632      	mov	r2, r6
 801b05e:	494c      	ldr	r1, [pc, #304]	; (801b190 <strptime_l+0x5a8>)
 801b060:	9801      	ldr	r0, [sp, #4]
 801b062:	f7ff fdc1 	bl	801abe8 <strptime_l>
 801b066:	9003      	str	r0, [sp, #12]
 801b068:	2800      	cmp	r0, #0
 801b06a:	d1e6      	bne.n	801b03a <strptime_l+0x452>
 801b06c:	e71d      	b.n	801aeaa <strptime_l+0x2c2>
 801b06e:	4623      	mov	r3, r4
 801b070:	220a      	movs	r2, #10
 801b072:	a903      	add	r1, sp, #12
 801b074:	9801      	ldr	r0, [sp, #4]
 801b076:	f000 fb6d 	bl	801b754 <strtol_l>
 801b07a:	9b03      	ldr	r3, [sp, #12]
 801b07c:	9300      	str	r3, [sp, #0]
 801b07e:	461a      	mov	r2, r3
 801b080:	9b01      	ldr	r3, [sp, #4]
 801b082:	429a      	cmp	r2, r3
 801b084:	f43f af11 	beq.w	801aeaa <strptime_l+0x2c2>
 801b088:	6973      	ldr	r3, [r6, #20]
 801b08a:	f240 78b1 	movw	r8, #1969	; 0x7b1
 801b08e:	f203 7e6b 	addw	lr, r3, #1899	; 0x76b
 801b092:	45c6      	cmp	lr, r8
 801b094:	f04f 0304 	mov.w	r3, #4
 801b098:	f340 81f3 	ble.w	801b482 <strptime_l+0x89a>
 801b09c:	f04f 0964 	mov.w	r9, #100	; 0x64
 801b0a0:	e01b      	b.n	801b0da <strptime_l+0x4f2>
 801b0a2:	ebc2 12ec 	rsb	r2, r2, ip, asr #7
 801b0a6:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 801b0aa:	fb0c e212 	mls	r2, ip, r2, lr
 801b0ae:	fab2 f282 	clz	r2, r2
 801b0b2:	2900      	cmp	r1, #0
 801b0b4:	f040 818e 	bne.w	801b3d4 <strptime_l+0x7ec>
 801b0b8:	0952      	lsrs	r2, r2, #5
 801b0ba:	441a      	add	r2, r3
 801b0bc:	fb8a 1302 	smull	r1, r3, sl, r2
 801b0c0:	4413      	add	r3, r2
 801b0c2:	17d1      	asrs	r1, r2, #31
 801b0c4:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 801b0c8:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 801b0cc:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b0d0:	45c6      	cmp	lr, r8
 801b0d2:	eba2 0303 	sub.w	r3, r2, r3
 801b0d6:	f000 81d4 	beq.w	801b482 <strptime_l+0x89a>
 801b0da:	fb8b 2c0e 	smull	r2, ip, fp, lr
 801b0de:	ea4f 72ee 	mov.w	r2, lr, asr #31
 801b0e2:	ebc2 116c 	rsb	r1, r2, ip, asr #5
 801b0e6:	f01e 0f03 	tst.w	lr, #3
 801b0ea:	f203 136d 	addw	r3, r3, #365	; 0x16d
 801b0ee:	fb09 e111 	mls	r1, r9, r1, lr
 801b0f2:	d0d6      	beq.n	801b0a2 <strptime_l+0x4ba>
 801b0f4:	2200      	movs	r2, #0
 801b0f6:	e7e0      	b.n	801b0ba <strptime_l+0x4d2>
 801b0f8:	4623      	mov	r3, r4
 801b0fa:	220a      	movs	r2, #10
 801b0fc:	a903      	add	r1, sp, #12
 801b0fe:	9801      	ldr	r0, [sp, #4]
 801b100:	f000 fb28 	bl	801b754 <strtol_l>
 801b104:	f8dd 900c 	ldr.w	r9, [sp, #12]
 801b108:	9b01      	ldr	r3, [sp, #4]
 801b10a:	9000      	str	r0, [sp, #0]
 801b10c:	4599      	cmp	r9, r3
 801b10e:	f43f aecc 	beq.w	801aeaa <strptime_l+0x2c2>
 801b112:	6970      	ldr	r0, [r6, #20]
 801b114:	f240 7cb1 	movw	ip, #1969	; 0x7b1
 801b118:	f200 706b 	addw	r0, r0, #1899	; 0x76b
 801b11c:	4560      	cmp	r0, ip
 801b11e:	f340 825c 	ble.w	801b5da <strptime_l+0x9f2>
 801b122:	2304      	movs	r3, #4
 801b124:	f04f 0864 	mov.w	r8, #100	; 0x64
 801b128:	e01a      	b.n	801b160 <strptime_l+0x578>
 801b12a:	ebc2 12ee 	rsb	r2, r2, lr, asr #7
 801b12e:	f44f 7ec8 	mov.w	lr, #400	; 0x190
 801b132:	fb0e 0212 	mls	r2, lr, r2, r0
 801b136:	fab2 f282 	clz	r2, r2
 801b13a:	2900      	cmp	r1, #0
 801b13c:	f040 814c 	bne.w	801b3d8 <strptime_l+0x7f0>
 801b140:	0952      	lsrs	r2, r2, #5
 801b142:	441a      	add	r2, r3
 801b144:	fb8a 1302 	smull	r1, r3, sl, r2
 801b148:	4413      	add	r3, r2
 801b14a:	17d1      	asrs	r1, r2, #31
 801b14c:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 801b150:	3801      	subs	r0, #1
 801b152:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b156:	4560      	cmp	r0, ip
 801b158:	eba2 0303 	sub.w	r3, r2, r3
 801b15c:	f000 81a0 	beq.w	801b4a0 <strptime_l+0x8b8>
 801b160:	fb8b 2e00 	smull	r2, lr, fp, r0
 801b164:	17c2      	asrs	r2, r0, #31
 801b166:	ebc2 116e 	rsb	r1, r2, lr, asr #5
 801b16a:	f010 0f03 	tst.w	r0, #3
 801b16e:	f203 136d 	addw	r3, r3, #365	; 0x16d
 801b172:	fb08 0111 	mls	r1, r8, r1, r0
 801b176:	d0d8      	beq.n	801b12a <strptime_l+0x542>
 801b178:	2200      	movs	r2, #0
 801b17a:	e7e2      	b.n	801b142 <strptime_l+0x55a>
 801b17c:	08024cf8 	.word	0x08024cf8
 801b180:	08024d74 	.word	0x08024d74
 801b184:	08024d28 	.word	0x08024d28
 801b188:	08024cd8 	.word	0x08024cd8
 801b18c:	08024ce4 	.word	0x08024ce4
 801b190:	08024cec 	.word	0x08024cec
 801b194:	92492493 	.word	0x92492493
 801b198:	51eb851f 	.word	0x51eb851f
 801b19c:	4623      	mov	r3, r4
 801b19e:	220a      	movs	r2, #10
 801b1a0:	a903      	add	r1, sp, #12
 801b1a2:	9801      	ldr	r0, [sp, #4]
 801b1a4:	f000 fad6 	bl	801b754 <strtol_l>
 801b1a8:	9b03      	ldr	r3, [sp, #12]
 801b1aa:	9300      	str	r3, [sp, #0]
 801b1ac:	461a      	mov	r2, r3
 801b1ae:	9b01      	ldr	r3, [sp, #4]
 801b1b0:	429a      	cmp	r2, r3
 801b1b2:	f43f ae7a 	beq.w	801aeaa <strptime_l+0x2c2>
 801b1b6:	6973      	ldr	r3, [r6, #20]
 801b1b8:	f240 78b1 	movw	r8, #1969	; 0x7b1
 801b1bc:	f203 7e6b 	addw	lr, r3, #1899	; 0x76b
 801b1c0:	45c6      	cmp	lr, r8
 801b1c2:	f340 8208 	ble.w	801b5d6 <strptime_l+0x9ee>
 801b1c6:	2304      	movs	r3, #4
 801b1c8:	f04f 0964 	mov.w	r9, #100	; 0x64
 801b1cc:	e01b      	b.n	801b206 <strptime_l+0x61e>
 801b1ce:	ebc2 12ec 	rsb	r2, r2, ip, asr #7
 801b1d2:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 801b1d6:	fb0c e212 	mls	r2, ip, r2, lr
 801b1da:	fab2 f282 	clz	r2, r2
 801b1de:	2900      	cmp	r1, #0
 801b1e0:	f040 80f6 	bne.w	801b3d0 <strptime_l+0x7e8>
 801b1e4:	0952      	lsrs	r2, r2, #5
 801b1e6:	441a      	add	r2, r3
 801b1e8:	fb8a 1302 	smull	r1, r3, sl, r2
 801b1ec:	4413      	add	r3, r2
 801b1ee:	17d1      	asrs	r1, r2, #31
 801b1f0:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 801b1f4:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 801b1f8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b1fc:	45c6      	cmp	lr, r8
 801b1fe:	eba2 0303 	sub.w	r3, r2, r3
 801b202:	f000 816c 	beq.w	801b4de <strptime_l+0x8f6>
 801b206:	fb8b 2c0e 	smull	r2, ip, fp, lr
 801b20a:	ea4f 72ee 	mov.w	r2, lr, asr #31
 801b20e:	ebc2 116c 	rsb	r1, r2, ip, asr #5
 801b212:	f01e 0f03 	tst.w	lr, #3
 801b216:	f203 136d 	addw	r3, r3, #365	; 0x16d
 801b21a:	fb09 e111 	mls	r1, r9, r1, lr
 801b21e:	d0d6      	beq.n	801b1ce <strptime_l+0x5e6>
 801b220:	2200      	movs	r2, #0
 801b222:	e7e0      	b.n	801b1e6 <strptime_l+0x5fe>
 801b224:	4623      	mov	r3, r4
 801b226:	220a      	movs	r2, #10
 801b228:	a903      	add	r1, sp, #12
 801b22a:	9801      	ldr	r0, [sp, #4]
 801b22c:	f000 fa92 	bl	801b754 <strtol_l>
 801b230:	9a03      	ldr	r2, [sp, #12]
 801b232:	9b01      	ldr	r3, [sp, #4]
 801b234:	429a      	cmp	r2, r3
 801b236:	f43f ae38 	beq.w	801aeaa <strptime_l+0x2c2>
 801b23a:	f2a0 706c 	subw	r0, r0, #1900	; 0x76c
 801b23e:	6170      	str	r0, [r6, #20]
 801b240:	9201      	str	r2, [sp, #4]
 801b242:	f047 0704 	orr.w	r7, r7, #4
 801b246:	e4eb      	b.n	801ac20 <strptime_l+0x38>
 801b248:	4622      	mov	r2, r4
 801b24a:	49ba      	ldr	r1, [pc, #744]	; (801b534 <strptime_l+0x94c>)
 801b24c:	a801      	add	r0, sp, #4
 801b24e:	f7ff fca7 	bl	801aba0 <match_string>
 801b252:	2800      	cmp	r0, #0
 801b254:	f6bf ae8b 	bge.w	801af6e <strptime_l+0x386>
 801b258:	e627      	b.n	801aeaa <strptime_l+0x2c2>
 801b25a:	4622      	mov	r2, r4
 801b25c:	49b6      	ldr	r1, [pc, #728]	; (801b538 <strptime_l+0x950>)
 801b25e:	a801      	add	r0, sp, #4
 801b260:	f7ff fc9e 	bl	801aba0 <match_string>
 801b264:	2800      	cmp	r0, #0
 801b266:	f6bf ae8d 	bge.w	801af84 <strptime_l+0x39c>
 801b26a:	e61e      	b.n	801aeaa <strptime_l+0x2c2>
 801b26c:	4bb2      	ldr	r3, [pc, #712]	; (801b538 <strptime_l+0x950>)
 801b26e:	9801      	ldr	r0, [sp, #4]
 801b270:	f8d3 10a0 	ldr.w	r1, [r3, #160]	; 0xa0
 801b274:	4632      	mov	r2, r6
 801b276:	4623      	mov	r3, r4
 801b278:	f7ff fcb6 	bl	801abe8 <strptime_l>
 801b27c:	9003      	str	r0, [sp, #12]
 801b27e:	2800      	cmp	r0, #0
 801b280:	f43f ae13 	beq.w	801aeaa <strptime_l+0x2c2>
 801b284:	9001      	str	r0, [sp, #4]
 801b286:	f047 070f 	orr.w	r7, r7, #15
 801b28a:	e4c9      	b.n	801ac20 <strptime_l+0x38>
 801b28c:	4623      	mov	r3, r4
 801b28e:	220a      	movs	r2, #10
 801b290:	a903      	add	r1, sp, #12
 801b292:	9801      	ldr	r0, [sp, #4]
 801b294:	f000 fa5e 	bl	801b754 <strtol_l>
 801b298:	9b03      	ldr	r3, [sp, #12]
 801b29a:	9a01      	ldr	r2, [sp, #4]
 801b29c:	4293      	cmp	r3, r2
 801b29e:	f43f ae04 	beq.w	801aeaa <strptime_l+0x2c2>
 801b2a2:	60f0      	str	r0, [r6, #12]
 801b2a4:	9301      	str	r3, [sp, #4]
 801b2a6:	f047 0701 	orr.w	r7, r7, #1
 801b2aa:	e4b9      	b.n	801ac20 <strptime_l+0x38>
 801b2ac:	4623      	mov	r3, r4
 801b2ae:	220a      	movs	r2, #10
 801b2b0:	a903      	add	r1, sp, #12
 801b2b2:	9801      	ldr	r0, [sp, #4]
 801b2b4:	f000 fa4e 	bl	801b754 <strtol_l>
 801b2b8:	9a03      	ldr	r2, [sp, #12]
 801b2ba:	9b01      	ldr	r3, [sp, #4]
 801b2bc:	429a      	cmp	r2, r3
 801b2be:	f43f adf4 	beq.w	801aeaa <strptime_l+0x2c2>
 801b2c2:	3801      	subs	r0, #1
 801b2c4:	61f0      	str	r0, [r6, #28]
 801b2c6:	9201      	str	r2, [sp, #4]
 801b2c8:	f047 0710 	orr.w	r7, r7, #16
 801b2cc:	e4a8      	b.n	801ac20 <strptime_l+0x38>
 801b2ce:	4623      	mov	r3, r4
 801b2d0:	220a      	movs	r2, #10
 801b2d2:	a903      	add	r1, sp, #12
 801b2d4:	9801      	ldr	r0, [sp, #4]
 801b2d6:	f000 fa3d 	bl	801b754 <strtol_l>
 801b2da:	9a03      	ldr	r2, [sp, #12]
 801b2dc:	9b01      	ldr	r3, [sp, #4]
 801b2de:	429a      	cmp	r2, r3
 801b2e0:	f43f ade3 	beq.w	801aeaa <strptime_l+0x2c2>
 801b2e4:	3801      	subs	r0, #1
 801b2e6:	6130      	str	r0, [r6, #16]
 801b2e8:	9201      	str	r2, [sp, #4]
 801b2ea:	f047 0702 	orr.w	r7, r7, #2
 801b2ee:	e497      	b.n	801ac20 <strptime_l+0x38>
 801b2f0:	9b01      	ldr	r3, [sp, #4]
 801b2f2:	781a      	ldrb	r2, [r3, #0]
 801b2f4:	2a0a      	cmp	r2, #10
 801b2f6:	f43f ac91 	beq.w	801ac1c <strptime_l+0x34>
 801b2fa:	e5d6      	b.n	801aeaa <strptime_l+0x2c2>
 801b2fc:	4622      	mov	r2, r4
 801b2fe:	498f      	ldr	r1, [pc, #572]	; (801b53c <strptime_l+0x954>)
 801b300:	a801      	add	r0, sp, #4
 801b302:	f7ff fc4d 	bl	801aba0 <match_string>
 801b306:	2800      	cmp	r0, #0
 801b308:	f6ff adcf 	blt.w	801aeaa <strptime_l+0x2c2>
 801b30c:	68b3      	ldr	r3, [r6, #8]
 801b30e:	2b00      	cmp	r3, #0
 801b310:	f040 811c 	bne.w	801b54c <strptime_l+0x964>
 801b314:	2801      	cmp	r0, #1
 801b316:	f47f ac83 	bne.w	801ac20 <strptime_l+0x38>
 801b31a:	230c      	movs	r3, #12
 801b31c:	60b3      	str	r3, [r6, #8]
 801b31e:	e47f      	b.n	801ac20 <strptime_l+0x38>
 801b320:	4b85      	ldr	r3, [pc, #532]	; (801b538 <strptime_l+0x950>)
 801b322:	9801      	ldr	r0, [sp, #4]
 801b324:	f8d3 10e4 	ldr.w	r1, [r3, #228]	; 0xe4
 801b328:	e5b7      	b.n	801ae9a <strptime_l+0x2b2>
 801b32a:	9b01      	ldr	r3, [sp, #4]
 801b32c:	781a      	ldrb	r2, [r3, #0]
 801b32e:	2a09      	cmp	r2, #9
 801b330:	f43f ac74 	beq.w	801ac1c <strptime_l+0x34>
 801b334:	e5b9      	b.n	801aeaa <strptime_l+0x2c2>
 801b336:	4623      	mov	r3, r4
 801b338:	220a      	movs	r2, #10
 801b33a:	a903      	add	r1, sp, #12
 801b33c:	9801      	ldr	r0, [sp, #4]
 801b33e:	f000 fa09 	bl	801b754 <strtol_l>
 801b342:	9a03      	ldr	r2, [sp, #12]
 801b344:	9b01      	ldr	r3, [sp, #4]
 801b346:	429a      	cmp	r2, r3
 801b348:	f43f adaf 	beq.w	801aeaa <strptime_l+0x2c2>
 801b34c:	3801      	subs	r0, #1
 801b34e:	61b0      	str	r0, [r6, #24]
 801b350:	9201      	str	r2, [sp, #4]
 801b352:	f047 0708 	orr.w	r7, r7, #8
 801b356:	e463      	b.n	801ac20 <strptime_l+0x38>
 801b358:	4623      	mov	r3, r4
 801b35a:	220a      	movs	r2, #10
 801b35c:	a903      	add	r1, sp, #12
 801b35e:	9801      	ldr	r0, [sp, #4]
 801b360:	f000 f9f8 	bl	801b754 <strtol_l>
 801b364:	9b03      	ldr	r3, [sp, #12]
 801b366:	9a01      	ldr	r2, [sp, #4]
 801b368:	4293      	cmp	r3, r2
 801b36a:	f43f ad9e 	beq.w	801aeaa <strptime_l+0x2c2>
 801b36e:	61b0      	str	r0, [r6, #24]
 801b370:	9301      	str	r3, [sp, #4]
 801b372:	f047 0708 	orr.w	r7, r7, #8
 801b376:	e453      	b.n	801ac20 <strptime_l+0x38>
 801b378:	4b6f      	ldr	r3, [pc, #444]	; (801b538 <strptime_l+0x950>)
 801b37a:	9801      	ldr	r0, [sp, #4]
 801b37c:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 801b380:	4632      	mov	r2, r6
 801b382:	4623      	mov	r3, r4
 801b384:	f7ff fc30 	bl	801abe8 <strptime_l>
 801b388:	9003      	str	r0, [sp, #12]
 801b38a:	2800      	cmp	r0, #0
 801b38c:	f47f ae1c 	bne.w	801afc8 <strptime_l+0x3e0>
 801b390:	e58b      	b.n	801aeaa <strptime_l+0x2c2>
 801b392:	9901      	ldr	r1, [sp, #4]
 801b394:	780a      	ldrb	r2, [r1, #0]
 801b396:	2a25      	cmp	r2, #37	; 0x25
 801b398:	f000 811b 	beq.w	801b5d2 <strptime_l+0x9ea>
 801b39c:	1c4a      	adds	r2, r1, #1
 801b39e:	9201      	str	r2, [sp, #4]
 801b3a0:	7849      	ldrb	r1, [r1, #1]
 801b3a2:	4299      	cmp	r1, r3
 801b3a4:	f47f ad81 	bne.w	801aeaa <strptime_l+0x2c2>
 801b3a8:	3201      	adds	r2, #1
 801b3aa:	9201      	str	r2, [sp, #4]
 801b3ac:	e438      	b.n	801ac20 <strptime_l+0x38>
 801b3ae:	2301      	movs	r3, #1
 801b3b0:	e59a      	b.n	801aee8 <strptime_l+0x300>
 801b3b2:	2304      	movs	r3, #4
 801b3b4:	69f1      	ldr	r1, [r6, #28]
 801b3b6:	4a62      	ldr	r2, [pc, #392]	; (801b540 <strptime_l+0x958>)
 801b3b8:	440b      	add	r3, r1
 801b3ba:	fb82 1203 	smull	r1, r2, r2, r3
 801b3be:	18d1      	adds	r1, r2, r3
 801b3c0:	17da      	asrs	r2, r3, #31
 801b3c2:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 801b3c6:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801b3ca:	1a9b      	subs	r3, r3, r2
 801b3cc:	61b3      	str	r3, [r6, #24]
 801b3ce:	e455      	b.n	801ac7c <strptime_l+0x94>
 801b3d0:	2201      	movs	r2, #1
 801b3d2:	e708      	b.n	801b1e6 <strptime_l+0x5fe>
 801b3d4:	2201      	movs	r2, #1
 801b3d6:	e670      	b.n	801b0ba <strptime_l+0x4d2>
 801b3d8:	2201      	movs	r2, #1
 801b3da:	e6b2      	b.n	801b142 <strptime_l+0x55a>
 801b3dc:	f017 0302 	ands.w	r3, r7, #2
 801b3e0:	d104      	bne.n	801b3ec <strptime_l+0x804>
 801b3e2:	69f4      	ldr	r4, [r6, #28]
 801b3e4:	2c1e      	cmp	r4, #30
 801b3e6:	f300 80b5 	bgt.w	801b554 <strptime_l+0x96c>
 801b3ea:	6133      	str	r3, [r6, #16]
 801b3ec:	07fc      	lsls	r4, r7, #31
 801b3ee:	f53f ac42 	bmi.w	801ac76 <strptime_l+0x8e>
 801b3f2:	4b54      	ldr	r3, [pc, #336]	; (801b544 <strptime_l+0x95c>)
 801b3f4:	6937      	ldr	r7, [r6, #16]
 801b3f6:	69f0      	ldr	r0, [r6, #28]
 801b3f8:	f853 1027 	ldr.w	r1, [r3, r7, lsl #2]
 801b3fc:	6973      	ldr	r3, [r6, #20]
 801b3fe:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801b402:	1a41      	subs	r1, r0, r1
 801b404:	0798      	lsls	r0, r3, #30
 801b406:	60f1      	str	r1, [r6, #12]
 801b408:	d10f      	bne.n	801b42a <strptime_l+0x842>
 801b40a:	4c4f      	ldr	r4, [pc, #316]	; (801b548 <strptime_l+0x960>)
 801b40c:	17d8      	asrs	r0, r3, #31
 801b40e:	fb84 5403 	smull	r5, r4, r4, r3
 801b412:	ebc0 1564 	rsb	r5, r0, r4, asr #5
 801b416:	f04f 0e64 	mov.w	lr, #100	; 0x64
 801b41a:	fb0e 3515 	mls	r5, lr, r5, r3
 801b41e:	2d00      	cmp	r5, #0
 801b420:	f000 80c1 	beq.w	801b5a6 <strptime_l+0x9be>
 801b424:	2f01      	cmp	r7, #1
 801b426:	f73f ac26 	bgt.w	801ac76 <strptime_l+0x8e>
 801b42a:	3101      	adds	r1, #1
 801b42c:	60f1      	str	r1, [r6, #12]
 801b42e:	e422      	b.n	801ac76 <strptime_l+0x8e>
 801b430:	4b44      	ldr	r3, [pc, #272]	; (801b544 <strptime_l+0x95c>)
 801b432:	6935      	ldr	r5, [r6, #16]
 801b434:	68f2      	ldr	r2, [r6, #12]
 801b436:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
 801b43a:	6973      	ldr	r3, [r6, #20]
 801b43c:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801b440:	440a      	add	r2, r1
 801b442:	0799      	lsls	r1, r3, #30
 801b444:	61f2      	str	r2, [r6, #28]
 801b446:	d111      	bne.n	801b46c <strptime_l+0x884>
 801b448:	483f      	ldr	r0, [pc, #252]	; (801b548 <strptime_l+0x960>)
 801b44a:	17d9      	asrs	r1, r3, #31
 801b44c:	fb80 4003 	smull	r4, r0, r0, r3
 801b450:	ebc1 1460 	rsb	r4, r1, r0, asr #5
 801b454:	f04f 0e64 	mov.w	lr, #100	; 0x64
 801b458:	fb0e 3414 	mls	r4, lr, r4, r3
 801b45c:	b974      	cbnz	r4, 801b47c <strptime_l+0x894>
 801b45e:	ebc1 11e0 	rsb	r1, r1, r0, asr #7
 801b462:	f44f 70c8 	mov.w	r0, #400	; 0x190
 801b466:	fb00 3311 	mls	r3, r0, r1, r3
 801b46a:	b13b      	cbz	r3, 801b47c <strptime_l+0x894>
 801b46c:	3a01      	subs	r2, #1
 801b46e:	61f2      	str	r2, [r6, #28]
 801b470:	f007 021c 	and.w	r2, r7, #28
 801b474:	f042 0210 	orr.w	r2, r2, #16
 801b478:	f7ff bbfd 	b.w	801ac76 <strptime_l+0x8e>
 801b47c:	2d01      	cmp	r5, #1
 801b47e:	dcf7      	bgt.n	801b470 <strptime_l+0x888>
 801b480:	e7f4      	b.n	801b46c <strptime_l+0x884>
 801b482:	69b2      	ldr	r2, [r6, #24]
 801b484:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 801b488:	4402      	add	r2, r0
 801b48a:	1ad2      	subs	r2, r2, r3
 801b48c:	2a00      	cmp	r2, #0
 801b48e:	61f2      	str	r2, [r6, #28]
 801b490:	f2c0 8099 	blt.w	801b5c6 <strptime_l+0x9de>
 801b494:	9b00      	ldr	r3, [sp, #0]
 801b496:	9301      	str	r3, [sp, #4]
 801b498:	f047 0710 	orr.w	r7, r7, #16
 801b49c:	f7ff bbc0 	b.w	801ac20 <strptime_l+0x38>
 801b4a0:	3306      	adds	r3, #6
 801b4a2:	fb8a 1203 	smull	r1, r2, sl, r3
 801b4a6:	441a      	add	r2, r3
 801b4a8:	17d9      	asrs	r1, r3, #31
 801b4aa:	ebc1 02a2 	rsb	r2, r1, r2, asr #2
 801b4ae:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801b4b2:	1a9a      	subs	r2, r3, r2
 801b4b4:	2a04      	cmp	r2, #4
 801b4b6:	bfb4      	ite	lt
 801b4b8:	2007      	movlt	r0, #7
 801b4ba:	2000      	movge	r0, #0
 801b4bc:	9b00      	ldr	r3, [sp, #0]
 801b4be:	69b1      	ldr	r1, [r6, #24]
 801b4c0:	3b01      	subs	r3, #1
 801b4c2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b4c6:	4403      	add	r3, r0
 801b4c8:	440b      	add	r3, r1
 801b4ca:	1a9b      	subs	r3, r3, r2
 801b4cc:	2b00      	cmp	r3, #0
 801b4ce:	61f3      	str	r3, [r6, #28]
 801b4d0:	db75      	blt.n	801b5be <strptime_l+0x9d6>
 801b4d2:	f8cd 9004 	str.w	r9, [sp, #4]
 801b4d6:	f047 0710 	orr.w	r7, r7, #16
 801b4da:	f7ff bba1 	b.w	801ac20 <strptime_l+0x38>
 801b4de:	3306      	adds	r3, #6
 801b4e0:	fb8a 1203 	smull	r1, r2, sl, r3
 801b4e4:	441a      	add	r2, r3
 801b4e6:	17d9      	asrs	r1, r3, #31
 801b4e8:	ebc1 02a2 	rsb	r2, r1, r2, asr #2
 801b4ec:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801b4f0:	1a9a      	subs	r2, r3, r2
 801b4f2:	69b3      	ldr	r3, [r6, #24]
 801b4f4:	3306      	adds	r3, #6
 801b4f6:	fb8a e103 	smull	lr, r1, sl, r3
 801b4fa:	eb01 0e03 	add.w	lr, r1, r3
 801b4fe:	17d9      	asrs	r1, r3, #31
 801b500:	ebc1 01ae 	rsb	r1, r1, lr, asr #2
 801b504:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 801b508:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 801b50c:	1a5b      	subs	r3, r3, r1
 801b50e:	4403      	add	r3, r0
 801b510:	1a9b      	subs	r3, r3, r2
 801b512:	2b00      	cmp	r3, #0
 801b514:	61f3      	str	r3, [r6, #28]
 801b516:	dabd      	bge.n	801b494 <strptime_l+0x8ac>
 801b518:	3201      	adds	r2, #1
 801b51a:	fb8a 1302 	smull	r1, r3, sl, r2
 801b51e:	1899      	adds	r1, r3, r2
 801b520:	17d3      	asrs	r3, r2, #31
 801b522:	ebc3 03a1 	rsb	r3, r3, r1, asr #2
 801b526:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b52a:	1ad2      	subs	r2, r2, r3
 801b52c:	2300      	movs	r3, #0
 801b52e:	61b2      	str	r2, [r6, #24]
 801b530:	61f3      	str	r3, [r6, #28]
 801b532:	e7af      	b.n	801b494 <strptime_l+0x8ac>
 801b534:	08024d58 	.word	0x08024d58
 801b538:	08024cf8 	.word	0x08024cf8
 801b53c:	08024d9c 	.word	0x08024d9c
 801b540:	92492493 	.word	0x92492493
 801b544:	08024ca8 	.word	0x08024ca8
 801b548:	51eb851f 	.word	0x51eb851f
 801b54c:	330c      	adds	r3, #12
 801b54e:	60b3      	str	r3, [r6, #8]
 801b550:	f7ff bb66 	b.w	801ac20 <strptime_l+0x38>
 801b554:	6971      	ldr	r1, [r6, #20]
 801b556:	f201 716c 	addw	r1, r1, #1900	; 0x76c
 801b55a:	078d      	lsls	r5, r1, #30
 801b55c:	d00e      	beq.n	801b57c <strptime_l+0x994>
 801b55e:	4d20      	ldr	r5, [pc, #128]	; (801b5e0 <strptime_l+0x9f8>)
 801b560:	203b      	movs	r0, #59	; 0x3b
 801b562:	2102      	movs	r1, #2
 801b564:	e004      	b.n	801b570 <strptime_l+0x988>
 801b566:	3101      	adds	r1, #1
 801b568:	290c      	cmp	r1, #12
 801b56a:	d026      	beq.n	801b5ba <strptime_l+0x9d2>
 801b56c:	f855 0f04 	ldr.w	r0, [r5, #4]!
 801b570:	4418      	add	r0, r3
 801b572:	4284      	cmp	r4, r0
 801b574:	daf7      	bge.n	801b566 <strptime_l+0x97e>
 801b576:	3901      	subs	r1, #1
 801b578:	6131      	str	r1, [r6, #16]
 801b57a:	e737      	b.n	801b3ec <strptime_l+0x804>
 801b57c:	4819      	ldr	r0, [pc, #100]	; (801b5e4 <strptime_l+0x9fc>)
 801b57e:	17cb      	asrs	r3, r1, #31
 801b580:	fb80 5001 	smull	r5, r0, r0, r1
 801b584:	ebc3 1560 	rsb	r5, r3, r0, asr #5
 801b588:	f04f 0e64 	mov.w	lr, #100	; 0x64
 801b58c:	fb0e 1515 	mls	r5, lr, r5, r1
 801b590:	b9ed      	cbnz	r5, 801b5ce <strptime_l+0x9e6>
 801b592:	ebc3 13e0 	rsb	r3, r3, r0, asr #7
 801b596:	f44f 70c8 	mov.w	r0, #400	; 0x190
 801b59a:	fb00 1313 	mls	r3, r0, r3, r1
 801b59e:	fab3 f383 	clz	r3, r3
 801b5a2:	095b      	lsrs	r3, r3, #5
 801b5a4:	e7db      	b.n	801b55e <strptime_l+0x976>
 801b5a6:	ebc0 10e4 	rsb	r0, r0, r4, asr #7
 801b5aa:	f44f 74c8 	mov.w	r4, #400	; 0x190
 801b5ae:	fb04 3310 	mls	r3, r4, r0, r3
 801b5b2:	2b00      	cmp	r3, #0
 801b5b4:	f43f af36 	beq.w	801b424 <strptime_l+0x83c>
 801b5b8:	e737      	b.n	801b42a <strptime_l+0x842>
 801b5ba:	210b      	movs	r1, #11
 801b5bc:	e7dc      	b.n	801b578 <strptime_l+0x990>
 801b5be:	2300      	movs	r3, #0
 801b5c0:	61b2      	str	r2, [r6, #24]
 801b5c2:	61f3      	str	r3, [r6, #28]
 801b5c4:	e785      	b.n	801b4d2 <strptime_l+0x8ea>
 801b5c6:	2200      	movs	r2, #0
 801b5c8:	61b3      	str	r3, [r6, #24]
 801b5ca:	61f2      	str	r2, [r6, #28]
 801b5cc:	e762      	b.n	801b494 <strptime_l+0x8ac>
 801b5ce:	2301      	movs	r3, #1
 801b5d0:	e7c5      	b.n	801b55e <strptime_l+0x976>
 801b5d2:	460a      	mov	r2, r1
 801b5d4:	e6e8      	b.n	801b3a8 <strptime_l+0x7c0>
 801b5d6:	2203      	movs	r2, #3
 801b5d8:	e78b      	b.n	801b4f2 <strptime_l+0x90a>
 801b5da:	2203      	movs	r2, #3
 801b5dc:	2007      	movs	r0, #7
 801b5de:	e76d      	b.n	801b4bc <strptime_l+0x8d4>
 801b5e0:	08024cb0 	.word	0x08024cb0
 801b5e4:	51eb851f 	.word	0x51eb851f

0801b5e8 <strptime>:
 801b5e8:	4b05      	ldr	r3, [pc, #20]	; (801b600 <strptime+0x18>)
 801b5ea:	681b      	ldr	r3, [r3, #0]
 801b5ec:	b410      	push	{r4}
 801b5ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801b5f0:	4c04      	ldr	r4, [pc, #16]	; (801b604 <strptime+0x1c>)
 801b5f2:	2b00      	cmp	r3, #0
 801b5f4:	bf08      	it	eq
 801b5f6:	4623      	moveq	r3, r4
 801b5f8:	f85d 4b04 	ldr.w	r4, [sp], #4
 801b5fc:	f7ff baf4 	b.w	801abe8 <strptime_l>
 801b600:	20004474 	.word	0x20004474
 801b604:	200048a0 	.word	0x200048a0

0801b608 <_strtol_l.isra.0>:
 801b608:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b60c:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 801b610:	460f      	mov	r7, r1
 801b612:	4680      	mov	r8, r0
 801b614:	4616      	mov	r6, r2
 801b616:	461d      	mov	r5, r3
 801b618:	468a      	mov	sl, r1
 801b61a:	e000      	b.n	801b61e <_strtol_l.isra.0+0x16>
 801b61c:	46a2      	mov	sl, r4
 801b61e:	4654      	mov	r4, sl
 801b620:	4648      	mov	r0, r9
 801b622:	f814 bb01 	ldrb.w	fp, [r4], #1
 801b626:	f7ff fa93 	bl	801ab50 <__locale_ctype_ptr_l>
 801b62a:	4458      	add	r0, fp
 801b62c:	7842      	ldrb	r2, [r0, #1]
 801b62e:	f012 0208 	ands.w	r2, r2, #8
 801b632:	d1f3      	bne.n	801b61c <_strtol_l.isra.0+0x14>
 801b634:	f1bb 0f2d 	cmp.w	fp, #45	; 0x2d
 801b638:	d04f      	beq.n	801b6da <_strtol_l.isra.0+0xd2>
 801b63a:	f1bb 0f2b 	cmp.w	fp, #43	; 0x2b
 801b63e:	bf04      	itt	eq
 801b640:	f894 b000 	ldrbeq.w	fp, [r4]
 801b644:	f10a 0402 	addeq.w	r4, sl, #2
 801b648:	b11d      	cbz	r5, 801b652 <_strtol_l.isra.0+0x4a>
 801b64a:	2d10      	cmp	r5, #16
 801b64c:	d056      	beq.n	801b6fc <_strtol_l.isra.0+0xf4>
 801b64e:	46ac      	mov	ip, r5
 801b650:	e004      	b.n	801b65c <_strtol_l.isra.0+0x54>
 801b652:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 801b656:	d060      	beq.n	801b71a <_strtol_l.isra.0+0x112>
 801b658:	250a      	movs	r5, #10
 801b65a:	46ac      	mov	ip, r5
 801b65c:	2a00      	cmp	r2, #0
 801b65e:	bf0c      	ite	eq
 801b660:	f06f 4900 	mvneq.w	r9, #2147483648	; 0x80000000
 801b664:	f04f 4900 	movne.w	r9, #2147483648	; 0x80000000
 801b668:	2100      	movs	r1, #0
 801b66a:	fbb9 fefc 	udiv	lr, r9, ip
 801b66e:	4608      	mov	r0, r1
 801b670:	fb0c 9a1e 	mls	sl, ip, lr, r9
 801b674:	e005      	b.n	801b682 <_strtol_l.isra.0+0x7a>
 801b676:	d029      	beq.n	801b6cc <_strtol_l.isra.0+0xc4>
 801b678:	fb0c 3000 	mla	r0, ip, r0, r3
 801b67c:	2101      	movs	r1, #1
 801b67e:	f814 bb01 	ldrb.w	fp, [r4], #1
 801b682:	f1ab 0330 	sub.w	r3, fp, #48	; 0x30
 801b686:	2b09      	cmp	r3, #9
 801b688:	d905      	bls.n	801b696 <_strtol_l.isra.0+0x8e>
 801b68a:	f1ab 0341 	sub.w	r3, fp, #65	; 0x41
 801b68e:	2b19      	cmp	r3, #25
 801b690:	d80b      	bhi.n	801b6aa <_strtol_l.isra.0+0xa2>
 801b692:	f1ab 0337 	sub.w	r3, fp, #55	; 0x37
 801b696:	429d      	cmp	r5, r3
 801b698:	dd0f      	ble.n	801b6ba <_strtol_l.isra.0+0xb2>
 801b69a:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 801b69e:	d0ee      	beq.n	801b67e <_strtol_l.isra.0+0x76>
 801b6a0:	4586      	cmp	lr, r0
 801b6a2:	d2e8      	bcs.n	801b676 <_strtol_l.isra.0+0x6e>
 801b6a4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801b6a8:	e7e9      	b.n	801b67e <_strtol_l.isra.0+0x76>
 801b6aa:	f1ab 0361 	sub.w	r3, fp, #97	; 0x61
 801b6ae:	2b19      	cmp	r3, #25
 801b6b0:	d803      	bhi.n	801b6ba <_strtol_l.isra.0+0xb2>
 801b6b2:	f1ab 0357 	sub.w	r3, fp, #87	; 0x57
 801b6b6:	429d      	cmp	r5, r3
 801b6b8:	dcef      	bgt.n	801b69a <_strtol_l.isra.0+0x92>
 801b6ba:	1c4b      	adds	r3, r1, #1
 801b6bc:	d013      	beq.n	801b6e6 <_strtol_l.isra.0+0xde>
 801b6be:	b102      	cbz	r2, 801b6c2 <_strtol_l.isra.0+0xba>
 801b6c0:	4240      	negs	r0, r0
 801b6c2:	b146      	cbz	r6, 801b6d6 <_strtol_l.isra.0+0xce>
 801b6c4:	b9c1      	cbnz	r1, 801b6f8 <_strtol_l.isra.0+0xf0>
 801b6c6:	6037      	str	r7, [r6, #0]
 801b6c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b6cc:	459a      	cmp	sl, r3
 801b6ce:	dad3      	bge.n	801b678 <_strtol_l.isra.0+0x70>
 801b6d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801b6d4:	e7d3      	b.n	801b67e <_strtol_l.isra.0+0x76>
 801b6d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b6da:	f894 b000 	ldrb.w	fp, [r4]
 801b6de:	2201      	movs	r2, #1
 801b6e0:	f10a 0402 	add.w	r4, sl, #2
 801b6e4:	e7b0      	b.n	801b648 <_strtol_l.isra.0+0x40>
 801b6e6:	2322      	movs	r3, #34	; 0x22
 801b6e8:	f8c8 3000 	str.w	r3, [r8]
 801b6ec:	b1ee      	cbz	r6, 801b72a <_strtol_l.isra.0+0x122>
 801b6ee:	1e67      	subs	r7, r4, #1
 801b6f0:	4648      	mov	r0, r9
 801b6f2:	6037      	str	r7, [r6, #0]
 801b6f4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b6f8:	4681      	mov	r9, r0
 801b6fa:	e7f8      	b.n	801b6ee <_strtol_l.isra.0+0xe6>
 801b6fc:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 801b700:	d1a5      	bne.n	801b64e <_strtol_l.isra.0+0x46>
 801b702:	7823      	ldrb	r3, [r4, #0]
 801b704:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801b708:	2b58      	cmp	r3, #88	; 0x58
 801b70a:	d1a0      	bne.n	801b64e <_strtol_l.isra.0+0x46>
 801b70c:	f04f 0c10 	mov.w	ip, #16
 801b710:	f894 b001 	ldrb.w	fp, [r4, #1]
 801b714:	4665      	mov	r5, ip
 801b716:	3402      	adds	r4, #2
 801b718:	e7a0      	b.n	801b65c <_strtol_l.isra.0+0x54>
 801b71a:	7823      	ldrb	r3, [r4, #0]
 801b71c:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801b720:	2b58      	cmp	r3, #88	; 0x58
 801b722:	d0f3      	beq.n	801b70c <_strtol_l.isra.0+0x104>
 801b724:	2508      	movs	r5, #8
 801b726:	46ac      	mov	ip, r5
 801b728:	e798      	b.n	801b65c <_strtol_l.isra.0+0x54>
 801b72a:	4648      	mov	r0, r9
 801b72c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801b730 <_strtol_r>:
 801b730:	b530      	push	{r4, r5, lr}
 801b732:	4c06      	ldr	r4, [pc, #24]	; (801b74c <_strtol_r+0x1c>)
 801b734:	4d06      	ldr	r5, [pc, #24]	; (801b750 <_strtol_r+0x20>)
 801b736:	6824      	ldr	r4, [r4, #0]
 801b738:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801b73a:	b083      	sub	sp, #12
 801b73c:	2c00      	cmp	r4, #0
 801b73e:	bf08      	it	eq
 801b740:	462c      	moveq	r4, r5
 801b742:	9400      	str	r4, [sp, #0]
 801b744:	f7ff ff60 	bl	801b608 <_strtol_l.isra.0>
 801b748:	b003      	add	sp, #12
 801b74a:	bd30      	pop	{r4, r5, pc}
 801b74c:	20004474 	.word	0x20004474
 801b750:	200048a0 	.word	0x200048a0

0801b754 <strtol_l>:
 801b754:	b510      	push	{r4, lr}
 801b756:	b082      	sub	sp, #8
 801b758:	4c05      	ldr	r4, [pc, #20]	; (801b770 <strtol_l+0x1c>)
 801b75a:	9300      	str	r3, [sp, #0]
 801b75c:	6824      	ldr	r4, [r4, #0]
 801b75e:	4613      	mov	r3, r2
 801b760:	460a      	mov	r2, r1
 801b762:	4601      	mov	r1, r0
 801b764:	4620      	mov	r0, r4
 801b766:	f7ff ff4f 	bl	801b608 <_strtol_l.isra.0>
 801b76a:	b002      	add	sp, #8
 801b76c:	bd10      	pop	{r4, pc}
 801b76e:	bf00      	nop
 801b770:	20004474 	.word	0x20004474

0801b774 <__tzcalc_limits>:
 801b774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b778:	b083      	sub	sp, #12
 801b77a:	4605      	mov	r5, r0
 801b77c:	f000 fab8 	bl	801bcf0 <__gettzinfo>
 801b780:	f240 73b1 	movw	r3, #1969	; 0x7b1
 801b784:	429d      	cmp	r5, r3
 801b786:	f340 8093 	ble.w	801b8b0 <__tzcalc_limits+0x13c>
 801b78a:	4c57      	ldr	r4, [pc, #348]	; (801b8e8 <__tzcalc_limits+0x174>)
 801b78c:	f8df 8164 	ldr.w	r8, [pc, #356]	; 801b8f4 <__tzcalc_limits+0x180>
 801b790:	6045      	str	r5, [r0, #4]
 801b792:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
 801b796:	18ee      	adds	r6, r5, r3
 801b798:	f2a5 726d 	subw	r2, r5, #1901	; 0x76d
 801b79c:	fb84 3102 	smull	r3, r1, r4, r2
 801b7a0:	10b7      	asrs	r7, r6, #2
 801b7a2:	f240 1e6d 	movw	lr, #365	; 0x16d
 801b7a6:	f46f 6cc8 	mvn.w	ip, #1600	; 0x640
 801b7aa:	f2a5 76b2 	subw	r6, r5, #1970	; 0x7b2
 801b7ae:	17d2      	asrs	r2, r2, #31
 801b7b0:	eb05 030c 	add.w	r3, r5, ip
 801b7b4:	fb0e 7606 	mla	r6, lr, r6, r7
 801b7b8:	eba2 1261 	sub.w	r2, r2, r1, asr #5
 801b7bc:	17ef      	asrs	r7, r5, #31
 801b7be:	fb84 c105 	smull	ip, r1, r4, r5
 801b7c2:	4416      	add	r6, r2
 801b7c4:	fb84 e403 	smull	lr, r4, r4, r3
 801b7c8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801b7cc:	ebc7 1ee1 	rsb	lr, r7, r1, asr #7
 801b7d0:	17db      	asrs	r3, r3, #31
 801b7d2:	ebc3 13e4 	rsb	r3, r3, r4, asr #7
 801b7d6:	fb02 5e1e 	mls	lr, r2, lr, r5
 801b7da:	ebc7 1761 	rsb	r7, r7, r1, asr #5
 801b7de:	2264      	movs	r2, #100	; 0x64
 801b7e0:	441e      	add	r6, r3
 801b7e2:	f1be 0f00 	cmp.w	lr, #0
 801b7e6:	bf0c      	ite	eq
 801b7e8:	2330      	moveq	r3, #48	; 0x30
 801b7ea:	2300      	movne	r3, #0
 801b7ec:	fb02 5717 	mls	r7, r2, r7, r5
 801b7f0:	9301      	str	r3, [sp, #4]
 801b7f2:	f005 0503 	and.w	r5, r5, #3
 801b7f6:	4604      	mov	r4, r0
 801b7f8:	f100 0c38 	add.w	ip, r0, #56	; 0x38
 801b7fc:	7a23      	ldrb	r3, [r4, #8]
 801b7fe:	2b4a      	cmp	r3, #74	; 0x4a
 801b800:	d05a      	beq.n	801b8b8 <__tzcalc_limits+0x144>
 801b802:	2b44      	cmp	r3, #68	; 0x44
 801b804:	d068      	beq.n	801b8d8 <__tzcalc_limits+0x164>
 801b806:	2d00      	cmp	r5, #0
 801b808:	d04b      	beq.n	801b8a2 <__tzcalc_limits+0x12e>
 801b80a:	f8dd 9004 	ldr.w	r9, [sp, #4]
 801b80e:	68e3      	ldr	r3, [r4, #12]
 801b810:	4a36      	ldr	r2, [pc, #216]	; (801b8ec <__tzcalc_limits+0x178>)
 801b812:	2b01      	cmp	r3, #1
 801b814:	4491      	add	r9, r2
 801b816:	dd62      	ble.n	801b8de <__tzcalc_limits+0x16a>
 801b818:	f103 4b80 	add.w	fp, r3, #1073741824	; 0x40000000
 801b81c:	f1ab 0b02 	sub.w	fp, fp, #2
 801b820:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 801b824:	eb09 0a0b 	add.w	sl, r9, fp
 801b828:	f1a9 0304 	sub.w	r3, r9, #4
 801b82c:	4632      	mov	r2, r6
 801b82e:	f853 1f04 	ldr.w	r1, [r3, #4]!
 801b832:	459a      	cmp	sl, r3
 801b834:	440a      	add	r2, r1
 801b836:	d1fa      	bne.n	801b82e <__tzcalc_limits+0xba>
 801b838:	f10b 0b04 	add.w	fp, fp, #4
 801b83c:	4b2c      	ldr	r3, [pc, #176]	; (801b8f0 <__tzcalc_limits+0x17c>)
 801b83e:	f859 900b 	ldr.w	r9, [r9, fp]
 801b842:	1d11      	adds	r1, r2, #4
 801b844:	fb83 a301 	smull	sl, r3, r3, r1
 801b848:	440b      	add	r3, r1
 801b84a:	ea4f 7ae1 	mov.w	sl, r1, asr #31
 801b84e:	ebca 0aa3 	rsb	sl, sl, r3, asr #2
 801b852:	ebca 0aca 	rsb	sl, sl, sl, lsl #3
 801b856:	6963      	ldr	r3, [r4, #20]
 801b858:	eba1 010a 	sub.w	r1, r1, sl
 801b85c:	1a59      	subs	r1, r3, r1
 801b85e:	6923      	ldr	r3, [r4, #16]
 801b860:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 801b864:	bf48      	it	mi
 801b866:	3107      	addmi	r1, #7
 801b868:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801b86c:	440b      	add	r3, r1
 801b86e:	454b      	cmp	r3, r9
 801b870:	db02      	blt.n	801b878 <__tzcalc_limits+0x104>
 801b872:	3b07      	subs	r3, #7
 801b874:	454b      	cmp	r3, r9
 801b876:	dafc      	bge.n	801b872 <__tzcalc_limits+0xfe>
 801b878:	441a      	add	r2, r3
 801b87a:	69a1      	ldr	r1, [r4, #24]
 801b87c:	6a23      	ldr	r3, [r4, #32]
 801b87e:	fb08 1102 	mla	r1, r8, r2, r1
 801b882:	440b      	add	r3, r1
 801b884:	f844 3f1c 	str.w	r3, [r4, #28]!
 801b888:	45a4      	cmp	ip, r4
 801b88a:	d1b7      	bne.n	801b7fc <__tzcalc_limits+0x88>
 801b88c:	69c3      	ldr	r3, [r0, #28]
 801b88e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 801b890:	4293      	cmp	r3, r2
 801b892:	bfac      	ite	ge
 801b894:	2300      	movge	r3, #0
 801b896:	2301      	movlt	r3, #1
 801b898:	6003      	str	r3, [r0, #0]
 801b89a:	2001      	movs	r0, #1
 801b89c:	b003      	add	sp, #12
 801b89e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b8a2:	9b01      	ldr	r3, [sp, #4]
 801b8a4:	2f00      	cmp	r7, #0
 801b8a6:	bf0c      	ite	eq
 801b8a8:	4699      	moveq	r9, r3
 801b8aa:	f04f 0930 	movne.w	r9, #48	; 0x30
 801b8ae:	e7ae      	b.n	801b80e <__tzcalc_limits+0x9a>
 801b8b0:	2000      	movs	r0, #0
 801b8b2:	b003      	add	sp, #12
 801b8b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b8b8:	6962      	ldr	r2, [r4, #20]
 801b8ba:	18b1      	adds	r1, r6, r2
 801b8bc:	b93d      	cbnz	r5, 801b8ce <__tzcalc_limits+0x15a>
 801b8be:	b137      	cbz	r7, 801b8ce <__tzcalc_limits+0x15a>
 801b8c0:	2a3b      	cmp	r2, #59	; 0x3b
 801b8c2:	bfd4      	ite	le
 801b8c4:	2200      	movle	r2, #0
 801b8c6:	2201      	movgt	r2, #1
 801b8c8:	440a      	add	r2, r1
 801b8ca:	3a01      	subs	r2, #1
 801b8cc:	e7d5      	b.n	801b87a <__tzcalc_limits+0x106>
 801b8ce:	f1be 0f00 	cmp.w	lr, #0
 801b8d2:	d0f5      	beq.n	801b8c0 <__tzcalc_limits+0x14c>
 801b8d4:	2200      	movs	r2, #0
 801b8d6:	e7f7      	b.n	801b8c8 <__tzcalc_limits+0x154>
 801b8d8:	6962      	ldr	r2, [r4, #20]
 801b8da:	4432      	add	r2, r6
 801b8dc:	e7cd      	b.n	801b87a <__tzcalc_limits+0x106>
 801b8de:	4632      	mov	r2, r6
 801b8e0:	f04f 0b00 	mov.w	fp, #0
 801b8e4:	e7aa      	b.n	801b83c <__tzcalc_limits+0xc8>
 801b8e6:	bf00      	nop
 801b8e8:	51eb851f 	.word	0x51eb851f
 801b8ec:	0802508c 	.word	0x0802508c
 801b8f0:	92492493 	.word	0x92492493
 801b8f4:	00015180 	.word	0x00015180

0801b8f8 <__tz_lock>:
 801b8f8:	4801      	ldr	r0, [pc, #4]	; (801b900 <__tz_lock+0x8>)
 801b8fa:	f000 ba01 	b.w	801bd00 <__retarget_lock_acquire>
 801b8fe:	bf00      	nop
 801b900:	2000f250 	.word	0x2000f250

0801b904 <__tz_unlock>:
 801b904:	4801      	ldr	r0, [pc, #4]	; (801b90c <__tz_unlock+0x8>)
 801b906:	f000 b9ff 	b.w	801bd08 <__retarget_lock_release>
 801b90a:	bf00      	nop
 801b90c:	2000f250 	.word	0x2000f250

0801b910 <_tzset_unlocked>:
 801b910:	4b01      	ldr	r3, [pc, #4]	; (801b918 <_tzset_unlocked+0x8>)
 801b912:	6818      	ldr	r0, [r3, #0]
 801b914:	f000 b802 	b.w	801b91c <_tzset_unlocked_r>
 801b918:	20004474 	.word	0x20004474

0801b91c <_tzset_unlocked_r>:
 801b91c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b920:	b08b      	sub	sp, #44	; 0x2c
 801b922:	4607      	mov	r7, r0
 801b924:	f000 f9e4 	bl	801bcf0 <__gettzinfo>
 801b928:	49bb      	ldr	r1, [pc, #748]	; (801bc18 <_tzset_unlocked_r+0x2fc>)
 801b92a:	4dbc      	ldr	r5, [pc, #752]	; (801bc1c <_tzset_unlocked_r+0x300>)
 801b92c:	4606      	mov	r6, r0
 801b92e:	4638      	mov	r0, r7
 801b930:	f000 f9d6 	bl	801bce0 <_getenv_r>
 801b934:	4604      	mov	r4, r0
 801b936:	2800      	cmp	r0, #0
 801b938:	f000 80f7 	beq.w	801bb2a <_tzset_unlocked_r+0x20e>
 801b93c:	6829      	ldr	r1, [r5, #0]
 801b93e:	b131      	cbz	r1, 801b94e <_tzset_unlocked_r+0x32>
 801b940:	f7e8 fd02 	bl	8004348 <strcmp>
 801b944:	b910      	cbnz	r0, 801b94c <_tzset_unlocked_r+0x30>
 801b946:	b00b      	add	sp, #44	; 0x2c
 801b948:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b94c:	6829      	ldr	r1, [r5, #0]
 801b94e:	4608      	mov	r0, r1
 801b950:	f000 f9de 	bl	801bd10 <free>
 801b954:	4620      	mov	r0, r4
 801b956:	f7e8 fe73 	bl	8004640 <strlen>
 801b95a:	1c41      	adds	r1, r0, #1
 801b95c:	4638      	mov	r0, r7
 801b95e:	f000 f9df 	bl	801bd20 <_malloc_r>
 801b962:	6028      	str	r0, [r5, #0]
 801b964:	b110      	cbz	r0, 801b96c <_tzset_unlocked_r+0x50>
 801b966:	4621      	mov	r1, r4
 801b968:	f000 fd08 	bl	801c37c <strcpy>
 801b96c:	7823      	ldrb	r3, [r4, #0]
 801b96e:	4aac      	ldr	r2, [pc, #688]	; (801bc20 <_tzset_unlocked_r+0x304>)
 801b970:	49ac      	ldr	r1, [pc, #688]	; (801bc24 <_tzset_unlocked_r+0x308>)
 801b972:	2b3a      	cmp	r3, #58	; 0x3a
 801b974:	bf08      	it	eq
 801b976:	3401      	addeq	r4, #1
 801b978:	ad08      	add	r5, sp, #32
 801b97a:	462b      	mov	r3, r5
 801b97c:	4620      	mov	r0, r4
 801b97e:	f000 fc8b 	bl	801c298 <siscanf>
 801b982:	2800      	cmp	r0, #0
 801b984:	dddf      	ble.n	801b946 <_tzset_unlocked_r+0x2a>
 801b986:	9b08      	ldr	r3, [sp, #32]
 801b988:	5ce2      	ldrb	r2, [r4, r3]
 801b98a:	2a2d      	cmp	r2, #45	; 0x2d
 801b98c:	441c      	add	r4, r3
 801b98e:	f000 80c8 	beq.w	801bb22 <_tzset_unlocked_r+0x206>
 801b992:	2a2b      	cmp	r2, #43	; 0x2b
 801b994:	bf08      	it	eq
 801b996:	3401      	addeq	r4, #1
 801b998:	f04f 0801 	mov.w	r8, #1
 801b99c:	ab06      	add	r3, sp, #24
 801b99e:	9302      	str	r3, [sp, #8]
 801b9a0:	f10d 0316 	add.w	r3, sp, #22
 801b9a4:	2700      	movs	r7, #0
 801b9a6:	9300      	str	r3, [sp, #0]
 801b9a8:	9503      	str	r5, [sp, #12]
 801b9aa:	9501      	str	r5, [sp, #4]
 801b9ac:	aa05      	add	r2, sp, #20
 801b9ae:	462b      	mov	r3, r5
 801b9b0:	499d      	ldr	r1, [pc, #628]	; (801bc28 <_tzset_unlocked_r+0x30c>)
 801b9b2:	f8ad 7016 	strh.w	r7, [sp, #22]
 801b9b6:	4620      	mov	r0, r4
 801b9b8:	f8ad 7018 	strh.w	r7, [sp, #24]
 801b9bc:	f000 fc6c 	bl	801c298 <siscanf>
 801b9c0:	42b8      	cmp	r0, r7
 801b9c2:	ddc0      	ble.n	801b946 <_tzset_unlocked_r+0x2a>
 801b9c4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 801b9c8:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 801b9cc:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 801b9d0:	9808      	ldr	r0, [sp, #32]
 801b9d2:	f8df a26c 	ldr.w	sl, [pc, #620]	; 801bc40 <_tzset_unlocked_r+0x324>
 801b9d6:	f8df 925c 	ldr.w	r9, [pc, #604]	; 801bc34 <_tzset_unlocked_r+0x318>
 801b9da:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801b9de:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 801b9e2:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801b9e6:	fb01 3302 	mla	r3, r1, r2, r3
 801b9ea:	fb08 f303 	mul.w	r3, r8, r3
 801b9ee:	6233      	str	r3, [r6, #32]
 801b9f0:	4404      	add	r4, r0
 801b9f2:	4b8b      	ldr	r3, [pc, #556]	; (801bc20 <_tzset_unlocked_r+0x304>)
 801b9f4:	f8c9 3000 	str.w	r3, [r9]
 801b9f8:	4620      	mov	r0, r4
 801b9fa:	4652      	mov	r2, sl
 801b9fc:	4989      	ldr	r1, [pc, #548]	; (801bc24 <_tzset_unlocked_r+0x308>)
 801b9fe:	462b      	mov	r3, r5
 801ba00:	f000 fc4a 	bl	801c298 <siscanf>
 801ba04:	42b8      	cmp	r0, r7
 801ba06:	f340 8082 	ble.w	801bb0e <_tzset_unlocked_r+0x1f2>
 801ba0a:	9808      	ldr	r0, [sp, #32]
 801ba0c:	f8c9 a004 	str.w	sl, [r9, #4]
 801ba10:	5c23      	ldrb	r3, [r4, r0]
 801ba12:	2b2d      	cmp	r3, #45	; 0x2d
 801ba14:	4404      	add	r4, r0
 801ba16:	f000 8095 	beq.w	801bb44 <_tzset_unlocked_r+0x228>
 801ba1a:	2b2b      	cmp	r3, #43	; 0x2b
 801ba1c:	bf08      	it	eq
 801ba1e:	3401      	addeq	r4, #1
 801ba20:	f04f 0801 	mov.w	r8, #1
 801ba24:	ab06      	add	r3, sp, #24
 801ba26:	9302      	str	r3, [sp, #8]
 801ba28:	f10d 0316 	add.w	r3, sp, #22
 801ba2c:	2700      	movs	r7, #0
 801ba2e:	9300      	str	r3, [sp, #0]
 801ba30:	9503      	str	r5, [sp, #12]
 801ba32:	9501      	str	r5, [sp, #4]
 801ba34:	462b      	mov	r3, r5
 801ba36:	aa05      	add	r2, sp, #20
 801ba38:	497b      	ldr	r1, [pc, #492]	; (801bc28 <_tzset_unlocked_r+0x30c>)
 801ba3a:	f8ad 7014 	strh.w	r7, [sp, #20]
 801ba3e:	4620      	mov	r0, r4
 801ba40:	f8ad 7016 	strh.w	r7, [sp, #22]
 801ba44:	f8ad 7018 	strh.w	r7, [sp, #24]
 801ba48:	9708      	str	r7, [sp, #32]
 801ba4a:	f000 fc25 	bl	801c298 <siscanf>
 801ba4e:	42b8      	cmp	r0, r7
 801ba50:	dd7c      	ble.n	801bb4c <_tzset_unlocked_r+0x230>
 801ba52:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 801ba56:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 801ba5a:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 801ba5e:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 801ba62:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 801ba66:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801ba6a:	fb01 3302 	mla	r3, r1, r2, r3
 801ba6e:	fb08 f303 	mul.w	r3, r8, r3
 801ba72:	63f3      	str	r3, [r6, #60]	; 0x3c
 801ba74:	9b08      	ldr	r3, [sp, #32]
 801ba76:	f8df b1cc 	ldr.w	fp, [pc, #460]	; 801bc44 <_tzset_unlocked_r+0x328>
 801ba7a:	441c      	add	r4, r3
 801ba7c:	46b0      	mov	r8, r6
 801ba7e:	f04f 0a00 	mov.w	sl, #0
 801ba82:	7827      	ldrb	r7, [r4, #0]
 801ba84:	2f2c      	cmp	r7, #44	; 0x2c
 801ba86:	bf04      	itt	eq
 801ba88:	7867      	ldrbeq	r7, [r4, #1]
 801ba8a:	3401      	addeq	r4, #1
 801ba8c:	2f4d      	cmp	r7, #77	; 0x4d
 801ba8e:	d062      	beq.n	801bb56 <_tzset_unlocked_r+0x23a>
 801ba90:	2f4a      	cmp	r7, #74	; 0x4a
 801ba92:	bf08      	it	eq
 801ba94:	3401      	addeq	r4, #1
 801ba96:	f04f 020a 	mov.w	r2, #10
 801ba9a:	a909      	add	r1, sp, #36	; 0x24
 801ba9c:	4620      	mov	r0, r4
 801ba9e:	bf18      	it	ne
 801baa0:	2744      	movne	r7, #68	; 0x44
 801baa2:	f000 fdf1 	bl	801c688 <strtoul>
 801baa6:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 801baaa:	f8ad 001e 	strh.w	r0, [sp, #30]
 801baae:	454c      	cmp	r4, r9
 801bab0:	f000 809c 	beq.w	801bbec <_tzset_unlocked_r+0x2d0>
 801bab4:	b280      	uxth	r0, r0
 801bab6:	f8c8 0014 	str.w	r0, [r8, #20]
 801baba:	f888 7008 	strb.w	r7, [r8, #8]
 801babe:	2400      	movs	r4, #0
 801bac0:	2302      	movs	r3, #2
 801bac2:	f8ad 3014 	strh.w	r3, [sp, #20]
 801bac6:	f8ad 4016 	strh.w	r4, [sp, #22]
 801baca:	f8ad 4018 	strh.w	r4, [sp, #24]
 801bace:	9408      	str	r4, [sp, #32]
 801bad0:	f899 3000 	ldrb.w	r3, [r9]
 801bad4:	2b2f      	cmp	r3, #47	; 0x2f
 801bad6:	d06c      	beq.n	801bbb2 <_tzset_unlocked_r+0x296>
 801bad8:	f44f 53e1 	mov.w	r3, #7200	; 0x1c20
 801badc:	f10a 0a01 	add.w	sl, sl, #1
 801bae0:	f1ba 0f02 	cmp.w	sl, #2
 801bae4:	f8c8 3018 	str.w	r3, [r8, #24]
 801bae8:	444c      	add	r4, r9
 801baea:	f108 081c 	add.w	r8, r8, #28
 801baee:	d1c8      	bne.n	801ba82 <_tzset_unlocked_r+0x166>
 801baf0:	6870      	ldr	r0, [r6, #4]
 801baf2:	f7ff fe3f 	bl	801b774 <__tzcalc_limits>
 801baf6:	6a32      	ldr	r2, [r6, #32]
 801baf8:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 801bafa:	484c      	ldr	r0, [pc, #304]	; (801bc2c <_tzset_unlocked_r+0x310>)
 801bafc:	494c      	ldr	r1, [pc, #304]	; (801bc30 <_tzset_unlocked_r+0x314>)
 801bafe:	1a9b      	subs	r3, r3, r2
 801bb00:	bf18      	it	ne
 801bb02:	2301      	movne	r3, #1
 801bb04:	6003      	str	r3, [r0, #0]
 801bb06:	600a      	str	r2, [r1, #0]
 801bb08:	b00b      	add	sp, #44	; 0x2c
 801bb0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801bb0e:	4948      	ldr	r1, [pc, #288]	; (801bc30 <_tzset_unlocked_r+0x314>)
 801bb10:	4a46      	ldr	r2, [pc, #280]	; (801bc2c <_tzset_unlocked_r+0x310>)
 801bb12:	6a30      	ldr	r0, [r6, #32]
 801bb14:	f8d9 3000 	ldr.w	r3, [r9]
 801bb18:	6008      	str	r0, [r1, #0]
 801bb1a:	6017      	str	r7, [r2, #0]
 801bb1c:	f8c9 3004 	str.w	r3, [r9, #4]
 801bb20:	e711      	b.n	801b946 <_tzset_unlocked_r+0x2a>
 801bb22:	3401      	adds	r4, #1
 801bb24:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 801bb28:	e738      	b.n	801b99c <_tzset_unlocked_r+0x80>
 801bb2a:	4b42      	ldr	r3, [pc, #264]	; (801bc34 <_tzset_unlocked_r+0x318>)
 801bb2c:	493f      	ldr	r1, [pc, #252]	; (801bc2c <_tzset_unlocked_r+0x310>)
 801bb2e:	4e40      	ldr	r6, [pc, #256]	; (801bc30 <_tzset_unlocked_r+0x314>)
 801bb30:	4a41      	ldr	r2, [pc, #260]	; (801bc38 <_tzset_unlocked_r+0x31c>)
 801bb32:	6828      	ldr	r0, [r5, #0]
 801bb34:	6034      	str	r4, [r6, #0]
 801bb36:	600c      	str	r4, [r1, #0]
 801bb38:	601a      	str	r2, [r3, #0]
 801bb3a:	605a      	str	r2, [r3, #4]
 801bb3c:	f000 f8e8 	bl	801bd10 <free>
 801bb40:	602c      	str	r4, [r5, #0]
 801bb42:	e700      	b.n	801b946 <_tzset_unlocked_r+0x2a>
 801bb44:	3401      	adds	r4, #1
 801bb46:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 801bb4a:	e76b      	b.n	801ba24 <_tzset_unlocked_r+0x108>
 801bb4c:	6a33      	ldr	r3, [r6, #32]
 801bb4e:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 801bb52:	63f3      	str	r3, [r6, #60]	; 0x3c
 801bb54:	e78e      	b.n	801ba74 <_tzset_unlocked_r+0x158>
 801bb56:	f10d 021e 	add.w	r2, sp, #30
 801bb5a:	ab07      	add	r3, sp, #28
 801bb5c:	9202      	str	r2, [sp, #8]
 801bb5e:	9300      	str	r3, [sp, #0]
 801bb60:	9503      	str	r5, [sp, #12]
 801bb62:	9501      	str	r5, [sp, #4]
 801bb64:	462b      	mov	r3, r5
 801bb66:	f10d 021a 	add.w	r2, sp, #26
 801bb6a:	4659      	mov	r1, fp
 801bb6c:	4620      	mov	r0, r4
 801bb6e:	f000 fb93 	bl	801c298 <siscanf>
 801bb72:	2803      	cmp	r0, #3
 801bb74:	f47f aee7 	bne.w	801b946 <_tzset_unlocked_r+0x2a>
 801bb78:	f8bd 301a 	ldrh.w	r3, [sp, #26]
 801bb7c:	1e5a      	subs	r2, r3, #1
 801bb7e:	2a0b      	cmp	r2, #11
 801bb80:	f63f aee1 	bhi.w	801b946 <_tzset_unlocked_r+0x2a>
 801bb84:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 801bb88:	1e51      	subs	r1, r2, #1
 801bb8a:	2904      	cmp	r1, #4
 801bb8c:	f63f aedb 	bhi.w	801b946 <_tzset_unlocked_r+0x2a>
 801bb90:	f8bd 101e 	ldrh.w	r1, [sp, #30]
 801bb94:	2906      	cmp	r1, #6
 801bb96:	f63f aed6 	bhi.w	801b946 <_tzset_unlocked_r+0x2a>
 801bb9a:	f888 7008 	strb.w	r7, [r8, #8]
 801bb9e:	f8c8 300c 	str.w	r3, [r8, #12]
 801bba2:	f8c8 2010 	str.w	r2, [r8, #16]
 801bba6:	f8c8 1014 	str.w	r1, [r8, #20]
 801bbaa:	9b08      	ldr	r3, [sp, #32]
 801bbac:	eb04 0903 	add.w	r9, r4, r3
 801bbb0:	e785      	b.n	801babe <_tzset_unlocked_r+0x1a2>
 801bbb2:	ab06      	add	r3, sp, #24
 801bbb4:	9302      	str	r3, [sp, #8]
 801bbb6:	f10d 0316 	add.w	r3, sp, #22
 801bbba:	9300      	str	r3, [sp, #0]
 801bbbc:	aa05      	add	r2, sp, #20
 801bbbe:	462b      	mov	r3, r5
 801bbc0:	491e      	ldr	r1, [pc, #120]	; (801bc3c <_tzset_unlocked_r+0x320>)
 801bbc2:	9503      	str	r5, [sp, #12]
 801bbc4:	9501      	str	r5, [sp, #4]
 801bbc6:	4648      	mov	r0, r9
 801bbc8:	f000 fb66 	bl	801c298 <siscanf>
 801bbcc:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 801bbd0:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 801bbd4:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801bbd8:	9c08      	ldr	r4, [sp, #32]
 801bbda:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 801bbde:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801bbe2:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801bbe6:	fb01 2303 	mla	r3, r1, r3, r2
 801bbea:	e777      	b.n	801badc <_tzset_unlocked_r+0x1c0>
 801bbec:	f1ba 0f00 	cmp.w	sl, #0
 801bbf0:	d009      	beq.n	801bc06 <_tzset_unlocked_r+0x2ea>
 801bbf2:	224d      	movs	r2, #77	; 0x4d
 801bbf4:	230b      	movs	r3, #11
 801bbf6:	f886 2024 	strb.w	r2, [r6, #36]	; 0x24
 801bbfa:	62b3      	str	r3, [r6, #40]	; 0x28
 801bbfc:	2201      	movs	r2, #1
 801bbfe:	2300      	movs	r3, #0
 801bc00:	62f2      	str	r2, [r6, #44]	; 0x2c
 801bc02:	6333      	str	r3, [r6, #48]	; 0x30
 801bc04:	e75b      	b.n	801babe <_tzset_unlocked_r+0x1a2>
 801bc06:	234d      	movs	r3, #77	; 0x4d
 801bc08:	2203      	movs	r2, #3
 801bc0a:	7233      	strb	r3, [r6, #8]
 801bc0c:	2302      	movs	r3, #2
 801bc0e:	f8c6 a014 	str.w	sl, [r6, #20]
 801bc12:	60f2      	str	r2, [r6, #12]
 801bc14:	6133      	str	r3, [r6, #16]
 801bc16:	e752      	b.n	801babe <_tzset_unlocked_r+0x1a2>
 801bc18:	08024f34 	.word	0x08024f34
 801bc1c:	2000f1f0 	.word	0x2000f1f0
 801bc20:	2000f1e4 	.word	0x2000f1e4
 801bc24:	08024f3c 	.word	0x08024f3c
 801bc28:	08024f4c 	.word	0x08024f4c
 801bc2c:	2000f1f4 	.word	0x2000f1f4
 801bc30:	2000f1f8 	.word	0x2000f1f8
 801bc34:	20004a0c 	.word	0x20004a0c
 801bc38:	08024f38 	.word	0x08024f38
 801bc3c:	08024f74 	.word	0x08024f74
 801bc40:	2000f1d8 	.word	0x2000f1d8
 801bc44:	08024f60 	.word	0x08024f60

0801bc48 <__ascii_wctomb>:
 801bc48:	b121      	cbz	r1, 801bc54 <__ascii_wctomb+0xc>
 801bc4a:	2aff      	cmp	r2, #255	; 0xff
 801bc4c:	d804      	bhi.n	801bc58 <__ascii_wctomb+0x10>
 801bc4e:	700a      	strb	r2, [r1, #0]
 801bc50:	2001      	movs	r0, #1
 801bc52:	4770      	bx	lr
 801bc54:	4608      	mov	r0, r1
 801bc56:	4770      	bx	lr
 801bc58:	238a      	movs	r3, #138	; 0x8a
 801bc5a:	6003      	str	r3, [r0, #0]
 801bc5c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801bc60:	4770      	bx	lr
 801bc62:	bf00      	nop

0801bc64 <_findenv_r>:
 801bc64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bc68:	4f1c      	ldr	r7, [pc, #112]	; (801bcdc <_findenv_r+0x78>)
 801bc6a:	460e      	mov	r6, r1
 801bc6c:	4691      	mov	r9, r2
 801bc6e:	4680      	mov	r8, r0
 801bc70:	f001 fad8 	bl	801d224 <__env_lock>
 801bc74:	683d      	ldr	r5, [r7, #0]
 801bc76:	b1f5      	cbz	r5, 801bcb6 <_findenv_r+0x52>
 801bc78:	7834      	ldrb	r4, [r6, #0]
 801bc7a:	b15c      	cbz	r4, 801bc94 <_findenv_r+0x30>
 801bc7c:	2c3d      	cmp	r4, #61	; 0x3d
 801bc7e:	bf18      	it	ne
 801bc80:	4634      	movne	r4, r6
 801bc82:	d102      	bne.n	801bc8a <_findenv_r+0x26>
 801bc84:	e017      	b.n	801bcb6 <_findenv_r+0x52>
 801bc86:	2b3d      	cmp	r3, #61	; 0x3d
 801bc88:	d015      	beq.n	801bcb6 <_findenv_r+0x52>
 801bc8a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 801bc8e:	2b00      	cmp	r3, #0
 801bc90:	d1f9      	bne.n	801bc86 <_findenv_r+0x22>
 801bc92:	1ba4      	subs	r4, r4, r6
 801bc94:	6828      	ldr	r0, [r5, #0]
 801bc96:	b170      	cbz	r0, 801bcb6 <_findenv_r+0x52>
 801bc98:	4622      	mov	r2, r4
 801bc9a:	4631      	mov	r1, r6
 801bc9c:	f000 fbec 	bl	801c478 <strncmp>
 801bca0:	b928      	cbnz	r0, 801bcae <_findenv_r+0x4a>
 801bca2:	6828      	ldr	r0, [r5, #0]
 801bca4:	5d03      	ldrb	r3, [r0, r4]
 801bca6:	2b3d      	cmp	r3, #61	; 0x3d
 801bca8:	eb00 0a04 	add.w	sl, r0, r4
 801bcac:	d009      	beq.n	801bcc2 <_findenv_r+0x5e>
 801bcae:	f855 0f04 	ldr.w	r0, [r5, #4]!
 801bcb2:	2800      	cmp	r0, #0
 801bcb4:	d1f0      	bne.n	801bc98 <_findenv_r+0x34>
 801bcb6:	4640      	mov	r0, r8
 801bcb8:	f001 faba 	bl	801d230 <__env_unlock>
 801bcbc:	2000      	movs	r0, #0
 801bcbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801bcc2:	683b      	ldr	r3, [r7, #0]
 801bcc4:	1aed      	subs	r5, r5, r3
 801bcc6:	10ad      	asrs	r5, r5, #2
 801bcc8:	4640      	mov	r0, r8
 801bcca:	f8c9 5000 	str.w	r5, [r9]
 801bcce:	f001 faaf 	bl	801d230 <__env_unlock>
 801bcd2:	f10a 0001 	add.w	r0, sl, #1
 801bcd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801bcda:	bf00      	nop
 801bcdc:	20004e64 	.word	0x20004e64

0801bce0 <_getenv_r>:
 801bce0:	b500      	push	{lr}
 801bce2:	b083      	sub	sp, #12
 801bce4:	aa01      	add	r2, sp, #4
 801bce6:	f7ff ffbd 	bl	801bc64 <_findenv_r>
 801bcea:	b003      	add	sp, #12
 801bcec:	f85d fb04 	ldr.w	pc, [sp], #4

0801bcf0 <__gettzinfo>:
 801bcf0:	4800      	ldr	r0, [pc, #0]	; (801bcf4 <__gettzinfo+0x4>)
 801bcf2:	4770      	bx	lr
 801bcf4:	20004a14 	.word	0x20004a14

0801bcf8 <__retarget_lock_init_recursive>:
 801bcf8:	4770      	bx	lr
 801bcfa:	bf00      	nop

0801bcfc <__retarget_lock_close_recursive>:
 801bcfc:	4770      	bx	lr
 801bcfe:	bf00      	nop

0801bd00 <__retarget_lock_acquire>:
 801bd00:	4770      	bx	lr
 801bd02:	bf00      	nop

0801bd04 <__retarget_lock_acquire_recursive>:
 801bd04:	4770      	bx	lr
 801bd06:	bf00      	nop

0801bd08 <__retarget_lock_release>:
 801bd08:	4770      	bx	lr
 801bd0a:	bf00      	nop

0801bd0c <__retarget_lock_release_recursive>:
 801bd0c:	4770      	bx	lr
 801bd0e:	bf00      	nop

0801bd10 <free>:
 801bd10:	4b02      	ldr	r3, [pc, #8]	; (801bd1c <free+0xc>)
 801bd12:	4601      	mov	r1, r0
 801bd14:	6818      	ldr	r0, [r3, #0]
 801bd16:	f001 bc11 	b.w	801d53c <_free_r>
 801bd1a:	bf00      	nop
 801bd1c:	20004474 	.word	0x20004474

0801bd20 <_malloc_r>:
 801bd20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801bd24:	f101 060b 	add.w	r6, r1, #11
 801bd28:	2e16      	cmp	r6, #22
 801bd2a:	b083      	sub	sp, #12
 801bd2c:	4605      	mov	r5, r0
 801bd2e:	f240 809e 	bls.w	801be6e <_malloc_r+0x14e>
 801bd32:	f036 0607 	bics.w	r6, r6, #7
 801bd36:	f100 80bd 	bmi.w	801beb4 <_malloc_r+0x194>
 801bd3a:	42b1      	cmp	r1, r6
 801bd3c:	f200 80ba 	bhi.w	801beb4 <_malloc_r+0x194>
 801bd40:	f000 fa9e 	bl	801c280 <__malloc_lock>
 801bd44:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
 801bd48:	f0c0 8293 	bcc.w	801c272 <_malloc_r+0x552>
 801bd4c:	0a73      	lsrs	r3, r6, #9
 801bd4e:	f000 80b8 	beq.w	801bec2 <_malloc_r+0x1a2>
 801bd52:	2b04      	cmp	r3, #4
 801bd54:	f200 8179 	bhi.w	801c04a <_malloc_r+0x32a>
 801bd58:	09b3      	lsrs	r3, r6, #6
 801bd5a:	f103 0039 	add.w	r0, r3, #57	; 0x39
 801bd5e:	f103 0e38 	add.w	lr, r3, #56	; 0x38
 801bd62:	00c3      	lsls	r3, r0, #3
 801bd64:	4fbf      	ldr	r7, [pc, #764]	; (801c064 <_malloc_r+0x344>)
 801bd66:	443b      	add	r3, r7
 801bd68:	f1a3 0108 	sub.w	r1, r3, #8
 801bd6c:	685c      	ldr	r4, [r3, #4]
 801bd6e:	42a1      	cmp	r1, r4
 801bd70:	d106      	bne.n	801bd80 <_malloc_r+0x60>
 801bd72:	e00c      	b.n	801bd8e <_malloc_r+0x6e>
 801bd74:	2a00      	cmp	r2, #0
 801bd76:	f280 80aa 	bge.w	801bece <_malloc_r+0x1ae>
 801bd7a:	68e4      	ldr	r4, [r4, #12]
 801bd7c:	42a1      	cmp	r1, r4
 801bd7e:	d006      	beq.n	801bd8e <_malloc_r+0x6e>
 801bd80:	6863      	ldr	r3, [r4, #4]
 801bd82:	f023 0303 	bic.w	r3, r3, #3
 801bd86:	1b9a      	subs	r2, r3, r6
 801bd88:	2a0f      	cmp	r2, #15
 801bd8a:	ddf3      	ble.n	801bd74 <_malloc_r+0x54>
 801bd8c:	4670      	mov	r0, lr
 801bd8e:	693c      	ldr	r4, [r7, #16]
 801bd90:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 801c078 <_malloc_r+0x358>
 801bd94:	4574      	cmp	r4, lr
 801bd96:	f000 81ab 	beq.w	801c0f0 <_malloc_r+0x3d0>
 801bd9a:	6863      	ldr	r3, [r4, #4]
 801bd9c:	f023 0303 	bic.w	r3, r3, #3
 801bda0:	1b9a      	subs	r2, r3, r6
 801bda2:	2a0f      	cmp	r2, #15
 801bda4:	f300 8190 	bgt.w	801c0c8 <_malloc_r+0x3a8>
 801bda8:	2a00      	cmp	r2, #0
 801bdaa:	f8c7 e014 	str.w	lr, [r7, #20]
 801bdae:	f8c7 e010 	str.w	lr, [r7, #16]
 801bdb2:	f280 809d 	bge.w	801bef0 <_malloc_r+0x1d0>
 801bdb6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801bdba:	f080 8161 	bcs.w	801c080 <_malloc_r+0x360>
 801bdbe:	08db      	lsrs	r3, r3, #3
 801bdc0:	f103 0c01 	add.w	ip, r3, #1
 801bdc4:	1099      	asrs	r1, r3, #2
 801bdc6:	687a      	ldr	r2, [r7, #4]
 801bdc8:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
 801bdcc:	f8c4 8008 	str.w	r8, [r4, #8]
 801bdd0:	2301      	movs	r3, #1
 801bdd2:	408b      	lsls	r3, r1
 801bdd4:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
 801bdd8:	4313      	orrs	r3, r2
 801bdda:	3908      	subs	r1, #8
 801bddc:	60e1      	str	r1, [r4, #12]
 801bdde:	607b      	str	r3, [r7, #4]
 801bde0:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
 801bde4:	f8c8 400c 	str.w	r4, [r8, #12]
 801bde8:	1082      	asrs	r2, r0, #2
 801bdea:	2401      	movs	r4, #1
 801bdec:	4094      	lsls	r4, r2
 801bdee:	429c      	cmp	r4, r3
 801bdf0:	f200 808b 	bhi.w	801bf0a <_malloc_r+0x1ea>
 801bdf4:	421c      	tst	r4, r3
 801bdf6:	d106      	bne.n	801be06 <_malloc_r+0xe6>
 801bdf8:	f020 0003 	bic.w	r0, r0, #3
 801bdfc:	0064      	lsls	r4, r4, #1
 801bdfe:	421c      	tst	r4, r3
 801be00:	f100 0004 	add.w	r0, r0, #4
 801be04:	d0fa      	beq.n	801bdfc <_malloc_r+0xdc>
 801be06:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 801be0a:	46cc      	mov	ip, r9
 801be0c:	4680      	mov	r8, r0
 801be0e:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801be12:	459c      	cmp	ip, r3
 801be14:	d107      	bne.n	801be26 <_malloc_r+0x106>
 801be16:	e16d      	b.n	801c0f4 <_malloc_r+0x3d4>
 801be18:	2a00      	cmp	r2, #0
 801be1a:	f280 817b 	bge.w	801c114 <_malloc_r+0x3f4>
 801be1e:	68db      	ldr	r3, [r3, #12]
 801be20:	459c      	cmp	ip, r3
 801be22:	f000 8167 	beq.w	801c0f4 <_malloc_r+0x3d4>
 801be26:	6859      	ldr	r1, [r3, #4]
 801be28:	f021 0103 	bic.w	r1, r1, #3
 801be2c:	1b8a      	subs	r2, r1, r6
 801be2e:	2a0f      	cmp	r2, #15
 801be30:	ddf2      	ble.n	801be18 <_malloc_r+0xf8>
 801be32:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 801be36:	f8d3 8008 	ldr.w	r8, [r3, #8]
 801be3a:	9300      	str	r3, [sp, #0]
 801be3c:	199c      	adds	r4, r3, r6
 801be3e:	4628      	mov	r0, r5
 801be40:	f046 0601 	orr.w	r6, r6, #1
 801be44:	f042 0501 	orr.w	r5, r2, #1
 801be48:	605e      	str	r6, [r3, #4]
 801be4a:	f8c8 c00c 	str.w	ip, [r8, #12]
 801be4e:	f8cc 8008 	str.w	r8, [ip, #8]
 801be52:	617c      	str	r4, [r7, #20]
 801be54:	613c      	str	r4, [r7, #16]
 801be56:	f8c4 e00c 	str.w	lr, [r4, #12]
 801be5a:	f8c4 e008 	str.w	lr, [r4, #8]
 801be5e:	6065      	str	r5, [r4, #4]
 801be60:	505a      	str	r2, [r3, r1]
 801be62:	f000 fa13 	bl	801c28c <__malloc_unlock>
 801be66:	9b00      	ldr	r3, [sp, #0]
 801be68:	f103 0408 	add.w	r4, r3, #8
 801be6c:	e01e      	b.n	801beac <_malloc_r+0x18c>
 801be6e:	2910      	cmp	r1, #16
 801be70:	d820      	bhi.n	801beb4 <_malloc_r+0x194>
 801be72:	f000 fa05 	bl	801c280 <__malloc_lock>
 801be76:	2610      	movs	r6, #16
 801be78:	2318      	movs	r3, #24
 801be7a:	2002      	movs	r0, #2
 801be7c:	4f79      	ldr	r7, [pc, #484]	; (801c064 <_malloc_r+0x344>)
 801be7e:	443b      	add	r3, r7
 801be80:	f1a3 0208 	sub.w	r2, r3, #8
 801be84:	685c      	ldr	r4, [r3, #4]
 801be86:	4294      	cmp	r4, r2
 801be88:	f000 813d 	beq.w	801c106 <_malloc_r+0x3e6>
 801be8c:	6863      	ldr	r3, [r4, #4]
 801be8e:	68e1      	ldr	r1, [r4, #12]
 801be90:	68a6      	ldr	r6, [r4, #8]
 801be92:	f023 0303 	bic.w	r3, r3, #3
 801be96:	4423      	add	r3, r4
 801be98:	4628      	mov	r0, r5
 801be9a:	685a      	ldr	r2, [r3, #4]
 801be9c:	60f1      	str	r1, [r6, #12]
 801be9e:	f042 0201 	orr.w	r2, r2, #1
 801bea2:	608e      	str	r6, [r1, #8]
 801bea4:	605a      	str	r2, [r3, #4]
 801bea6:	f000 f9f1 	bl	801c28c <__malloc_unlock>
 801beaa:	3408      	adds	r4, #8
 801beac:	4620      	mov	r0, r4
 801beae:	b003      	add	sp, #12
 801beb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801beb4:	2400      	movs	r4, #0
 801beb6:	230c      	movs	r3, #12
 801beb8:	4620      	mov	r0, r4
 801beba:	602b      	str	r3, [r5, #0]
 801bebc:	b003      	add	sp, #12
 801bebe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801bec2:	2040      	movs	r0, #64	; 0x40
 801bec4:	f44f 7300 	mov.w	r3, #512	; 0x200
 801bec8:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
 801becc:	e74a      	b.n	801bd64 <_malloc_r+0x44>
 801bece:	4423      	add	r3, r4
 801bed0:	68e1      	ldr	r1, [r4, #12]
 801bed2:	685a      	ldr	r2, [r3, #4]
 801bed4:	68a6      	ldr	r6, [r4, #8]
 801bed6:	f042 0201 	orr.w	r2, r2, #1
 801beda:	60f1      	str	r1, [r6, #12]
 801bedc:	4628      	mov	r0, r5
 801bede:	608e      	str	r6, [r1, #8]
 801bee0:	605a      	str	r2, [r3, #4]
 801bee2:	f000 f9d3 	bl	801c28c <__malloc_unlock>
 801bee6:	3408      	adds	r4, #8
 801bee8:	4620      	mov	r0, r4
 801beea:	b003      	add	sp, #12
 801beec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801bef0:	4423      	add	r3, r4
 801bef2:	4628      	mov	r0, r5
 801bef4:	685a      	ldr	r2, [r3, #4]
 801bef6:	f042 0201 	orr.w	r2, r2, #1
 801befa:	605a      	str	r2, [r3, #4]
 801befc:	f000 f9c6 	bl	801c28c <__malloc_unlock>
 801bf00:	3408      	adds	r4, #8
 801bf02:	4620      	mov	r0, r4
 801bf04:	b003      	add	sp, #12
 801bf06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801bf0a:	68bc      	ldr	r4, [r7, #8]
 801bf0c:	6863      	ldr	r3, [r4, #4]
 801bf0e:	f023 0803 	bic.w	r8, r3, #3
 801bf12:	45b0      	cmp	r8, r6
 801bf14:	d304      	bcc.n	801bf20 <_malloc_r+0x200>
 801bf16:	eba8 0306 	sub.w	r3, r8, r6
 801bf1a:	2b0f      	cmp	r3, #15
 801bf1c:	f300 8085 	bgt.w	801c02a <_malloc_r+0x30a>
 801bf20:	f8df 9158 	ldr.w	r9, [pc, #344]	; 801c07c <_malloc_r+0x35c>
 801bf24:	4b50      	ldr	r3, [pc, #320]	; (801c068 <_malloc_r+0x348>)
 801bf26:	f8d9 2000 	ldr.w	r2, [r9]
 801bf2a:	681b      	ldr	r3, [r3, #0]
 801bf2c:	3201      	adds	r2, #1
 801bf2e:	4433      	add	r3, r6
 801bf30:	eb04 0a08 	add.w	sl, r4, r8
 801bf34:	f000 8155 	beq.w	801c1e2 <_malloc_r+0x4c2>
 801bf38:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801bf3c:	330f      	adds	r3, #15
 801bf3e:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
 801bf42:	f02b 0b0f 	bic.w	fp, fp, #15
 801bf46:	4659      	mov	r1, fp
 801bf48:	4628      	mov	r0, r5
 801bf4a:	f7e9 fb89 	bl	8005660 <_sbrk_r>
 801bf4e:	1c41      	adds	r1, r0, #1
 801bf50:	4602      	mov	r2, r0
 801bf52:	f000 80fc 	beq.w	801c14e <_malloc_r+0x42e>
 801bf56:	4582      	cmp	sl, r0
 801bf58:	f200 80f7 	bhi.w	801c14a <_malloc_r+0x42a>
 801bf5c:	4b43      	ldr	r3, [pc, #268]	; (801c06c <_malloc_r+0x34c>)
 801bf5e:	6819      	ldr	r1, [r3, #0]
 801bf60:	4459      	add	r1, fp
 801bf62:	6019      	str	r1, [r3, #0]
 801bf64:	f000 814d 	beq.w	801c202 <_malloc_r+0x4e2>
 801bf68:	f8d9 0000 	ldr.w	r0, [r9]
 801bf6c:	3001      	adds	r0, #1
 801bf6e:	bf1b      	ittet	ne
 801bf70:	eba2 0a0a 	subne.w	sl, r2, sl
 801bf74:	4451      	addne	r1, sl
 801bf76:	f8c9 2000 	streq.w	r2, [r9]
 801bf7a:	6019      	strne	r1, [r3, #0]
 801bf7c:	f012 0107 	ands.w	r1, r2, #7
 801bf80:	f000 8115 	beq.w	801c1ae <_malloc_r+0x48e>
 801bf84:	f1c1 0008 	rsb	r0, r1, #8
 801bf88:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 801bf8c:	4402      	add	r2, r0
 801bf8e:	3108      	adds	r1, #8
 801bf90:	eb02 090b 	add.w	r9, r2, fp
 801bf94:	f3c9 090b 	ubfx	r9, r9, #0, #12
 801bf98:	eba1 0909 	sub.w	r9, r1, r9
 801bf9c:	4649      	mov	r1, r9
 801bf9e:	4628      	mov	r0, r5
 801bfa0:	9301      	str	r3, [sp, #4]
 801bfa2:	9200      	str	r2, [sp, #0]
 801bfa4:	f7e9 fb5c 	bl	8005660 <_sbrk_r>
 801bfa8:	1c43      	adds	r3, r0, #1
 801bfaa:	e89d 000c 	ldmia.w	sp, {r2, r3}
 801bfae:	f000 8143 	beq.w	801c238 <_malloc_r+0x518>
 801bfb2:	1a80      	subs	r0, r0, r2
 801bfb4:	4448      	add	r0, r9
 801bfb6:	f040 0001 	orr.w	r0, r0, #1
 801bfba:	6819      	ldr	r1, [r3, #0]
 801bfbc:	60ba      	str	r2, [r7, #8]
 801bfbe:	4449      	add	r1, r9
 801bfc0:	42bc      	cmp	r4, r7
 801bfc2:	6050      	str	r0, [r2, #4]
 801bfc4:	6019      	str	r1, [r3, #0]
 801bfc6:	d017      	beq.n	801bff8 <_malloc_r+0x2d8>
 801bfc8:	f1b8 0f0f 	cmp.w	r8, #15
 801bfcc:	f240 80fb 	bls.w	801c1c6 <_malloc_r+0x4a6>
 801bfd0:	6860      	ldr	r0, [r4, #4]
 801bfd2:	f1a8 020c 	sub.w	r2, r8, #12
 801bfd6:	f022 0207 	bic.w	r2, r2, #7
 801bfda:	eb04 0e02 	add.w	lr, r4, r2
 801bfde:	f000 0001 	and.w	r0, r0, #1
 801bfe2:	f04f 0c05 	mov.w	ip, #5
 801bfe6:	4310      	orrs	r0, r2
 801bfe8:	2a0f      	cmp	r2, #15
 801bfea:	6060      	str	r0, [r4, #4]
 801bfec:	f8ce c004 	str.w	ip, [lr, #4]
 801bff0:	f8ce c008 	str.w	ip, [lr, #8]
 801bff4:	f200 8117 	bhi.w	801c226 <_malloc_r+0x506>
 801bff8:	4b1d      	ldr	r3, [pc, #116]	; (801c070 <_malloc_r+0x350>)
 801bffa:	68bc      	ldr	r4, [r7, #8]
 801bffc:	681a      	ldr	r2, [r3, #0]
 801bffe:	4291      	cmp	r1, r2
 801c000:	bf88      	it	hi
 801c002:	6019      	strhi	r1, [r3, #0]
 801c004:	4b1b      	ldr	r3, [pc, #108]	; (801c074 <_malloc_r+0x354>)
 801c006:	681a      	ldr	r2, [r3, #0]
 801c008:	4291      	cmp	r1, r2
 801c00a:	6862      	ldr	r2, [r4, #4]
 801c00c:	bf88      	it	hi
 801c00e:	6019      	strhi	r1, [r3, #0]
 801c010:	f022 0203 	bic.w	r2, r2, #3
 801c014:	4296      	cmp	r6, r2
 801c016:	eba2 0306 	sub.w	r3, r2, r6
 801c01a:	d801      	bhi.n	801c020 <_malloc_r+0x300>
 801c01c:	2b0f      	cmp	r3, #15
 801c01e:	dc04      	bgt.n	801c02a <_malloc_r+0x30a>
 801c020:	4628      	mov	r0, r5
 801c022:	f000 f933 	bl	801c28c <__malloc_unlock>
 801c026:	2400      	movs	r4, #0
 801c028:	e740      	b.n	801beac <_malloc_r+0x18c>
 801c02a:	19a2      	adds	r2, r4, r6
 801c02c:	f043 0301 	orr.w	r3, r3, #1
 801c030:	f046 0601 	orr.w	r6, r6, #1
 801c034:	6066      	str	r6, [r4, #4]
 801c036:	4628      	mov	r0, r5
 801c038:	60ba      	str	r2, [r7, #8]
 801c03a:	6053      	str	r3, [r2, #4]
 801c03c:	f000 f926 	bl	801c28c <__malloc_unlock>
 801c040:	3408      	adds	r4, #8
 801c042:	4620      	mov	r0, r4
 801c044:	b003      	add	sp, #12
 801c046:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c04a:	2b14      	cmp	r3, #20
 801c04c:	d971      	bls.n	801c132 <_malloc_r+0x412>
 801c04e:	2b54      	cmp	r3, #84	; 0x54
 801c050:	f200 80a3 	bhi.w	801c19a <_malloc_r+0x47a>
 801c054:	0b33      	lsrs	r3, r6, #12
 801c056:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 801c05a:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
 801c05e:	00c3      	lsls	r3, r0, #3
 801c060:	e680      	b.n	801bd64 <_malloc_r+0x44>
 801c062:	bf00      	nop
 801c064:	20004a54 	.word	0x20004a54
 801c068:	2000f22c 	.word	0x2000f22c
 801c06c:	2000f1fc 	.word	0x2000f1fc
 801c070:	2000f224 	.word	0x2000f224
 801c074:	2000f228 	.word	0x2000f228
 801c078:	20004a5c 	.word	0x20004a5c
 801c07c:	20004e5c 	.word	0x20004e5c
 801c080:	0a5a      	lsrs	r2, r3, #9
 801c082:	2a04      	cmp	r2, #4
 801c084:	d95b      	bls.n	801c13e <_malloc_r+0x41e>
 801c086:	2a14      	cmp	r2, #20
 801c088:	f200 80ae 	bhi.w	801c1e8 <_malloc_r+0x4c8>
 801c08c:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 801c090:	00c9      	lsls	r1, r1, #3
 801c092:	325b      	adds	r2, #91	; 0x5b
 801c094:	eb07 0c01 	add.w	ip, r7, r1
 801c098:	5879      	ldr	r1, [r7, r1]
 801c09a:	f1ac 0c08 	sub.w	ip, ip, #8
 801c09e:	458c      	cmp	ip, r1
 801c0a0:	f000 8088 	beq.w	801c1b4 <_malloc_r+0x494>
 801c0a4:	684a      	ldr	r2, [r1, #4]
 801c0a6:	f022 0203 	bic.w	r2, r2, #3
 801c0aa:	4293      	cmp	r3, r2
 801c0ac:	d273      	bcs.n	801c196 <_malloc_r+0x476>
 801c0ae:	6889      	ldr	r1, [r1, #8]
 801c0b0:	458c      	cmp	ip, r1
 801c0b2:	d1f7      	bne.n	801c0a4 <_malloc_r+0x384>
 801c0b4:	f8dc 200c 	ldr.w	r2, [ip, #12]
 801c0b8:	687b      	ldr	r3, [r7, #4]
 801c0ba:	60e2      	str	r2, [r4, #12]
 801c0bc:	f8c4 c008 	str.w	ip, [r4, #8]
 801c0c0:	6094      	str	r4, [r2, #8]
 801c0c2:	f8cc 400c 	str.w	r4, [ip, #12]
 801c0c6:	e68f      	b.n	801bde8 <_malloc_r+0xc8>
 801c0c8:	19a1      	adds	r1, r4, r6
 801c0ca:	f046 0c01 	orr.w	ip, r6, #1
 801c0ce:	f042 0601 	orr.w	r6, r2, #1
 801c0d2:	f8c4 c004 	str.w	ip, [r4, #4]
 801c0d6:	4628      	mov	r0, r5
 801c0d8:	6179      	str	r1, [r7, #20]
 801c0da:	6139      	str	r1, [r7, #16]
 801c0dc:	f8c1 e00c 	str.w	lr, [r1, #12]
 801c0e0:	f8c1 e008 	str.w	lr, [r1, #8]
 801c0e4:	604e      	str	r6, [r1, #4]
 801c0e6:	50e2      	str	r2, [r4, r3]
 801c0e8:	f000 f8d0 	bl	801c28c <__malloc_unlock>
 801c0ec:	3408      	adds	r4, #8
 801c0ee:	e6dd      	b.n	801beac <_malloc_r+0x18c>
 801c0f0:	687b      	ldr	r3, [r7, #4]
 801c0f2:	e679      	b.n	801bde8 <_malloc_r+0xc8>
 801c0f4:	f108 0801 	add.w	r8, r8, #1
 801c0f8:	f018 0f03 	tst.w	r8, #3
 801c0fc:	f10c 0c08 	add.w	ip, ip, #8
 801c100:	f47f ae85 	bne.w	801be0e <_malloc_r+0xee>
 801c104:	e02d      	b.n	801c162 <_malloc_r+0x442>
 801c106:	68dc      	ldr	r4, [r3, #12]
 801c108:	42a3      	cmp	r3, r4
 801c10a:	bf08      	it	eq
 801c10c:	3002      	addeq	r0, #2
 801c10e:	f43f ae3e 	beq.w	801bd8e <_malloc_r+0x6e>
 801c112:	e6bb      	b.n	801be8c <_malloc_r+0x16c>
 801c114:	4419      	add	r1, r3
 801c116:	461c      	mov	r4, r3
 801c118:	684a      	ldr	r2, [r1, #4]
 801c11a:	68db      	ldr	r3, [r3, #12]
 801c11c:	f854 6f08 	ldr.w	r6, [r4, #8]!
 801c120:	f042 0201 	orr.w	r2, r2, #1
 801c124:	604a      	str	r2, [r1, #4]
 801c126:	4628      	mov	r0, r5
 801c128:	60f3      	str	r3, [r6, #12]
 801c12a:	609e      	str	r6, [r3, #8]
 801c12c:	f000 f8ae 	bl	801c28c <__malloc_unlock>
 801c130:	e6bc      	b.n	801beac <_malloc_r+0x18c>
 801c132:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 801c136:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
 801c13a:	00c3      	lsls	r3, r0, #3
 801c13c:	e612      	b.n	801bd64 <_malloc_r+0x44>
 801c13e:	099a      	lsrs	r2, r3, #6
 801c140:	f102 0139 	add.w	r1, r2, #57	; 0x39
 801c144:	00c9      	lsls	r1, r1, #3
 801c146:	3238      	adds	r2, #56	; 0x38
 801c148:	e7a4      	b.n	801c094 <_malloc_r+0x374>
 801c14a:	42bc      	cmp	r4, r7
 801c14c:	d054      	beq.n	801c1f8 <_malloc_r+0x4d8>
 801c14e:	68bc      	ldr	r4, [r7, #8]
 801c150:	6862      	ldr	r2, [r4, #4]
 801c152:	f022 0203 	bic.w	r2, r2, #3
 801c156:	e75d      	b.n	801c014 <_malloc_r+0x2f4>
 801c158:	f859 3908 	ldr.w	r3, [r9], #-8
 801c15c:	4599      	cmp	r9, r3
 801c15e:	f040 8086 	bne.w	801c26e <_malloc_r+0x54e>
 801c162:	f010 0f03 	tst.w	r0, #3
 801c166:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 801c16a:	d1f5      	bne.n	801c158 <_malloc_r+0x438>
 801c16c:	687b      	ldr	r3, [r7, #4]
 801c16e:	ea23 0304 	bic.w	r3, r3, r4
 801c172:	607b      	str	r3, [r7, #4]
 801c174:	0064      	lsls	r4, r4, #1
 801c176:	429c      	cmp	r4, r3
 801c178:	f63f aec7 	bhi.w	801bf0a <_malloc_r+0x1ea>
 801c17c:	2c00      	cmp	r4, #0
 801c17e:	f43f aec4 	beq.w	801bf0a <_malloc_r+0x1ea>
 801c182:	421c      	tst	r4, r3
 801c184:	4640      	mov	r0, r8
 801c186:	f47f ae3e 	bne.w	801be06 <_malloc_r+0xe6>
 801c18a:	0064      	lsls	r4, r4, #1
 801c18c:	421c      	tst	r4, r3
 801c18e:	f100 0004 	add.w	r0, r0, #4
 801c192:	d0fa      	beq.n	801c18a <_malloc_r+0x46a>
 801c194:	e637      	b.n	801be06 <_malloc_r+0xe6>
 801c196:	468c      	mov	ip, r1
 801c198:	e78c      	b.n	801c0b4 <_malloc_r+0x394>
 801c19a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801c19e:	d815      	bhi.n	801c1cc <_malloc_r+0x4ac>
 801c1a0:	0bf3      	lsrs	r3, r6, #15
 801c1a2:	f103 0078 	add.w	r0, r3, #120	; 0x78
 801c1a6:	f103 0e77 	add.w	lr, r3, #119	; 0x77
 801c1aa:	00c3      	lsls	r3, r0, #3
 801c1ac:	e5da      	b.n	801bd64 <_malloc_r+0x44>
 801c1ae:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801c1b2:	e6ed      	b.n	801bf90 <_malloc_r+0x270>
 801c1b4:	687b      	ldr	r3, [r7, #4]
 801c1b6:	1092      	asrs	r2, r2, #2
 801c1b8:	2101      	movs	r1, #1
 801c1ba:	fa01 f202 	lsl.w	r2, r1, r2
 801c1be:	4313      	orrs	r3, r2
 801c1c0:	607b      	str	r3, [r7, #4]
 801c1c2:	4662      	mov	r2, ip
 801c1c4:	e779      	b.n	801c0ba <_malloc_r+0x39a>
 801c1c6:	2301      	movs	r3, #1
 801c1c8:	6053      	str	r3, [r2, #4]
 801c1ca:	e729      	b.n	801c020 <_malloc_r+0x300>
 801c1cc:	f240 5254 	movw	r2, #1364	; 0x554
 801c1d0:	4293      	cmp	r3, r2
 801c1d2:	d822      	bhi.n	801c21a <_malloc_r+0x4fa>
 801c1d4:	0cb3      	lsrs	r3, r6, #18
 801c1d6:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 801c1da:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
 801c1de:	00c3      	lsls	r3, r0, #3
 801c1e0:	e5c0      	b.n	801bd64 <_malloc_r+0x44>
 801c1e2:	f103 0b10 	add.w	fp, r3, #16
 801c1e6:	e6ae      	b.n	801bf46 <_malloc_r+0x226>
 801c1e8:	2a54      	cmp	r2, #84	; 0x54
 801c1ea:	d829      	bhi.n	801c240 <_malloc_r+0x520>
 801c1ec:	0b1a      	lsrs	r2, r3, #12
 801c1ee:	f102 016f 	add.w	r1, r2, #111	; 0x6f
 801c1f2:	00c9      	lsls	r1, r1, #3
 801c1f4:	326e      	adds	r2, #110	; 0x6e
 801c1f6:	e74d      	b.n	801c094 <_malloc_r+0x374>
 801c1f8:	4b20      	ldr	r3, [pc, #128]	; (801c27c <_malloc_r+0x55c>)
 801c1fa:	6819      	ldr	r1, [r3, #0]
 801c1fc:	4459      	add	r1, fp
 801c1fe:	6019      	str	r1, [r3, #0]
 801c200:	e6b2      	b.n	801bf68 <_malloc_r+0x248>
 801c202:	f3ca 000b 	ubfx	r0, sl, #0, #12
 801c206:	2800      	cmp	r0, #0
 801c208:	f47f aeae 	bne.w	801bf68 <_malloc_r+0x248>
 801c20c:	eb08 030b 	add.w	r3, r8, fp
 801c210:	68ba      	ldr	r2, [r7, #8]
 801c212:	f043 0301 	orr.w	r3, r3, #1
 801c216:	6053      	str	r3, [r2, #4]
 801c218:	e6ee      	b.n	801bff8 <_malloc_r+0x2d8>
 801c21a:	207f      	movs	r0, #127	; 0x7f
 801c21c:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 801c220:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
 801c224:	e59e      	b.n	801bd64 <_malloc_r+0x44>
 801c226:	f104 0108 	add.w	r1, r4, #8
 801c22a:	4628      	mov	r0, r5
 801c22c:	9300      	str	r3, [sp, #0]
 801c22e:	f001 f985 	bl	801d53c <_free_r>
 801c232:	9b00      	ldr	r3, [sp, #0]
 801c234:	6819      	ldr	r1, [r3, #0]
 801c236:	e6df      	b.n	801bff8 <_malloc_r+0x2d8>
 801c238:	2001      	movs	r0, #1
 801c23a:	f04f 0900 	mov.w	r9, #0
 801c23e:	e6bc      	b.n	801bfba <_malloc_r+0x29a>
 801c240:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 801c244:	d805      	bhi.n	801c252 <_malloc_r+0x532>
 801c246:	0bda      	lsrs	r2, r3, #15
 801c248:	f102 0178 	add.w	r1, r2, #120	; 0x78
 801c24c:	00c9      	lsls	r1, r1, #3
 801c24e:	3277      	adds	r2, #119	; 0x77
 801c250:	e720      	b.n	801c094 <_malloc_r+0x374>
 801c252:	f240 5154 	movw	r1, #1364	; 0x554
 801c256:	428a      	cmp	r2, r1
 801c258:	d805      	bhi.n	801c266 <_malloc_r+0x546>
 801c25a:	0c9a      	lsrs	r2, r3, #18
 801c25c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
 801c260:	00c9      	lsls	r1, r1, #3
 801c262:	327c      	adds	r2, #124	; 0x7c
 801c264:	e716      	b.n	801c094 <_malloc_r+0x374>
 801c266:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
 801c26a:	227e      	movs	r2, #126	; 0x7e
 801c26c:	e712      	b.n	801c094 <_malloc_r+0x374>
 801c26e:	687b      	ldr	r3, [r7, #4]
 801c270:	e780      	b.n	801c174 <_malloc_r+0x454>
 801c272:	08f0      	lsrs	r0, r6, #3
 801c274:	f106 0308 	add.w	r3, r6, #8
 801c278:	e600      	b.n	801be7c <_malloc_r+0x15c>
 801c27a:	bf00      	nop
 801c27c:	2000f1fc 	.word	0x2000f1fc

0801c280 <__malloc_lock>:
 801c280:	4801      	ldr	r0, [pc, #4]	; (801c288 <__malloc_lock+0x8>)
 801c282:	f7ff bd3f 	b.w	801bd04 <__retarget_lock_acquire_recursive>
 801c286:	bf00      	nop
 801c288:	2000f244 	.word	0x2000f244

0801c28c <__malloc_unlock>:
 801c28c:	4801      	ldr	r0, [pc, #4]	; (801c294 <__malloc_unlock+0x8>)
 801c28e:	f7ff bd3d 	b.w	801bd0c <__retarget_lock_release_recursive>
 801c292:	bf00      	nop
 801c294:	2000f244 	.word	0x2000f244

0801c298 <siscanf>:
 801c298:	b40e      	push	{r1, r2, r3}
 801c29a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c29c:	b09c      	sub	sp, #112	; 0x70
 801c29e:	ac21      	add	r4, sp, #132	; 0x84
 801c2a0:	f44f 7201 	mov.w	r2, #516	; 0x204
 801c2a4:	f854 6b04 	ldr.w	r6, [r4], #4
 801c2a8:	f8ad 2014 	strh.w	r2, [sp, #20]
 801c2ac:	9002      	str	r0, [sp, #8]
 801c2ae:	9006      	str	r0, [sp, #24]
 801c2b0:	f7e8 f9c6 	bl	8004640 <strlen>
 801c2b4:	4b0c      	ldr	r3, [pc, #48]	; (801c2e8 <siscanf+0x50>)
 801c2b6:	9401      	str	r4, [sp, #4]
 801c2b8:	4605      	mov	r5, r0
 801c2ba:	4632      	mov	r2, r6
 801c2bc:	4f0b      	ldr	r7, [pc, #44]	; (801c2ec <siscanf+0x54>)
 801c2be:	6818      	ldr	r0, [r3, #0]
 801c2c0:	9503      	str	r5, [sp, #12]
 801c2c2:	4623      	mov	r3, r4
 801c2c4:	f64f 76ff 	movw	r6, #65535	; 0xffff
 801c2c8:	2400      	movs	r4, #0
 801c2ca:	a902      	add	r1, sp, #8
 801c2cc:	9507      	str	r5, [sp, #28]
 801c2ce:	970a      	str	r7, [sp, #40]	; 0x28
 801c2d0:	940e      	str	r4, [sp, #56]	; 0x38
 801c2d2:	9413      	str	r4, [sp, #76]	; 0x4c
 801c2d4:	f8ad 6016 	strh.w	r6, [sp, #22]
 801c2d8:	f000 fa8a 	bl	801c7f0 <__ssvfiscanf_r>
 801c2dc:	b01c      	add	sp, #112	; 0x70
 801c2de:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 801c2e2:	b003      	add	sp, #12
 801c2e4:	4770      	bx	lr
 801c2e6:	bf00      	nop
 801c2e8:	20004474 	.word	0x20004474
 801c2ec:	0801c315 	.word	0x0801c315

0801c2f0 <__sread>:
 801c2f0:	b510      	push	{r4, lr}
 801c2f2:	460c      	mov	r4, r1
 801c2f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801c2f8:	f7e9 f97a 	bl	80055f0 <_read_r>
 801c2fc:	2800      	cmp	r0, #0
 801c2fe:	db03      	blt.n	801c308 <__sread+0x18>
 801c300:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801c302:	4403      	add	r3, r0
 801c304:	6523      	str	r3, [r4, #80]	; 0x50
 801c306:	bd10      	pop	{r4, pc}
 801c308:	89a3      	ldrh	r3, [r4, #12]
 801c30a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801c30e:	81a3      	strh	r3, [r4, #12]
 801c310:	bd10      	pop	{r4, pc}
 801c312:	bf00      	nop

0801c314 <__seofread>:
 801c314:	2000      	movs	r0, #0
 801c316:	4770      	bx	lr

0801c318 <__swrite>:
 801c318:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c31c:	4616      	mov	r6, r2
 801c31e:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 801c322:	461f      	mov	r7, r3
 801c324:	05d3      	lsls	r3, r2, #23
 801c326:	460c      	mov	r4, r1
 801c328:	4605      	mov	r5, r0
 801c32a:	d507      	bpl.n	801c33c <__swrite+0x24>
 801c32c:	2200      	movs	r2, #0
 801c32e:	2302      	movs	r3, #2
 801c330:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801c334:	f7e9 f96c 	bl	8005610 <_lseek_r>
 801c338:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 801c33c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801c340:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801c344:	81a2      	strh	r2, [r4, #12]
 801c346:	463b      	mov	r3, r7
 801c348:	4632      	mov	r2, r6
 801c34a:	4628      	mov	r0, r5
 801c34c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801c350:	f7e9 b96e 	b.w	8005630 <_write_r>

0801c354 <__sseek>:
 801c354:	b510      	push	{r4, lr}
 801c356:	460c      	mov	r4, r1
 801c358:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801c35c:	f7e9 f958 	bl	8005610 <_lseek_r>
 801c360:	89a3      	ldrh	r3, [r4, #12]
 801c362:	1c42      	adds	r2, r0, #1
 801c364:	bf0e      	itee	eq
 801c366:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 801c36a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 801c36e:	6520      	strne	r0, [r4, #80]	; 0x50
 801c370:	81a3      	strh	r3, [r4, #12]
 801c372:	bd10      	pop	{r4, pc}

0801c374 <__sclose>:
 801c374:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801c378:	f7e9 b96a 	b.w	8005650 <_close_r>

0801c37c <strcpy>:
 801c37c:	ea80 0201 	eor.w	r2, r0, r1
 801c380:	4684      	mov	ip, r0
 801c382:	f012 0f03 	tst.w	r2, #3
 801c386:	d14f      	bne.n	801c428 <strcpy+0xac>
 801c388:	f011 0f03 	tst.w	r1, #3
 801c38c:	d132      	bne.n	801c3f4 <strcpy+0x78>
 801c38e:	f84d 4d04 	str.w	r4, [sp, #-4]!
 801c392:	f011 0f04 	tst.w	r1, #4
 801c396:	f851 3b04 	ldr.w	r3, [r1], #4
 801c39a:	d00b      	beq.n	801c3b4 <strcpy+0x38>
 801c39c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801c3a0:	439a      	bics	r2, r3
 801c3a2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 801c3a6:	bf04      	itt	eq
 801c3a8:	f84c 3b04 	streq.w	r3, [ip], #4
 801c3ac:	f851 3b04 	ldreq.w	r3, [r1], #4
 801c3b0:	d116      	bne.n	801c3e0 <strcpy+0x64>
 801c3b2:	bf00      	nop
 801c3b4:	f851 4b04 	ldr.w	r4, [r1], #4
 801c3b8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801c3bc:	439a      	bics	r2, r3
 801c3be:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 801c3c2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 801c3c6:	d10b      	bne.n	801c3e0 <strcpy+0x64>
 801c3c8:	f84c 3b04 	str.w	r3, [ip], #4
 801c3cc:	43a2      	bics	r2, r4
 801c3ce:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 801c3d2:	bf04      	itt	eq
 801c3d4:	f851 3b04 	ldreq.w	r3, [r1], #4
 801c3d8:	f84c 4b04 	streq.w	r4, [ip], #4
 801c3dc:	d0ea      	beq.n	801c3b4 <strcpy+0x38>
 801c3de:	4623      	mov	r3, r4
 801c3e0:	f80c 3b01 	strb.w	r3, [ip], #1
 801c3e4:	f013 0fff 	tst.w	r3, #255	; 0xff
 801c3e8:	ea4f 2333 	mov.w	r3, r3, ror #8
 801c3ec:	d1f8      	bne.n	801c3e0 <strcpy+0x64>
 801c3ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 801c3f2:	4770      	bx	lr
 801c3f4:	f011 0f01 	tst.w	r1, #1
 801c3f8:	d006      	beq.n	801c408 <strcpy+0x8c>
 801c3fa:	f811 2b01 	ldrb.w	r2, [r1], #1
 801c3fe:	f80c 2b01 	strb.w	r2, [ip], #1
 801c402:	2a00      	cmp	r2, #0
 801c404:	bf08      	it	eq
 801c406:	4770      	bxeq	lr
 801c408:	f011 0f02 	tst.w	r1, #2
 801c40c:	d0bf      	beq.n	801c38e <strcpy+0x12>
 801c40e:	f831 2b02 	ldrh.w	r2, [r1], #2
 801c412:	f012 0fff 	tst.w	r2, #255	; 0xff
 801c416:	bf16      	itet	ne
 801c418:	f82c 2b02 	strhne.w	r2, [ip], #2
 801c41c:	f88c 2000 	strbeq.w	r2, [ip]
 801c420:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 801c424:	d1b3      	bne.n	801c38e <strcpy+0x12>
 801c426:	4770      	bx	lr
 801c428:	f811 2b01 	ldrb.w	r2, [r1], #1
 801c42c:	f80c 2b01 	strb.w	r2, [ip], #1
 801c430:	2a00      	cmp	r2, #0
 801c432:	d1f9      	bne.n	801c428 <strcpy+0xac>
 801c434:	4770      	bx	lr
 801c436:	bf00      	nop

0801c438 <strncasecmp_l>:
 801c438:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c43c:	b1c2      	cbz	r2, 801c470 <strncasecmp_l+0x38>
 801c43e:	4605      	mov	r5, r0
 801c440:	460e      	mov	r6, r1
 801c442:	461f      	mov	r7, r3
 801c444:	eb00 0802 	add.w	r8, r0, r2
 801c448:	e002      	b.n	801c450 <strncasecmp_l+0x18>
 801c44a:	b188      	cbz	r0, 801c470 <strncasecmp_l+0x38>
 801c44c:	45a8      	cmp	r8, r5
 801c44e:	d00f      	beq.n	801c470 <strncasecmp_l+0x38>
 801c450:	4639      	mov	r1, r7
 801c452:	f815 0b01 	ldrb.w	r0, [r5], #1
 801c456:	f000 fe9b 	bl	801d190 <tolower_l>
 801c45a:	4639      	mov	r1, r7
 801c45c:	4604      	mov	r4, r0
 801c45e:	f816 0b01 	ldrb.w	r0, [r6], #1
 801c462:	f000 fe95 	bl	801d190 <tolower_l>
 801c466:	1a24      	subs	r4, r4, r0
 801c468:	d0ef      	beq.n	801c44a <strncasecmp_l+0x12>
 801c46a:	4620      	mov	r0, r4
 801c46c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801c470:	2400      	movs	r4, #0
 801c472:	4620      	mov	r0, r4
 801c474:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801c478 <strncmp>:
 801c478:	2a00      	cmp	r2, #0
 801c47a:	d041      	beq.n	801c500 <strncmp+0x88>
 801c47c:	ea40 0301 	orr.w	r3, r0, r1
 801c480:	f013 0303 	ands.w	r3, r3, #3
 801c484:	b4f0      	push	{r4, r5, r6, r7}
 801c486:	d125      	bne.n	801c4d4 <strncmp+0x5c>
 801c488:	2a03      	cmp	r2, #3
 801c48a:	d923      	bls.n	801c4d4 <strncmp+0x5c>
 801c48c:	6804      	ldr	r4, [r0, #0]
 801c48e:	680d      	ldr	r5, [r1, #0]
 801c490:	42ac      	cmp	r4, r5
 801c492:	d11f      	bne.n	801c4d4 <strncmp+0x5c>
 801c494:	3a04      	subs	r2, #4
 801c496:	d038      	beq.n	801c50a <strncmp+0x92>
 801c498:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 801c49c:	ea25 0404 	bic.w	r4, r5, r4
 801c4a0:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801c4a4:	d12e      	bne.n	801c504 <strncmp+0x8c>
 801c4a6:	3004      	adds	r0, #4
 801c4a8:	3104      	adds	r1, #4
 801c4aa:	e00f      	b.n	801c4cc <strncmp+0x54>
 801c4ac:	f850 3b04 	ldr.w	r3, [r0], #4
 801c4b0:	680e      	ldr	r6, [r1, #0]
 801c4b2:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 801c4b6:	42b3      	cmp	r3, r6
 801c4b8:	ea24 0403 	bic.w	r4, r4, r3
 801c4bc:	f101 0104 	add.w	r1, r1, #4
 801c4c0:	d126      	bne.n	801c510 <strncmp+0x98>
 801c4c2:	3a04      	subs	r2, #4
 801c4c4:	d021      	beq.n	801c50a <strncmp+0x92>
 801c4c6:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801c4ca:	d11b      	bne.n	801c504 <strncmp+0x8c>
 801c4cc:	2a03      	cmp	r2, #3
 801c4ce:	4607      	mov	r7, r0
 801c4d0:	460d      	mov	r5, r1
 801c4d2:	d8eb      	bhi.n	801c4ac <strncmp+0x34>
 801c4d4:	7805      	ldrb	r5, [r0, #0]
 801c4d6:	780c      	ldrb	r4, [r1, #0]
 801c4d8:	42ac      	cmp	r4, r5
 801c4da:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
 801c4de:	d11a      	bne.n	801c516 <strncmp+0x9e>
 801c4e0:	b183      	cbz	r3, 801c504 <strncmp+0x8c>
 801c4e2:	b914      	cbnz	r4, 801c4ea <strncmp+0x72>
 801c4e4:	e00e      	b.n	801c504 <strncmp+0x8c>
 801c4e6:	b16b      	cbz	r3, 801c504 <strncmp+0x8c>
 801c4e8:	b17a      	cbz	r2, 801c50a <strncmp+0x92>
 801c4ea:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 801c4ee:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 801c4f2:	42a2      	cmp	r2, r4
 801c4f4:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 801c4f8:	d0f5      	beq.n	801c4e6 <strncmp+0x6e>
 801c4fa:	1b10      	subs	r0, r2, r4
 801c4fc:	bcf0      	pop	{r4, r5, r6, r7}
 801c4fe:	4770      	bx	lr
 801c500:	4610      	mov	r0, r2
 801c502:	4770      	bx	lr
 801c504:	2000      	movs	r0, #0
 801c506:	bcf0      	pop	{r4, r5, r6, r7}
 801c508:	4770      	bx	lr
 801c50a:	4610      	mov	r0, r2
 801c50c:	bcf0      	pop	{r4, r5, r6, r7}
 801c50e:	4770      	bx	lr
 801c510:	4629      	mov	r1, r5
 801c512:	4638      	mov	r0, r7
 801c514:	e7de      	b.n	801c4d4 <strncmp+0x5c>
 801c516:	462a      	mov	r2, r5
 801c518:	e7ef      	b.n	801c4fa <strncmp+0x82>
 801c51a:	bf00      	nop

0801c51c <_strtoul_l.isra.0>:
 801c51c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c520:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 801c524:	460e      	mov	r6, r1
 801c526:	4607      	mov	r7, r0
 801c528:	4615      	mov	r5, r2
 801c52a:	4698      	mov	r8, r3
 801c52c:	468a      	mov	sl, r1
 801c52e:	e000      	b.n	801c532 <_strtoul_l.isra.0+0x16>
 801c530:	46a2      	mov	sl, r4
 801c532:	4654      	mov	r4, sl
 801c534:	4648      	mov	r0, r9
 801c536:	f814 bb01 	ldrb.w	fp, [r4], #1
 801c53a:	f7fe fb09 	bl	801ab50 <__locale_ctype_ptr_l>
 801c53e:	4458      	add	r0, fp
 801c540:	7840      	ldrb	r0, [r0, #1]
 801c542:	f010 0008 	ands.w	r0, r0, #8
 801c546:	d1f3      	bne.n	801c530 <_strtoul_l.isra.0+0x14>
 801c548:	4659      	mov	r1, fp
 801c54a:	292d      	cmp	r1, #45	; 0x2d
 801c54c:	d059      	beq.n	801c602 <_strtoul_l.isra.0+0xe6>
 801c54e:	292b      	cmp	r1, #43	; 0x2b
 801c550:	bf04      	itt	eq
 801c552:	7821      	ldrbeq	r1, [r4, #0]
 801c554:	f10a 0402 	addeq.w	r4, sl, #2
 801c558:	f1b8 0f00 	cmp.w	r8, #0
 801c55c:	d00c      	beq.n	801c578 <_strtoul_l.isra.0+0x5c>
 801c55e:	f1b8 0f10 	cmp.w	r8, #16
 801c562:	d053      	beq.n	801c60c <_strtoul_l.isra.0+0xf0>
 801c564:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 801c568:	fbbc fcf8 	udiv	ip, ip, r8
 801c56c:	fb08 fa0c 	mul.w	sl, r8, ip
 801c570:	ea6f 0a0a 	mvn.w	sl, sl
 801c574:	46c1      	mov	r9, r8
 801c576:	e008      	b.n	801c58a <_strtoul_l.isra.0+0x6e>
 801c578:	2930      	cmp	r1, #48	; 0x30
 801c57a:	d058      	beq.n	801c62e <_strtoul_l.isra.0+0x112>
 801c57c:	f04f 080a 	mov.w	r8, #10
 801c580:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 801c660 <_strtoul_l.isra.0+0x144>
 801c584:	46c1      	mov	r9, r8
 801c586:	f04f 0a05 	mov.w	sl, #5
 801c58a:	2300      	movs	r3, #0
 801c58c:	469e      	mov	lr, r3
 801c58e:	e005      	b.n	801c59c <_strtoul_l.isra.0+0x80>
 801c590:	d02a      	beq.n	801c5e8 <_strtoul_l.isra.0+0xcc>
 801c592:	fb09 2e0e 	mla	lr, r9, lr, r2
 801c596:	2301      	movs	r3, #1
 801c598:	f814 1b01 	ldrb.w	r1, [r4], #1
 801c59c:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 801c5a0:	2a09      	cmp	r2, #9
 801c5a2:	d905      	bls.n	801c5b0 <_strtoul_l.isra.0+0x94>
 801c5a4:	f1a1 0241 	sub.w	r2, r1, #65	; 0x41
 801c5a8:	2a19      	cmp	r2, #25
 801c5aa:	d80a      	bhi.n	801c5c2 <_strtoul_l.isra.0+0xa6>
 801c5ac:	f1a1 0237 	sub.w	r2, r1, #55	; 0x37
 801c5b0:	4590      	cmp	r8, r2
 801c5b2:	dd0e      	ble.n	801c5d2 <_strtoul_l.isra.0+0xb6>
 801c5b4:	2b00      	cmp	r3, #0
 801c5b6:	db01      	blt.n	801c5bc <_strtoul_l.isra.0+0xa0>
 801c5b8:	45e6      	cmp	lr, ip
 801c5ba:	d9e9      	bls.n	801c590 <_strtoul_l.isra.0+0x74>
 801c5bc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801c5c0:	e7ea      	b.n	801c598 <_strtoul_l.isra.0+0x7c>
 801c5c2:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 801c5c6:	2a19      	cmp	r2, #25
 801c5c8:	d803      	bhi.n	801c5d2 <_strtoul_l.isra.0+0xb6>
 801c5ca:	f1a1 0257 	sub.w	r2, r1, #87	; 0x57
 801c5ce:	4590      	cmp	r8, r2
 801c5d0:	dcf0      	bgt.n	801c5b4 <_strtoul_l.isra.0+0x98>
 801c5d2:	2b00      	cmp	r3, #0
 801c5d4:	db0d      	blt.n	801c5f2 <_strtoul_l.isra.0+0xd6>
 801c5d6:	b108      	cbz	r0, 801c5dc <_strtoul_l.isra.0+0xc0>
 801c5d8:	f1ce 0e00 	rsb	lr, lr, #0
 801c5dc:	b10d      	cbz	r5, 801c5e2 <_strtoul_l.isra.0+0xc6>
 801c5de:	b973      	cbnz	r3, 801c5fe <_strtoul_l.isra.0+0xe2>
 801c5e0:	602e      	str	r6, [r5, #0]
 801c5e2:	4670      	mov	r0, lr
 801c5e4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c5e8:	4552      	cmp	r2, sl
 801c5ea:	ddd2      	ble.n	801c592 <_strtoul_l.isra.0+0x76>
 801c5ec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801c5f0:	e7d2      	b.n	801c598 <_strtoul_l.isra.0+0x7c>
 801c5f2:	2322      	movs	r3, #34	; 0x22
 801c5f4:	603b      	str	r3, [r7, #0]
 801c5f6:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 801c5fa:	2d00      	cmp	r5, #0
 801c5fc:	d0f1      	beq.n	801c5e2 <_strtoul_l.isra.0+0xc6>
 801c5fe:	1e66      	subs	r6, r4, #1
 801c600:	e7ee      	b.n	801c5e0 <_strtoul_l.isra.0+0xc4>
 801c602:	7821      	ldrb	r1, [r4, #0]
 801c604:	2001      	movs	r0, #1
 801c606:	f10a 0402 	add.w	r4, sl, #2
 801c60a:	e7a5      	b.n	801c558 <_strtoul_l.isra.0+0x3c>
 801c60c:	2930      	cmp	r1, #48	; 0x30
 801c60e:	d11b      	bne.n	801c648 <_strtoul_l.isra.0+0x12c>
 801c610:	7823      	ldrb	r3, [r4, #0]
 801c612:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801c616:	2b58      	cmp	r3, #88	; 0x58
 801c618:	d11c      	bne.n	801c654 <_strtoul_l.isra.0+0x138>
 801c61a:	f04f 0910 	mov.w	r9, #16
 801c61e:	7861      	ldrb	r1, [r4, #1]
 801c620:	46c8      	mov	r8, r9
 801c622:	f04f 0a0f 	mov.w	sl, #15
 801c626:	3402      	adds	r4, #2
 801c628:	f06f 4c70 	mvn.w	ip, #4026531840	; 0xf0000000
 801c62c:	e7ad      	b.n	801c58a <_strtoul_l.isra.0+0x6e>
 801c62e:	7823      	ldrb	r3, [r4, #0]
 801c630:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801c634:	2b58      	cmp	r3, #88	; 0x58
 801c636:	d0f0      	beq.n	801c61a <_strtoul_l.isra.0+0xfe>
 801c638:	f04f 0808 	mov.w	r8, #8
 801c63c:	46c1      	mov	r9, r8
 801c63e:	f04f 0a07 	mov.w	sl, #7
 801c642:	f06f 4c60 	mvn.w	ip, #3758096384	; 0xe0000000
 801c646:	e7a0      	b.n	801c58a <_strtoul_l.isra.0+0x6e>
 801c648:	f04f 0a0f 	mov.w	sl, #15
 801c64c:	f06f 4c70 	mvn.w	ip, #4026531840	; 0xf0000000
 801c650:	46c1      	mov	r9, r8
 801c652:	e79a      	b.n	801c58a <_strtoul_l.isra.0+0x6e>
 801c654:	46c1      	mov	r9, r8
 801c656:	f06f 4c70 	mvn.w	ip, #4026531840	; 0xf0000000
 801c65a:	f04f 0a0f 	mov.w	sl, #15
 801c65e:	e794      	b.n	801c58a <_strtoul_l.isra.0+0x6e>
 801c660:	19999999 	.word	0x19999999

0801c664 <_strtoul_r>:
 801c664:	b530      	push	{r4, r5, lr}
 801c666:	4c06      	ldr	r4, [pc, #24]	; (801c680 <_strtoul_r+0x1c>)
 801c668:	4d06      	ldr	r5, [pc, #24]	; (801c684 <_strtoul_r+0x20>)
 801c66a:	6824      	ldr	r4, [r4, #0]
 801c66c:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801c66e:	b083      	sub	sp, #12
 801c670:	2c00      	cmp	r4, #0
 801c672:	bf08      	it	eq
 801c674:	462c      	moveq	r4, r5
 801c676:	9400      	str	r4, [sp, #0]
 801c678:	f7ff ff50 	bl	801c51c <_strtoul_l.isra.0>
 801c67c:	b003      	add	sp, #12
 801c67e:	bd30      	pop	{r4, r5, pc}
 801c680:	20004474 	.word	0x20004474
 801c684:	200048a0 	.word	0x200048a0

0801c688 <strtoul>:
 801c688:	b530      	push	{r4, r5, lr}
 801c68a:	4c08      	ldr	r4, [pc, #32]	; (801c6ac <strtoul+0x24>)
 801c68c:	4b08      	ldr	r3, [pc, #32]	; (801c6b0 <strtoul+0x28>)
 801c68e:	6825      	ldr	r5, [r4, #0]
 801c690:	6b6c      	ldr	r4, [r5, #52]	; 0x34
 801c692:	b083      	sub	sp, #12
 801c694:	2c00      	cmp	r4, #0
 801c696:	bf08      	it	eq
 801c698:	461c      	moveq	r4, r3
 801c69a:	9400      	str	r4, [sp, #0]
 801c69c:	4613      	mov	r3, r2
 801c69e:	460a      	mov	r2, r1
 801c6a0:	4601      	mov	r1, r0
 801c6a2:	4628      	mov	r0, r5
 801c6a4:	f7ff ff3a 	bl	801c51c <_strtoul_l.isra.0>
 801c6a8:	b003      	add	sp, #12
 801c6aa:	bd30      	pop	{r4, r5, pc}
 801c6ac:	20004474 	.word	0x20004474
 801c6b0:	200048a0 	.word	0x200048a0

0801c6b4 <_sungetc_r>:
 801c6b4:	b538      	push	{r3, r4, r5, lr}
 801c6b6:	1c4b      	adds	r3, r1, #1
 801c6b8:	d01a      	beq.n	801c6f0 <_sungetc_r+0x3c>
 801c6ba:	8993      	ldrh	r3, [r2, #12]
 801c6bc:	6b14      	ldr	r4, [r2, #48]	; 0x30
 801c6be:	f023 0320 	bic.w	r3, r3, #32
 801c6c2:	b2cd      	uxtb	r5, r1
 801c6c4:	8193      	strh	r3, [r2, #12]
 801c6c6:	b1b4      	cbz	r4, 801c6f6 <_sungetc_r+0x42>
 801c6c8:	4614      	mov	r4, r2
 801c6ca:	6852      	ldr	r2, [r2, #4]
 801c6cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801c6ce:	429a      	cmp	r2, r3
 801c6d0:	da09      	bge.n	801c6e6 <_sungetc_r+0x32>
 801c6d2:	6823      	ldr	r3, [r4, #0]
 801c6d4:	1e5a      	subs	r2, r3, #1
 801c6d6:	6022      	str	r2, [r4, #0]
 801c6d8:	f803 5c01 	strb.w	r5, [r3, #-1]
 801c6dc:	6863      	ldr	r3, [r4, #4]
 801c6de:	3301      	adds	r3, #1
 801c6e0:	6063      	str	r3, [r4, #4]
 801c6e2:	4628      	mov	r0, r5
 801c6e4:	bd38      	pop	{r3, r4, r5, pc}
 801c6e6:	4621      	mov	r1, r4
 801c6e8:	f000 fd60 	bl	801d1ac <__submore>
 801c6ec:	2800      	cmp	r0, #0
 801c6ee:	d0f0      	beq.n	801c6d2 <_sungetc_r+0x1e>
 801c6f0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 801c6f4:	e7f5      	b.n	801c6e2 <_sungetc_r+0x2e>
 801c6f6:	6911      	ldr	r1, [r2, #16]
 801c6f8:	6813      	ldr	r3, [r2, #0]
 801c6fa:	b129      	cbz	r1, 801c708 <_sungetc_r+0x54>
 801c6fc:	4299      	cmp	r1, r3
 801c6fe:	d203      	bcs.n	801c708 <_sungetc_r+0x54>
 801c700:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 801c704:	428d      	cmp	r5, r1
 801c706:	d00f      	beq.n	801c728 <_sungetc_r+0x74>
 801c708:	6393      	str	r3, [r2, #56]	; 0x38
 801c70a:	4613      	mov	r3, r2
 801c70c:	6854      	ldr	r4, [r2, #4]
 801c70e:	63d4      	str	r4, [r2, #60]	; 0x3c
 801c710:	f102 0040 	add.w	r0, r2, #64	; 0x40
 801c714:	2103      	movs	r1, #3
 801c716:	6310      	str	r0, [r2, #48]	; 0x30
 801c718:	6351      	str	r1, [r2, #52]	; 0x34
 801c71a:	f803 5f42 	strb.w	r5, [r3, #66]!
 801c71e:	2101      	movs	r1, #1
 801c720:	6013      	str	r3, [r2, #0]
 801c722:	6051      	str	r1, [r2, #4]
 801c724:	4628      	mov	r0, r5
 801c726:	bd38      	pop	{r3, r4, r5, pc}
 801c728:	6851      	ldr	r1, [r2, #4]
 801c72a:	3b01      	subs	r3, #1
 801c72c:	3101      	adds	r1, #1
 801c72e:	6013      	str	r3, [r2, #0]
 801c730:	6051      	str	r1, [r2, #4]
 801c732:	e7d6      	b.n	801c6e2 <_sungetc_r+0x2e>

0801c734 <__ssrefill_r>:
 801c734:	b510      	push	{r4, lr}
 801c736:	460c      	mov	r4, r1
 801c738:	6b09      	ldr	r1, [r1, #48]	; 0x30
 801c73a:	b169      	cbz	r1, 801c758 <__ssrefill_r+0x24>
 801c73c:	f104 0340 	add.w	r3, r4, #64	; 0x40
 801c740:	4299      	cmp	r1, r3
 801c742:	d001      	beq.n	801c748 <__ssrefill_r+0x14>
 801c744:	f000 fefa 	bl	801d53c <_free_r>
 801c748:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 801c74a:	6063      	str	r3, [r4, #4]
 801c74c:	2000      	movs	r0, #0
 801c74e:	6320      	str	r0, [r4, #48]	; 0x30
 801c750:	b113      	cbz	r3, 801c758 <__ssrefill_r+0x24>
 801c752:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801c754:	6023      	str	r3, [r4, #0]
 801c756:	bd10      	pop	{r4, pc}
 801c758:	89a3      	ldrh	r3, [r4, #12]
 801c75a:	6922      	ldr	r2, [r4, #16]
 801c75c:	6022      	str	r2, [r4, #0]
 801c75e:	f043 0320 	orr.w	r3, r3, #32
 801c762:	2200      	movs	r2, #0
 801c764:	81a3      	strh	r3, [r4, #12]
 801c766:	6062      	str	r2, [r4, #4]
 801c768:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801c76c:	bd10      	pop	{r4, pc}
 801c76e:	bf00      	nop

0801c770 <_sfread_r>:
 801c770:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c774:	b083      	sub	sp, #12
 801c776:	fb02 f903 	mul.w	r9, r2, r3
 801c77a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801c77c:	f1b9 0f00 	cmp.w	r9, #0
 801c780:	d028      	beq.n	801c7d4 <_sfread_r+0x64>
 801c782:	4607      	mov	r7, r0
 801c784:	469a      	mov	sl, r3
 801c786:	9201      	str	r2, [sp, #4]
 801c788:	460d      	mov	r5, r1
 801c78a:	464e      	mov	r6, r9
 801c78c:	f04f 0800 	mov.w	r8, #0
 801c790:	e00f      	b.n	801c7b2 <_sfread_r+0x42>
 801c792:	6821      	ldr	r1, [r4, #0]
 801c794:	f7e7 ffc2 	bl	800471c <memcpy>
 801c798:	6822      	ldr	r2, [r4, #0]
 801c79a:	f8c4 8004 	str.w	r8, [r4, #4]
 801c79e:	445a      	add	r2, fp
 801c7a0:	6022      	str	r2, [r4, #0]
 801c7a2:	4621      	mov	r1, r4
 801c7a4:	4638      	mov	r0, r7
 801c7a6:	445d      	add	r5, fp
 801c7a8:	eba6 060b 	sub.w	r6, r6, fp
 801c7ac:	f7ff ffc2 	bl	801c734 <__ssrefill_r>
 801c7b0:	b9a0      	cbnz	r0, 801c7dc <_sfread_r+0x6c>
 801c7b2:	f8d4 b004 	ldr.w	fp, [r4, #4]
 801c7b6:	455e      	cmp	r6, fp
 801c7b8:	4628      	mov	r0, r5
 801c7ba:	465a      	mov	r2, fp
 801c7bc:	d8e9      	bhi.n	801c792 <_sfread_r+0x22>
 801c7be:	4632      	mov	r2, r6
 801c7c0:	6821      	ldr	r1, [r4, #0]
 801c7c2:	f7e7 ffab 	bl	800471c <memcpy>
 801c7c6:	6862      	ldr	r2, [r4, #4]
 801c7c8:	6823      	ldr	r3, [r4, #0]
 801c7ca:	1b92      	subs	r2, r2, r6
 801c7cc:	441e      	add	r6, r3
 801c7ce:	46d1      	mov	r9, sl
 801c7d0:	6062      	str	r2, [r4, #4]
 801c7d2:	6026      	str	r6, [r4, #0]
 801c7d4:	4648      	mov	r0, r9
 801c7d6:	b003      	add	sp, #12
 801c7d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c7dc:	9b01      	ldr	r3, [sp, #4]
 801c7de:	eba9 0906 	sub.w	r9, r9, r6
 801c7e2:	fbb9 f9f3 	udiv	r9, r9, r3
 801c7e6:	4648      	mov	r0, r9
 801c7e8:	b003      	add	sp, #12
 801c7ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c7ee:	bf00      	nop

0801c7f0 <__ssvfiscanf_r>:
 801c7f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c7f4:	468b      	mov	fp, r1
 801c7f6:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
 801c7fa:	b0d9      	sub	sp, #356	; 0x164
 801c7fc:	4607      	mov	r7, r0
 801c7fe:	0488      	lsls	r0, r1, #18
 801c800:	9306      	str	r3, [sp, #24]
 801c802:	d409      	bmi.n	801c818 <__ssvfiscanf_r+0x28>
 801c804:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
 801c808:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 801c80c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 801c810:	f8ab 100c 	strh.w	r1, [fp, #12]
 801c814:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
 801c818:	4614      	mov	r4, r2
 801c81a:	4626      	mov	r6, r4
 801c81c:	2300      	movs	r3, #0
 801c81e:	9307      	str	r3, [sp, #28]
 801c820:	9304      	str	r3, [sp, #16]
 801c822:	469a      	mov	sl, r3
 801c824:	9305      	str	r3, [sp, #20]
 801c826:	f816 3b01 	ldrb.w	r3, [r6], #1
 801c82a:	930b      	str	r3, [sp, #44]	; 0x2c
 801c82c:	b363      	cbz	r3, 801c888 <__ssvfiscanf_r+0x98>
 801c82e:	f7fe f993 	bl	801ab58 <__locale_ctype_ptr>
 801c832:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801c834:	4418      	add	r0, r3
 801c836:	7845      	ldrb	r5, [r0, #1]
 801c838:	f015 0508 	ands.w	r5, r5, #8
 801c83c:	d028      	beq.n	801c890 <__ssvfiscanf_r+0xa0>
 801c83e:	f8db 2004 	ldr.w	r2, [fp, #4]
 801c842:	e012      	b.n	801c86a <__ssvfiscanf_r+0x7a>
 801c844:	f7fe f988 	bl	801ab58 <__locale_ctype_ptr>
 801c848:	f8db 3000 	ldr.w	r3, [fp]
 801c84c:	781a      	ldrb	r2, [r3, #0]
 801c84e:	4410      	add	r0, r2
 801c850:	3301      	adds	r3, #1
 801c852:	7842      	ldrb	r2, [r0, #1]
 801c854:	0712      	lsls	r2, r2, #28
 801c856:	d510      	bpl.n	801c87a <__ssvfiscanf_r+0x8a>
 801c858:	f8db 2004 	ldr.w	r2, [fp, #4]
 801c85c:	f8cb 3000 	str.w	r3, [fp]
 801c860:	3a01      	subs	r2, #1
 801c862:	f10a 0a01 	add.w	sl, sl, #1
 801c866:	f8cb 2004 	str.w	r2, [fp, #4]
 801c86a:	2a00      	cmp	r2, #0
 801c86c:	dcea      	bgt.n	801c844 <__ssvfiscanf_r+0x54>
 801c86e:	4659      	mov	r1, fp
 801c870:	4638      	mov	r0, r7
 801c872:	f7ff ff5f 	bl	801c734 <__ssrefill_r>
 801c876:	2800      	cmp	r0, #0
 801c878:	d0e4      	beq.n	801c844 <__ssvfiscanf_r+0x54>
 801c87a:	4634      	mov	r4, r6
 801c87c:	4626      	mov	r6, r4
 801c87e:	f816 3b01 	ldrb.w	r3, [r6], #1
 801c882:	930b      	str	r3, [sp, #44]	; 0x2c
 801c884:	2b00      	cmp	r3, #0
 801c886:	d1d2      	bne.n	801c82e <__ssvfiscanf_r+0x3e>
 801c888:	9805      	ldr	r0, [sp, #20]
 801c88a:	b059      	add	sp, #356	; 0x164
 801c88c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c890:	2b25      	cmp	r3, #37	; 0x25
 801c892:	f040 8084 	bne.w	801c99e <__ssvfiscanf_r+0x1ae>
 801c896:	f894 8001 	ldrb.w	r8, [r4, #1]
 801c89a:	462c      	mov	r4, r5
 801c89c:	1c73      	adds	r3, r6, #1
 801c89e:	f1b8 0f78 	cmp.w	r8, #120	; 0x78
 801c8a2:	f200 8187 	bhi.w	801cbb4 <__ssvfiscanf_r+0x3c4>
 801c8a6:	e8df f018 	tbh	[pc, r8, lsl #1]
 801c8aa:	0093      	.short	0x0093
 801c8ac:	01850185 	.word	0x01850185
 801c8b0:	01850185 	.word	0x01850185
 801c8b4:	01850185 	.word	0x01850185
 801c8b8:	01850185 	.word	0x01850185
 801c8bc:	01850185 	.word	0x01850185
 801c8c0:	01850185 	.word	0x01850185
 801c8c4:	01850185 	.word	0x01850185
 801c8c8:	01850185 	.word	0x01850185
 801c8cc:	01850185 	.word	0x01850185
 801c8d0:	01850185 	.word	0x01850185
 801c8d4:	01850185 	.word	0x01850185
 801c8d8:	01850185 	.word	0x01850185
 801c8dc:	01850185 	.word	0x01850185
 801c8e0:	01850185 	.word	0x01850185
 801c8e4:	01850185 	.word	0x01850185
 801c8e8:	01850185 	.word	0x01850185
 801c8ec:	01850185 	.word	0x01850185
 801c8f0:	01850185 	.word	0x01850185
 801c8f4:	01850079 	.word	0x01850079
 801c8f8:	01850185 	.word	0x01850185
 801c8fc:	017f0185 	.word	0x017f0185
 801c900:	01850185 	.word	0x01850185
 801c904:	01850185 	.word	0x01850185
 801c908:	01760185 	.word	0x01760185
 801c90c:	01760176 	.word	0x01760176
 801c910:	01760176 	.word	0x01760176
 801c914:	01760176 	.word	0x01760176
 801c918:	01760176 	.word	0x01760176
 801c91c:	01850176 	.word	0x01850176
 801c920:	01850185 	.word	0x01850185
 801c924:	01850185 	.word	0x01850185
 801c928:	01850185 	.word	0x01850185
 801c92c:	01850185 	.word	0x01850185
 801c930:	01720185 	.word	0x01720185
 801c934:	01850185 	.word	0x01850185
 801c938:	01850185 	.word	0x01850185
 801c93c:	01850185 	.word	0x01850185
 801c940:	016c0185 	.word	0x016c0185
 801c944:	01850185 	.word	0x01850185
 801c948:	01850168 	.word	0x01850168
 801c94c:	01850185 	.word	0x01850185
 801c950:	01850185 	.word	0x01850185
 801c954:	01850185 	.word	0x01850185
 801c958:	01640185 	.word	0x01640185
 801c95c:	01850185 	.word	0x01850185
 801c960:	0185015b 	.word	0x0185015b
 801c964:	01850185 	.word	0x01850185
 801c968:	01850185 	.word	0x01850185
 801c96c:	01850185 	.word	0x01850185
 801c970:	01030115 	.word	0x01030115
 801c974:	01850185 	.word	0x01850185
 801c978:	011a0185 	.word	0x011a0185
 801c97c:	0185009a 	.word	0x0185009a
 801c980:	01510185 	.word	0x01510185
 801c984:	013a0185 	.word	0x013a0185
 801c988:	012a0133 	.word	0x012a0133
 801c98c:	01850185 	.word	0x01850185
 801c990:	01850127 	.word	0x01850127
 801c994:	01850120 	.word	0x01850120
 801c998:	01640185 	.word	0x01640185
 801c99c:	461e      	mov	r6, r3
 801c99e:	f8db 3004 	ldr.w	r3, [fp, #4]
 801c9a2:	2b00      	cmp	r3, #0
 801c9a4:	f340 8375 	ble.w	801d092 <__ssvfiscanf_r+0x8a2>
 801c9a8:	f8db 3000 	ldr.w	r3, [fp]
 801c9ac:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 801c9b0:	7819      	ldrb	r1, [r3, #0]
 801c9b2:	4291      	cmp	r1, r2
 801c9b4:	f47f af68 	bne.w	801c888 <__ssvfiscanf_r+0x98>
 801c9b8:	f8db 2004 	ldr.w	r2, [fp, #4]
 801c9bc:	3301      	adds	r3, #1
 801c9be:	3a01      	subs	r2, #1
 801c9c0:	f8cb 3000 	str.w	r3, [fp]
 801c9c4:	f10a 0a01 	add.w	sl, sl, #1
 801c9c8:	f8cb 2004 	str.w	r2, [fp, #4]
 801c9cc:	4634      	mov	r4, r6
 801c9ce:	e755      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801c9d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801c9d4:	9305      	str	r3, [sp, #20]
 801c9d6:	9805      	ldr	r0, [sp, #20]
 801c9d8:	b059      	add	sp, #356	; 0x164
 801c9da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c9de:	9303      	str	r3, [sp, #12]
 801c9e0:	4ba7      	ldr	r3, [pc, #668]	; (801cc80 <__ssvfiscanf_r+0x490>)
 801c9e2:	9307      	str	r3, [sp, #28]
 801c9e4:	2300      	movs	r3, #0
 801c9e6:	9304      	str	r3, [sp, #16]
 801c9e8:	2603      	movs	r6, #3
 801c9ea:	f8db 3004 	ldr.w	r3, [fp, #4]
 801c9ee:	2b00      	cmp	r3, #0
 801c9f0:	dd69      	ble.n	801cac6 <__ssvfiscanf_r+0x2d6>
 801c9f2:	0669      	lsls	r1, r5, #25
 801c9f4:	d533      	bpl.n	801ca5e <__ssvfiscanf_r+0x26e>
 801c9f6:	2e02      	cmp	r6, #2
 801c9f8:	f000 81f7 	beq.w	801cdea <__ssvfiscanf_r+0x5fa>
 801c9fc:	2e03      	cmp	r6, #3
 801c9fe:	f000 8143 	beq.w	801cc88 <__ssvfiscanf_r+0x498>
 801ca02:	2e01      	cmp	r6, #1
 801ca04:	f000 810a 	beq.w	801cc1c <__ssvfiscanf_r+0x42c>
 801ca08:	2c00      	cmp	r4, #0
 801ca0a:	bf08      	it	eq
 801ca0c:	2401      	moveq	r4, #1
 801ca0e:	f015 0301 	ands.w	r3, r5, #1
 801ca12:	f040 8247 	bne.w	801cea4 <__ssvfiscanf_r+0x6b4>
 801ca16:	06ed      	lsls	r5, r5, #27
 801ca18:	f140 831c 	bpl.w	801d054 <__ssvfiscanf_r+0x864>
 801ca1c:	461d      	mov	r5, r3
 801ca1e:	e009      	b.n	801ca34 <__ssvfiscanf_r+0x244>
 801ca20:	4413      	add	r3, r2
 801ca22:	f8cb 3000 	str.w	r3, [fp]
 801ca26:	4415      	add	r5, r2
 801ca28:	1aa4      	subs	r4, r4, r2
 801ca2a:	f7ff fe83 	bl	801c734 <__ssrefill_r>
 801ca2e:	2800      	cmp	r0, #0
 801ca30:	f040 82d6 	bne.w	801cfe0 <__ssvfiscanf_r+0x7f0>
 801ca34:	f8db 2004 	ldr.w	r2, [fp, #4]
 801ca38:	f8db 3000 	ldr.w	r3, [fp]
 801ca3c:	42a2      	cmp	r2, r4
 801ca3e:	4659      	mov	r1, fp
 801ca40:	4638      	mov	r0, r7
 801ca42:	dbed      	blt.n	801ca20 <__ssvfiscanf_r+0x230>
 801ca44:	1b12      	subs	r2, r2, r4
 801ca46:	4423      	add	r3, r4
 801ca48:	f8cb 2004 	str.w	r2, [fp, #4]
 801ca4c:	4425      	add	r5, r4
 801ca4e:	f8cb 3000 	str.w	r3, [fp]
 801ca52:	9e03      	ldr	r6, [sp, #12]
 801ca54:	44aa      	add	sl, r5
 801ca56:	4634      	mov	r4, r6
 801ca58:	e710      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801ca5a:	f8cb 3000 	str.w	r3, [fp]
 801ca5e:	f7fe f87b 	bl	801ab58 <__locale_ctype_ptr>
 801ca62:	f8db 3000 	ldr.w	r3, [fp]
 801ca66:	781a      	ldrb	r2, [r3, #0]
 801ca68:	4410      	add	r0, r2
 801ca6a:	3301      	adds	r3, #1
 801ca6c:	7842      	ldrb	r2, [r0, #1]
 801ca6e:	0712      	lsls	r2, r2, #28
 801ca70:	d5c1      	bpl.n	801c9f6 <__ssvfiscanf_r+0x206>
 801ca72:	f8db 2004 	ldr.w	r2, [fp, #4]
 801ca76:	3a01      	subs	r2, #1
 801ca78:	2a00      	cmp	r2, #0
 801ca7a:	f10a 0a01 	add.w	sl, sl, #1
 801ca7e:	f8cb 2004 	str.w	r2, [fp, #4]
 801ca82:	dcea      	bgt.n	801ca5a <__ssvfiscanf_r+0x26a>
 801ca84:	4659      	mov	r1, fp
 801ca86:	4638      	mov	r0, r7
 801ca88:	f7ff fe54 	bl	801c734 <__ssrefill_r>
 801ca8c:	2800      	cmp	r0, #0
 801ca8e:	d0e6      	beq.n	801ca5e <__ssvfiscanf_r+0x26e>
 801ca90:	9a05      	ldr	r2, [sp, #20]
 801ca92:	2a00      	cmp	r2, #0
 801ca94:	d09c      	beq.n	801c9d0 <__ssvfiscanf_r+0x1e0>
 801ca96:	f8bb 300c 	ldrh.w	r3, [fp, #12]
 801ca9a:	f013 0f40 	tst.w	r3, #64	; 0x40
 801ca9e:	4613      	mov	r3, r2
 801caa0:	bf18      	it	ne
 801caa2:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 801caa6:	9305      	str	r3, [sp, #20]
 801caa8:	9805      	ldr	r0, [sp, #20]
 801caaa:	b059      	add	sp, #356	; 0x164
 801caac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801cab0:	9303      	str	r3, [sp, #12]
 801cab2:	4b73      	ldr	r3, [pc, #460]	; (801cc80 <__ssvfiscanf_r+0x490>)
 801cab4:	9307      	str	r3, [sp, #28]
 801cab6:	230a      	movs	r3, #10
 801cab8:	9304      	str	r3, [sp, #16]
 801caba:	f8db 3004 	ldr.w	r3, [fp, #4]
 801cabe:	2b00      	cmp	r3, #0
 801cac0:	f04f 0603 	mov.w	r6, #3
 801cac4:	dc95      	bgt.n	801c9f2 <__ssvfiscanf_r+0x202>
 801cac6:	4659      	mov	r1, fp
 801cac8:	4638      	mov	r0, r7
 801caca:	f7ff fe33 	bl	801c734 <__ssrefill_r>
 801cace:	2800      	cmp	r0, #0
 801cad0:	d08f      	beq.n	801c9f2 <__ssvfiscanf_r+0x202>
 801cad2:	e7dd      	b.n	801ca90 <__ssvfiscanf_r+0x2a0>
 801cad4:	9303      	str	r3, [sp, #12]
 801cad6:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 801cada:	2600      	movs	r6, #0
 801cadc:	e785      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801cade:	f896 8001 	ldrb.w	r8, [r6, #1]
 801cae2:	f045 0504 	orr.w	r5, r5, #4
 801cae6:	461e      	mov	r6, r3
 801cae8:	e6d8      	b.n	801c89c <__ssvfiscanf_r+0xac>
 801caea:	9303      	str	r3, [sp, #12]
 801caec:	4b65      	ldr	r3, [pc, #404]	; (801cc84 <__ssvfiscanf_r+0x494>)
 801caee:	9307      	str	r3, [sp, #28]
 801caf0:	230a      	movs	r3, #10
 801caf2:	9304      	str	r3, [sp, #16]
 801caf4:	2603      	movs	r6, #3
 801caf6:	e778      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801caf8:	9303      	str	r3, [sp, #12]
 801cafa:	2602      	movs	r6, #2
 801cafc:	e775      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801cafe:	9303      	str	r3, [sp, #12]
 801cb00:	f445 7508 	orr.w	r5, r5, #544	; 0x220
 801cb04:	4b5f      	ldr	r3, [pc, #380]	; (801cc84 <__ssvfiscanf_r+0x494>)
 801cb06:	9307      	str	r3, [sp, #28]
 801cb08:	2310      	movs	r3, #16
 801cb0a:	9304      	str	r3, [sp, #16]
 801cb0c:	2603      	movs	r6, #3
 801cb0e:	e76c      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801cb10:	9303      	str	r3, [sp, #12]
 801cb12:	4b5c      	ldr	r3, [pc, #368]	; (801cc84 <__ssvfiscanf_r+0x494>)
 801cb14:	9307      	str	r3, [sp, #28]
 801cb16:	2308      	movs	r3, #8
 801cb18:	9304      	str	r3, [sp, #16]
 801cb1a:	2603      	movs	r6, #3
 801cb1c:	e765      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801cb1e:	9303      	str	r3, [sp, #12]
 801cb20:	06eb      	lsls	r3, r5, #27
 801cb22:	d478      	bmi.n	801cc16 <__ssvfiscanf_r+0x426>
 801cb24:	076e      	lsls	r6, r5, #29
 801cb26:	f100 82d4 	bmi.w	801d0d2 <__ssvfiscanf_r+0x8e2>
 801cb2a:	07ec      	lsls	r4, r5, #31
 801cb2c:	f100 82c0 	bmi.w	801d0b0 <__ssvfiscanf_r+0x8c0>
 801cb30:	07a8      	lsls	r0, r5, #30
 801cb32:	f140 82bd 	bpl.w	801d0b0 <__ssvfiscanf_r+0x8c0>
 801cb36:	9a06      	ldr	r2, [sp, #24]
 801cb38:	9e03      	ldr	r6, [sp, #12]
 801cb3a:	6813      	ldr	r3, [r2, #0]
 801cb3c:	4650      	mov	r0, sl
 801cb3e:	17c1      	asrs	r1, r0, #31
 801cb40:	3204      	adds	r2, #4
 801cb42:	9206      	str	r2, [sp, #24]
 801cb44:	e9c3 0100 	strd	r0, r1, [r3]
 801cb48:	4634      	mov	r4, r6
 801cb4a:	e697      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801cb4c:	f896 8001 	ldrb.w	r8, [r6, #1]
 801cb50:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 801cb54:	f000 82a5 	beq.w	801d0a2 <__ssvfiscanf_r+0x8b2>
 801cb58:	f045 0501 	orr.w	r5, r5, #1
 801cb5c:	461e      	mov	r6, r3
 801cb5e:	e69d      	b.n	801c89c <__ssvfiscanf_r+0xac>
 801cb60:	4619      	mov	r1, r3
 801cb62:	a818      	add	r0, sp, #96	; 0x60
 801cb64:	f001 f82a 	bl	801dbbc <__sccl>
 801cb68:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 801cb6c:	9003      	str	r0, [sp, #12]
 801cb6e:	2601      	movs	r6, #1
 801cb70:	e73b      	b.n	801c9ea <__ssvfiscanf_r+0x1fa>
 801cb72:	9303      	str	r3, [sp, #12]
 801cb74:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 801cb78:	e7c4      	b.n	801cb04 <__ssvfiscanf_r+0x314>
 801cb7a:	9303      	str	r3, [sp, #12]
 801cb7c:	f045 0501 	orr.w	r5, r5, #1
 801cb80:	e7c7      	b.n	801cb12 <__ssvfiscanf_r+0x322>
 801cb82:	f896 8001 	ldrb.w	r8, [r6, #1]
 801cb86:	f045 0502 	orr.w	r5, r5, #2
 801cb8a:	461e      	mov	r6, r3
 801cb8c:	e686      	b.n	801c89c <__ssvfiscanf_r+0xac>
 801cb8e:	9303      	str	r3, [sp, #12]
 801cb90:	f045 0501 	orr.w	r5, r5, #1
 801cb94:	e78d      	b.n	801cab2 <__ssvfiscanf_r+0x2c2>
 801cb96:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 801cb9a:	eb08 0444 	add.w	r4, r8, r4, lsl #1
 801cb9e:	3c30      	subs	r4, #48	; 0x30
 801cba0:	f896 8001 	ldrb.w	r8, [r6, #1]
 801cba4:	461e      	mov	r6, r3
 801cba6:	e679      	b.n	801c89c <__ssvfiscanf_r+0xac>
 801cba8:	f896 8001 	ldrb.w	r8, [r6, #1]
 801cbac:	f045 0510 	orr.w	r5, r5, #16
 801cbb0:	461e      	mov	r6, r3
 801cbb2:	e673      	b.n	801c89c <__ssvfiscanf_r+0xac>
 801cbb4:	9303      	str	r3, [sp, #12]
 801cbb6:	f7fd ffcf 	bl	801ab58 <__locale_ctype_ptr>
 801cbba:	4440      	add	r0, r8
 801cbbc:	7843      	ldrb	r3, [r0, #1]
 801cbbe:	f003 0303 	and.w	r3, r3, #3
 801cbc2:	2b01      	cmp	r3, #1
 801cbc4:	f47f af75 	bne.w	801cab2 <__ssvfiscanf_r+0x2c2>
 801cbc8:	f045 0501 	orr.w	r5, r5, #1
 801cbcc:	e771      	b.n	801cab2 <__ssvfiscanf_r+0x2c2>
 801cbce:	ab0c      	add	r3, sp, #48	; 0x30
 801cbd0:	4618      	mov	r0, r3
 801cbd2:	2208      	movs	r2, #8
 801cbd4:	2100      	movs	r1, #0
 801cbd6:	9308      	str	r3, [sp, #32]
 801cbd8:	f000 fdfc 	bl	801d7d4 <memset>
 801cbdc:	f015 0310 	ands.w	r3, r5, #16
 801cbe0:	9309      	str	r3, [sp, #36]	; 0x24
 801cbe2:	f000 81e1 	beq.w	801cfa8 <__ssvfiscanf_r+0x7b8>
 801cbe6:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
 801cbea:	2600      	movs	r6, #0
 801cbec:	f10d 0838 	add.w	r8, sp, #56	; 0x38
 801cbf0:	f7fd ffb2 	bl	801ab58 <__locale_ctype_ptr>
 801cbf4:	f8db 3000 	ldr.w	r3, [fp]
 801cbf8:	781b      	ldrb	r3, [r3, #0]
 801cbfa:	4403      	add	r3, r0
 801cbfc:	785b      	ldrb	r3, [r3, #1]
 801cbfe:	071a      	lsls	r2, r3, #28
 801cc00:	d402      	bmi.n	801cc08 <__ssvfiscanf_r+0x418>
 801cc02:	2c00      	cmp	r4, #0
 801cc04:	f040 8270 	bne.w	801d0e8 <__ssvfiscanf_r+0x8f8>
 801cc08:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801cc0a:	b923      	cbnz	r3, 801cc16 <__ssvfiscanf_r+0x426>
 801cc0c:	f8c9 3000 	str.w	r3, [r9]
 801cc10:	9b05      	ldr	r3, [sp, #20]
 801cc12:	3301      	adds	r3, #1
 801cc14:	9305      	str	r3, [sp, #20]
 801cc16:	9e03      	ldr	r6, [sp, #12]
 801cc18:	4634      	mov	r4, r6
 801cc1a:	e62f      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801cc1c:	2c00      	cmp	r4, #0
 801cc1e:	bf08      	it	eq
 801cc20:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
 801cc24:	06e8      	lsls	r0, r5, #27
 801cc26:	f140 810b 	bpl.w	801ce40 <__ssvfiscanf_r+0x650>
 801cc2a:	f8db 2000 	ldr.w	r2, [fp]
 801cc2e:	2500      	movs	r5, #0
 801cc30:	f10d 0860 	add.w	r8, sp, #96	; 0x60
 801cc34:	7813      	ldrb	r3, [r2, #0]
 801cc36:	f818 3003 	ldrb.w	r3, [r8, r3]
 801cc3a:	3201      	adds	r2, #1
 801cc3c:	b1db      	cbz	r3, 801cc76 <__ssvfiscanf_r+0x486>
 801cc3e:	f8db 3004 	ldr.w	r3, [fp, #4]
 801cc42:	f8cb 2000 	str.w	r2, [fp]
 801cc46:	3501      	adds	r5, #1
 801cc48:	3b01      	subs	r3, #1
 801cc4a:	42ac      	cmp	r4, r5
 801cc4c:	f8cb 3004 	str.w	r3, [fp, #4]
 801cc50:	f43f aeff 	beq.w	801ca52 <__ssvfiscanf_r+0x262>
 801cc54:	2b00      	cmp	r3, #0
 801cc56:	dced      	bgt.n	801cc34 <__ssvfiscanf_r+0x444>
 801cc58:	4659      	mov	r1, fp
 801cc5a:	4638      	mov	r0, r7
 801cc5c:	f7ff fd6a 	bl	801c734 <__ssrefill_r>
 801cc60:	2800      	cmp	r0, #0
 801cc62:	f47f aef6 	bne.w	801ca52 <__ssvfiscanf_r+0x262>
 801cc66:	f8db 2000 	ldr.w	r2, [fp]
 801cc6a:	7813      	ldrb	r3, [r2, #0]
 801cc6c:	f818 3003 	ldrb.w	r3, [r8, r3]
 801cc70:	3201      	adds	r2, #1
 801cc72:	2b00      	cmp	r3, #0
 801cc74:	d1e3      	bne.n	801cc3e <__ssvfiscanf_r+0x44e>
 801cc76:	2d00      	cmp	r5, #0
 801cc78:	f47f aeeb 	bne.w	801ca52 <__ssvfiscanf_r+0x262>
 801cc7c:	e604      	b.n	801c888 <__ssvfiscanf_r+0x98>
 801cc7e:	bf00      	nop
 801cc80:	0801b731 	.word	0x0801b731
 801cc84:	0801c665 	.word	0x0801c665
 801cc88:	1e63      	subs	r3, r4, #1
 801cc8a:	2b26      	cmp	r3, #38	; 0x26
 801cc8c:	bf8c      	ite	hi
 801cc8e:	f1a4 0227 	subhi.w	r2, r4, #39	; 0x27
 801cc92:	2200      	movls	r2, #0
 801cc94:	f04f 0900 	mov.w	r9, #0
 801cc98:	4611      	mov	r1, r2
 801cc9a:	ae0e      	add	r6, sp, #56	; 0x38
 801cc9c:	464b      	mov	r3, r9
 801cc9e:	46b9      	mov	r9, r7
 801cca0:	9f04      	ldr	r7, [sp, #16]
 801cca2:	4652      	mov	r2, sl
 801cca4:	bf88      	it	hi
 801cca6:	2427      	movhi	r4, #39	; 0x27
 801cca8:	f445 6558 	orr.w	r5, r5, #3456	; 0xd80
 801ccac:	46b0      	mov	r8, r6
 801ccae:	468a      	mov	sl, r1
 801ccb0:	f8db 0000 	ldr.w	r0, [fp]
 801ccb4:	f890 e000 	ldrb.w	lr, [r0]
 801ccb8:	f1ae 012b 	sub.w	r1, lr, #43	; 0x2b
 801ccbc:	294d      	cmp	r1, #77	; 0x4d
 801ccbe:	d842      	bhi.n	801cd46 <__ssvfiscanf_r+0x556>
 801ccc0:	e8df f001 	tbb	[pc, r1]
 801ccc4:	418e418e 	.word	0x418e418e
 801ccc8:	5d5d6341 	.word	0x5d5d6341
 801cccc:	5d5d5d5d 	.word	0x5d5d5d5d
 801ccd0:	4188885d 	.word	0x4188885d
 801ccd4:	41414141 	.word	0x41414141
 801ccd8:	58584141 	.word	0x58584141
 801ccdc:	58585858 	.word	0x58585858
 801cce0:	41414141 	.word	0x41414141
 801cce4:	41414141 	.word	0x41414141
 801cce8:	41414141 	.word	0x41414141
 801ccec:	41414141 	.word	0x41414141
 801ccf0:	41412741 	.word	0x41412741
 801ccf4:	41414141 	.word	0x41414141
 801ccf8:	58584141 	.word	0x58584141
 801ccfc:	58585858 	.word	0x58585858
 801cd00:	41414141 	.word	0x41414141
 801cd04:	41414141 	.word	0x41414141
 801cd08:	41414141 	.word	0x41414141
 801cd0c:	41414141 	.word	0x41414141
 801cd10:	2741      	.short	0x2741
 801cd12:	f405 61c0 	and.w	r1, r5, #1536	; 0x600
 801cd16:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 801cd1a:	d114      	bne.n	801cd46 <__ssvfiscanf_r+0x556>
 801cd1c:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 801cd20:	f445 65a0 	orr.w	r5, r5, #1280	; 0x500
 801cd24:	2710      	movs	r7, #16
 801cd26:	f8db 1004 	ldr.w	r1, [fp, #4]
 801cd2a:	f888 e000 	strb.w	lr, [r8]
 801cd2e:	3901      	subs	r1, #1
 801cd30:	2900      	cmp	r1, #0
 801cd32:	f108 0801 	add.w	r8, r8, #1
 801cd36:	f8cb 1004 	str.w	r1, [fp, #4]
 801cd3a:	dd40      	ble.n	801cdbe <__ssvfiscanf_r+0x5ce>
 801cd3c:	3001      	adds	r0, #1
 801cd3e:	f8cb 0000 	str.w	r0, [fp]
 801cd42:	3c01      	subs	r4, #1
 801cd44:	d1b4      	bne.n	801ccb0 <__ssvfiscanf_r+0x4c0>
 801cd46:	05e8      	lsls	r0, r5, #23
 801cd48:	9704      	str	r7, [sp, #16]
 801cd4a:	4692      	mov	sl, r2
 801cd4c:	464f      	mov	r7, r9
 801cd4e:	4699      	mov	r9, r3
 801cd50:	d505      	bpl.n	801cd5e <__ssvfiscanf_r+0x56e>
 801cd52:	45b0      	cmp	r8, r6
 801cd54:	f200 8194 	bhi.w	801d080 <__ssvfiscanf_r+0x890>
 801cd58:	45b0      	cmp	r8, r6
 801cd5a:	f43f ad95 	beq.w	801c888 <__ssvfiscanf_r+0x98>
 801cd5e:	f015 0410 	ands.w	r4, r5, #16
 801cd62:	f000 80e5 	beq.w	801cf30 <__ssvfiscanf_r+0x740>
 801cd66:	eba8 0606 	sub.w	r6, r8, r6
 801cd6a:	44b1      	add	r9, r6
 801cd6c:	9e03      	ldr	r6, [sp, #12]
 801cd6e:	44ca      	add	sl, r9
 801cd70:	4634      	mov	r4, r6
 801cd72:	e583      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801cd74:	2f0a      	cmp	r7, #10
 801cd76:	dde6      	ble.n	801cd46 <__ssvfiscanf_r+0x556>
 801cd78:	f425 6538 	bic.w	r5, r5, #2944	; 0xb80
 801cd7c:	e7d3      	b.n	801cd26 <__ssvfiscanf_r+0x536>
 801cd7e:	49b3      	ldr	r1, [pc, #716]	; (801d04c <__ssvfiscanf_r+0x85c>)
 801cd80:	f425 6538 	bic.w	r5, r5, #2944	; 0xb80
 801cd84:	f931 7017 	ldrsh.w	r7, [r1, r7, lsl #1]
 801cd88:	e7cd      	b.n	801cd26 <__ssvfiscanf_r+0x536>
 801cd8a:	0529      	lsls	r1, r5, #20
 801cd8c:	d5cb      	bpl.n	801cd26 <__ssvfiscanf_r+0x536>
 801cd8e:	b917      	cbnz	r7, 801cd96 <__ssvfiscanf_r+0x5a6>
 801cd90:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 801cd94:	2708      	movs	r7, #8
 801cd96:	0569      	lsls	r1, r5, #21
 801cd98:	f100 80fa 	bmi.w	801cf90 <__ssvfiscanf_r+0x7a0>
 801cd9c:	f425 7560 	bic.w	r5, r5, #896	; 0x380
 801cda0:	f1ba 0f00 	cmp.w	sl, #0
 801cda4:	d002      	beq.n	801cdac <__ssvfiscanf_r+0x5bc>
 801cda6:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 801cdaa:	3401      	adds	r4, #1
 801cdac:	f8db 1004 	ldr.w	r1, [fp, #4]
 801cdb0:	3901      	subs	r1, #1
 801cdb2:	2900      	cmp	r1, #0
 801cdb4:	f103 0301 	add.w	r3, r3, #1
 801cdb8:	f8cb 1004 	str.w	r1, [fp, #4]
 801cdbc:	dcbe      	bgt.n	801cd3c <__ssvfiscanf_r+0x54c>
 801cdbe:	4659      	mov	r1, fp
 801cdc0:	4648      	mov	r0, r9
 801cdc2:	9308      	str	r3, [sp, #32]
 801cdc4:	9204      	str	r2, [sp, #16]
 801cdc6:	f7ff fcb5 	bl	801c734 <__ssrefill_r>
 801cdca:	9a04      	ldr	r2, [sp, #16]
 801cdcc:	9b08      	ldr	r3, [sp, #32]
 801cdce:	2800      	cmp	r0, #0
 801cdd0:	d0b7      	beq.n	801cd42 <__ssvfiscanf_r+0x552>
 801cdd2:	e7b8      	b.n	801cd46 <__ssvfiscanf_r+0x556>
 801cdd4:	499d      	ldr	r1, [pc, #628]	; (801d04c <__ssvfiscanf_r+0x85c>)
 801cdd6:	f931 7017 	ldrsh.w	r7, [r1, r7, lsl #1]
 801cdda:	2f08      	cmp	r7, #8
 801cddc:	dccc      	bgt.n	801cd78 <__ssvfiscanf_r+0x588>
 801cdde:	e7b2      	b.n	801cd46 <__ssvfiscanf_r+0x556>
 801cde0:	0629      	lsls	r1, r5, #24
 801cde2:	d5b0      	bpl.n	801cd46 <__ssvfiscanf_r+0x556>
 801cde4:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 801cde8:	e79d      	b.n	801cd26 <__ssvfiscanf_r+0x536>
 801cdea:	2c00      	cmp	r4, #0
 801cdec:	bf08      	it	eq
 801cdee:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
 801cdf2:	f015 0601 	ands.w	r6, r5, #1
 801cdf6:	f47f aeea 	bne.w	801cbce <__ssvfiscanf_r+0x3de>
 801cdfa:	06eb      	lsls	r3, r5, #27
 801cdfc:	f140 80f4 	bpl.w	801cfe8 <__ssvfiscanf_r+0x7f8>
 801ce00:	f7fd feaa 	bl	801ab58 <__locale_ctype_ptr>
 801ce04:	f8db 3000 	ldr.w	r3, [fp]
 801ce08:	781a      	ldrb	r2, [r3, #0]
 801ce0a:	4410      	add	r0, r2
 801ce0c:	3301      	adds	r3, #1
 801ce0e:	7842      	ldrb	r2, [r0, #1]
 801ce10:	0715      	lsls	r5, r2, #28
 801ce12:	d411      	bmi.n	801ce38 <__ssvfiscanf_r+0x648>
 801ce14:	f8db 2004 	ldr.w	r2, [fp, #4]
 801ce18:	f8cb 3000 	str.w	r3, [fp]
 801ce1c:	3601      	adds	r6, #1
 801ce1e:	3a01      	subs	r2, #1
 801ce20:	42b4      	cmp	r4, r6
 801ce22:	f8cb 2004 	str.w	r2, [fp, #4]
 801ce26:	d007      	beq.n	801ce38 <__ssvfiscanf_r+0x648>
 801ce28:	2a00      	cmp	r2, #0
 801ce2a:	dce9      	bgt.n	801ce00 <__ssvfiscanf_r+0x610>
 801ce2c:	4659      	mov	r1, fp
 801ce2e:	4638      	mov	r0, r7
 801ce30:	f7ff fc80 	bl	801c734 <__ssrefill_r>
 801ce34:	2800      	cmp	r0, #0
 801ce36:	d0e3      	beq.n	801ce00 <__ssvfiscanf_r+0x610>
 801ce38:	44b2      	add	sl, r6
 801ce3a:	9e03      	ldr	r6, [sp, #12]
 801ce3c:	4634      	mov	r4, r6
 801ce3e:	e51d      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801ce40:	9a06      	ldr	r2, [sp, #24]
 801ce42:	6815      	ldr	r5, [r2, #0]
 801ce44:	1d16      	adds	r6, r2, #4
 801ce46:	46a9      	mov	r9, r5
 801ce48:	f10d 0860 	add.w	r8, sp, #96	; 0x60
 801ce4c:	f8db 3000 	ldr.w	r3, [fp]
 801ce50:	781a      	ldrb	r2, [r3, #0]
 801ce52:	f818 2002 	ldrb.w	r2, [r8, r2]
 801ce56:	1c59      	adds	r1, r3, #1
 801ce58:	b1c2      	cbz	r2, 801ce8c <__ssvfiscanf_r+0x69c>
 801ce5a:	f8db 2004 	ldr.w	r2, [fp, #4]
 801ce5e:	f8cb 1000 	str.w	r1, [fp]
 801ce62:	3a01      	subs	r2, #1
 801ce64:	f8cb 2004 	str.w	r2, [fp, #4]
 801ce68:	781b      	ldrb	r3, [r3, #0]
 801ce6a:	f809 3b01 	strb.w	r3, [r9], #1
 801ce6e:	3c01      	subs	r4, #1
 801ce70:	d00c      	beq.n	801ce8c <__ssvfiscanf_r+0x69c>
 801ce72:	f8db 3004 	ldr.w	r3, [fp, #4]
 801ce76:	2b00      	cmp	r3, #0
 801ce78:	dce8      	bgt.n	801ce4c <__ssvfiscanf_r+0x65c>
 801ce7a:	4659      	mov	r1, fp
 801ce7c:	4638      	mov	r0, r7
 801ce7e:	f7ff fc59 	bl	801c734 <__ssrefill_r>
 801ce82:	2800      	cmp	r0, #0
 801ce84:	d0e2      	beq.n	801ce4c <__ssvfiscanf_r+0x65c>
 801ce86:	454d      	cmp	r5, r9
 801ce88:	f43f ae02 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801ce8c:	ebb9 0505 	subs.w	r5, r9, r5
 801ce90:	f43f acfa 	beq.w	801c888 <__ssvfiscanf_r+0x98>
 801ce94:	9a05      	ldr	r2, [sp, #20]
 801ce96:	9606      	str	r6, [sp, #24]
 801ce98:	2300      	movs	r3, #0
 801ce9a:	3201      	adds	r2, #1
 801ce9c:	9205      	str	r2, [sp, #20]
 801ce9e:	f889 3000 	strb.w	r3, [r9]
 801cea2:	e5d6      	b.n	801ca52 <__ssvfiscanf_r+0x262>
 801cea4:	ab0c      	add	r3, sp, #48	; 0x30
 801cea6:	4618      	mov	r0, r3
 801cea8:	2208      	movs	r2, #8
 801ceaa:	2100      	movs	r1, #0
 801ceac:	9308      	str	r3, [sp, #32]
 801ceae:	f000 fc91 	bl	801d7d4 <memset>
 801ceb2:	f015 0310 	ands.w	r3, r5, #16
 801ceb6:	9309      	str	r3, [sp, #36]	; 0x24
 801ceb8:	d06d      	beq.n	801cf96 <__ssvfiscanf_r+0x7a6>
 801ceba:	f04f 0900 	mov.w	r9, #0
 801cebe:	2c00      	cmp	r4, #0
 801cec0:	f43f aea9 	beq.w	801cc16 <__ssvfiscanf_r+0x426>
 801cec4:	2500      	movs	r5, #0
 801cec6:	f10d 0838 	add.w	r8, sp, #56	; 0x38
 801ceca:	f7fd fe33 	bl	801ab34 <__locale_mb_cur_max>
 801cece:	4285      	cmp	r5, r0
 801ced0:	f43f adde 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801ced4:	e89b 000c 	ldmia.w	fp, {r2, r3}
 801ced8:	f812 0b01 	ldrb.w	r0, [r2], #1
 801cedc:	f8cb 2000 	str.w	r2, [fp]
 801cee0:	3b01      	subs	r3, #1
 801cee2:	9a08      	ldr	r2, [sp, #32]
 801cee4:	9200      	str	r2, [sp, #0]
 801cee6:	1c6e      	adds	r6, r5, #1
 801cee8:	f8cb 3004 	str.w	r3, [fp, #4]
 801ceec:	f808 0005 	strb.w	r0, [r8, r5]
 801cef0:	4633      	mov	r3, r6
 801cef2:	4642      	mov	r2, r8
 801cef4:	4649      	mov	r1, r9
 801cef6:	4638      	mov	r0, r7
 801cef8:	f000 fc3e 	bl	801d778 <_mbrtowc_r>
 801cefc:	1c43      	adds	r3, r0, #1
 801cefe:	f43f adc7 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801cf02:	2800      	cmp	r0, #0
 801cf04:	d15d      	bne.n	801cfc2 <__ssvfiscanf_r+0x7d2>
 801cf06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801cf08:	2b00      	cmp	r3, #0
 801cf0a:	d15e      	bne.n	801cfca <__ssvfiscanf_r+0x7da>
 801cf0c:	f8c9 3000 	str.w	r3, [r9]
 801cf10:	44b2      	add	sl, r6
 801cf12:	3c01      	subs	r4, #1
 801cf14:	f109 0904 	add.w	r9, r9, #4
 801cf18:	2500      	movs	r5, #0
 801cf1a:	f8db 3004 	ldr.w	r3, [fp, #4]
 801cf1e:	2b00      	cmp	r3, #0
 801cf20:	dd2d      	ble.n	801cf7e <__ssvfiscanf_r+0x78e>
 801cf22:	2c00      	cmp	r4, #0
 801cf24:	d1d1      	bne.n	801ceca <__ssvfiscanf_r+0x6da>
 801cf26:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801cf28:	2b00      	cmp	r3, #0
 801cf2a:	f43f ae71 	beq.w	801cc10 <__ssvfiscanf_r+0x420>
 801cf2e:	e672      	b.n	801cc16 <__ssvfiscanf_r+0x426>
 801cf30:	4622      	mov	r2, r4
 801cf32:	4631      	mov	r1, r6
 801cf34:	f888 4000 	strb.w	r4, [r8]
 801cf38:	9b04      	ldr	r3, [sp, #16]
 801cf3a:	9c07      	ldr	r4, [sp, #28]
 801cf3c:	4638      	mov	r0, r7
 801cf3e:	47a0      	blx	r4
 801cf40:	06a9      	lsls	r1, r5, #26
 801cf42:	d438      	bmi.n	801cfb6 <__ssvfiscanf_r+0x7c6>
 801cf44:	076a      	lsls	r2, r5, #29
 801cf46:	f100 80be 	bmi.w	801d0c6 <__ssvfiscanf_r+0x8d6>
 801cf4a:	f015 0201 	ands.w	r2, r5, #1
 801cf4e:	d132      	bne.n	801cfb6 <__ssvfiscanf_r+0x7c6>
 801cf50:	07ab      	lsls	r3, r5, #30
 801cf52:	d530      	bpl.n	801cfb6 <__ssvfiscanf_r+0x7c6>
 801cf54:	9b07      	ldr	r3, [sp, #28]
 801cf56:	4619      	mov	r1, r3
 801cf58:	4b3d      	ldr	r3, [pc, #244]	; (801d050 <__ssvfiscanf_r+0x860>)
 801cf5a:	4299      	cmp	r1, r3
 801cf5c:	4638      	mov	r0, r7
 801cf5e:	9b04      	ldr	r3, [sp, #16]
 801cf60:	4631      	mov	r1, r6
 801cf62:	f000 8105 	beq.w	801d170 <__ssvfiscanf_r+0x980>
 801cf66:	f000 ff31 	bl	801ddcc <_strtoll_r>
 801cf6a:	9a06      	ldr	r2, [sp, #24]
 801cf6c:	6813      	ldr	r3, [r2, #0]
 801cf6e:	e9c3 0100 	strd	r0, r1, [r3]
 801cf72:	3204      	adds	r2, #4
 801cf74:	9206      	str	r2, [sp, #24]
 801cf76:	9b05      	ldr	r3, [sp, #20]
 801cf78:	3301      	adds	r3, #1
 801cf7a:	9305      	str	r3, [sp, #20]
 801cf7c:	e6f3      	b.n	801cd66 <__ssvfiscanf_r+0x576>
 801cf7e:	4659      	mov	r1, fp
 801cf80:	4638      	mov	r0, r7
 801cf82:	f7ff fbd7 	bl	801c734 <__ssrefill_r>
 801cf86:	2800      	cmp	r0, #0
 801cf88:	d0cb      	beq.n	801cf22 <__ssvfiscanf_r+0x732>
 801cf8a:	2d00      	cmp	r5, #0
 801cf8c:	d0cb      	beq.n	801cf26 <__ssvfiscanf_r+0x736>
 801cf8e:	e57f      	b.n	801ca90 <__ssvfiscanf_r+0x2a0>
 801cf90:	f425 65b0 	bic.w	r5, r5, #1408	; 0x580
 801cf94:	e6c7      	b.n	801cd26 <__ssvfiscanf_r+0x536>
 801cf96:	9a06      	ldr	r2, [sp, #24]
 801cf98:	4613      	mov	r3, r2
 801cf9a:	3304      	adds	r3, #4
 801cf9c:	f8d2 9000 	ldr.w	r9, [r2]
 801cfa0:	9306      	str	r3, [sp, #24]
 801cfa2:	2c00      	cmp	r4, #0
 801cfa4:	d18e      	bne.n	801cec4 <__ssvfiscanf_r+0x6d4>
 801cfa6:	e633      	b.n	801cc10 <__ssvfiscanf_r+0x420>
 801cfa8:	9a06      	ldr	r2, [sp, #24]
 801cfaa:	4613      	mov	r3, r2
 801cfac:	3304      	adds	r3, #4
 801cfae:	f8d2 9000 	ldr.w	r9, [r2]
 801cfb2:	9306      	str	r3, [sp, #24]
 801cfb4:	e619      	b.n	801cbea <__ssvfiscanf_r+0x3fa>
 801cfb6:	9a06      	ldr	r2, [sp, #24]
 801cfb8:	6813      	ldr	r3, [r2, #0]
 801cfba:	3204      	adds	r2, #4
 801cfbc:	9206      	str	r2, [sp, #24]
 801cfbe:	6018      	str	r0, [r3, #0]
 801cfc0:	e7d9      	b.n	801cf76 <__ssvfiscanf_r+0x786>
 801cfc2:	3002      	adds	r0, #2
 801cfc4:	d105      	bne.n	801cfd2 <__ssvfiscanf_r+0x7e2>
 801cfc6:	4635      	mov	r5, r6
 801cfc8:	e7a7      	b.n	801cf1a <__ssvfiscanf_r+0x72a>
 801cfca:	44b2      	add	sl, r6
 801cfcc:	3c01      	subs	r4, #1
 801cfce:	4605      	mov	r5, r0
 801cfd0:	e7a3      	b.n	801cf1a <__ssvfiscanf_r+0x72a>
 801cfd2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801cfd4:	44b2      	add	sl, r6
 801cfd6:	3c01      	subs	r4, #1
 801cfd8:	2b00      	cmp	r3, #0
 801cfda:	d09b      	beq.n	801cf14 <__ssvfiscanf_r+0x724>
 801cfdc:	2500      	movs	r5, #0
 801cfde:	e79c      	b.n	801cf1a <__ssvfiscanf_r+0x72a>
 801cfe0:	2d00      	cmp	r5, #0
 801cfe2:	f47f ad36 	bne.w	801ca52 <__ssvfiscanf_r+0x262>
 801cfe6:	e553      	b.n	801ca90 <__ssvfiscanf_r+0x2a0>
 801cfe8:	9a06      	ldr	r2, [sp, #24]
 801cfea:	6816      	ldr	r6, [r2, #0]
 801cfec:	f102 0804 	add.w	r8, r2, #4
 801cff0:	4635      	mov	r5, r6
 801cff2:	f7fd fdb1 	bl	801ab58 <__locale_ctype_ptr>
 801cff6:	f8db 2000 	ldr.w	r2, [fp]
 801cffa:	7813      	ldrb	r3, [r2, #0]
 801cffc:	4418      	add	r0, r3
 801cffe:	1c51      	adds	r1, r2, #1
 801d000:	7843      	ldrb	r3, [r0, #1]
 801d002:	0718      	lsls	r0, r3, #28
 801d004:	d415      	bmi.n	801d032 <__ssvfiscanf_r+0x842>
 801d006:	f8db 3004 	ldr.w	r3, [fp, #4]
 801d00a:	f8cb 1000 	str.w	r1, [fp]
 801d00e:	3b01      	subs	r3, #1
 801d010:	f8cb 3004 	str.w	r3, [fp, #4]
 801d014:	7813      	ldrb	r3, [r2, #0]
 801d016:	f805 3b01 	strb.w	r3, [r5], #1
 801d01a:	3c01      	subs	r4, #1
 801d01c:	d009      	beq.n	801d032 <__ssvfiscanf_r+0x842>
 801d01e:	f8db 3004 	ldr.w	r3, [fp, #4]
 801d022:	2b00      	cmp	r3, #0
 801d024:	dce5      	bgt.n	801cff2 <__ssvfiscanf_r+0x802>
 801d026:	4659      	mov	r1, fp
 801d028:	4638      	mov	r0, r7
 801d02a:	f7ff fb83 	bl	801c734 <__ssrefill_r>
 801d02e:	2800      	cmp	r0, #0
 801d030:	d0df      	beq.n	801cff2 <__ssvfiscanf_r+0x802>
 801d032:	1bae      	subs	r6, r5, r6
 801d034:	9a05      	ldr	r2, [sp, #20]
 801d036:	f8cd 8018 	str.w	r8, [sp, #24]
 801d03a:	44b2      	add	sl, r6
 801d03c:	9e03      	ldr	r6, [sp, #12]
 801d03e:	2300      	movs	r3, #0
 801d040:	3201      	adds	r2, #1
 801d042:	9205      	str	r2, [sp, #20]
 801d044:	702b      	strb	r3, [r5, #0]
 801d046:	4634      	mov	r4, r6
 801d048:	e418      	b.n	801c87c <__ssvfiscanf_r+0x8c>
 801d04a:	bf00      	nop
 801d04c:	080250ec 	.word	0x080250ec
 801d050:	0801c665 	.word	0x0801c665
 801d054:	9d06      	ldr	r5, [sp, #24]
 801d056:	4623      	mov	r3, r4
 801d058:	6829      	ldr	r1, [r5, #0]
 801d05a:	f8cd b000 	str.w	fp, [sp]
 801d05e:	2201      	movs	r2, #1
 801d060:	4638      	mov	r0, r7
 801d062:	f7ff fb85 	bl	801c770 <_sfread_r>
 801d066:	1d2e      	adds	r6, r5, #4
 801d068:	2800      	cmp	r0, #0
 801d06a:	f43f ad11 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801d06e:	9b05      	ldr	r3, [sp, #20]
 801d070:	9606      	str	r6, [sp, #24]
 801d072:	9e03      	ldr	r6, [sp, #12]
 801d074:	3301      	adds	r3, #1
 801d076:	4482      	add	sl, r0
 801d078:	9305      	str	r3, [sp, #20]
 801d07a:	4634      	mov	r4, r6
 801d07c:	f7ff bbfe 	b.w	801c87c <__ssvfiscanf_r+0x8c>
 801d080:	f818 1c01 	ldrb.w	r1, [r8, #-1]
 801d084:	465a      	mov	r2, fp
 801d086:	4638      	mov	r0, r7
 801d088:	f7ff fb14 	bl	801c6b4 <_sungetc_r>
 801d08c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 801d090:	e662      	b.n	801cd58 <__ssvfiscanf_r+0x568>
 801d092:	4659      	mov	r1, fp
 801d094:	4638      	mov	r0, r7
 801d096:	f7ff fb4d 	bl	801c734 <__ssrefill_r>
 801d09a:	2800      	cmp	r0, #0
 801d09c:	f43f ac84 	beq.w	801c9a8 <__ssvfiscanf_r+0x1b8>
 801d0a0:	e4f6      	b.n	801ca90 <__ssvfiscanf_r+0x2a0>
 801d0a2:	f896 8002 	ldrb.w	r8, [r6, #2]
 801d0a6:	f045 0502 	orr.w	r5, r5, #2
 801d0aa:	3602      	adds	r6, #2
 801d0ac:	f7ff bbf6 	b.w	801c89c <__ssvfiscanf_r+0xac>
 801d0b0:	9a06      	ldr	r2, [sp, #24]
 801d0b2:	9e03      	ldr	r6, [sp, #12]
 801d0b4:	6813      	ldr	r3, [r2, #0]
 801d0b6:	f8c3 a000 	str.w	sl, [r3]
 801d0ba:	4613      	mov	r3, r2
 801d0bc:	3304      	adds	r3, #4
 801d0be:	9306      	str	r3, [sp, #24]
 801d0c0:	4634      	mov	r4, r6
 801d0c2:	f7ff bbdb 	b.w	801c87c <__ssvfiscanf_r+0x8c>
 801d0c6:	9a06      	ldr	r2, [sp, #24]
 801d0c8:	6813      	ldr	r3, [r2, #0]
 801d0ca:	3204      	adds	r2, #4
 801d0cc:	9206      	str	r2, [sp, #24]
 801d0ce:	8018      	strh	r0, [r3, #0]
 801d0d0:	e751      	b.n	801cf76 <__ssvfiscanf_r+0x786>
 801d0d2:	9a06      	ldr	r2, [sp, #24]
 801d0d4:	9e03      	ldr	r6, [sp, #12]
 801d0d6:	6813      	ldr	r3, [r2, #0]
 801d0d8:	f8a3 a000 	strh.w	sl, [r3]
 801d0dc:	4613      	mov	r3, r2
 801d0de:	3304      	adds	r3, #4
 801d0e0:	9306      	str	r3, [sp, #24]
 801d0e2:	4634      	mov	r4, r6
 801d0e4:	f7ff bbca 	b.w	801c87c <__ssvfiscanf_r+0x8c>
 801d0e8:	f7fd fd24 	bl	801ab34 <__locale_mb_cur_max>
 801d0ec:	4286      	cmp	r6, r0
 801d0ee:	f43f accf 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801d0f2:	e89b 000c 	ldmia.w	fp, {r2, r3}
 801d0f6:	f812 0b01 	ldrb.w	r0, [r2], #1
 801d0fa:	f8cb 2000 	str.w	r2, [fp]
 801d0fe:	3b01      	subs	r3, #1
 801d100:	9a08      	ldr	r2, [sp, #32]
 801d102:	9200      	str	r2, [sp, #0]
 801d104:	1c75      	adds	r5, r6, #1
 801d106:	f8cb 3004 	str.w	r3, [fp, #4]
 801d10a:	4649      	mov	r1, r9
 801d10c:	f808 0006 	strb.w	r0, [r8, r6]
 801d110:	462b      	mov	r3, r5
 801d112:	4642      	mov	r2, r8
 801d114:	4638      	mov	r0, r7
 801d116:	f000 fb2f 	bl	801d778 <_mbrtowc_r>
 801d11a:	1c41      	adds	r1, r0, #1
 801d11c:	f43f acb8 	beq.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801d120:	b198      	cbz	r0, 801d14a <__ssvfiscanf_r+0x95a>
 801d122:	3002      	adds	r0, #2
 801d124:	bf08      	it	eq
 801d126:	462e      	moveq	r6, r5
 801d128:	d12e      	bne.n	801d188 <__ssvfiscanf_r+0x998>
 801d12a:	f8db 3004 	ldr.w	r3, [fp, #4]
 801d12e:	2b00      	cmp	r3, #0
 801d130:	f73f ad5e 	bgt.w	801cbf0 <__ssvfiscanf_r+0x400>
 801d134:	4659      	mov	r1, fp
 801d136:	4638      	mov	r0, r7
 801d138:	f7ff fafc 	bl	801c734 <__ssrefill_r>
 801d13c:	2800      	cmp	r0, #0
 801d13e:	f43f ad57 	beq.w	801cbf0 <__ssvfiscanf_r+0x400>
 801d142:	2e00      	cmp	r6, #0
 801d144:	f47f aca4 	bne.w	801ca90 <__ssvfiscanf_r+0x2a0>
 801d148:	e55e      	b.n	801cc08 <__ssvfiscanf_r+0x418>
 801d14a:	f8c9 0000 	str.w	r0, [r9]
 801d14e:	f000 fb05 	bl	801d75c <iswspace>
 801d152:	4606      	mov	r6, r0
 801d154:	b178      	cbz	r0, 801d176 <__ssvfiscanf_r+0x986>
 801d156:	2d00      	cmp	r5, #0
 801d158:	f43f ad56 	beq.w	801cc08 <__ssvfiscanf_r+0x418>
 801d15c:	4445      	add	r5, r8
 801d15e:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
 801d162:	465a      	mov	r2, fp
 801d164:	4638      	mov	r0, r7
 801d166:	f7ff faa5 	bl	801c6b4 <_sungetc_r>
 801d16a:	4545      	cmp	r5, r8
 801d16c:	d1f7      	bne.n	801d15e <__ssvfiscanf_r+0x96e>
 801d16e:	e54b      	b.n	801cc08 <__ssvfiscanf_r+0x418>
 801d170:	f000 ff1c 	bl	801dfac <_strtoull_r>
 801d174:	e6f9      	b.n	801cf6a <__ssvfiscanf_r+0x77a>
 801d176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d178:	44aa      	add	sl, r5
 801d17a:	3c01      	subs	r4, #1
 801d17c:	2b00      	cmp	r3, #0
 801d17e:	d1d4      	bne.n	801d12a <__ssvfiscanf_r+0x93a>
 801d180:	f109 0904 	add.w	r9, r9, #4
 801d184:	461e      	mov	r6, r3
 801d186:	e7d0      	b.n	801d12a <__ssvfiscanf_r+0x93a>
 801d188:	f8d9 0000 	ldr.w	r0, [r9]
 801d18c:	e7df      	b.n	801d14e <__ssvfiscanf_r+0x95e>
 801d18e:	bf00      	nop

0801d190 <tolower_l>:
 801d190:	b510      	push	{r4, lr}
 801d192:	4604      	mov	r4, r0
 801d194:	4608      	mov	r0, r1
 801d196:	f7fd fcdb 	bl	801ab50 <__locale_ctype_ptr_l>
 801d19a:	4420      	add	r0, r4
 801d19c:	7843      	ldrb	r3, [r0, #1]
 801d19e:	f003 0303 	and.w	r3, r3, #3
 801d1a2:	2b01      	cmp	r3, #1
 801d1a4:	bf08      	it	eq
 801d1a6:	3420      	addeq	r4, #32
 801d1a8:	4620      	mov	r0, r4
 801d1aa:	bd10      	pop	{r4, pc}

0801d1ac <__submore>:
 801d1ac:	f101 0340 	add.w	r3, r1, #64	; 0x40
 801d1b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d1b4:	460c      	mov	r4, r1
 801d1b6:	6b09      	ldr	r1, [r1, #48]	; 0x30
 801d1b8:	4299      	cmp	r1, r3
 801d1ba:	d014      	beq.n	801d1e6 <__submore+0x3a>
 801d1bc:	6b66      	ldr	r6, [r4, #52]	; 0x34
 801d1be:	0077      	lsls	r7, r6, #1
 801d1c0:	463a      	mov	r2, r7
 801d1c2:	f000 fb55 	bl	801d870 <_realloc_r>
 801d1c6:	4605      	mov	r5, r0
 801d1c8:	b340      	cbz	r0, 801d21c <__submore+0x70>
 801d1ca:	eb00 0806 	add.w	r8, r0, r6
 801d1ce:	4632      	mov	r2, r6
 801d1d0:	4640      	mov	r0, r8
 801d1d2:	4629      	mov	r1, r5
 801d1d4:	f7e7 faa2 	bl	800471c <memcpy>
 801d1d8:	f8c4 8000 	str.w	r8, [r4]
 801d1dc:	6325      	str	r5, [r4, #48]	; 0x30
 801d1de:	6367      	str	r7, [r4, #52]	; 0x34
 801d1e0:	2000      	movs	r0, #0
 801d1e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d1e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801d1ea:	f7fe fd99 	bl	801bd20 <_malloc_r>
 801d1ee:	b1a8      	cbz	r0, 801d21c <__submore+0x70>
 801d1f0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 801d1f4:	6320      	str	r0, [r4, #48]	; 0x30
 801d1f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801d1fa:	6362      	str	r2, [r4, #52]	; 0x34
 801d1fc:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 801d200:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 801d204:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 801d208:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 801d20c:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 801d210:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 801d214:	6020      	str	r0, [r4, #0]
 801d216:	2000      	movs	r0, #0
 801d218:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d21c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801d220:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801d224 <__env_lock>:
 801d224:	4801      	ldr	r0, [pc, #4]	; (801d22c <__env_lock+0x8>)
 801d226:	f7fe bd6d 	b.w	801bd04 <__retarget_lock_acquire_recursive>
 801d22a:	bf00      	nop
 801d22c:	2000f23c 	.word	0x2000f23c

0801d230 <__env_unlock>:
 801d230:	4801      	ldr	r0, [pc, #4]	; (801d238 <__env_unlock+0x8>)
 801d232:	f7fe bd6b 	b.w	801bd0c <__retarget_lock_release_recursive>
 801d236:	bf00      	nop
 801d238:	2000f23c 	.word	0x2000f23c

0801d23c <__sflush_r>:
 801d23c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
 801d240:	b29a      	uxth	r2, r3
 801d242:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d246:	460d      	mov	r5, r1
 801d248:	0711      	lsls	r1, r2, #28
 801d24a:	4680      	mov	r8, r0
 801d24c:	d43a      	bmi.n	801d2c4 <__sflush_r+0x88>
 801d24e:	686a      	ldr	r2, [r5, #4]
 801d250:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801d254:	2a00      	cmp	r2, #0
 801d256:	81ab      	strh	r3, [r5, #12]
 801d258:	dd6f      	ble.n	801d33a <__sflush_r+0xfe>
 801d25a:	6aac      	ldr	r4, [r5, #40]	; 0x28
 801d25c:	2c00      	cmp	r4, #0
 801d25e:	d049      	beq.n	801d2f4 <__sflush_r+0xb8>
 801d260:	2200      	movs	r2, #0
 801d262:	b29b      	uxth	r3, r3
 801d264:	f8d8 6000 	ldr.w	r6, [r8]
 801d268:	f8c8 2000 	str.w	r2, [r8]
 801d26c:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
 801d270:	d067      	beq.n	801d342 <__sflush_r+0x106>
 801d272:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 801d274:	075f      	lsls	r7, r3, #29
 801d276:	d505      	bpl.n	801d284 <__sflush_r+0x48>
 801d278:	6869      	ldr	r1, [r5, #4]
 801d27a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 801d27c:	1a52      	subs	r2, r2, r1
 801d27e:	b10b      	cbz	r3, 801d284 <__sflush_r+0x48>
 801d280:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 801d282:	1ad2      	subs	r2, r2, r3
 801d284:	2300      	movs	r3, #0
 801d286:	69e9      	ldr	r1, [r5, #28]
 801d288:	4640      	mov	r0, r8
 801d28a:	47a0      	blx	r4
 801d28c:	1c44      	adds	r4, r0, #1
 801d28e:	d03c      	beq.n	801d30a <__sflush_r+0xce>
 801d290:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
 801d294:	692a      	ldr	r2, [r5, #16]
 801d296:	602a      	str	r2, [r5, #0]
 801d298:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801d29c:	2200      	movs	r2, #0
 801d29e:	81ab      	strh	r3, [r5, #12]
 801d2a0:	04db      	lsls	r3, r3, #19
 801d2a2:	606a      	str	r2, [r5, #4]
 801d2a4:	d447      	bmi.n	801d336 <__sflush_r+0xfa>
 801d2a6:	6b29      	ldr	r1, [r5, #48]	; 0x30
 801d2a8:	f8c8 6000 	str.w	r6, [r8]
 801d2ac:	b311      	cbz	r1, 801d2f4 <__sflush_r+0xb8>
 801d2ae:	f105 0340 	add.w	r3, r5, #64	; 0x40
 801d2b2:	4299      	cmp	r1, r3
 801d2b4:	d002      	beq.n	801d2bc <__sflush_r+0x80>
 801d2b6:	4640      	mov	r0, r8
 801d2b8:	f000 f940 	bl	801d53c <_free_r>
 801d2bc:	2000      	movs	r0, #0
 801d2be:	6328      	str	r0, [r5, #48]	; 0x30
 801d2c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d2c4:	692e      	ldr	r6, [r5, #16]
 801d2c6:	b1ae      	cbz	r6, 801d2f4 <__sflush_r+0xb8>
 801d2c8:	682c      	ldr	r4, [r5, #0]
 801d2ca:	602e      	str	r6, [r5, #0]
 801d2cc:	0791      	lsls	r1, r2, #30
 801d2ce:	bf0c      	ite	eq
 801d2d0:	696b      	ldreq	r3, [r5, #20]
 801d2d2:	2300      	movne	r3, #0
 801d2d4:	1ba4      	subs	r4, r4, r6
 801d2d6:	60ab      	str	r3, [r5, #8]
 801d2d8:	e00a      	b.n	801d2f0 <__sflush_r+0xb4>
 801d2da:	4623      	mov	r3, r4
 801d2dc:	4632      	mov	r2, r6
 801d2de:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 801d2e0:	69e9      	ldr	r1, [r5, #28]
 801d2e2:	4640      	mov	r0, r8
 801d2e4:	47b8      	blx	r7
 801d2e6:	2800      	cmp	r0, #0
 801d2e8:	eba4 0400 	sub.w	r4, r4, r0
 801d2ec:	4406      	add	r6, r0
 801d2ee:	dd04      	ble.n	801d2fa <__sflush_r+0xbe>
 801d2f0:	2c00      	cmp	r4, #0
 801d2f2:	dcf2      	bgt.n	801d2da <__sflush_r+0x9e>
 801d2f4:	2000      	movs	r0, #0
 801d2f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d2fa:	89ab      	ldrh	r3, [r5, #12]
 801d2fc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801d300:	81ab      	strh	r3, [r5, #12]
 801d302:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801d306:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d30a:	f8d8 4000 	ldr.w	r4, [r8]
 801d30e:	2c1d      	cmp	r4, #29
 801d310:	d8f3      	bhi.n	801d2fa <__sflush_r+0xbe>
 801d312:	4b19      	ldr	r3, [pc, #100]	; (801d378 <__sflush_r+0x13c>)
 801d314:	40e3      	lsrs	r3, r4
 801d316:	43db      	mvns	r3, r3
 801d318:	f013 0301 	ands.w	r3, r3, #1
 801d31c:	d1ed      	bne.n	801d2fa <__sflush_r+0xbe>
 801d31e:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
 801d322:	606b      	str	r3, [r5, #4]
 801d324:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
 801d328:	6929      	ldr	r1, [r5, #16]
 801d32a:	81ab      	strh	r3, [r5, #12]
 801d32c:	04da      	lsls	r2, r3, #19
 801d32e:	6029      	str	r1, [r5, #0]
 801d330:	d5b9      	bpl.n	801d2a6 <__sflush_r+0x6a>
 801d332:	2c00      	cmp	r4, #0
 801d334:	d1b7      	bne.n	801d2a6 <__sflush_r+0x6a>
 801d336:	6528      	str	r0, [r5, #80]	; 0x50
 801d338:	e7b5      	b.n	801d2a6 <__sflush_r+0x6a>
 801d33a:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 801d33c:	2a00      	cmp	r2, #0
 801d33e:	dc8c      	bgt.n	801d25a <__sflush_r+0x1e>
 801d340:	e7d8      	b.n	801d2f4 <__sflush_r+0xb8>
 801d342:	2301      	movs	r3, #1
 801d344:	69e9      	ldr	r1, [r5, #28]
 801d346:	4640      	mov	r0, r8
 801d348:	47a0      	blx	r4
 801d34a:	1c43      	adds	r3, r0, #1
 801d34c:	4602      	mov	r2, r0
 801d34e:	d002      	beq.n	801d356 <__sflush_r+0x11a>
 801d350:	89ab      	ldrh	r3, [r5, #12]
 801d352:	6aac      	ldr	r4, [r5, #40]	; 0x28
 801d354:	e78e      	b.n	801d274 <__sflush_r+0x38>
 801d356:	f8d8 3000 	ldr.w	r3, [r8]
 801d35a:	2b00      	cmp	r3, #0
 801d35c:	d0f8      	beq.n	801d350 <__sflush_r+0x114>
 801d35e:	2b1d      	cmp	r3, #29
 801d360:	d001      	beq.n	801d366 <__sflush_r+0x12a>
 801d362:	2b16      	cmp	r3, #22
 801d364:	d102      	bne.n	801d36c <__sflush_r+0x130>
 801d366:	f8c8 6000 	str.w	r6, [r8]
 801d36a:	e7c3      	b.n	801d2f4 <__sflush_r+0xb8>
 801d36c:	89ab      	ldrh	r3, [r5, #12]
 801d36e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801d372:	81ab      	strh	r3, [r5, #12]
 801d374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801d378:	20400001 	.word	0x20400001

0801d37c <_fflush_r>:
 801d37c:	b538      	push	{r3, r4, r5, lr}
 801d37e:	460d      	mov	r5, r1
 801d380:	4604      	mov	r4, r0
 801d382:	b108      	cbz	r0, 801d388 <_fflush_r+0xc>
 801d384:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801d386:	b1bb      	cbz	r3, 801d3b8 <_fflush_r+0x3c>
 801d388:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
 801d38c:	b188      	cbz	r0, 801d3b2 <_fflush_r+0x36>
 801d38e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801d390:	07db      	lsls	r3, r3, #31
 801d392:	d401      	bmi.n	801d398 <_fflush_r+0x1c>
 801d394:	0581      	lsls	r1, r0, #22
 801d396:	d517      	bpl.n	801d3c8 <_fflush_r+0x4c>
 801d398:	4620      	mov	r0, r4
 801d39a:	4629      	mov	r1, r5
 801d39c:	f7ff ff4e 	bl	801d23c <__sflush_r>
 801d3a0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801d3a2:	07da      	lsls	r2, r3, #31
 801d3a4:	4604      	mov	r4, r0
 801d3a6:	d402      	bmi.n	801d3ae <_fflush_r+0x32>
 801d3a8:	89ab      	ldrh	r3, [r5, #12]
 801d3aa:	059b      	lsls	r3, r3, #22
 801d3ac:	d507      	bpl.n	801d3be <_fflush_r+0x42>
 801d3ae:	4620      	mov	r0, r4
 801d3b0:	bd38      	pop	{r3, r4, r5, pc}
 801d3b2:	4604      	mov	r4, r0
 801d3b4:	4620      	mov	r0, r4
 801d3b6:	bd38      	pop	{r3, r4, r5, pc}
 801d3b8:	f000 f838 	bl	801d42c <__sinit>
 801d3bc:	e7e4      	b.n	801d388 <_fflush_r+0xc>
 801d3be:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801d3c0:	f7fe fca4 	bl	801bd0c <__retarget_lock_release_recursive>
 801d3c4:	4620      	mov	r0, r4
 801d3c6:	bd38      	pop	{r3, r4, r5, pc}
 801d3c8:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801d3ca:	f7fe fc9b 	bl	801bd04 <__retarget_lock_acquire_recursive>
 801d3ce:	e7e3      	b.n	801d398 <_fflush_r+0x1c>

0801d3d0 <_cleanup_r>:
 801d3d0:	4901      	ldr	r1, [pc, #4]	; (801d3d8 <_cleanup_r+0x8>)
 801d3d2:	f000 b999 	b.w	801d708 <_fwalk_reent>
 801d3d6:	bf00      	nop
 801d3d8:	0801dfd1 	.word	0x0801dfd1

0801d3dc <std.isra.0>:
 801d3dc:	b510      	push	{r4, lr}
 801d3de:	2300      	movs	r3, #0
 801d3e0:	4604      	mov	r4, r0
 801d3e2:	8181      	strh	r1, [r0, #12]
 801d3e4:	81c2      	strh	r2, [r0, #14]
 801d3e6:	6003      	str	r3, [r0, #0]
 801d3e8:	6043      	str	r3, [r0, #4]
 801d3ea:	6083      	str	r3, [r0, #8]
 801d3ec:	6643      	str	r3, [r0, #100]	; 0x64
 801d3ee:	6103      	str	r3, [r0, #16]
 801d3f0:	6143      	str	r3, [r0, #20]
 801d3f2:	6183      	str	r3, [r0, #24]
 801d3f4:	4619      	mov	r1, r3
 801d3f6:	2208      	movs	r2, #8
 801d3f8:	305c      	adds	r0, #92	; 0x5c
 801d3fa:	f000 f9eb 	bl	801d7d4 <memset>
 801d3fe:	4807      	ldr	r0, [pc, #28]	; (801d41c <std.isra.0+0x40>)
 801d400:	4907      	ldr	r1, [pc, #28]	; (801d420 <std.isra.0+0x44>)
 801d402:	4a08      	ldr	r2, [pc, #32]	; (801d424 <std.isra.0+0x48>)
 801d404:	4b08      	ldr	r3, [pc, #32]	; (801d428 <std.isra.0+0x4c>)
 801d406:	6220      	str	r0, [r4, #32]
 801d408:	61e4      	str	r4, [r4, #28]
 801d40a:	6261      	str	r1, [r4, #36]	; 0x24
 801d40c:	62a2      	str	r2, [r4, #40]	; 0x28
 801d40e:	62e3      	str	r3, [r4, #44]	; 0x2c
 801d410:	f104 0058 	add.w	r0, r4, #88	; 0x58
 801d414:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d418:	f7fe bc6e 	b.w	801bcf8 <__retarget_lock_init_recursive>
 801d41c:	0801c2f1 	.word	0x0801c2f1
 801d420:	0801c319 	.word	0x0801c319
 801d424:	0801c355 	.word	0x0801c355
 801d428:	0801c375 	.word	0x0801c375

0801d42c <__sinit>:
 801d42c:	b510      	push	{r4, lr}
 801d42e:	4604      	mov	r4, r0
 801d430:	4812      	ldr	r0, [pc, #72]	; (801d47c <__sinit+0x50>)
 801d432:	f7fe fc67 	bl	801bd04 <__retarget_lock_acquire_recursive>
 801d436:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 801d438:	b9d2      	cbnz	r2, 801d470 <__sinit+0x44>
 801d43a:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
 801d43e:	4810      	ldr	r0, [pc, #64]	; (801d480 <__sinit+0x54>)
 801d440:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
 801d444:	2103      	movs	r1, #3
 801d446:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
 801d44a:	63e0      	str	r0, [r4, #60]	; 0x3c
 801d44c:	f8c4 12e4 	str.w	r1, [r4, #740]	; 0x2e4
 801d450:	6860      	ldr	r0, [r4, #4]
 801d452:	2104      	movs	r1, #4
 801d454:	f7ff ffc2 	bl	801d3dc <std.isra.0>
 801d458:	2201      	movs	r2, #1
 801d45a:	2109      	movs	r1, #9
 801d45c:	68a0      	ldr	r0, [r4, #8]
 801d45e:	f7ff ffbd 	bl	801d3dc <std.isra.0>
 801d462:	2202      	movs	r2, #2
 801d464:	2112      	movs	r1, #18
 801d466:	68e0      	ldr	r0, [r4, #12]
 801d468:	f7ff ffb8 	bl	801d3dc <std.isra.0>
 801d46c:	2301      	movs	r3, #1
 801d46e:	63a3      	str	r3, [r4, #56]	; 0x38
 801d470:	4802      	ldr	r0, [pc, #8]	; (801d47c <__sinit+0x50>)
 801d472:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d476:	f7fe bc49 	b.w	801bd0c <__retarget_lock_release_recursive>
 801d47a:	bf00      	nop
 801d47c:	2000f240 	.word	0x2000f240
 801d480:	0801d3d1 	.word	0x0801d3d1

0801d484 <__sfp_lock_acquire>:
 801d484:	4801      	ldr	r0, [pc, #4]	; (801d48c <__sfp_lock_acquire+0x8>)
 801d486:	f7fe bc3d 	b.w	801bd04 <__retarget_lock_acquire_recursive>
 801d48a:	bf00      	nop
 801d48c:	2000f254 	.word	0x2000f254

0801d490 <__sfp_lock_release>:
 801d490:	4801      	ldr	r0, [pc, #4]	; (801d498 <__sfp_lock_release+0x8>)
 801d492:	f7fe bc3b 	b.w	801bd0c <__retarget_lock_release_recursive>
 801d496:	bf00      	nop
 801d498:	2000f254 	.word	0x2000f254

0801d49c <_malloc_trim_r>:
 801d49c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d49e:	4f24      	ldr	r7, [pc, #144]	; (801d530 <_malloc_trim_r+0x94>)
 801d4a0:	460c      	mov	r4, r1
 801d4a2:	4606      	mov	r6, r0
 801d4a4:	f7fe feec 	bl	801c280 <__malloc_lock>
 801d4a8:	68bb      	ldr	r3, [r7, #8]
 801d4aa:	685d      	ldr	r5, [r3, #4]
 801d4ac:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
 801d4b0:	310f      	adds	r1, #15
 801d4b2:	f025 0503 	bic.w	r5, r5, #3
 801d4b6:	4429      	add	r1, r5
 801d4b8:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 801d4bc:	f021 010f 	bic.w	r1, r1, #15
 801d4c0:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 801d4c4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 801d4c8:	db07      	blt.n	801d4da <_malloc_trim_r+0x3e>
 801d4ca:	2100      	movs	r1, #0
 801d4cc:	4630      	mov	r0, r6
 801d4ce:	f7e8 f8c7 	bl	8005660 <_sbrk_r>
 801d4d2:	68bb      	ldr	r3, [r7, #8]
 801d4d4:	442b      	add	r3, r5
 801d4d6:	4298      	cmp	r0, r3
 801d4d8:	d004      	beq.n	801d4e4 <_malloc_trim_r+0x48>
 801d4da:	4630      	mov	r0, r6
 801d4dc:	f7fe fed6 	bl	801c28c <__malloc_unlock>
 801d4e0:	2000      	movs	r0, #0
 801d4e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d4e4:	4261      	negs	r1, r4
 801d4e6:	4630      	mov	r0, r6
 801d4e8:	f7e8 f8ba 	bl	8005660 <_sbrk_r>
 801d4ec:	3001      	adds	r0, #1
 801d4ee:	d00d      	beq.n	801d50c <_malloc_trim_r+0x70>
 801d4f0:	4b10      	ldr	r3, [pc, #64]	; (801d534 <_malloc_trim_r+0x98>)
 801d4f2:	68ba      	ldr	r2, [r7, #8]
 801d4f4:	6819      	ldr	r1, [r3, #0]
 801d4f6:	1b2d      	subs	r5, r5, r4
 801d4f8:	f045 0501 	orr.w	r5, r5, #1
 801d4fc:	4630      	mov	r0, r6
 801d4fe:	1b09      	subs	r1, r1, r4
 801d500:	6055      	str	r5, [r2, #4]
 801d502:	6019      	str	r1, [r3, #0]
 801d504:	f7fe fec2 	bl	801c28c <__malloc_unlock>
 801d508:	2001      	movs	r0, #1
 801d50a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d50c:	2100      	movs	r1, #0
 801d50e:	4630      	mov	r0, r6
 801d510:	f7e8 f8a6 	bl	8005660 <_sbrk_r>
 801d514:	68ba      	ldr	r2, [r7, #8]
 801d516:	1a83      	subs	r3, r0, r2
 801d518:	2b0f      	cmp	r3, #15
 801d51a:	ddde      	ble.n	801d4da <_malloc_trim_r+0x3e>
 801d51c:	4c06      	ldr	r4, [pc, #24]	; (801d538 <_malloc_trim_r+0x9c>)
 801d51e:	4905      	ldr	r1, [pc, #20]	; (801d534 <_malloc_trim_r+0x98>)
 801d520:	6824      	ldr	r4, [r4, #0]
 801d522:	f043 0301 	orr.w	r3, r3, #1
 801d526:	1b00      	subs	r0, r0, r4
 801d528:	6053      	str	r3, [r2, #4]
 801d52a:	6008      	str	r0, [r1, #0]
 801d52c:	e7d5      	b.n	801d4da <_malloc_trim_r+0x3e>
 801d52e:	bf00      	nop
 801d530:	20004a54 	.word	0x20004a54
 801d534:	2000f1fc 	.word	0x2000f1fc
 801d538:	20004e5c 	.word	0x20004e5c

0801d53c <_free_r>:
 801d53c:	2900      	cmp	r1, #0
 801d53e:	d044      	beq.n	801d5ca <_free_r+0x8e>
 801d540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d544:	460d      	mov	r5, r1
 801d546:	4680      	mov	r8, r0
 801d548:	f7fe fe9a 	bl	801c280 <__malloc_lock>
 801d54c:	f855 7c04 	ldr.w	r7, [r5, #-4]
 801d550:	4969      	ldr	r1, [pc, #420]	; (801d6f8 <_free_r+0x1bc>)
 801d552:	f027 0301 	bic.w	r3, r7, #1
 801d556:	f1a5 0408 	sub.w	r4, r5, #8
 801d55a:	18e2      	adds	r2, r4, r3
 801d55c:	688e      	ldr	r6, [r1, #8]
 801d55e:	6850      	ldr	r0, [r2, #4]
 801d560:	42b2      	cmp	r2, r6
 801d562:	f020 0003 	bic.w	r0, r0, #3
 801d566:	d05e      	beq.n	801d626 <_free_r+0xea>
 801d568:	07fe      	lsls	r6, r7, #31
 801d56a:	6050      	str	r0, [r2, #4]
 801d56c:	d40b      	bmi.n	801d586 <_free_r+0x4a>
 801d56e:	f855 7c08 	ldr.w	r7, [r5, #-8]
 801d572:	1be4      	subs	r4, r4, r7
 801d574:	f101 0e08 	add.w	lr, r1, #8
 801d578:	68a5      	ldr	r5, [r4, #8]
 801d57a:	4575      	cmp	r5, lr
 801d57c:	443b      	add	r3, r7
 801d57e:	d06d      	beq.n	801d65c <_free_r+0x120>
 801d580:	68e7      	ldr	r7, [r4, #12]
 801d582:	60ef      	str	r7, [r5, #12]
 801d584:	60bd      	str	r5, [r7, #8]
 801d586:	1815      	adds	r5, r2, r0
 801d588:	686d      	ldr	r5, [r5, #4]
 801d58a:	07ed      	lsls	r5, r5, #31
 801d58c:	d53e      	bpl.n	801d60c <_free_r+0xd0>
 801d58e:	f043 0201 	orr.w	r2, r3, #1
 801d592:	6062      	str	r2, [r4, #4]
 801d594:	50e3      	str	r3, [r4, r3]
 801d596:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801d59a:	d217      	bcs.n	801d5cc <_free_r+0x90>
 801d59c:	08db      	lsrs	r3, r3, #3
 801d59e:	1c58      	adds	r0, r3, #1
 801d5a0:	109a      	asrs	r2, r3, #2
 801d5a2:	684d      	ldr	r5, [r1, #4]
 801d5a4:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
 801d5a8:	60a7      	str	r7, [r4, #8]
 801d5aa:	2301      	movs	r3, #1
 801d5ac:	4093      	lsls	r3, r2
 801d5ae:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
 801d5b2:	432b      	orrs	r3, r5
 801d5b4:	3a08      	subs	r2, #8
 801d5b6:	60e2      	str	r2, [r4, #12]
 801d5b8:	604b      	str	r3, [r1, #4]
 801d5ba:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
 801d5be:	60fc      	str	r4, [r7, #12]
 801d5c0:	4640      	mov	r0, r8
 801d5c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801d5c6:	f7fe be61 	b.w	801c28c <__malloc_unlock>
 801d5ca:	4770      	bx	lr
 801d5cc:	0a5a      	lsrs	r2, r3, #9
 801d5ce:	2a04      	cmp	r2, #4
 801d5d0:	d852      	bhi.n	801d678 <_free_r+0x13c>
 801d5d2:	099a      	lsrs	r2, r3, #6
 801d5d4:	f102 0739 	add.w	r7, r2, #57	; 0x39
 801d5d8:	00ff      	lsls	r7, r7, #3
 801d5da:	f102 0538 	add.w	r5, r2, #56	; 0x38
 801d5de:	19c8      	adds	r0, r1, r7
 801d5e0:	59ca      	ldr	r2, [r1, r7]
 801d5e2:	3808      	subs	r0, #8
 801d5e4:	4290      	cmp	r0, r2
 801d5e6:	d04f      	beq.n	801d688 <_free_r+0x14c>
 801d5e8:	6851      	ldr	r1, [r2, #4]
 801d5ea:	f021 0103 	bic.w	r1, r1, #3
 801d5ee:	428b      	cmp	r3, r1
 801d5f0:	d232      	bcs.n	801d658 <_free_r+0x11c>
 801d5f2:	6892      	ldr	r2, [r2, #8]
 801d5f4:	4290      	cmp	r0, r2
 801d5f6:	d1f7      	bne.n	801d5e8 <_free_r+0xac>
 801d5f8:	68c3      	ldr	r3, [r0, #12]
 801d5fa:	60a0      	str	r0, [r4, #8]
 801d5fc:	60e3      	str	r3, [r4, #12]
 801d5fe:	609c      	str	r4, [r3, #8]
 801d600:	60c4      	str	r4, [r0, #12]
 801d602:	4640      	mov	r0, r8
 801d604:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801d608:	f7fe be40 	b.w	801c28c <__malloc_unlock>
 801d60c:	6895      	ldr	r5, [r2, #8]
 801d60e:	4f3b      	ldr	r7, [pc, #236]	; (801d6fc <_free_r+0x1c0>)
 801d610:	42bd      	cmp	r5, r7
 801d612:	4403      	add	r3, r0
 801d614:	d040      	beq.n	801d698 <_free_r+0x15c>
 801d616:	68d0      	ldr	r0, [r2, #12]
 801d618:	60e8      	str	r0, [r5, #12]
 801d61a:	f043 0201 	orr.w	r2, r3, #1
 801d61e:	6085      	str	r5, [r0, #8]
 801d620:	6062      	str	r2, [r4, #4]
 801d622:	50e3      	str	r3, [r4, r3]
 801d624:	e7b7      	b.n	801d596 <_free_r+0x5a>
 801d626:	07ff      	lsls	r7, r7, #31
 801d628:	4403      	add	r3, r0
 801d62a:	d407      	bmi.n	801d63c <_free_r+0x100>
 801d62c:	f855 2c08 	ldr.w	r2, [r5, #-8]
 801d630:	1aa4      	subs	r4, r4, r2
 801d632:	4413      	add	r3, r2
 801d634:	68a0      	ldr	r0, [r4, #8]
 801d636:	68e2      	ldr	r2, [r4, #12]
 801d638:	60c2      	str	r2, [r0, #12]
 801d63a:	6090      	str	r0, [r2, #8]
 801d63c:	4a30      	ldr	r2, [pc, #192]	; (801d700 <_free_r+0x1c4>)
 801d63e:	6812      	ldr	r2, [r2, #0]
 801d640:	f043 0001 	orr.w	r0, r3, #1
 801d644:	4293      	cmp	r3, r2
 801d646:	6060      	str	r0, [r4, #4]
 801d648:	608c      	str	r4, [r1, #8]
 801d64a:	d3b9      	bcc.n	801d5c0 <_free_r+0x84>
 801d64c:	4b2d      	ldr	r3, [pc, #180]	; (801d704 <_free_r+0x1c8>)
 801d64e:	4640      	mov	r0, r8
 801d650:	6819      	ldr	r1, [r3, #0]
 801d652:	f7ff ff23 	bl	801d49c <_malloc_trim_r>
 801d656:	e7b3      	b.n	801d5c0 <_free_r+0x84>
 801d658:	4610      	mov	r0, r2
 801d65a:	e7cd      	b.n	801d5f8 <_free_r+0xbc>
 801d65c:	1811      	adds	r1, r2, r0
 801d65e:	6849      	ldr	r1, [r1, #4]
 801d660:	07c9      	lsls	r1, r1, #31
 801d662:	d444      	bmi.n	801d6ee <_free_r+0x1b2>
 801d664:	6891      	ldr	r1, [r2, #8]
 801d666:	68d2      	ldr	r2, [r2, #12]
 801d668:	60ca      	str	r2, [r1, #12]
 801d66a:	4403      	add	r3, r0
 801d66c:	f043 0001 	orr.w	r0, r3, #1
 801d670:	6091      	str	r1, [r2, #8]
 801d672:	6060      	str	r0, [r4, #4]
 801d674:	50e3      	str	r3, [r4, r3]
 801d676:	e7a3      	b.n	801d5c0 <_free_r+0x84>
 801d678:	2a14      	cmp	r2, #20
 801d67a:	d816      	bhi.n	801d6aa <_free_r+0x16e>
 801d67c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
 801d680:	00ff      	lsls	r7, r7, #3
 801d682:	f102 055b 	add.w	r5, r2, #91	; 0x5b
 801d686:	e7aa      	b.n	801d5de <_free_r+0xa2>
 801d688:	10aa      	asrs	r2, r5, #2
 801d68a:	2301      	movs	r3, #1
 801d68c:	684d      	ldr	r5, [r1, #4]
 801d68e:	4093      	lsls	r3, r2
 801d690:	432b      	orrs	r3, r5
 801d692:	604b      	str	r3, [r1, #4]
 801d694:	4603      	mov	r3, r0
 801d696:	e7b0      	b.n	801d5fa <_free_r+0xbe>
 801d698:	f043 0201 	orr.w	r2, r3, #1
 801d69c:	614c      	str	r4, [r1, #20]
 801d69e:	610c      	str	r4, [r1, #16]
 801d6a0:	60e5      	str	r5, [r4, #12]
 801d6a2:	60a5      	str	r5, [r4, #8]
 801d6a4:	6062      	str	r2, [r4, #4]
 801d6a6:	50e3      	str	r3, [r4, r3]
 801d6a8:	e78a      	b.n	801d5c0 <_free_r+0x84>
 801d6aa:	2a54      	cmp	r2, #84	; 0x54
 801d6ac:	d806      	bhi.n	801d6bc <_free_r+0x180>
 801d6ae:	0b1a      	lsrs	r2, r3, #12
 801d6b0:	f102 076f 	add.w	r7, r2, #111	; 0x6f
 801d6b4:	00ff      	lsls	r7, r7, #3
 801d6b6:	f102 056e 	add.w	r5, r2, #110	; 0x6e
 801d6ba:	e790      	b.n	801d5de <_free_r+0xa2>
 801d6bc:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 801d6c0:	d806      	bhi.n	801d6d0 <_free_r+0x194>
 801d6c2:	0bda      	lsrs	r2, r3, #15
 801d6c4:	f102 0778 	add.w	r7, r2, #120	; 0x78
 801d6c8:	00ff      	lsls	r7, r7, #3
 801d6ca:	f102 0577 	add.w	r5, r2, #119	; 0x77
 801d6ce:	e786      	b.n	801d5de <_free_r+0xa2>
 801d6d0:	f240 5054 	movw	r0, #1364	; 0x554
 801d6d4:	4282      	cmp	r2, r0
 801d6d6:	d806      	bhi.n	801d6e6 <_free_r+0x1aa>
 801d6d8:	0c9a      	lsrs	r2, r3, #18
 801d6da:	f102 077d 	add.w	r7, r2, #125	; 0x7d
 801d6de:	00ff      	lsls	r7, r7, #3
 801d6e0:	f102 057c 	add.w	r5, r2, #124	; 0x7c
 801d6e4:	e77b      	b.n	801d5de <_free_r+0xa2>
 801d6e6:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
 801d6ea:	257e      	movs	r5, #126	; 0x7e
 801d6ec:	e777      	b.n	801d5de <_free_r+0xa2>
 801d6ee:	f043 0101 	orr.w	r1, r3, #1
 801d6f2:	6061      	str	r1, [r4, #4]
 801d6f4:	6013      	str	r3, [r2, #0]
 801d6f6:	e763      	b.n	801d5c0 <_free_r+0x84>
 801d6f8:	20004a54 	.word	0x20004a54
 801d6fc:	20004a5c 	.word	0x20004a5c
 801d700:	20004e60 	.word	0x20004e60
 801d704:	2000f22c 	.word	0x2000f22c

0801d708 <_fwalk_reent>:
 801d708:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801d70c:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
 801d710:	d01f      	beq.n	801d752 <_fwalk_reent+0x4a>
 801d712:	4688      	mov	r8, r1
 801d714:	4606      	mov	r6, r0
 801d716:	f04f 0900 	mov.w	r9, #0
 801d71a:	687d      	ldr	r5, [r7, #4]
 801d71c:	68bc      	ldr	r4, [r7, #8]
 801d71e:	3d01      	subs	r5, #1
 801d720:	d411      	bmi.n	801d746 <_fwalk_reent+0x3e>
 801d722:	89a3      	ldrh	r3, [r4, #12]
 801d724:	2b01      	cmp	r3, #1
 801d726:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 801d72a:	d908      	bls.n	801d73e <_fwalk_reent+0x36>
 801d72c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 801d730:	3301      	adds	r3, #1
 801d732:	4621      	mov	r1, r4
 801d734:	4630      	mov	r0, r6
 801d736:	d002      	beq.n	801d73e <_fwalk_reent+0x36>
 801d738:	47c0      	blx	r8
 801d73a:	ea49 0900 	orr.w	r9, r9, r0
 801d73e:	1c6b      	adds	r3, r5, #1
 801d740:	f104 0468 	add.w	r4, r4, #104	; 0x68
 801d744:	d1ed      	bne.n	801d722 <_fwalk_reent+0x1a>
 801d746:	683f      	ldr	r7, [r7, #0]
 801d748:	2f00      	cmp	r7, #0
 801d74a:	d1e6      	bne.n	801d71a <_fwalk_reent+0x12>
 801d74c:	4648      	mov	r0, r9
 801d74e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801d752:	46b9      	mov	r9, r7
 801d754:	4648      	mov	r0, r9
 801d756:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801d75a:	bf00      	nop

0801d75c <iswspace>:
 801d75c:	28ff      	cmp	r0, #255	; 0xff
 801d75e:	d901      	bls.n	801d764 <iswspace+0x8>
 801d760:	2000      	movs	r0, #0
 801d762:	4770      	bx	lr
 801d764:	b510      	push	{r4, lr}
 801d766:	4604      	mov	r4, r0
 801d768:	f7fd f9f6 	bl	801ab58 <__locale_ctype_ptr>
 801d76c:	4420      	add	r0, r4
 801d76e:	7840      	ldrb	r0, [r0, #1]
 801d770:	f000 0008 	and.w	r0, r0, #8
 801d774:	bd10      	pop	{r4, pc}
 801d776:	bf00      	nop

0801d778 <_mbrtowc_r>:
 801d778:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d77a:	b083      	sub	sp, #12
 801d77c:	4607      	mov	r7, r0
 801d77e:	9d08      	ldr	r5, [sp, #32]
 801d780:	b192      	cbz	r2, 801d7a8 <_mbrtowc_r+0x30>
 801d782:	4c11      	ldr	r4, [pc, #68]	; (801d7c8 <_mbrtowc_r+0x50>)
 801d784:	4e11      	ldr	r6, [pc, #68]	; (801d7cc <_mbrtowc_r+0x54>)
 801d786:	6824      	ldr	r4, [r4, #0]
 801d788:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801d78a:	9500      	str	r5, [sp, #0]
 801d78c:	2c00      	cmp	r4, #0
 801d78e:	bf08      	it	eq
 801d790:	4634      	moveq	r4, r6
 801d792:	f8d4 40e4 	ldr.w	r4, [r4, #228]	; 0xe4
 801d796:	47a0      	blx	r4
 801d798:	1c43      	adds	r3, r0, #1
 801d79a:	d103      	bne.n	801d7a4 <_mbrtowc_r+0x2c>
 801d79c:	2200      	movs	r2, #0
 801d79e:	238a      	movs	r3, #138	; 0x8a
 801d7a0:	602a      	str	r2, [r5, #0]
 801d7a2:	603b      	str	r3, [r7, #0]
 801d7a4:	b003      	add	sp, #12
 801d7a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d7a8:	4b07      	ldr	r3, [pc, #28]	; (801d7c8 <_mbrtowc_r+0x50>)
 801d7aa:	4908      	ldr	r1, [pc, #32]	; (801d7cc <_mbrtowc_r+0x54>)
 801d7ac:	681b      	ldr	r3, [r3, #0]
 801d7ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d7b0:	9500      	str	r5, [sp, #0]
 801d7b2:	2b00      	cmp	r3, #0
 801d7b4:	bf08      	it	eq
 801d7b6:	460b      	moveq	r3, r1
 801d7b8:	4614      	mov	r4, r2
 801d7ba:	4621      	mov	r1, r4
 801d7bc:	4a04      	ldr	r2, [pc, #16]	; (801d7d0 <_mbrtowc_r+0x58>)
 801d7be:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
 801d7c2:	2301      	movs	r3, #1
 801d7c4:	47a0      	blx	r4
 801d7c6:	e7e7      	b.n	801d798 <_mbrtowc_r+0x20>
 801d7c8:	20004474 	.word	0x20004474
 801d7cc:	200048a0 	.word	0x200048a0
 801d7d0:	08023558 	.word	0x08023558

0801d7d4 <memset>:
 801d7d4:	b470      	push	{r4, r5, r6}
 801d7d6:	0786      	lsls	r6, r0, #30
 801d7d8:	d046      	beq.n	801d868 <memset+0x94>
 801d7da:	1e54      	subs	r4, r2, #1
 801d7dc:	2a00      	cmp	r2, #0
 801d7de:	d041      	beq.n	801d864 <memset+0x90>
 801d7e0:	b2ca      	uxtb	r2, r1
 801d7e2:	4603      	mov	r3, r0
 801d7e4:	e002      	b.n	801d7ec <memset+0x18>
 801d7e6:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 801d7ea:	d33b      	bcc.n	801d864 <memset+0x90>
 801d7ec:	f803 2b01 	strb.w	r2, [r3], #1
 801d7f0:	079d      	lsls	r5, r3, #30
 801d7f2:	d1f8      	bne.n	801d7e6 <memset+0x12>
 801d7f4:	2c03      	cmp	r4, #3
 801d7f6:	d92e      	bls.n	801d856 <memset+0x82>
 801d7f8:	b2cd      	uxtb	r5, r1
 801d7fa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 801d7fe:	2c0f      	cmp	r4, #15
 801d800:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 801d804:	d919      	bls.n	801d83a <memset+0x66>
 801d806:	f103 0210 	add.w	r2, r3, #16
 801d80a:	4626      	mov	r6, r4
 801d80c:	3e10      	subs	r6, #16
 801d80e:	2e0f      	cmp	r6, #15
 801d810:	f842 5c10 	str.w	r5, [r2, #-16]
 801d814:	f842 5c0c 	str.w	r5, [r2, #-12]
 801d818:	f842 5c08 	str.w	r5, [r2, #-8]
 801d81c:	f842 5c04 	str.w	r5, [r2, #-4]
 801d820:	f102 0210 	add.w	r2, r2, #16
 801d824:	d8f2      	bhi.n	801d80c <memset+0x38>
 801d826:	f1a4 0210 	sub.w	r2, r4, #16
 801d82a:	f022 020f 	bic.w	r2, r2, #15
 801d82e:	f004 040f 	and.w	r4, r4, #15
 801d832:	3210      	adds	r2, #16
 801d834:	2c03      	cmp	r4, #3
 801d836:	4413      	add	r3, r2
 801d838:	d90d      	bls.n	801d856 <memset+0x82>
 801d83a:	461e      	mov	r6, r3
 801d83c:	4622      	mov	r2, r4
 801d83e:	3a04      	subs	r2, #4
 801d840:	2a03      	cmp	r2, #3
 801d842:	f846 5b04 	str.w	r5, [r6], #4
 801d846:	d8fa      	bhi.n	801d83e <memset+0x6a>
 801d848:	1f22      	subs	r2, r4, #4
 801d84a:	f022 0203 	bic.w	r2, r2, #3
 801d84e:	3204      	adds	r2, #4
 801d850:	4413      	add	r3, r2
 801d852:	f004 0403 	and.w	r4, r4, #3
 801d856:	b12c      	cbz	r4, 801d864 <memset+0x90>
 801d858:	b2c9      	uxtb	r1, r1
 801d85a:	441c      	add	r4, r3
 801d85c:	f803 1b01 	strb.w	r1, [r3], #1
 801d860:	429c      	cmp	r4, r3
 801d862:	d1fb      	bne.n	801d85c <memset+0x88>
 801d864:	bc70      	pop	{r4, r5, r6}
 801d866:	4770      	bx	lr
 801d868:	4614      	mov	r4, r2
 801d86a:	4603      	mov	r3, r0
 801d86c:	e7c2      	b.n	801d7f4 <memset+0x20>
 801d86e:	bf00      	nop

0801d870 <_realloc_r>:
 801d870:	2900      	cmp	r1, #0
 801d872:	f000 8095 	beq.w	801d9a0 <_realloc_r+0x130>
 801d876:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d87a:	460d      	mov	r5, r1
 801d87c:	4616      	mov	r6, r2
 801d87e:	b083      	sub	sp, #12
 801d880:	4680      	mov	r8, r0
 801d882:	f106 070b 	add.w	r7, r6, #11
 801d886:	f7fe fcfb 	bl	801c280 <__malloc_lock>
 801d88a:	f855 ec04 	ldr.w	lr, [r5, #-4]
 801d88e:	2f16      	cmp	r7, #22
 801d890:	f02e 0403 	bic.w	r4, lr, #3
 801d894:	f1a5 0908 	sub.w	r9, r5, #8
 801d898:	d83c      	bhi.n	801d914 <_realloc_r+0xa4>
 801d89a:	2210      	movs	r2, #16
 801d89c:	4617      	mov	r7, r2
 801d89e:	42be      	cmp	r6, r7
 801d8a0:	d83d      	bhi.n	801d91e <_realloc_r+0xae>
 801d8a2:	4294      	cmp	r4, r2
 801d8a4:	da43      	bge.n	801d92e <_realloc_r+0xbe>
 801d8a6:	4bc4      	ldr	r3, [pc, #784]	; (801dbb8 <_realloc_r+0x348>)
 801d8a8:	6899      	ldr	r1, [r3, #8]
 801d8aa:	eb09 0004 	add.w	r0, r9, r4
 801d8ae:	4288      	cmp	r0, r1
 801d8b0:	f000 80b4 	beq.w	801da1c <_realloc_r+0x1ac>
 801d8b4:	6843      	ldr	r3, [r0, #4]
 801d8b6:	f023 0101 	bic.w	r1, r3, #1
 801d8ba:	4401      	add	r1, r0
 801d8bc:	6849      	ldr	r1, [r1, #4]
 801d8be:	07c9      	lsls	r1, r1, #31
 801d8c0:	d54c      	bpl.n	801d95c <_realloc_r+0xec>
 801d8c2:	f01e 0f01 	tst.w	lr, #1
 801d8c6:	f000 809b 	beq.w	801da00 <_realloc_r+0x190>
 801d8ca:	4631      	mov	r1, r6
 801d8cc:	4640      	mov	r0, r8
 801d8ce:	f7fe fa27 	bl	801bd20 <_malloc_r>
 801d8d2:	4606      	mov	r6, r0
 801d8d4:	2800      	cmp	r0, #0
 801d8d6:	d03a      	beq.n	801d94e <_realloc_r+0xde>
 801d8d8:	f855 3c04 	ldr.w	r3, [r5, #-4]
 801d8dc:	f023 0301 	bic.w	r3, r3, #1
 801d8e0:	444b      	add	r3, r9
 801d8e2:	f1a0 0208 	sub.w	r2, r0, #8
 801d8e6:	429a      	cmp	r2, r3
 801d8e8:	f000 8121 	beq.w	801db2e <_realloc_r+0x2be>
 801d8ec:	1f22      	subs	r2, r4, #4
 801d8ee:	2a24      	cmp	r2, #36	; 0x24
 801d8f0:	f200 8107 	bhi.w	801db02 <_realloc_r+0x292>
 801d8f4:	2a13      	cmp	r2, #19
 801d8f6:	f200 80db 	bhi.w	801dab0 <_realloc_r+0x240>
 801d8fa:	4603      	mov	r3, r0
 801d8fc:	462a      	mov	r2, r5
 801d8fe:	6811      	ldr	r1, [r2, #0]
 801d900:	6019      	str	r1, [r3, #0]
 801d902:	6851      	ldr	r1, [r2, #4]
 801d904:	6059      	str	r1, [r3, #4]
 801d906:	6892      	ldr	r2, [r2, #8]
 801d908:	609a      	str	r2, [r3, #8]
 801d90a:	4629      	mov	r1, r5
 801d90c:	4640      	mov	r0, r8
 801d90e:	f7ff fe15 	bl	801d53c <_free_r>
 801d912:	e01c      	b.n	801d94e <_realloc_r+0xde>
 801d914:	f027 0707 	bic.w	r7, r7, #7
 801d918:	2f00      	cmp	r7, #0
 801d91a:	463a      	mov	r2, r7
 801d91c:	dabf      	bge.n	801d89e <_realloc_r+0x2e>
 801d91e:	2600      	movs	r6, #0
 801d920:	230c      	movs	r3, #12
 801d922:	4630      	mov	r0, r6
 801d924:	f8c8 3000 	str.w	r3, [r8]
 801d928:	b003      	add	sp, #12
 801d92a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d92e:	462e      	mov	r6, r5
 801d930:	1be3      	subs	r3, r4, r7
 801d932:	2b0f      	cmp	r3, #15
 801d934:	d81e      	bhi.n	801d974 <_realloc_r+0x104>
 801d936:	f8d9 3004 	ldr.w	r3, [r9, #4]
 801d93a:	f003 0301 	and.w	r3, r3, #1
 801d93e:	4323      	orrs	r3, r4
 801d940:	444c      	add	r4, r9
 801d942:	f8c9 3004 	str.w	r3, [r9, #4]
 801d946:	6863      	ldr	r3, [r4, #4]
 801d948:	f043 0301 	orr.w	r3, r3, #1
 801d94c:	6063      	str	r3, [r4, #4]
 801d94e:	4640      	mov	r0, r8
 801d950:	f7fe fc9c 	bl	801c28c <__malloc_unlock>
 801d954:	4630      	mov	r0, r6
 801d956:	b003      	add	sp, #12
 801d958:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d95c:	f023 0303 	bic.w	r3, r3, #3
 801d960:	18e1      	adds	r1, r4, r3
 801d962:	4291      	cmp	r1, r2
 801d964:	db1f      	blt.n	801d9a6 <_realloc_r+0x136>
 801d966:	68c3      	ldr	r3, [r0, #12]
 801d968:	6882      	ldr	r2, [r0, #8]
 801d96a:	462e      	mov	r6, r5
 801d96c:	60d3      	str	r3, [r2, #12]
 801d96e:	460c      	mov	r4, r1
 801d970:	609a      	str	r2, [r3, #8]
 801d972:	e7dd      	b.n	801d930 <_realloc_r+0xc0>
 801d974:	f8d9 2004 	ldr.w	r2, [r9, #4]
 801d978:	eb09 0107 	add.w	r1, r9, r7
 801d97c:	f002 0201 	and.w	r2, r2, #1
 801d980:	444c      	add	r4, r9
 801d982:	f043 0301 	orr.w	r3, r3, #1
 801d986:	4317      	orrs	r7, r2
 801d988:	f8c9 7004 	str.w	r7, [r9, #4]
 801d98c:	604b      	str	r3, [r1, #4]
 801d98e:	6863      	ldr	r3, [r4, #4]
 801d990:	f043 0301 	orr.w	r3, r3, #1
 801d994:	3108      	adds	r1, #8
 801d996:	6063      	str	r3, [r4, #4]
 801d998:	4640      	mov	r0, r8
 801d99a:	f7ff fdcf 	bl	801d53c <_free_r>
 801d99e:	e7d6      	b.n	801d94e <_realloc_r+0xde>
 801d9a0:	4611      	mov	r1, r2
 801d9a2:	f7fe b9bd 	b.w	801bd20 <_malloc_r>
 801d9a6:	f01e 0f01 	tst.w	lr, #1
 801d9aa:	d18e      	bne.n	801d8ca <_realloc_r+0x5a>
 801d9ac:	f855 1c08 	ldr.w	r1, [r5, #-8]
 801d9b0:	eba9 0a01 	sub.w	sl, r9, r1
 801d9b4:	f8da 1004 	ldr.w	r1, [sl, #4]
 801d9b8:	f021 0103 	bic.w	r1, r1, #3
 801d9bc:	440b      	add	r3, r1
 801d9be:	4423      	add	r3, r4
 801d9c0:	4293      	cmp	r3, r2
 801d9c2:	db25      	blt.n	801da10 <_realloc_r+0x1a0>
 801d9c4:	68c2      	ldr	r2, [r0, #12]
 801d9c6:	6881      	ldr	r1, [r0, #8]
 801d9c8:	4656      	mov	r6, sl
 801d9ca:	60ca      	str	r2, [r1, #12]
 801d9cc:	6091      	str	r1, [r2, #8]
 801d9ce:	f8da 100c 	ldr.w	r1, [sl, #12]
 801d9d2:	f856 0f08 	ldr.w	r0, [r6, #8]!
 801d9d6:	1f22      	subs	r2, r4, #4
 801d9d8:	2a24      	cmp	r2, #36	; 0x24
 801d9da:	60c1      	str	r1, [r0, #12]
 801d9dc:	6088      	str	r0, [r1, #8]
 801d9de:	f200 8094 	bhi.w	801db0a <_realloc_r+0x29a>
 801d9e2:	2a13      	cmp	r2, #19
 801d9e4:	d96f      	bls.n	801dac6 <_realloc_r+0x256>
 801d9e6:	6829      	ldr	r1, [r5, #0]
 801d9e8:	f8ca 1008 	str.w	r1, [sl, #8]
 801d9ec:	6869      	ldr	r1, [r5, #4]
 801d9ee:	f8ca 100c 	str.w	r1, [sl, #12]
 801d9f2:	2a1b      	cmp	r2, #27
 801d9f4:	f200 80a2 	bhi.w	801db3c <_realloc_r+0x2cc>
 801d9f8:	3508      	adds	r5, #8
 801d9fa:	f10a 0210 	add.w	r2, sl, #16
 801d9fe:	e063      	b.n	801dac8 <_realloc_r+0x258>
 801da00:	f855 3c08 	ldr.w	r3, [r5, #-8]
 801da04:	eba9 0a03 	sub.w	sl, r9, r3
 801da08:	f8da 1004 	ldr.w	r1, [sl, #4]
 801da0c:	f021 0103 	bic.w	r1, r1, #3
 801da10:	1863      	adds	r3, r4, r1
 801da12:	4293      	cmp	r3, r2
 801da14:	f6ff af59 	blt.w	801d8ca <_realloc_r+0x5a>
 801da18:	4656      	mov	r6, sl
 801da1a:	e7d8      	b.n	801d9ce <_realloc_r+0x15e>
 801da1c:	6841      	ldr	r1, [r0, #4]
 801da1e:	f021 0b03 	bic.w	fp, r1, #3
 801da22:	44a3      	add	fp, r4
 801da24:	f107 0010 	add.w	r0, r7, #16
 801da28:	4583      	cmp	fp, r0
 801da2a:	da56      	bge.n	801dada <_realloc_r+0x26a>
 801da2c:	f01e 0f01 	tst.w	lr, #1
 801da30:	f47f af4b 	bne.w	801d8ca <_realloc_r+0x5a>
 801da34:	f855 1c08 	ldr.w	r1, [r5, #-8]
 801da38:	eba9 0a01 	sub.w	sl, r9, r1
 801da3c:	f8da 1004 	ldr.w	r1, [sl, #4]
 801da40:	f021 0103 	bic.w	r1, r1, #3
 801da44:	448b      	add	fp, r1
 801da46:	4558      	cmp	r0, fp
 801da48:	dce2      	bgt.n	801da10 <_realloc_r+0x1a0>
 801da4a:	4656      	mov	r6, sl
 801da4c:	f8da 100c 	ldr.w	r1, [sl, #12]
 801da50:	f856 0f08 	ldr.w	r0, [r6, #8]!
 801da54:	1f22      	subs	r2, r4, #4
 801da56:	2a24      	cmp	r2, #36	; 0x24
 801da58:	60c1      	str	r1, [r0, #12]
 801da5a:	6088      	str	r0, [r1, #8]
 801da5c:	f200 808f 	bhi.w	801db7e <_realloc_r+0x30e>
 801da60:	2a13      	cmp	r2, #19
 801da62:	f240 808a 	bls.w	801db7a <_realloc_r+0x30a>
 801da66:	6829      	ldr	r1, [r5, #0]
 801da68:	f8ca 1008 	str.w	r1, [sl, #8]
 801da6c:	6869      	ldr	r1, [r5, #4]
 801da6e:	f8ca 100c 	str.w	r1, [sl, #12]
 801da72:	2a1b      	cmp	r2, #27
 801da74:	f200 808a 	bhi.w	801db8c <_realloc_r+0x31c>
 801da78:	3508      	adds	r5, #8
 801da7a:	f10a 0210 	add.w	r2, sl, #16
 801da7e:	6829      	ldr	r1, [r5, #0]
 801da80:	6011      	str	r1, [r2, #0]
 801da82:	6869      	ldr	r1, [r5, #4]
 801da84:	6051      	str	r1, [r2, #4]
 801da86:	68a9      	ldr	r1, [r5, #8]
 801da88:	6091      	str	r1, [r2, #8]
 801da8a:	eb0a 0107 	add.w	r1, sl, r7
 801da8e:	ebab 0207 	sub.w	r2, fp, r7
 801da92:	f042 0201 	orr.w	r2, r2, #1
 801da96:	6099      	str	r1, [r3, #8]
 801da98:	604a      	str	r2, [r1, #4]
 801da9a:	f8da 3004 	ldr.w	r3, [sl, #4]
 801da9e:	f003 0301 	and.w	r3, r3, #1
 801daa2:	431f      	orrs	r7, r3
 801daa4:	4640      	mov	r0, r8
 801daa6:	f8ca 7004 	str.w	r7, [sl, #4]
 801daaa:	f7fe fbef 	bl	801c28c <__malloc_unlock>
 801daae:	e751      	b.n	801d954 <_realloc_r+0xe4>
 801dab0:	682b      	ldr	r3, [r5, #0]
 801dab2:	6003      	str	r3, [r0, #0]
 801dab4:	686b      	ldr	r3, [r5, #4]
 801dab6:	6043      	str	r3, [r0, #4]
 801dab8:	2a1b      	cmp	r2, #27
 801daba:	d82d      	bhi.n	801db18 <_realloc_r+0x2a8>
 801dabc:	f100 0308 	add.w	r3, r0, #8
 801dac0:	f105 0208 	add.w	r2, r5, #8
 801dac4:	e71b      	b.n	801d8fe <_realloc_r+0x8e>
 801dac6:	4632      	mov	r2, r6
 801dac8:	6829      	ldr	r1, [r5, #0]
 801daca:	6011      	str	r1, [r2, #0]
 801dacc:	6869      	ldr	r1, [r5, #4]
 801dace:	6051      	str	r1, [r2, #4]
 801dad0:	68a9      	ldr	r1, [r5, #8]
 801dad2:	6091      	str	r1, [r2, #8]
 801dad4:	461c      	mov	r4, r3
 801dad6:	46d1      	mov	r9, sl
 801dad8:	e72a      	b.n	801d930 <_realloc_r+0xc0>
 801dada:	eb09 0107 	add.w	r1, r9, r7
 801dade:	ebab 0b07 	sub.w	fp, fp, r7
 801dae2:	f04b 0201 	orr.w	r2, fp, #1
 801dae6:	6099      	str	r1, [r3, #8]
 801dae8:	604a      	str	r2, [r1, #4]
 801daea:	f855 3c04 	ldr.w	r3, [r5, #-4]
 801daee:	f003 0301 	and.w	r3, r3, #1
 801daf2:	431f      	orrs	r7, r3
 801daf4:	4640      	mov	r0, r8
 801daf6:	f845 7c04 	str.w	r7, [r5, #-4]
 801dafa:	f7fe fbc7 	bl	801c28c <__malloc_unlock>
 801dafe:	462e      	mov	r6, r5
 801db00:	e728      	b.n	801d954 <_realloc_r+0xe4>
 801db02:	4629      	mov	r1, r5
 801db04:	f000 fac6 	bl	801e094 <memmove>
 801db08:	e6ff      	b.n	801d90a <_realloc_r+0x9a>
 801db0a:	4629      	mov	r1, r5
 801db0c:	4630      	mov	r0, r6
 801db0e:	461c      	mov	r4, r3
 801db10:	46d1      	mov	r9, sl
 801db12:	f000 fabf 	bl	801e094 <memmove>
 801db16:	e70b      	b.n	801d930 <_realloc_r+0xc0>
 801db18:	68ab      	ldr	r3, [r5, #8]
 801db1a:	6083      	str	r3, [r0, #8]
 801db1c:	68eb      	ldr	r3, [r5, #12]
 801db1e:	60c3      	str	r3, [r0, #12]
 801db20:	2a24      	cmp	r2, #36	; 0x24
 801db22:	d017      	beq.n	801db54 <_realloc_r+0x2e4>
 801db24:	f100 0310 	add.w	r3, r0, #16
 801db28:	f105 0210 	add.w	r2, r5, #16
 801db2c:	e6e7      	b.n	801d8fe <_realloc_r+0x8e>
 801db2e:	f850 3c04 	ldr.w	r3, [r0, #-4]
 801db32:	f023 0303 	bic.w	r3, r3, #3
 801db36:	441c      	add	r4, r3
 801db38:	462e      	mov	r6, r5
 801db3a:	e6f9      	b.n	801d930 <_realloc_r+0xc0>
 801db3c:	68a9      	ldr	r1, [r5, #8]
 801db3e:	f8ca 1010 	str.w	r1, [sl, #16]
 801db42:	68e9      	ldr	r1, [r5, #12]
 801db44:	f8ca 1014 	str.w	r1, [sl, #20]
 801db48:	2a24      	cmp	r2, #36	; 0x24
 801db4a:	d00c      	beq.n	801db66 <_realloc_r+0x2f6>
 801db4c:	3510      	adds	r5, #16
 801db4e:	f10a 0218 	add.w	r2, sl, #24
 801db52:	e7b9      	b.n	801dac8 <_realloc_r+0x258>
 801db54:	692b      	ldr	r3, [r5, #16]
 801db56:	6103      	str	r3, [r0, #16]
 801db58:	696b      	ldr	r3, [r5, #20]
 801db5a:	6143      	str	r3, [r0, #20]
 801db5c:	f105 0218 	add.w	r2, r5, #24
 801db60:	f100 0318 	add.w	r3, r0, #24
 801db64:	e6cb      	b.n	801d8fe <_realloc_r+0x8e>
 801db66:	692a      	ldr	r2, [r5, #16]
 801db68:	f8ca 2018 	str.w	r2, [sl, #24]
 801db6c:	696a      	ldr	r2, [r5, #20]
 801db6e:	f8ca 201c 	str.w	r2, [sl, #28]
 801db72:	3518      	adds	r5, #24
 801db74:	f10a 0220 	add.w	r2, sl, #32
 801db78:	e7a6      	b.n	801dac8 <_realloc_r+0x258>
 801db7a:	4632      	mov	r2, r6
 801db7c:	e77f      	b.n	801da7e <_realloc_r+0x20e>
 801db7e:	4629      	mov	r1, r5
 801db80:	4630      	mov	r0, r6
 801db82:	9301      	str	r3, [sp, #4]
 801db84:	f000 fa86 	bl	801e094 <memmove>
 801db88:	9b01      	ldr	r3, [sp, #4]
 801db8a:	e77e      	b.n	801da8a <_realloc_r+0x21a>
 801db8c:	68a9      	ldr	r1, [r5, #8]
 801db8e:	f8ca 1010 	str.w	r1, [sl, #16]
 801db92:	68e9      	ldr	r1, [r5, #12]
 801db94:	f8ca 1014 	str.w	r1, [sl, #20]
 801db98:	2a24      	cmp	r2, #36	; 0x24
 801db9a:	d003      	beq.n	801dba4 <_realloc_r+0x334>
 801db9c:	3510      	adds	r5, #16
 801db9e:	f10a 0218 	add.w	r2, sl, #24
 801dba2:	e76c      	b.n	801da7e <_realloc_r+0x20e>
 801dba4:	692a      	ldr	r2, [r5, #16]
 801dba6:	f8ca 2018 	str.w	r2, [sl, #24]
 801dbaa:	696a      	ldr	r2, [r5, #20]
 801dbac:	f8ca 201c 	str.w	r2, [sl, #28]
 801dbb0:	3518      	adds	r5, #24
 801dbb2:	f10a 0220 	add.w	r2, sl, #32
 801dbb6:	e762      	b.n	801da7e <_realloc_r+0x20e>
 801dbb8:	20004a54 	.word	0x20004a54

0801dbbc <__sccl>:
 801dbbc:	b470      	push	{r4, r5, r6}
 801dbbe:	780c      	ldrb	r4, [r1, #0]
 801dbc0:	2c5e      	cmp	r4, #94	; 0x5e
 801dbc2:	d02f      	beq.n	801dc24 <__sccl+0x68>
 801dbc4:	2200      	movs	r2, #0
 801dbc6:	1c4d      	adds	r5, r1, #1
 801dbc8:	4616      	mov	r6, r2
 801dbca:	1e43      	subs	r3, r0, #1
 801dbcc:	f100 01ff 	add.w	r1, r0, #255	; 0xff
 801dbd0:	f803 2f01 	strb.w	r2, [r3, #1]!
 801dbd4:	428b      	cmp	r3, r1
 801dbd6:	d1fb      	bne.n	801dbd0 <__sccl+0x14>
 801dbd8:	b174      	cbz	r4, 801dbf8 <__sccl+0x3c>
 801dbda:	f086 0201 	eor.w	r2, r6, #1
 801dbde:	5502      	strb	r2, [r0, r4]
 801dbe0:	1c6e      	adds	r6, r5, #1
 801dbe2:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 801dbe6:	2b2d      	cmp	r3, #45	; 0x2d
 801dbe8:	4631      	mov	r1, r6
 801dbea:	d00d      	beq.n	801dc08 <__sccl+0x4c>
 801dbec:	2b5d      	cmp	r3, #93	; 0x5d
 801dbee:	d004      	beq.n	801dbfa <__sccl+0x3e>
 801dbf0:	b133      	cbz	r3, 801dc00 <__sccl+0x44>
 801dbf2:	461c      	mov	r4, r3
 801dbf4:	4635      	mov	r5, r6
 801dbf6:	e7f2      	b.n	801dbde <__sccl+0x22>
 801dbf8:	1e69      	subs	r1, r5, #1
 801dbfa:	4608      	mov	r0, r1
 801dbfc:	bc70      	pop	{r4, r5, r6}
 801dbfe:	4770      	bx	lr
 801dc00:	4629      	mov	r1, r5
 801dc02:	4608      	mov	r0, r1
 801dc04:	bc70      	pop	{r4, r5, r6}
 801dc06:	4770      	bx	lr
 801dc08:	7869      	ldrb	r1, [r5, #1]
 801dc0a:	295d      	cmp	r1, #93	; 0x5d
 801dc0c:	d0f1      	beq.n	801dbf2 <__sccl+0x36>
 801dc0e:	428c      	cmp	r4, r1
 801dc10:	dcef      	bgt.n	801dbf2 <__sccl+0x36>
 801dc12:	3502      	adds	r5, #2
 801dc14:	1903      	adds	r3, r0, r4
 801dc16:	3401      	adds	r4, #1
 801dc18:	42a1      	cmp	r1, r4
 801dc1a:	f803 2f01 	strb.w	r2, [r3, #1]!
 801dc1e:	dcfa      	bgt.n	801dc16 <__sccl+0x5a>
 801dc20:	3602      	adds	r6, #2
 801dc22:	e7de      	b.n	801dbe2 <__sccl+0x26>
 801dc24:	2201      	movs	r2, #1
 801dc26:	784c      	ldrb	r4, [r1, #1]
 801dc28:	4616      	mov	r6, r2
 801dc2a:	1c8d      	adds	r5, r1, #2
 801dc2c:	e7cd      	b.n	801dbca <__sccl+0xe>
 801dc2e:	bf00      	nop

0801dc30 <_strtoll_l.isra.0>:
 801dc30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dc34:	b085      	sub	sp, #20
 801dc36:	461e      	mov	r6, r3
 801dc38:	9102      	str	r1, [sp, #8]
 801dc3a:	9003      	str	r0, [sp, #12]
 801dc3c:	9200      	str	r2, [sp, #0]
 801dc3e:	4688      	mov	r8, r1
 801dc40:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 801dc42:	e000      	b.n	801dc46 <_strtoll_l.isra.0+0x16>
 801dc44:	46a8      	mov	r8, r5
 801dc46:	4645      	mov	r5, r8
 801dc48:	4638      	mov	r0, r7
 801dc4a:	f815 4b01 	ldrb.w	r4, [r5], #1
 801dc4e:	f7fc ff7f 	bl	801ab50 <__locale_ctype_ptr_l>
 801dc52:	4420      	add	r0, r4
 801dc54:	7843      	ldrb	r3, [r0, #1]
 801dc56:	f013 0308 	ands.w	r3, r3, #8
 801dc5a:	d1f3      	bne.n	801dc44 <_strtoll_l.isra.0+0x14>
 801dc5c:	2c2d      	cmp	r4, #45	; 0x2d
 801dc5e:	f000 8081 	beq.w	801dd64 <_strtoll_l.isra.0+0x134>
 801dc62:	2c2b      	cmp	r4, #43	; 0x2b
 801dc64:	bf03      	ittte	eq
 801dc66:	782c      	ldrbeq	r4, [r5, #0]
 801dc68:	9301      	streq	r3, [sp, #4]
 801dc6a:	f108 0502 	addeq.w	r5, r8, #2
 801dc6e:	9301      	strne	r3, [sp, #4]
 801dc70:	b166      	cbz	r6, 801dc8c <_strtoll_l.isra.0+0x5c>
 801dc72:	2e10      	cmp	r6, #16
 801dc74:	f000 8088 	beq.w	801dd88 <_strtoll_l.isra.0+0x158>
 801dc78:	9b01      	ldr	r3, [sp, #4]
 801dc7a:	46b0      	mov	r8, r6
 801dc7c:	ea4f 79e6 	mov.w	r9, r6, asr #31
 801dc80:	b97b      	cbnz	r3, 801dca2 <_strtoll_l.isra.0+0x72>
 801dc82:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 801dc86:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
 801dc8a:	e00e      	b.n	801dcaa <_strtoll_l.isra.0+0x7a>
 801dc8c:	2c30      	cmp	r4, #48	; 0x30
 801dc8e:	f000 808a 	beq.w	801dda6 <_strtoll_l.isra.0+0x176>
 801dc92:	f04f 080a 	mov.w	r8, #10
 801dc96:	f04f 0900 	mov.w	r9, #0
 801dc9a:	260a      	movs	r6, #10
 801dc9c:	9b01      	ldr	r3, [sp, #4]
 801dc9e:	2b00      	cmp	r3, #0
 801dca0:	d0ef      	beq.n	801dc82 <_strtoll_l.isra.0+0x52>
 801dca2:	f04f 0a00 	mov.w	sl, #0
 801dca6:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 801dcaa:	4642      	mov	r2, r8
 801dcac:	464b      	mov	r3, r9
 801dcae:	4650      	mov	r0, sl
 801dcb0:	4639      	mov	r1, r7
 801dcb2:	f7e6 fdcd 	bl	8004850 <__aeabi_uldivmod>
 801dcb6:	464b      	mov	r3, r9
 801dcb8:	4693      	mov	fp, r2
 801dcba:	4650      	mov	r0, sl
 801dcbc:	4642      	mov	r2, r8
 801dcbe:	4639      	mov	r1, r7
 801dcc0:	f7e6 fdc6 	bl	8004850 <__aeabi_uldivmod>
 801dcc4:	f04f 0e00 	mov.w	lr, #0
 801dcc8:	2200      	movs	r2, #0
 801dcca:	2300      	movs	r3, #0
 801dccc:	e00f      	b.n	801dcee <_strtoll_l.isra.0+0xbe>
 801dcce:	d044      	beq.n	801dd5a <_strtoll_l.isra.0+0x12a>
 801dcd0:	fb02 f409 	mul.w	r4, r2, r9
 801dcd4:	fb08 4403 	mla	r4, r8, r3, r4
 801dcd8:	fba2 2308 	umull	r2, r3, r2, r8
 801dcdc:	4423      	add	r3, r4
 801dcde:	eb12 020c 	adds.w	r2, r2, ip
 801dce2:	eb43 73ec 	adc.w	r3, r3, ip, asr #31
 801dce6:	f04f 0e01 	mov.w	lr, #1
 801dcea:	f815 4b01 	ldrb.w	r4, [r5], #1
 801dcee:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
 801dcf2:	f1bc 0f09 	cmp.w	ip, #9
 801dcf6:	d906      	bls.n	801dd06 <_strtoll_l.isra.0+0xd6>
 801dcf8:	f1a4 0c41 	sub.w	ip, r4, #65	; 0x41
 801dcfc:	f1bc 0f19 	cmp.w	ip, #25
 801dd00:	d80d      	bhi.n	801dd1e <_strtoll_l.isra.0+0xee>
 801dd02:	f1a4 0c37 	sub.w	ip, r4, #55	; 0x37
 801dd06:	4566      	cmp	r6, ip
 801dd08:	dd12      	ble.n	801dd30 <_strtoll_l.isra.0+0x100>
 801dd0a:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
 801dd0e:	d0ec      	beq.n	801dcea <_strtoll_l.isra.0+0xba>
 801dd10:	4299      	cmp	r1, r3
 801dd12:	bf08      	it	eq
 801dd14:	4290      	cmpeq	r0, r2
 801dd16:	d2da      	bcs.n	801dcce <_strtoll_l.isra.0+0x9e>
 801dd18:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 801dd1c:	e7e5      	b.n	801dcea <_strtoll_l.isra.0+0xba>
 801dd1e:	f1a4 0c61 	sub.w	ip, r4, #97	; 0x61
 801dd22:	f1bc 0f19 	cmp.w	ip, #25
 801dd26:	d803      	bhi.n	801dd30 <_strtoll_l.isra.0+0x100>
 801dd28:	f1a4 0c57 	sub.w	ip, r4, #87	; 0x57
 801dd2c:	4566      	cmp	r6, ip
 801dd2e:	dcec      	bgt.n	801dd0a <_strtoll_l.isra.0+0xda>
 801dd30:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
 801dd34:	d01c      	beq.n	801dd70 <_strtoll_l.isra.0+0x140>
 801dd36:	9901      	ldr	r1, [sp, #4]
 801dd38:	b111      	cbz	r1, 801dd40 <_strtoll_l.isra.0+0x110>
 801dd3a:	4252      	negs	r2, r2
 801dd3c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801dd40:	9900      	ldr	r1, [sp, #0]
 801dd42:	b129      	cbz	r1, 801dd50 <_strtoll_l.isra.0+0x120>
 801dd44:	f1be 0f00 	cmp.w	lr, #0
 801dd48:	d11b      	bne.n	801dd82 <_strtoll_l.isra.0+0x152>
 801dd4a:	9d02      	ldr	r5, [sp, #8]
 801dd4c:	9900      	ldr	r1, [sp, #0]
 801dd4e:	600d      	str	r5, [r1, #0]
 801dd50:	4610      	mov	r0, r2
 801dd52:	4619      	mov	r1, r3
 801dd54:	b005      	add	sp, #20
 801dd56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801dd5a:	45e3      	cmp	fp, ip
 801dd5c:	dab8      	bge.n	801dcd0 <_strtoll_l.isra.0+0xa0>
 801dd5e:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 801dd62:	e7c2      	b.n	801dcea <_strtoll_l.isra.0+0xba>
 801dd64:	2301      	movs	r3, #1
 801dd66:	782c      	ldrb	r4, [r5, #0]
 801dd68:	9301      	str	r3, [sp, #4]
 801dd6a:	f108 0502 	add.w	r5, r8, #2
 801dd6e:	e77f      	b.n	801dc70 <_strtoll_l.isra.0+0x40>
 801dd70:	9a03      	ldr	r2, [sp, #12]
 801dd72:	2322      	movs	r3, #34	; 0x22
 801dd74:	6013      	str	r3, [r2, #0]
 801dd76:	9b00      	ldr	r3, [sp, #0]
 801dd78:	b32b      	cbz	r3, 801ddc6 <_strtoll_l.isra.0+0x196>
 801dd7a:	4652      	mov	r2, sl
 801dd7c:	463b      	mov	r3, r7
 801dd7e:	3d01      	subs	r5, #1
 801dd80:	e7e4      	b.n	801dd4c <_strtoll_l.isra.0+0x11c>
 801dd82:	4692      	mov	sl, r2
 801dd84:	461f      	mov	r7, r3
 801dd86:	e7f8      	b.n	801dd7a <_strtoll_l.isra.0+0x14a>
 801dd88:	2c30      	cmp	r4, #48	; 0x30
 801dd8a:	d117      	bne.n	801ddbc <_strtoll_l.isra.0+0x18c>
 801dd8c:	782b      	ldrb	r3, [r5, #0]
 801dd8e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801dd92:	2b58      	cmp	r3, #88	; 0x58
 801dd94:	d112      	bne.n	801ddbc <_strtoll_l.isra.0+0x18c>
 801dd96:	786c      	ldrb	r4, [r5, #1]
 801dd98:	f04f 0810 	mov.w	r8, #16
 801dd9c:	f04f 0900 	mov.w	r9, #0
 801dda0:	3502      	adds	r5, #2
 801dda2:	2610      	movs	r6, #16
 801dda4:	e77a      	b.n	801dc9c <_strtoll_l.isra.0+0x6c>
 801dda6:	782b      	ldrb	r3, [r5, #0]
 801dda8:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801ddac:	2b58      	cmp	r3, #88	; 0x58
 801ddae:	d0f2      	beq.n	801dd96 <_strtoll_l.isra.0+0x166>
 801ddb0:	f04f 0808 	mov.w	r8, #8
 801ddb4:	f04f 0900 	mov.w	r9, #0
 801ddb8:	2608      	movs	r6, #8
 801ddba:	e76f      	b.n	801dc9c <_strtoll_l.isra.0+0x6c>
 801ddbc:	f04f 0810 	mov.w	r8, #16
 801ddc0:	f04f 0900 	mov.w	r9, #0
 801ddc4:	e76a      	b.n	801dc9c <_strtoll_l.isra.0+0x6c>
 801ddc6:	4652      	mov	r2, sl
 801ddc8:	463b      	mov	r3, r7
 801ddca:	e7c1      	b.n	801dd50 <_strtoll_l.isra.0+0x120>

0801ddcc <_strtoll_r>:
 801ddcc:	b530      	push	{r4, r5, lr}
 801ddce:	4c06      	ldr	r4, [pc, #24]	; (801dde8 <_strtoll_r+0x1c>)
 801ddd0:	4d06      	ldr	r5, [pc, #24]	; (801ddec <_strtoll_r+0x20>)
 801ddd2:	6824      	ldr	r4, [r4, #0]
 801ddd4:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801ddd6:	b083      	sub	sp, #12
 801ddd8:	2c00      	cmp	r4, #0
 801ddda:	bf08      	it	eq
 801dddc:	462c      	moveq	r4, r5
 801ddde:	9400      	str	r4, [sp, #0]
 801dde0:	f7ff ff26 	bl	801dc30 <_strtoll_l.isra.0>
 801dde4:	b003      	add	sp, #12
 801dde6:	bd30      	pop	{r4, r5, pc}
 801dde8:	20004474 	.word	0x20004474
 801ddec:	200048a0 	.word	0x200048a0

0801ddf0 <_strtoull_l.isra.0>:
 801ddf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ddf4:	b085      	sub	sp, #20
 801ddf6:	4693      	mov	fp, r2
 801ddf8:	9102      	str	r1, [sp, #8]
 801ddfa:	9003      	str	r0, [sp, #12]
 801ddfc:	469a      	mov	sl, r3
 801ddfe:	460f      	mov	r7, r1
 801de00:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801de02:	e000      	b.n	801de06 <_strtoull_l.isra.0+0x16>
 801de04:	462f      	mov	r7, r5
 801de06:	463d      	mov	r5, r7
 801de08:	4630      	mov	r0, r6
 801de0a:	f815 4b01 	ldrb.w	r4, [r5], #1
 801de0e:	f7fc fe9f 	bl	801ab50 <__locale_ctype_ptr_l>
 801de12:	4420      	add	r0, r4
 801de14:	7843      	ldrb	r3, [r0, #1]
 801de16:	f013 0308 	ands.w	r3, r3, #8
 801de1a:	d1f3      	bne.n	801de04 <_strtoull_l.isra.0+0x14>
 801de1c:	2c2d      	cmp	r4, #45	; 0x2d
 801de1e:	f000 8089 	beq.w	801df34 <_strtoull_l.isra.0+0x144>
 801de22:	2c2b      	cmp	r4, #43	; 0x2b
 801de24:	bf03      	ittte	eq
 801de26:	782c      	ldrbeq	r4, [r5, #0]
 801de28:	9301      	streq	r3, [sp, #4]
 801de2a:	1cbd      	addeq	r5, r7, #2
 801de2c:	9301      	strne	r3, [sp, #4]
 801de2e:	f1ba 0f00 	cmp.w	sl, #0
 801de32:	d019      	beq.n	801de68 <_strtoull_l.isra.0+0x78>
 801de34:	f1ba 0f10 	cmp.w	sl, #16
 801de38:	f000 8081 	beq.w	801df3e <_strtoull_l.isra.0+0x14e>
 801de3c:	46d0      	mov	r8, sl
 801de3e:	ea4f 79ea 	mov.w	r9, sl, asr #31
 801de42:	4642      	mov	r2, r8
 801de44:	464b      	mov	r3, r9
 801de46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801de4a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801de4e:	f7e6 fcff 	bl	8004850 <__aeabi_uldivmod>
 801de52:	4642      	mov	r2, r8
 801de54:	4606      	mov	r6, r0
 801de56:	460f      	mov	r7, r1
 801de58:	464b      	mov	r3, r9
 801de5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801de5e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801de62:	f7e6 fcf5 	bl	8004850 <__aeabi_uldivmod>
 801de66:	e00b      	b.n	801de80 <_strtoull_l.isra.0+0x90>
 801de68:	2c30      	cmp	r4, #48	; 0x30
 801de6a:	d07d      	beq.n	801df68 <_strtoull_l.isra.0+0x178>
 801de6c:	4f4e      	ldr	r7, [pc, #312]	; (801dfa8 <_strtoull_l.isra.0+0x1b8>)
 801de6e:	2205      	movs	r2, #5
 801de70:	f04f 3699 	mov.w	r6, #2576980377	; 0x99999999
 801de74:	f04f 080a 	mov.w	r8, #10
 801de78:	f04f 0900 	mov.w	r9, #0
 801de7c:	f04f 0a0a 	mov.w	sl, #10
 801de80:	f04f 0e00 	mov.w	lr, #0
 801de84:	2000      	movs	r0, #0
 801de86:	2100      	movs	r1, #0
 801de88:	e011      	b.n	801deae <_strtoull_l.isra.0+0xbe>
 801de8a:	42b9      	cmp	r1, r7
 801de8c:	bf08      	it	eq
 801de8e:	42b0      	cmpeq	r0, r6
 801de90:	d03f      	beq.n	801df12 <_strtoull_l.isra.0+0x122>
 801de92:	fb00 f409 	mul.w	r4, r0, r9
 801de96:	fb08 4401 	mla	r4, r8, r1, r4
 801de9a:	fba0 0108 	umull	r0, r1, r0, r8
 801de9e:	4421      	add	r1, r4
 801dea0:	18c0      	adds	r0, r0, r3
 801dea2:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
 801dea6:	f04f 0e01 	mov.w	lr, #1
 801deaa:	f815 4b01 	ldrb.w	r4, [r5], #1
 801deae:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 801deb2:	2b09      	cmp	r3, #9
 801deb4:	d905      	bls.n	801dec2 <_strtoull_l.isra.0+0xd2>
 801deb6:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 801deba:	2b19      	cmp	r3, #25
 801debc:	d80d      	bhi.n	801deda <_strtoull_l.isra.0+0xea>
 801debe:	f1a4 0337 	sub.w	r3, r4, #55	; 0x37
 801dec2:	459a      	cmp	sl, r3
 801dec4:	dd11      	ble.n	801deea <_strtoull_l.isra.0+0xfa>
 801dec6:	f1be 0f00 	cmp.w	lr, #0
 801deca:	db03      	blt.n	801ded4 <_strtoull_l.isra.0+0xe4>
 801decc:	428f      	cmp	r7, r1
 801dece:	bf08      	it	eq
 801ded0:	4286      	cmpeq	r6, r0
 801ded2:	d2da      	bcs.n	801de8a <_strtoull_l.isra.0+0x9a>
 801ded4:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 801ded8:	e7e7      	b.n	801deaa <_strtoull_l.isra.0+0xba>
 801deda:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 801dede:	2b19      	cmp	r3, #25
 801dee0:	d803      	bhi.n	801deea <_strtoull_l.isra.0+0xfa>
 801dee2:	f1a4 0357 	sub.w	r3, r4, #87	; 0x57
 801dee6:	459a      	cmp	sl, r3
 801dee8:	dced      	bgt.n	801dec6 <_strtoull_l.isra.0+0xd6>
 801deea:	f1be 0f00 	cmp.w	lr, #0
 801deee:	db15      	blt.n	801df1c <_strtoull_l.isra.0+0x12c>
 801def0:	9b01      	ldr	r3, [sp, #4]
 801def2:	b113      	cbz	r3, 801defa <_strtoull_l.isra.0+0x10a>
 801def4:	4240      	negs	r0, r0
 801def6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801defa:	f1bb 0f00 	cmp.w	fp, #0
 801defe:	d005      	beq.n	801df0c <_strtoull_l.isra.0+0x11c>
 801df00:	f1be 0f00 	cmp.w	lr, #0
 801df04:	d114      	bne.n	801df30 <_strtoull_l.isra.0+0x140>
 801df06:	9d02      	ldr	r5, [sp, #8]
 801df08:	f8cb 5000 	str.w	r5, [fp]
 801df0c:	b005      	add	sp, #20
 801df0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801df12:	4293      	cmp	r3, r2
 801df14:	ddbd      	ble.n	801de92 <_strtoull_l.isra.0+0xa2>
 801df16:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 801df1a:	e7c6      	b.n	801deaa <_strtoull_l.isra.0+0xba>
 801df1c:	9a03      	ldr	r2, [sp, #12]
 801df1e:	2322      	movs	r3, #34	; 0x22
 801df20:	6013      	str	r3, [r2, #0]
 801df22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801df26:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801df2a:	f1bb 0f00 	cmp.w	fp, #0
 801df2e:	d0ed      	beq.n	801df0c <_strtoull_l.isra.0+0x11c>
 801df30:	3d01      	subs	r5, #1
 801df32:	e7e9      	b.n	801df08 <_strtoull_l.isra.0+0x118>
 801df34:	2301      	movs	r3, #1
 801df36:	782c      	ldrb	r4, [r5, #0]
 801df38:	9301      	str	r3, [sp, #4]
 801df3a:	1cbd      	adds	r5, r7, #2
 801df3c:	e777      	b.n	801de2e <_strtoull_l.isra.0+0x3e>
 801df3e:	2c30      	cmp	r4, #48	; 0x30
 801df40:	d123      	bne.n	801df8a <_strtoull_l.isra.0+0x19a>
 801df42:	782b      	ldrb	r3, [r5, #0]
 801df44:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801df48:	2b58      	cmp	r3, #88	; 0x58
 801df4a:	d128      	bne.n	801df9e <_strtoull_l.isra.0+0x1ae>
 801df4c:	786c      	ldrb	r4, [r5, #1]
 801df4e:	220f      	movs	r2, #15
 801df50:	3502      	adds	r5, #2
 801df52:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 801df56:	f06f 4770 	mvn.w	r7, #4026531840	; 0xf0000000
 801df5a:	f04f 0810 	mov.w	r8, #16
 801df5e:	f04f 0900 	mov.w	r9, #0
 801df62:	f04f 0a10 	mov.w	sl, #16
 801df66:	e78b      	b.n	801de80 <_strtoull_l.isra.0+0x90>
 801df68:	782b      	ldrb	r3, [r5, #0]
 801df6a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 801df6e:	2b58      	cmp	r3, #88	; 0x58
 801df70:	d0ec      	beq.n	801df4c <_strtoull_l.isra.0+0x15c>
 801df72:	2207      	movs	r2, #7
 801df74:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 801df78:	f06f 4760 	mvn.w	r7, #3758096384	; 0xe0000000
 801df7c:	f04f 0808 	mov.w	r8, #8
 801df80:	f04f 0900 	mov.w	r9, #0
 801df84:	f04f 0a08 	mov.w	sl, #8
 801df88:	e77a      	b.n	801de80 <_strtoull_l.isra.0+0x90>
 801df8a:	220f      	movs	r2, #15
 801df8c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 801df90:	f06f 4770 	mvn.w	r7, #4026531840	; 0xf0000000
 801df94:	f04f 0810 	mov.w	r8, #16
 801df98:	f04f 0900 	mov.w	r9, #0
 801df9c:	e770      	b.n	801de80 <_strtoull_l.isra.0+0x90>
 801df9e:	f04f 0810 	mov.w	r8, #16
 801dfa2:	f04f 0900 	mov.w	r9, #0
 801dfa6:	e74c      	b.n	801de42 <_strtoull_l.isra.0+0x52>
 801dfa8:	19999999 	.word	0x19999999

0801dfac <_strtoull_r>:
 801dfac:	b530      	push	{r4, r5, lr}
 801dfae:	4c06      	ldr	r4, [pc, #24]	; (801dfc8 <_strtoull_r+0x1c>)
 801dfb0:	4d06      	ldr	r5, [pc, #24]	; (801dfcc <_strtoull_r+0x20>)
 801dfb2:	6824      	ldr	r4, [r4, #0]
 801dfb4:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801dfb6:	b083      	sub	sp, #12
 801dfb8:	2c00      	cmp	r4, #0
 801dfba:	bf08      	it	eq
 801dfbc:	462c      	moveq	r4, r5
 801dfbe:	9400      	str	r4, [sp, #0]
 801dfc0:	f7ff ff16 	bl	801ddf0 <_strtoull_l.isra.0>
 801dfc4:	b003      	add	sp, #12
 801dfc6:	bd30      	pop	{r4, r5, pc}
 801dfc8:	20004474 	.word	0x20004474
 801dfcc:	200048a0 	.word	0x200048a0

0801dfd0 <_fclose_r>:
 801dfd0:	b570      	push	{r4, r5, r6, lr}
 801dfd2:	b159      	cbz	r1, 801dfec <_fclose_r+0x1c>
 801dfd4:	4605      	mov	r5, r0
 801dfd6:	460c      	mov	r4, r1
 801dfd8:	b110      	cbz	r0, 801dfe0 <_fclose_r+0x10>
 801dfda:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801dfdc:	2b00      	cmp	r3, #0
 801dfde:	d03c      	beq.n	801e05a <_fclose_r+0x8a>
 801dfe0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801dfe2:	07d8      	lsls	r0, r3, #31
 801dfe4:	d505      	bpl.n	801dff2 <_fclose_r+0x22>
 801dfe6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801dfea:	b92b      	cbnz	r3, 801dff8 <_fclose_r+0x28>
 801dfec:	2600      	movs	r6, #0
 801dfee:	4630      	mov	r0, r6
 801dff0:	bd70      	pop	{r4, r5, r6, pc}
 801dff2:	89a3      	ldrh	r3, [r4, #12]
 801dff4:	0599      	lsls	r1, r3, #22
 801dff6:	d53c      	bpl.n	801e072 <_fclose_r+0xa2>
 801dff8:	4621      	mov	r1, r4
 801dffa:	4628      	mov	r0, r5
 801dffc:	f7ff f91e 	bl	801d23c <__sflush_r>
 801e000:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801e002:	4606      	mov	r6, r0
 801e004:	b133      	cbz	r3, 801e014 <_fclose_r+0x44>
 801e006:	69e1      	ldr	r1, [r4, #28]
 801e008:	4628      	mov	r0, r5
 801e00a:	4798      	blx	r3
 801e00c:	2800      	cmp	r0, #0
 801e00e:	bfb8      	it	lt
 801e010:	f04f 36ff 	movlt.w	r6, #4294967295	; 0xffffffff
 801e014:	89a3      	ldrh	r3, [r4, #12]
 801e016:	061a      	lsls	r2, r3, #24
 801e018:	d422      	bmi.n	801e060 <_fclose_r+0x90>
 801e01a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 801e01c:	b141      	cbz	r1, 801e030 <_fclose_r+0x60>
 801e01e:	f104 0340 	add.w	r3, r4, #64	; 0x40
 801e022:	4299      	cmp	r1, r3
 801e024:	d002      	beq.n	801e02c <_fclose_r+0x5c>
 801e026:	4628      	mov	r0, r5
 801e028:	f7ff fa88 	bl	801d53c <_free_r>
 801e02c:	2300      	movs	r3, #0
 801e02e:	6323      	str	r3, [r4, #48]	; 0x30
 801e030:	6c61      	ldr	r1, [r4, #68]	; 0x44
 801e032:	b121      	cbz	r1, 801e03e <_fclose_r+0x6e>
 801e034:	4628      	mov	r0, r5
 801e036:	f7ff fa81 	bl	801d53c <_free_r>
 801e03a:	2300      	movs	r3, #0
 801e03c:	6463      	str	r3, [r4, #68]	; 0x44
 801e03e:	f7ff fa21 	bl	801d484 <__sfp_lock_acquire>
 801e042:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801e044:	2200      	movs	r2, #0
 801e046:	07db      	lsls	r3, r3, #31
 801e048:	81a2      	strh	r2, [r4, #12]
 801e04a:	d50e      	bpl.n	801e06a <_fclose_r+0x9a>
 801e04c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e04e:	f7fd fe55 	bl	801bcfc <__retarget_lock_close_recursive>
 801e052:	f7ff fa1d 	bl	801d490 <__sfp_lock_release>
 801e056:	4630      	mov	r0, r6
 801e058:	bd70      	pop	{r4, r5, r6, pc}
 801e05a:	f7ff f9e7 	bl	801d42c <__sinit>
 801e05e:	e7bf      	b.n	801dfe0 <_fclose_r+0x10>
 801e060:	6921      	ldr	r1, [r4, #16]
 801e062:	4628      	mov	r0, r5
 801e064:	f7ff fa6a 	bl	801d53c <_free_r>
 801e068:	e7d7      	b.n	801e01a <_fclose_r+0x4a>
 801e06a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e06c:	f7fd fe4e 	bl	801bd0c <__retarget_lock_release_recursive>
 801e070:	e7ec      	b.n	801e04c <_fclose_r+0x7c>
 801e072:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e074:	f7fd fe46 	bl	801bd04 <__retarget_lock_acquire_recursive>
 801e078:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801e07c:	2b00      	cmp	r3, #0
 801e07e:	d1bb      	bne.n	801dff8 <_fclose_r+0x28>
 801e080:	6e66      	ldr	r6, [r4, #100]	; 0x64
 801e082:	f016 0601 	ands.w	r6, r6, #1
 801e086:	d1b1      	bne.n	801dfec <_fclose_r+0x1c>
 801e088:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e08a:	f7fd fe3f 	bl	801bd0c <__retarget_lock_release_recursive>
 801e08e:	4630      	mov	r0, r6
 801e090:	bd70      	pop	{r4, r5, r6, pc}
 801e092:	bf00      	nop

0801e094 <memmove>:
 801e094:	4288      	cmp	r0, r1
 801e096:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e098:	d90d      	bls.n	801e0b6 <memmove+0x22>
 801e09a:	188b      	adds	r3, r1, r2
 801e09c:	4298      	cmp	r0, r3
 801e09e:	d20a      	bcs.n	801e0b6 <memmove+0x22>
 801e0a0:	1884      	adds	r4, r0, r2
 801e0a2:	2a00      	cmp	r2, #0
 801e0a4:	d051      	beq.n	801e14a <memmove+0xb6>
 801e0a6:	4622      	mov	r2, r4
 801e0a8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 801e0ac:	f802 4d01 	strb.w	r4, [r2, #-1]!
 801e0b0:	4299      	cmp	r1, r3
 801e0b2:	d1f9      	bne.n	801e0a8 <memmove+0x14>
 801e0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e0b6:	2a0f      	cmp	r2, #15
 801e0b8:	d948      	bls.n	801e14c <memmove+0xb8>
 801e0ba:	ea41 0300 	orr.w	r3, r1, r0
 801e0be:	079b      	lsls	r3, r3, #30
 801e0c0:	d146      	bne.n	801e150 <memmove+0xbc>
 801e0c2:	f100 0410 	add.w	r4, r0, #16
 801e0c6:	f101 0310 	add.w	r3, r1, #16
 801e0ca:	4615      	mov	r5, r2
 801e0cc:	f853 6c10 	ldr.w	r6, [r3, #-16]
 801e0d0:	f844 6c10 	str.w	r6, [r4, #-16]
 801e0d4:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 801e0d8:	f844 6c0c 	str.w	r6, [r4, #-12]
 801e0dc:	f853 6c08 	ldr.w	r6, [r3, #-8]
 801e0e0:	f844 6c08 	str.w	r6, [r4, #-8]
 801e0e4:	3d10      	subs	r5, #16
 801e0e6:	f853 6c04 	ldr.w	r6, [r3, #-4]
 801e0ea:	f844 6c04 	str.w	r6, [r4, #-4]
 801e0ee:	2d0f      	cmp	r5, #15
 801e0f0:	f103 0310 	add.w	r3, r3, #16
 801e0f4:	f104 0410 	add.w	r4, r4, #16
 801e0f8:	d8e8      	bhi.n	801e0cc <memmove+0x38>
 801e0fa:	f1a2 0310 	sub.w	r3, r2, #16
 801e0fe:	f023 030f 	bic.w	r3, r3, #15
 801e102:	f002 0e0f 	and.w	lr, r2, #15
 801e106:	3310      	adds	r3, #16
 801e108:	f1be 0f03 	cmp.w	lr, #3
 801e10c:	4419      	add	r1, r3
 801e10e:	4403      	add	r3, r0
 801e110:	d921      	bls.n	801e156 <memmove+0xc2>
 801e112:	1f1e      	subs	r6, r3, #4
 801e114:	460d      	mov	r5, r1
 801e116:	4674      	mov	r4, lr
 801e118:	3c04      	subs	r4, #4
 801e11a:	f855 7b04 	ldr.w	r7, [r5], #4
 801e11e:	f846 7f04 	str.w	r7, [r6, #4]!
 801e122:	2c03      	cmp	r4, #3
 801e124:	d8f8      	bhi.n	801e118 <memmove+0x84>
 801e126:	f1ae 0404 	sub.w	r4, lr, #4
 801e12a:	f024 0403 	bic.w	r4, r4, #3
 801e12e:	3404      	adds	r4, #4
 801e130:	4421      	add	r1, r4
 801e132:	4423      	add	r3, r4
 801e134:	f002 0203 	and.w	r2, r2, #3
 801e138:	b162      	cbz	r2, 801e154 <memmove+0xc0>
 801e13a:	3b01      	subs	r3, #1
 801e13c:	440a      	add	r2, r1
 801e13e:	f811 4b01 	ldrb.w	r4, [r1], #1
 801e142:	f803 4f01 	strb.w	r4, [r3, #1]!
 801e146:	428a      	cmp	r2, r1
 801e148:	d1f9      	bne.n	801e13e <memmove+0xaa>
 801e14a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e14c:	4603      	mov	r3, r0
 801e14e:	e7f3      	b.n	801e138 <memmove+0xa4>
 801e150:	4603      	mov	r3, r0
 801e152:	e7f2      	b.n	801e13a <memmove+0xa6>
 801e154:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e156:	4672      	mov	r2, lr
 801e158:	e7ee      	b.n	801e138 <memmove+0xa4>
 801e15a:	bf00      	nop

0801e15c <memcmp>:
 801e15c:	2a03      	cmp	r2, #3
 801e15e:	b470      	push	{r4, r5, r6}
 801e160:	d922      	bls.n	801e1a8 <memcmp+0x4c>
 801e162:	ea40 0301 	orr.w	r3, r0, r1
 801e166:	079b      	lsls	r3, r3, #30
 801e168:	d011      	beq.n	801e18e <memcmp+0x32>
 801e16a:	7803      	ldrb	r3, [r0, #0]
 801e16c:	780c      	ldrb	r4, [r1, #0]
 801e16e:	42a3      	cmp	r3, r4
 801e170:	d11d      	bne.n	801e1ae <memcmp+0x52>
 801e172:	440a      	add	r2, r1
 801e174:	3101      	adds	r1, #1
 801e176:	e005      	b.n	801e184 <memcmp+0x28>
 801e178:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801e17c:	f811 4b01 	ldrb.w	r4, [r1], #1
 801e180:	42a3      	cmp	r3, r4
 801e182:	d114      	bne.n	801e1ae <memcmp+0x52>
 801e184:	4291      	cmp	r1, r2
 801e186:	d1f7      	bne.n	801e178 <memcmp+0x1c>
 801e188:	2000      	movs	r0, #0
 801e18a:	bc70      	pop	{r4, r5, r6}
 801e18c:	4770      	bx	lr
 801e18e:	680d      	ldr	r5, [r1, #0]
 801e190:	6806      	ldr	r6, [r0, #0]
 801e192:	42ae      	cmp	r6, r5
 801e194:	460c      	mov	r4, r1
 801e196:	4603      	mov	r3, r0
 801e198:	f101 0104 	add.w	r1, r1, #4
 801e19c:	f100 0004 	add.w	r0, r0, #4
 801e1a0:	d108      	bne.n	801e1b4 <memcmp+0x58>
 801e1a2:	3a04      	subs	r2, #4
 801e1a4:	2a03      	cmp	r2, #3
 801e1a6:	d8f2      	bhi.n	801e18e <memcmp+0x32>
 801e1a8:	2a00      	cmp	r2, #0
 801e1aa:	d1de      	bne.n	801e16a <memcmp+0xe>
 801e1ac:	e7ec      	b.n	801e188 <memcmp+0x2c>
 801e1ae:	1b18      	subs	r0, r3, r4
 801e1b0:	bc70      	pop	{r4, r5, r6}
 801e1b2:	4770      	bx	lr
 801e1b4:	4621      	mov	r1, r4
 801e1b6:	4618      	mov	r0, r3
 801e1b8:	e7d7      	b.n	801e16a <memcmp+0xe>
 801e1ba:	bf00      	nop

0801e1bc <printf>:
 801e1bc:	b40f      	push	{r0, r1, r2, r3}
 801e1be:	b500      	push	{lr}
 801e1c0:	4907      	ldr	r1, [pc, #28]	; (801e1e0 <printf+0x24>)
 801e1c2:	b083      	sub	sp, #12
 801e1c4:	ab04      	add	r3, sp, #16
 801e1c6:	6808      	ldr	r0, [r1, #0]
 801e1c8:	f853 2b04 	ldr.w	r2, [r3], #4
 801e1cc:	6881      	ldr	r1, [r0, #8]
 801e1ce:	9301      	str	r3, [sp, #4]
 801e1d0:	f000 ff12 	bl	801eff8 <_vfprintf_r>
 801e1d4:	b003      	add	sp, #12
 801e1d6:	f85d eb04 	ldr.w	lr, [sp], #4
 801e1da:	b004      	add	sp, #16
 801e1dc:	4770      	bx	lr
 801e1de:	bf00      	nop
 801e1e0:	20004474 	.word	0x20004474

0801e1e4 <_puts_r>:
 801e1e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e1e6:	4605      	mov	r5, r0
 801e1e8:	b089      	sub	sp, #36	; 0x24
 801e1ea:	4608      	mov	r0, r1
 801e1ec:	460c      	mov	r4, r1
 801e1ee:	f7e6 fa27 	bl	8004640 <strlen>
 801e1f2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 801e1f4:	4f21      	ldr	r7, [pc, #132]	; (801e27c <_puts_r+0x98>)
 801e1f6:	9404      	str	r4, [sp, #16]
 801e1f8:	2601      	movs	r6, #1
 801e1fa:	1c44      	adds	r4, r0, #1
 801e1fc:	a904      	add	r1, sp, #16
 801e1fe:	2202      	movs	r2, #2
 801e200:	9403      	str	r4, [sp, #12]
 801e202:	9005      	str	r0, [sp, #20]
 801e204:	68ac      	ldr	r4, [r5, #8]
 801e206:	9706      	str	r7, [sp, #24]
 801e208:	9607      	str	r6, [sp, #28]
 801e20a:	9101      	str	r1, [sp, #4]
 801e20c:	9202      	str	r2, [sp, #8]
 801e20e:	b353      	cbz	r3, 801e266 <_puts_r+0x82>
 801e210:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801e212:	f013 0f01 	tst.w	r3, #1
 801e216:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801e21a:	b29a      	uxth	r2, r3
 801e21c:	d101      	bne.n	801e222 <_puts_r+0x3e>
 801e21e:	0590      	lsls	r0, r2, #22
 801e220:	d525      	bpl.n	801e26e <_puts_r+0x8a>
 801e222:	0491      	lsls	r1, r2, #18
 801e224:	d406      	bmi.n	801e234 <_puts_r+0x50>
 801e226:	6e62      	ldr	r2, [r4, #100]	; 0x64
 801e228:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801e22c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 801e230:	81a3      	strh	r3, [r4, #12]
 801e232:	6662      	str	r2, [r4, #100]	; 0x64
 801e234:	4628      	mov	r0, r5
 801e236:	aa01      	add	r2, sp, #4
 801e238:	4621      	mov	r1, r4
 801e23a:	f003 f9ff 	bl	802163c <__sfvwrite_r>
 801e23e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801e240:	2800      	cmp	r0, #0
 801e242:	bf0c      	ite	eq
 801e244:	250a      	moveq	r5, #10
 801e246:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
 801e24a:	07da      	lsls	r2, r3, #31
 801e24c:	d402      	bmi.n	801e254 <_puts_r+0x70>
 801e24e:	89a3      	ldrh	r3, [r4, #12]
 801e250:	059b      	lsls	r3, r3, #22
 801e252:	d502      	bpl.n	801e25a <_puts_r+0x76>
 801e254:	4628      	mov	r0, r5
 801e256:	b009      	add	sp, #36	; 0x24
 801e258:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e25a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e25c:	f7fd fd56 	bl	801bd0c <__retarget_lock_release_recursive>
 801e260:	4628      	mov	r0, r5
 801e262:	b009      	add	sp, #36	; 0x24
 801e264:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e266:	4628      	mov	r0, r5
 801e268:	f7ff f8e0 	bl	801d42c <__sinit>
 801e26c:	e7d0      	b.n	801e210 <_puts_r+0x2c>
 801e26e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e270:	f7fd fd48 	bl	801bd04 <__retarget_lock_acquire_recursive>
 801e274:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801e278:	b29a      	uxth	r2, r3
 801e27a:	e7d2      	b.n	801e222 <_puts_r+0x3e>
 801e27c:	08024c5c 	.word	0x08024c5c

0801e280 <puts>:
 801e280:	4b02      	ldr	r3, [pc, #8]	; (801e28c <puts+0xc>)
 801e282:	4601      	mov	r1, r0
 801e284:	6818      	ldr	r0, [r3, #0]
 801e286:	f7ff bfad 	b.w	801e1e4 <_puts_r>
 801e28a:	bf00      	nop
 801e28c:	20004474 	.word	0x20004474

0801e290 <iso_year_adjust>:
 801e290:	6943      	ldr	r3, [r0, #20]
 801e292:	2b00      	cmp	r3, #0
 801e294:	f240 726c 	movw	r2, #1900	; 0x76c
 801e298:	bfa8      	it	ge
 801e29a:	f06f 0263 	mvnge.w	r2, #99	; 0x63
 801e29e:	441a      	add	r2, r3
 801e2a0:	0793      	lsls	r3, r2, #30
 801e2a2:	b410      	push	{r4}
 801e2a4:	d021      	beq.n	801e2ea <iso_year_adjust+0x5a>
 801e2a6:	17d3      	asrs	r3, r2, #31
 801e2a8:	492d      	ldr	r1, [pc, #180]	; (801e360 <iso_year_adjust+0xd0>)
 801e2aa:	fb81 4102 	smull	r4, r1, r1, r2
 801e2ae:	ebc3 13e1 	rsb	r3, r3, r1, asr #7
 801e2b2:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801e2b6:	fb01 2213 	mls	r2, r1, r3, r2
 801e2ba:	fab2 f282 	clz	r2, r2
 801e2be:	0952      	lsrs	r2, r2, #5
 801e2c0:	6983      	ldr	r3, [r0, #24]
 801e2c2:	69c1      	ldr	r1, [r0, #28]
 801e2c4:	005b      	lsls	r3, r3, #1
 801e2c6:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801e2ca:	4413      	add	r3, r2
 801e2cc:	2b21      	cmp	r3, #33	; 0x21
 801e2ce:	dc29      	bgt.n	801e324 <iso_year_adjust+0x94>
 801e2d0:	2b20      	cmp	r3, #32
 801e2d2:	da05      	bge.n	801e2e0 <iso_year_adjust+0x50>
 801e2d4:	2b0d      	cmp	r3, #13
 801e2d6:	dc3b      	bgt.n	801e350 <iso_year_adjust+0xc0>
 801e2d8:	2b0a      	cmp	r3, #10
 801e2da:	da01      	bge.n	801e2e0 <iso_year_adjust+0x50>
 801e2dc:	2b01      	cmp	r3, #1
 801e2de:	d81d      	bhi.n	801e31c <iso_year_adjust+0x8c>
 801e2e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801e2e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801e2e8:	4770      	bx	lr
 801e2ea:	491d      	ldr	r1, [pc, #116]	; (801e360 <iso_year_adjust+0xd0>)
 801e2ec:	17d3      	asrs	r3, r2, #31
 801e2ee:	fb81 4102 	smull	r4, r1, r1, r2
 801e2f2:	ebc3 1161 	rsb	r1, r3, r1, asr #5
 801e2f6:	2464      	movs	r4, #100	; 0x64
 801e2f8:	fb04 2111 	mls	r1, r4, r1, r2
 801e2fc:	2900      	cmp	r1, #0
 801e2fe:	d0d3      	beq.n	801e2a8 <iso_year_adjust+0x18>
 801e300:	2201      	movs	r2, #1
 801e302:	e7dd      	b.n	801e2c0 <iso_year_adjust+0x30>
 801e304:	f241 62d5 	movw	r2, #5845	; 0x16d5
 801e308:	4293      	cmp	r3, r2
 801e30a:	d01d      	beq.n	801e348 <iso_year_adjust+0xb8>
 801e30c:	f241 62d7 	movw	r2, #5847	; 0x16d7
 801e310:	4293      	cmp	r3, r2
 801e312:	d019      	beq.n	801e348 <iso_year_adjust+0xb8>
 801e314:	f241 62d3 	movw	r2, #5843	; 0x16d3
 801e318:	4293      	cmp	r3, r2
 801e31a:	d015      	beq.n	801e348 <iso_year_adjust+0xb8>
 801e31c:	2000      	movs	r0, #0
 801e31e:	f85d 4b04 	ldr.w	r4, [sp], #4
 801e322:	4770      	bx	lr
 801e324:	f241 62c6 	movw	r2, #5830	; 0x16c6
 801e328:	4293      	cmp	r3, r2
 801e32a:	dceb      	bgt.n	801e304 <iso_year_adjust+0x74>
 801e32c:	f241 62c2 	movw	r2, #5826	; 0x16c2
 801e330:	4293      	cmp	r3, r2
 801e332:	da09      	bge.n	801e348 <iso_year_adjust+0xb8>
 801e334:	f241 62a2 	movw	r2, #5794	; 0x16a2
 801e338:	4293      	cmp	r3, r2
 801e33a:	d005      	beq.n	801e348 <iso_year_adjust+0xb8>
 801e33c:	dbee      	blt.n	801e31c <iso_year_adjust+0x8c>
 801e33e:	f5a3 53b5 	sub.w	r3, r3, #5792	; 0x16a0
 801e342:	3b12      	subs	r3, #18
 801e344:	2b02      	cmp	r3, #2
 801e346:	d8e9      	bhi.n	801e31c <iso_year_adjust+0x8c>
 801e348:	2001      	movs	r0, #1
 801e34a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801e34e:	4770      	bx	lr
 801e350:	2b10      	cmp	r3, #16
 801e352:	dbe3      	blt.n	801e31c <iso_year_adjust+0x8c>
 801e354:	2b11      	cmp	r3, #17
 801e356:	ddc3      	ble.n	801e2e0 <iso_year_adjust+0x50>
 801e358:	3b1c      	subs	r3, #28
 801e35a:	2b01      	cmp	r3, #1
 801e35c:	d9c0      	bls.n	801e2e0 <iso_year_adjust+0x50>
 801e35e:	e7dd      	b.n	801e31c <iso_year_adjust+0x8c>
 801e360:	51eb851f 	.word	0x51eb851f

0801e364 <__strftime>:
 801e364:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e368:	b093      	sub	sp, #76	; 0x4c
 801e36a:	2400      	movs	r4, #0
 801e36c:	9403      	str	r4, [sp, #12]
 801e36e:	4681      	mov	r9, r0
 801e370:	468b      	mov	fp, r1
 801e372:	4698      	mov	r8, r3
 801e374:	46a2      	mov	sl, r4
 801e376:	7813      	ldrb	r3, [r2, #0]
 801e378:	b173      	cbz	r3, 801e398 <__strftime+0x34>
 801e37a:	2b25      	cmp	r3, #37	; 0x25
 801e37c:	d016      	beq.n	801e3ac <__strftime+0x48>
 801e37e:	f10b 31ff 	add.w	r1, fp, #4294967295	; 0xffffffff
 801e382:	458a      	cmp	sl, r1
 801e384:	f080 8083 	bcs.w	801e48e <__strftime+0x12a>
 801e388:	f809 300a 	strb.w	r3, [r9, sl]
 801e38c:	3201      	adds	r2, #1
 801e38e:	7813      	ldrb	r3, [r2, #0]
 801e390:	f10a 0a01 	add.w	sl, sl, #1
 801e394:	2b00      	cmp	r3, #0
 801e396:	d1f0      	bne.n	801e37a <__strftime+0x16>
 801e398:	f1bb 0f00 	cmp.w	fp, #0
 801e39c:	d079      	beq.n	801e492 <__strftime+0x12e>
 801e39e:	2300      	movs	r3, #0
 801e3a0:	4650      	mov	r0, sl
 801e3a2:	f809 300a 	strb.w	r3, [r9, sl]
 801e3a6:	b013      	add	sp, #76	; 0x4c
 801e3a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e3ac:	7851      	ldrb	r1, [r2, #1]
 801e3ae:	2930      	cmp	r1, #48	; 0x30
 801e3b0:	d073      	beq.n	801e49a <__strftime+0x136>
 801e3b2:	292b      	cmp	r1, #43	; 0x2b
 801e3b4:	d071      	beq.n	801e49a <__strftime+0x136>
 801e3b6:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 801e3ba:	2b08      	cmp	r3, #8
 801e3bc:	f102 0501 	add.w	r5, r2, #1
 801e3c0:	f04f 0400 	mov.w	r4, #0
 801e3c4:	d971      	bls.n	801e4aa <__strftime+0x146>
 801e3c6:	2945      	cmp	r1, #69	; 0x45
 801e3c8:	f04f 0600 	mov.w	r6, #0
 801e3cc:	d077      	beq.n	801e4be <__strftime+0x15a>
 801e3ce:	294f      	cmp	r1, #79	; 0x4f
 801e3d0:	d075      	beq.n	801e4be <__strftime+0x15a>
 801e3d2:	f1a1 0225 	sub.w	r2, r1, #37	; 0x25
 801e3d6:	2a55      	cmp	r2, #85	; 0x55
 801e3d8:	d859      	bhi.n	801e48e <__strftime+0x12a>
 801e3da:	e8df f012 	tbh	[pc, r2, lsl #1]
 801e3de:	0093      	.short	0x0093
 801e3e0:	00580058 	.word	0x00580058
 801e3e4:	00580058 	.word	0x00580058
 801e3e8:	00580058 	.word	0x00580058
 801e3ec:	00580058 	.word	0x00580058
 801e3f0:	00580058 	.word	0x00580058
 801e3f4:	00580058 	.word	0x00580058
 801e3f8:	00580058 	.word	0x00580058
 801e3fc:	00580058 	.word	0x00580058
 801e400:	00580058 	.word	0x00580058
 801e404:	00580058 	.word	0x00580058
 801e408:	00580058 	.word	0x00580058
 801e40c:	00580058 	.word	0x00580058
 801e410:	00580058 	.word	0x00580058
 801e414:	009d0058 	.word	0x009d0058
 801e418:	00d900bb 	.word	0x00d900bb
 801e41c:	005800f9 	.word	0x005800f9
 801e420:	03ef03d9 	.word	0x03ef03d9
 801e424:	04370378 	.word	0x04370378
 801e428:	00580058 	.word	0x00580058
 801e42c:	03800058 	.word	0x03800058
 801e430:	00580058 	.word	0x00580058
 801e434:	00580384 	.word	0x00580384
 801e438:	03190309 	.word	0x03190309
 801e43c:	032c031d 	.word	0x032c031d
 801e440:	0349033b 	.word	0x0349033b
 801e444:	03590352 	.word	0x03590352
 801e448:	0058011b 	.word	0x0058011b
 801e44c:	00580058 	.word	0x00580058
 801e450:	00580058 	.word	0x00580058
 801e454:	014b0058 	.word	0x014b0058
 801e458:	018c016c 	.word	0x018c016c
 801e45c:	01a501a5 	.word	0x01a501a5
 801e460:	01ad0058 	.word	0x01ad0058
 801e464:	0058016c 	.word	0x0058016c
 801e468:	037801e0 	.word	0x037801e0
 801e46c:	02400437 	.word	0x02400437
 801e470:	00580245 	.word	0x00580245
 801e474:	00580384 	.word	0x00580384
 801e478:	02570250 	.word	0x02570250
 801e47c:	02fa02db 	.word	0x02fa02db
 801e480:	02e60058 	.word	0x02e60058
 801e484:	007302f3 	.word	0x007302f3
 801e488:	01fb      	.short	0x01fb
 801e48a:	f7fd fa3b 	bl	801b904 <__tz_unlock>
 801e48e:	f04f 0a00 	mov.w	sl, #0
 801e492:	4650      	mov	r0, sl
 801e494:	b013      	add	sp, #76	; 0x4c
 801e496:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e49a:	460c      	mov	r4, r1
 801e49c:	7891      	ldrb	r1, [r2, #2]
 801e49e:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 801e4a2:	2b08      	cmp	r3, #8
 801e4a4:	f102 0502 	add.w	r5, r2, #2
 801e4a8:	d88d      	bhi.n	801e3c6 <__strftime+0x62>
 801e4aa:	4628      	mov	r0, r5
 801e4ac:	a90a      	add	r1, sp, #40	; 0x28
 801e4ae:	220a      	movs	r2, #10
 801e4b0:	f7fe f8ea 	bl	801c688 <strtoul>
 801e4b4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801e4b6:	7829      	ldrb	r1, [r5, #0]
 801e4b8:	2945      	cmp	r1, #69	; 0x45
 801e4ba:	4606      	mov	r6, r0
 801e4bc:	d187      	bne.n	801e3ce <__strftime+0x6a>
 801e4be:	7869      	ldrb	r1, [r5, #1]
 801e4c0:	3501      	adds	r5, #1
 801e4c2:	e786      	b.n	801e3d2 <__strftime+0x6e>
 801e4c4:	f8d8 0014 	ldr.w	r0, [r8, #20]
 801e4c8:	2800      	cmp	r0, #0
 801e4ca:	f2c0 84a1 	blt.w	801ee10 <__strftime+0xaac>
 801e4ce:	4bb6      	ldr	r3, [pc, #728]	; (801e7a8 <__strftime+0x444>)
 801e4d0:	fb83 3200 	smull	r3, r2, r3, r0
 801e4d4:	17c3      	asrs	r3, r0, #31
 801e4d6:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 801e4da:	2264      	movs	r2, #100	; 0x64
 801e4dc:	fb02 0313 	mls	r3, r2, r3, r0
 801e4e0:	4ab2      	ldr	r2, [pc, #712]	; (801e7ac <__strftime+0x448>)
 801e4e2:	ebab 010a 	sub.w	r1, fp, sl
 801e4e6:	eb09 000a 	add.w	r0, r9, sl
 801e4ea:	f003 fda3 	bl	8022034 <sniprintf>
 801e4ee:	2800      	cmp	r0, #0
 801e4f0:	dbcd      	blt.n	801e48e <__strftime+0x12a>
 801e4f2:	4482      	add	sl, r0
 801e4f4:	45d3      	cmp	fp, sl
 801e4f6:	d9ca      	bls.n	801e48e <__strftime+0x12a>
 801e4f8:	782b      	ldrb	r3, [r5, #0]
 801e4fa:	2b00      	cmp	r3, #0
 801e4fc:	f43f af4c 	beq.w	801e398 <__strftime+0x34>
 801e500:	1c6a      	adds	r2, r5, #1
 801e502:	e738      	b.n	801e376 <__strftime+0x12>
 801e504:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 801e508:	459a      	cmp	sl, r3
 801e50a:	d2c0      	bcs.n	801e48e <__strftime+0x12a>
 801e50c:	2325      	movs	r3, #37	; 0x25
 801e50e:	f809 300a 	strb.w	r3, [r9, sl]
 801e512:	f10a 0a01 	add.w	sl, sl, #1
 801e516:	e7ef      	b.n	801e4f8 <__strftime+0x194>
 801e518:	4ba5      	ldr	r3, [pc, #660]	; (801e7b0 <__strftime+0x44c>)
 801e51a:	f8d8 2018 	ldr.w	r2, [r8, #24]
 801e51e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801e522:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
 801e524:	4620      	mov	r0, r4
 801e526:	f7e6 f88b 	bl	8004640 <strlen>
 801e52a:	2800      	cmp	r0, #0
 801e52c:	d0e4      	beq.n	801e4f8 <__strftime+0x194>
 801e52e:	f10b 36ff 	add.w	r6, fp, #4294967295	; 0xffffffff
 801e532:	45b2      	cmp	sl, r6
 801e534:	d2ab      	bcs.n	801e48e <__strftime+0x12a>
 801e536:	1e63      	subs	r3, r4, #1
 801e538:	4450      	add	r0, sl
 801e53a:	eb09 020a 	add.w	r2, r9, sl
 801e53e:	f10a 0a01 	add.w	sl, sl, #1
 801e542:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801e546:	f802 1b01 	strb.w	r1, [r2], #1
 801e54a:	4582      	cmp	sl, r0
 801e54c:	d0d4      	beq.n	801e4f8 <__strftime+0x194>
 801e54e:	4556      	cmp	r6, sl
 801e550:	d8f5      	bhi.n	801e53e <__strftime+0x1da>
 801e552:	e79c      	b.n	801e48e <__strftime+0x12a>
 801e554:	f8d8 3010 	ldr.w	r3, [r8, #16]
 801e558:	4a95      	ldr	r2, [pc, #596]	; (801e7b0 <__strftime+0x44c>)
 801e55a:	330c      	adds	r3, #12
 801e55c:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 801e560:	4620      	mov	r0, r4
 801e562:	f7e6 f86d 	bl	8004640 <strlen>
 801e566:	2800      	cmp	r0, #0
 801e568:	d0c6      	beq.n	801e4f8 <__strftime+0x194>
 801e56a:	f10b 36ff 	add.w	r6, fp, #4294967295	; 0xffffffff
 801e56e:	45b2      	cmp	sl, r6
 801e570:	d28d      	bcs.n	801e48e <__strftime+0x12a>
 801e572:	1e63      	subs	r3, r4, #1
 801e574:	4450      	add	r0, sl
 801e576:	eb09 020a 	add.w	r2, r9, sl
 801e57a:	f10a 0a01 	add.w	sl, sl, #1
 801e57e:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801e582:	f802 1b01 	strb.w	r1, [r2], #1
 801e586:	4582      	cmp	sl, r0
 801e588:	d0b6      	beq.n	801e4f8 <__strftime+0x194>
 801e58a:	45b2      	cmp	sl, r6
 801e58c:	d3f5      	bcc.n	801e57a <__strftime+0x216>
 801e58e:	e77e      	b.n	801e48e <__strftime+0x12a>
 801e590:	4b88      	ldr	r3, [pc, #544]	; (801e7b4 <__strftime+0x450>)
 801e592:	f8d8 7014 	ldr.w	r7, [r8, #20]
 801e596:	429f      	cmp	r7, r3
 801e598:	bfac      	ite	ge
 801e59a:	2300      	movge	r3, #0
 801e59c:	2301      	movlt	r3, #1
 801e59e:	2f00      	cmp	r7, #0
 801e5a0:	f2c0 8428 	blt.w	801edf4 <__strftime+0xa90>
 801e5a4:	4a80      	ldr	r2, [pc, #512]	; (801e7a8 <__strftime+0x444>)
 801e5a6:	fb82 2107 	smull	r2, r1, r2, r7
 801e5aa:	17fa      	asrs	r2, r7, #31
 801e5ac:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 801e5b0:	3113      	adds	r1, #19
 801e5b2:	2c00      	cmp	r4, #0
 801e5b4:	f000 83b7 	beq.w	801ed26 <__strftime+0x9c2>
 801e5b8:	2963      	cmp	r1, #99	; 0x63
 801e5ba:	f340 83cb 	ble.w	801ed54 <__strftime+0x9f0>
 801e5be:	f8df e210 	ldr.w	lr, [pc, #528]	; 801e7d0 <__strftime+0x46c>
 801e5c2:	487d      	ldr	r0, [pc, #500]	; (801e7b8 <__strftime+0x454>)
 801e5c4:	4a7d      	ldr	r2, [pc, #500]	; (801e7bc <__strftime+0x458>)
 801e5c6:	2c2b      	cmp	r4, #43	; 0x2b
 801e5c8:	bf14      	ite	ne
 801e5ca:	4674      	movne	r4, lr
 801e5cc:	4604      	moveq	r4, r0
 801e5ce:	e3ac      	b.n	801ed2a <__strftime+0x9c6>
 801e5d0:	f8d8 0014 	ldr.w	r0, [r8, #20]
 801e5d4:	f8d8 3010 	ldr.w	r3, [r8, #16]
 801e5d8:	f8d8 600c 	ldr.w	r6, [r8, #12]
 801e5dc:	2800      	cmp	r0, #0
 801e5de:	f103 0301 	add.w	r3, r3, #1
 801e5e2:	eb09 040a 	add.w	r4, r9, sl
 801e5e6:	ebab 010a 	sub.w	r1, fp, sl
 801e5ea:	f2c0 83f1 	blt.w	801edd0 <__strftime+0xa6c>
 801e5ee:	4a6e      	ldr	r2, [pc, #440]	; (801e7a8 <__strftime+0x444>)
 801e5f0:	fb82 2700 	smull	r2, r7, r2, r0
 801e5f4:	17c2      	asrs	r2, r0, #31
 801e5f6:	ebc2 1267 	rsb	r2, r2, r7, asr #5
 801e5fa:	2764      	movs	r7, #100	; 0x64
 801e5fc:	fb07 0212 	mls	r2, r7, r2, r0
 801e600:	9201      	str	r2, [sp, #4]
 801e602:	9600      	str	r6, [sp, #0]
 801e604:	4620      	mov	r0, r4
 801e606:	4a6e      	ldr	r2, [pc, #440]	; (801e7c0 <__strftime+0x45c>)
 801e608:	f003 fd14 	bl	8022034 <sniprintf>
 801e60c:	2800      	cmp	r0, #0
 801e60e:	f6bf af70 	bge.w	801e4f2 <__strftime+0x18e>
 801e612:	e73c      	b.n	801e48e <__strftime+0x12a>
 801e614:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801e618:	2b00      	cmp	r3, #0
 801e61a:	f6ff af71 	blt.w	801e500 <__strftime+0x19c>
 801e61e:	f7fd f96b 	bl	801b8f8 <__tz_lock>
 801e622:	9b03      	ldr	r3, [sp, #12]
 801e624:	2b00      	cmp	r3, #0
 801e626:	f000 83ce 	beq.w	801edc6 <__strftime+0xa62>
 801e62a:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801e62e:	4a65      	ldr	r2, [pc, #404]	; (801e7c4 <__strftime+0x460>)
 801e630:	2b00      	cmp	r3, #0
 801e632:	bfd4      	ite	le
 801e634:	2300      	movle	r3, #0
 801e636:	2301      	movgt	r3, #1
 801e638:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 801e63c:	4620      	mov	r0, r4
 801e63e:	f7e5 ffff 	bl	8004640 <strlen>
 801e642:	b1a0      	cbz	r0, 801e66e <__strftime+0x30a>
 801e644:	f10b 36ff 	add.w	r6, fp, #4294967295	; 0xffffffff
 801e648:	45b2      	cmp	sl, r6
 801e64a:	f4bf af1e 	bcs.w	801e48a <__strftime+0x126>
 801e64e:	1e63      	subs	r3, r4, #1
 801e650:	4450      	add	r0, sl
 801e652:	eb09 020a 	add.w	r2, r9, sl
 801e656:	e002      	b.n	801e65e <__strftime+0x2fa>
 801e658:	45b2      	cmp	sl, r6
 801e65a:	f4bf af16 	bcs.w	801e48a <__strftime+0x126>
 801e65e:	f10a 0a01 	add.w	sl, sl, #1
 801e662:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801e666:	f802 1b01 	strb.w	r1, [r2], #1
 801e66a:	4582      	cmp	sl, r0
 801e66c:	d1f4      	bne.n	801e658 <__strftime+0x2f4>
 801e66e:	f7fd f949 	bl	801b904 <__tz_unlock>
 801e672:	e0f1      	b.n	801e858 <__strftime+0x4f4>
 801e674:	f8d8 3018 	ldr.w	r3, [r8, #24]
 801e678:	4a4d      	ldr	r2, [pc, #308]	; (801e7b0 <__strftime+0x44c>)
 801e67a:	3318      	adds	r3, #24
 801e67c:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 801e680:	4620      	mov	r0, r4
 801e682:	f7e5 ffdd 	bl	8004640 <strlen>
 801e686:	2800      	cmp	r0, #0
 801e688:	f43f af36 	beq.w	801e4f8 <__strftime+0x194>
 801e68c:	f10b 36ff 	add.w	r6, fp, #4294967295	; 0xffffffff
 801e690:	45b2      	cmp	sl, r6
 801e692:	f4bf aefc 	bcs.w	801e48e <__strftime+0x12a>
 801e696:	1e63      	subs	r3, r4, #1
 801e698:	4450      	add	r0, sl
 801e69a:	eb09 020a 	add.w	r2, r9, sl
 801e69e:	f10a 0a01 	add.w	sl, sl, #1
 801e6a2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801e6a6:	f802 1b01 	strb.w	r1, [r2], #1
 801e6aa:	4582      	cmp	sl, r0
 801e6ac:	f43f af24 	beq.w	801e4f8 <__strftime+0x194>
 801e6b0:	4556      	cmp	r6, sl
 801e6b2:	d8f4      	bhi.n	801e69e <__strftime+0x33a>
 801e6b4:	e6eb      	b.n	801e48e <__strftime+0x12a>
 801e6b6:	4b3e      	ldr	r3, [pc, #248]	; (801e7b0 <__strftime+0x44c>)
 801e6b8:	f8d8 2010 	ldr.w	r2, [r8, #16]
 801e6bc:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 801e6c0:	4620      	mov	r0, r4
 801e6c2:	f7e5 ffbd 	bl	8004640 <strlen>
 801e6c6:	2800      	cmp	r0, #0
 801e6c8:	f43f af16 	beq.w	801e4f8 <__strftime+0x194>
 801e6cc:	f10b 36ff 	add.w	r6, fp, #4294967295	; 0xffffffff
 801e6d0:	45b2      	cmp	sl, r6
 801e6d2:	f4bf aedc 	bcs.w	801e48e <__strftime+0x12a>
 801e6d6:	1e63      	subs	r3, r4, #1
 801e6d8:	4450      	add	r0, sl
 801e6da:	eb09 020a 	add.w	r2, r9, sl
 801e6de:	f10a 0a01 	add.w	sl, sl, #1
 801e6e2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801e6e6:	f802 1b01 	strb.w	r1, [r2], #1
 801e6ea:	4550      	cmp	r0, sl
 801e6ec:	f43f af04 	beq.w	801e4f8 <__strftime+0x194>
 801e6f0:	45b2      	cmp	sl, r6
 801e6f2:	d3f4      	bcc.n	801e6de <__strftime+0x37a>
 801e6f4:	e6cb      	b.n	801e48e <__strftime+0x12a>
 801e6f6:	4b2e      	ldr	r3, [pc, #184]	; (801e7b0 <__strftime+0x44c>)
 801e6f8:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
 801e6fc:	4620      	mov	r0, r4
 801e6fe:	f7e5 ff9f 	bl	8004640 <strlen>
 801e702:	7823      	ldrb	r3, [r4, #0]
 801e704:	2b00      	cmp	r3, #0
 801e706:	f43f aef7 	beq.w	801e4f8 <__strftime+0x194>
 801e70a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801e70c:	9300      	str	r3, [sp, #0]
 801e70e:	4622      	mov	r2, r4
 801e710:	4643      	mov	r3, r8
 801e712:	ebab 010a 	sub.w	r1, fp, sl
 801e716:	eb09 000a 	add.w	r0, r9, sl
 801e71a:	f7ff fe23 	bl	801e364 <__strftime>
 801e71e:	2800      	cmp	r0, #0
 801e720:	f77f aeb5 	ble.w	801e48e <__strftime+0x12a>
 801e724:	4482      	add	sl, r0
 801e726:	e6e7      	b.n	801e4f8 <__strftime+0x194>
 801e728:	4827      	ldr	r0, [pc, #156]	; (801e7c8 <__strftime+0x464>)
 801e72a:	4a20      	ldr	r2, [pc, #128]	; (801e7ac <__strftime+0x448>)
 801e72c:	f8d8 300c 	ldr.w	r3, [r8, #12]
 801e730:	2964      	cmp	r1, #100	; 0x64
 801e732:	bf18      	it	ne
 801e734:	4602      	movne	r2, r0
 801e736:	e6d4      	b.n	801e4e2 <__strftime+0x17e>
 801e738:	4640      	mov	r0, r8
 801e73a:	f7ff fda9 	bl	801e290 <iso_year_adjust>
 801e73e:	4604      	mov	r4, r0
 801e740:	f8d8 0014 	ldr.w	r0, [r8, #20]
 801e744:	2800      	cmp	r0, #0
 801e746:	f2c0 8369 	blt.w	801ee1c <__strftime+0xab8>
 801e74a:	4b17      	ldr	r3, [pc, #92]	; (801e7a8 <__strftime+0x444>)
 801e74c:	fb83 2300 	smull	r2, r3, r3, r0
 801e750:	17c2      	asrs	r2, r0, #31
 801e752:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 801e756:	2c00      	cmp	r4, #0
 801e758:	f04f 0364 	mov.w	r3, #100	; 0x64
 801e75c:	fb03 0212 	mls	r2, r3, r2, r0
 801e760:	f2c0 8307 	blt.w	801ed72 <__strftime+0xa0e>
 801e764:	d006      	beq.n	801e774 <__strftime+0x410>
 801e766:	4b13      	ldr	r3, [pc, #76]	; (801e7b4 <__strftime+0x450>)
 801e768:	f8d8 1014 	ldr.w	r1, [r8, #20]
 801e76c:	4299      	cmp	r1, r3
 801e76e:	bfb8      	it	lt
 801e770:	f04f 34ff 	movlt.w	r4, #4294967295	; 0xffffffff
 801e774:	4b0c      	ldr	r3, [pc, #48]	; (801e7a8 <__strftime+0x444>)
 801e776:	4414      	add	r4, r2
 801e778:	fb83 2304 	smull	r2, r3, r3, r4
 801e77c:	17e2      	asrs	r2, r4, #31
 801e77e:	2164      	movs	r1, #100	; 0x64
 801e780:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 801e784:	fb01 4212 	mls	r2, r1, r2, r4
 801e788:	4b07      	ldr	r3, [pc, #28]	; (801e7a8 <__strftime+0x444>)
 801e78a:	440a      	add	r2, r1
 801e78c:	fb83 3002 	smull	r3, r0, r3, r2
 801e790:	17d3      	asrs	r3, r2, #31
 801e792:	ebc3 1360 	rsb	r3, r3, r0, asr #5
 801e796:	fb01 2313 	mls	r3, r1, r3, r2
 801e79a:	4a04      	ldr	r2, [pc, #16]	; (801e7ac <__strftime+0x448>)
 801e79c:	e6a1      	b.n	801e4e2 <__strftime+0x17e>
 801e79e:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801e7a2:	4a0a      	ldr	r2, [pc, #40]	; (801e7cc <__strftime+0x468>)
 801e7a4:	3301      	adds	r3, #1
 801e7a6:	e69c      	b.n	801e4e2 <__strftime+0x17e>
 801e7a8:	51eb851f 	.word	0x51eb851f
 801e7ac:	08025124 	.word	0x08025124
 801e7b0:	08024cf8 	.word	0x08024cf8
 801e7b4:	fffff894 	.word	0xfffff894
 801e7b8:	08025120 	.word	0x08025120
 801e7bc:	08025118 	.word	0x08025118
 801e7c0:	08025130 	.word	0x08025130
 801e7c4:	20004a0c 	.word	0x20004a0c
 801e7c8:	0802512c 	.word	0x0802512c
 801e7cc:	08025150 	.word	0x08025150
 801e7d0:	08023558 	.word	0x08023558
 801e7d4:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801e7d8:	2b00      	cmp	r3, #0
 801e7da:	f6ff ae91 	blt.w	801e500 <__strftime+0x19c>
 801e7de:	f7fd f88b 	bl	801b8f8 <__tz_lock>
 801e7e2:	9b03      	ldr	r3, [sp, #12]
 801e7e4:	2b00      	cmp	r3, #0
 801e7e6:	f000 82e8 	beq.w	801edba <__strftime+0xa56>
 801e7ea:	f7fd fa81 	bl	801bcf0 <__gettzinfo>
 801e7ee:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801e7f2:	2b00      	cmp	r3, #0
 801e7f4:	bfcc      	ite	gt
 801e7f6:	231c      	movgt	r3, #28
 801e7f8:	2300      	movle	r3, #0
 801e7fa:	4403      	add	r3, r0
 801e7fc:	eb09 040a 	add.w	r4, r9, sl
 801e800:	6a1f      	ldr	r7, [r3, #32]
 801e802:	f7fd f87f 	bl	801b904 <__tz_unlock>
 801e806:	4bc7      	ldr	r3, [pc, #796]	; (801eb24 <__strftime+0x7c0>)
 801e808:	427f      	negs	r7, r7
 801e80a:	fb83 3007 	smull	r3, r0, r3, r7
 801e80e:	17fe      	asrs	r6, r7, #31
 801e810:	4438      	add	r0, r7
 801e812:	ebc6 1060 	rsb	r0, r6, r0, asr #5
 801e816:	f003 f889 	bl	802192c <labs>
 801e81a:	4bc2      	ldr	r3, [pc, #776]	; (801eb24 <__strftime+0x7c0>)
 801e81c:	fb83 3200 	smull	r3, r2, r3, r0
 801e820:	4bc1      	ldr	r3, [pc, #772]	; (801eb28 <__strftime+0x7c4>)
 801e822:	4402      	add	r2, r0
 801e824:	fb83 1307 	smull	r1, r3, r3, r7
 801e828:	17c1      	asrs	r1, r0, #31
 801e82a:	ebc1 1162 	rsb	r1, r1, r2, asr #5
 801e82e:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 801e832:	eba0 0081 	sub.w	r0, r0, r1, lsl #2
 801e836:	443b      	add	r3, r7
 801e838:	9000      	str	r0, [sp, #0]
 801e83a:	ebab 010a 	sub.w	r1, fp, sl
 801e83e:	ebc6 23e3 	rsb	r3, r6, r3, asr #11
 801e842:	4620      	mov	r0, r4
 801e844:	4ab9      	ldr	r2, [pc, #740]	; (801eb2c <__strftime+0x7c8>)
 801e846:	f003 fbf5 	bl	8022034 <sniprintf>
 801e84a:	2800      	cmp	r0, #0
 801e84c:	f6ff ae1f 	blt.w	801e48e <__strftime+0x12a>
 801e850:	4482      	add	sl, r0
 801e852:	45d3      	cmp	fp, sl
 801e854:	f67f ae1b 	bls.w	801e48e <__strftime+0x12a>
 801e858:	2301      	movs	r3, #1
 801e85a:	9303      	str	r3, [sp, #12]
 801e85c:	e64c      	b.n	801e4f8 <__strftime+0x194>
 801e85e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 801e862:	4ab3      	ldr	r2, [pc, #716]	; (801eb30 <__strftime+0x7cc>)
 801e864:	3301      	adds	r3, #1
 801e866:	e63c      	b.n	801e4e2 <__strftime+0x17e>
 801e868:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 801e86c:	459a      	cmp	sl, r3
 801e86e:	f4bf ae0e 	bcs.w	801e48e <__strftime+0x12a>
 801e872:	230a      	movs	r3, #10
 801e874:	f809 300a 	strb.w	r3, [r9, sl]
 801e878:	f10a 0a01 	add.w	sl, sl, #1
 801e87c:	e63c      	b.n	801e4f8 <__strftime+0x194>
 801e87e:	4bad      	ldr	r3, [pc, #692]	; (801eb34 <__strftime+0x7d0>)
 801e880:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
 801e884:	4620      	mov	r0, r4
 801e886:	f7e5 fedb 	bl	8004640 <strlen>
 801e88a:	e73a      	b.n	801e702 <__strftime+0x39e>
 801e88c:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801e890:	2b00      	cmp	r3, #0
 801e892:	f280 8203 	bge.w	801ec9c <__strftime+0x938>
 801e896:	2300      	movs	r3, #0
 801e898:	2400      	movs	r4, #0
 801e89a:	e9cd 3406 	strd	r3, r4, [sp, #24]
 801e89e:	f8d8 6014 	ldr.w	r6, [r8, #20]
 801e8a2:	f1b6 0245 	subs.w	r2, r6, #69	; 0x45
 801e8a6:	ea4f 71e6 	mov.w	r1, r6, asr #31
 801e8aa:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
 801e8ae:	2a00      	cmp	r2, #0
 801e8b0:	f173 0400 	sbcs.w	r4, r3, #0
 801e8b4:	ebab 0e0a 	sub.w	lr, fp, sl
 801e8b8:	eb09 0c0a 	add.w	ip, r9, sl
 801e8bc:	f2c0 8278 	blt.w	801edb0 <__strftime+0xa4c>
 801e8c0:	0891      	lsrs	r1, r2, #2
 801e8c2:	ea41 7183 	orr.w	r1, r1, r3, lsl #30
 801e8c6:	9104      	str	r1, [sp, #16]
 801e8c8:	109b      	asrs	r3, r3, #2
 801e8ca:	499b      	ldr	r1, [pc, #620]	; (801eb38 <__strftime+0x7d4>)
 801e8cc:	9305      	str	r3, [sp, #20]
 801e8ce:	1e72      	subs	r2, r6, #1
 801e8d0:	4b99      	ldr	r3, [pc, #612]	; (801eb38 <__strftime+0x7d4>)
 801e8d2:	fb81 1402 	smull	r1, r4, r1, r2
 801e8d6:	17d0      	asrs	r0, r2, #31
 801e8d8:	f206 112b 	addw	r1, r6, #299	; 0x12b
 801e8dc:	ebc0 1064 	rsb	r0, r0, r4, asr #5
 801e8e0:	fb83 3401 	smull	r3, r4, r3, r1
 801e8e4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801e8e8:	17c9      	asrs	r1, r1, #31
 801e8ea:	1a12      	subs	r2, r2, r0
 801e8ec:	ebc1 11e4 	rsb	r1, r1, r4, asr #7
 801e8f0:	eb63 73e0 	sbc.w	r3, r3, r0, asr #31
 801e8f4:	3e46      	subs	r6, #70	; 0x46
 801e8f6:	f240 106d 	movw	r0, #365	; 0x16d
 801e8fa:	f8d8 401c 	ldr.w	r4, [r8, #28]
 801e8fe:	fb00 f606 	mul.w	r6, r0, r6
 801e902:	1852      	adds	r2, r2, r1
 801e904:	eb43 73e1 	adc.w	r3, r3, r1, asr #31
 801e908:	1992      	adds	r2, r2, r6
 801e90a:	eb43 73e6 	adc.w	r3, r3, r6, asr #31
 801e90e:	1916      	adds	r6, r2, r4
 801e910:	eb43 77e4 	adc.w	r7, r3, r4, asr #31
 801e914:	19b2      	adds	r2, r6, r6
 801e916:	eb47 0307 	adc.w	r3, r7, r7
 801e91a:	1992      	adds	r2, r2, r6
 801e91c:	f8d8 0008 	ldr.w	r0, [r8, #8]
 801e920:	f8d8 1004 	ldr.w	r1, [r8, #4]
 801e924:	417b      	adcs	r3, r7
 801e926:	00dc      	lsls	r4, r3, #3
 801e928:	00d6      	lsls	r6, r2, #3
 801e92a:	1836      	adds	r6, r6, r0
 801e92c:	ea44 7452 	orr.w	r4, r4, r2, lsr #29
 801e930:	eb44 77e0 	adc.w	r7, r4, r0, asr #31
 801e934:	0138      	lsls	r0, r7, #4
 801e936:	0132      	lsls	r2, r6, #4
 801e938:	1b92      	subs	r2, r2, r6
 801e93a:	ea40 7316 	orr.w	r3, r0, r6, lsr #28
 801e93e:	eb63 0307 	sbc.w	r3, r3, r7
 801e942:	0098      	lsls	r0, r3, #2
 801e944:	0094      	lsls	r4, r2, #2
 801e946:	ea40 7092 	orr.w	r0, r0, r2, lsr #30
 801e94a:	1862      	adds	r2, r4, r1
 801e94c:	eb40 73e1 	adc.w	r3, r0, r1, asr #31
 801e950:	0119      	lsls	r1, r3, #4
 801e952:	0116      	lsls	r6, r2, #4
 801e954:	1ab6      	subs	r6, r6, r2
 801e956:	ea41 7712 	orr.w	r7, r1, r2, lsr #28
 801e95a:	eb67 0703 	sbc.w	r7, r7, r3
 801e95e:	f8d8 3000 	ldr.w	r3, [r8]
 801e962:	4a76      	ldr	r2, [pc, #472]	; (801eb3c <__strftime+0x7d8>)
 801e964:	00b9      	lsls	r1, r7, #2
 801e966:	00b0      	lsls	r0, r6, #2
 801e968:	ea41 7196 	orr.w	r1, r1, r6, lsr #30
 801e96c:	18c6      	adds	r6, r0, r3
 801e96e:	eb41 77e3 	adc.w	r7, r1, r3, asr #31
 801e972:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
 801e976:	1af3      	subs	r3, r6, r3
 801e978:	eb67 0404 	sbc.w	r4, r7, r4
 801e97c:	461e      	mov	r6, r3
 801e97e:	4627      	mov	r7, r4
 801e980:	4671      	mov	r1, lr
 801e982:	4660      	mov	r0, ip
 801e984:	e9cd 6700 	strd	r6, r7, [sp]
 801e988:	f003 fb54 	bl	8022034 <sniprintf>
 801e98c:	2800      	cmp	r0, #0
 801e98e:	f6bf adb0 	bge.w	801e4f2 <__strftime+0x18e>
 801e992:	e57c      	b.n	801e48e <__strftime+0x12a>
 801e994:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 801e998:	459a      	cmp	sl, r3
 801e99a:	f4bf ad78 	bcs.w	801e48e <__strftime+0x12a>
 801e99e:	2309      	movs	r3, #9
 801e9a0:	f809 300a 	strb.w	r3, [r9, sl]
 801e9a4:	f10a 0a01 	add.w	sl, sl, #1
 801e9a8:	e5a6      	b.n	801e4f8 <__strftime+0x194>
 801e9aa:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 801e9ae:	459a      	cmp	sl, r3
 801e9b0:	f4bf ad6d 	bcs.w	801e48e <__strftime+0x12a>
 801e9b4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 801e9b8:	3330      	adds	r3, #48	; 0x30
 801e9ba:	f809 300a 	strb.w	r3, [r9, sl]
 801e9be:	f10a 0a01 	add.w	sl, sl, #1
 801e9c2:	e599      	b.n	801e4f8 <__strftime+0x194>
 801e9c4:	4b5b      	ldr	r3, [pc, #364]	; (801eb34 <__strftime+0x7d0>)
 801e9c6:	f8d3 409c 	ldr.w	r4, [r3, #156]	; 0x9c
 801e9ca:	4620      	mov	r0, r4
 801e9cc:	f7e5 fe38 	bl	8004640 <strlen>
 801e9d0:	e697      	b.n	801e702 <__strftime+0x39e>
 801e9d2:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 801e9d6:	459a      	cmp	sl, r3
 801e9d8:	f4bf ad59 	bcs.w	801e48e <__strftime+0x12a>
 801e9dc:	f8d8 3018 	ldr.w	r3, [r8, #24]
 801e9e0:	2b00      	cmp	r3, #0
 801e9e2:	d1e9      	bne.n	801e9b8 <__strftime+0x654>
 801e9e4:	2337      	movs	r3, #55	; 0x37
 801e9e6:	f809 300a 	strb.w	r3, [r9, sl]
 801e9ea:	f10a 0a01 	add.w	sl, sl, #1
 801e9ee:	e583      	b.n	801e4f8 <__strftime+0x194>
 801e9f0:	f8d8 2004 	ldr.w	r2, [r8, #4]
 801e9f4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801e9f8:	9200      	str	r2, [sp, #0]
 801e9fa:	4a51      	ldr	r2, [pc, #324]	; (801eb40 <__strftime+0x7dc>)
 801e9fc:	ebab 010a 	sub.w	r1, fp, sl
 801ea00:	eb09 000a 	add.w	r0, r9, sl
 801ea04:	f003 fb16 	bl	8022034 <sniprintf>
 801ea08:	2800      	cmp	r0, #0
 801ea0a:	f6bf ad72 	bge.w	801e4f2 <__strftime+0x18e>
 801ea0e:	e53e      	b.n	801e48e <__strftime+0x12a>
 801ea10:	f8d8 3000 	ldr.w	r3, [r8]
 801ea14:	4a46      	ldr	r2, [pc, #280]	; (801eb30 <__strftime+0x7cc>)
 801ea16:	e564      	b.n	801e4e2 <__strftime+0x17e>
 801ea18:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 801ea1c:	9200      	str	r2, [sp, #0]
 801ea1e:	4a49      	ldr	r2, [pc, #292]	; (801eb44 <__strftime+0x7e0>)
 801ea20:	9101      	str	r1, [sp, #4]
 801ea22:	ebab 010a 	sub.w	r1, fp, sl
 801ea26:	eb09 000a 	add.w	r0, r9, sl
 801ea2a:	f003 fb03 	bl	8022034 <sniprintf>
 801ea2e:	2800      	cmp	r0, #0
 801ea30:	f6bf ad5f 	bge.w	801e4f2 <__strftime+0x18e>
 801ea34:	e52b      	b.n	801e48e <__strftime+0x12a>
 801ea36:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801ea3a:	f8d8 1018 	ldr.w	r1, [r8, #24]
 801ea3e:	4a3c      	ldr	r2, [pc, #240]	; (801eb30 <__strftime+0x7cc>)
 801ea40:	3307      	adds	r3, #7
 801ea42:	1a59      	subs	r1, r3, r1
 801ea44:	4b40      	ldr	r3, [pc, #256]	; (801eb48 <__strftime+0x7e4>)
 801ea46:	fb83 0301 	smull	r0, r3, r3, r1
 801ea4a:	440b      	add	r3, r1
 801ea4c:	17c9      	asrs	r1, r1, #31
 801ea4e:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 801ea52:	e546      	b.n	801e4e2 <__strftime+0x17e>
 801ea54:	4640      	mov	r0, r8
 801ea56:	f7ff fc1b 	bl	801e290 <iso_year_adjust>
 801ea5a:	f8d8 2018 	ldr.w	r2, [r8, #24]
 801ea5e:	2a00      	cmp	r2, #0
 801ea60:	f000 8146 	beq.w	801ecf0 <__strftime+0x98c>
 801ea64:	3a01      	subs	r2, #1
 801ea66:	2800      	cmp	r0, #0
 801ea68:	f340 818a 	ble.w	801ed80 <__strftime+0xa1c>
 801ea6c:	2301      	movs	r3, #1
 801ea6e:	e537      	b.n	801e4e0 <__strftime+0x17c>
 801ea70:	f8d8 1018 	ldr.w	r1, [r8, #24]
 801ea74:	2900      	cmp	r1, #0
 801ea76:	f000 813d 	beq.w	801ecf4 <__strftime+0x990>
 801ea7a:	3901      	subs	r1, #1
 801ea7c:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801ea80:	e7dd      	b.n	801ea3e <__strftime+0x6da>
 801ea82:	4b2c      	ldr	r3, [pc, #176]	; (801eb34 <__strftime+0x7d0>)
 801ea84:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
 801ea88:	4620      	mov	r0, r4
 801ea8a:	f7e5 fdd9 	bl	8004640 <strlen>
 801ea8e:	e638      	b.n	801e702 <__strftime+0x39e>
 801ea90:	f8d8 3014 	ldr.w	r3, [r8, #20]
 801ea94:	4a2d      	ldr	r2, [pc, #180]	; (801eb4c <__strftime+0x7e8>)
 801ea96:	4293      	cmp	r3, r2
 801ea98:	f280 8133 	bge.w	801ed02 <__strftime+0x99e>
 801ea9c:	212d      	movs	r1, #45	; 0x2d
 801ea9e:	1ad3      	subs	r3, r2, r3
 801eaa0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801eaa4:	2e00      	cmp	r6, #0
 801eaa6:	f040 80cf 	bne.w	801ec48 <__strftime+0x8e4>
 801eaaa:	f10d 0029 	add.w	r0, sp, #41	; 0x29
 801eaae:	af0a      	add	r7, sp, #40	; 0x28
 801eab0:	2225      	movs	r2, #37	; 0x25
 801eab2:	7002      	strb	r2, [r0, #0]
 801eab4:	2c00      	cmp	r4, #0
 801eab6:	f040 80ed 	bne.w	801ec94 <__strftime+0x930>
 801eaba:	3001      	adds	r0, #1
 801eabc:	4924      	ldr	r1, [pc, #144]	; (801eb50 <__strftime+0x7ec>)
 801eabe:	9306      	str	r3, [sp, #24]
 801eac0:	f7fd fc5c 	bl	801c37c <strcpy>
 801eac4:	9b06      	ldr	r3, [sp, #24]
 801eac6:	9300      	str	r3, [sp, #0]
 801eac8:	463a      	mov	r2, r7
 801eaca:	4633      	mov	r3, r6
 801eacc:	e796      	b.n	801e9fc <__strftime+0x698>
 801eace:	4818      	ldr	r0, [pc, #96]	; (801eb30 <__strftime+0x7cc>)
 801ead0:	4a20      	ldr	r2, [pc, #128]	; (801eb54 <__strftime+0x7f0>)
 801ead2:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801ead6:	296b      	cmp	r1, #107	; 0x6b
 801ead8:	bf18      	it	ne
 801eada:	4602      	movne	r2, r0
 801eadc:	e501      	b.n	801e4e2 <__strftime+0x17e>
 801eade:	f8d8 3004 	ldr.w	r3, [r8, #4]
 801eae2:	4a13      	ldr	r2, [pc, #76]	; (801eb30 <__strftime+0x7cc>)
 801eae4:	e4fd      	b.n	801e4e2 <__strftime+0x17e>
 801eae6:	f8d8 2008 	ldr.w	r2, [r8, #8]
 801eaea:	4b12      	ldr	r3, [pc, #72]	; (801eb34 <__strftime+0x7d0>)
 801eaec:	2a0b      	cmp	r2, #11
 801eaee:	bfcc      	ite	gt
 801eaf0:	22a4      	movgt	r2, #164	; 0xa4
 801eaf2:	22a0      	movle	r2, #160	; 0xa0
 801eaf4:	4413      	add	r3, r2
 801eaf6:	685c      	ldr	r4, [r3, #4]
 801eaf8:	4620      	mov	r0, r4
 801eafa:	f7e5 fda1 	bl	8004640 <strlen>
 801eafe:	2800      	cmp	r0, #0
 801eb00:	f43f acfa 	beq.w	801e4f8 <__strftime+0x194>
 801eb04:	f10b 31ff 	add.w	r1, fp, #4294967295	; 0xffffffff
 801eb08:	458a      	cmp	sl, r1
 801eb0a:	f4bf acc0 	bcs.w	801e48e <__strftime+0x12a>
 801eb0e:	eb0a 0200 	add.w	r2, sl, r0
 801eb12:	eb09 070a 	add.w	r7, r9, sl
 801eb16:	f8cd 9018 	str.w	r9, [sp, #24]
 801eb1a:	f8cd 8020 	str.w	r8, [sp, #32]
 801eb1e:	4689      	mov	r9, r1
 801eb20:	4690      	mov	r8, r2
 801eb22:	e024      	b.n	801eb6e <__strftime+0x80a>
 801eb24:	88888889 	.word	0x88888889
 801eb28:	91a2b3c5 	.word	0x91a2b3c5
 801eb2c:	0802517c 	.word	0x0802517c
 801eb30:	08025124 	.word	0x08025124
 801eb34:	08024cf8 	.word	0x08024cf8
 801eb38:	51eb851f 	.word	0x51eb851f
 801eb3c:	08025164 	.word	0x08025164
 801eb40:	08025158 	.word	0x08025158
 801eb44:	0802516c 	.word	0x0802516c
 801eb48:	92492493 	.word	0x92492493
 801eb4c:	fffff894 	.word	0xfffff894
 801eb50:	0802514c 	.word	0x0802514c
 801eb54:	0802512c 	.word	0x0802512c
 801eb58:	7823      	ldrb	r3, [r4, #0]
 801eb5a:	f807 3b01 	strb.w	r3, [r7], #1
 801eb5e:	45c2      	cmp	sl, r8
 801eb60:	f104 0401 	add.w	r4, r4, #1
 801eb64:	f000 80f0 	beq.w	801ed48 <__strftime+0x9e4>
 801eb68:	45ca      	cmp	sl, r9
 801eb6a:	f4bf ac90 	bcs.w	801e48e <__strftime+0x12a>
 801eb6e:	782b      	ldrb	r3, [r5, #0]
 801eb70:	2b50      	cmp	r3, #80	; 0x50
 801eb72:	f10a 0a01 	add.w	sl, sl, #1
 801eb76:	d1ef      	bne.n	801eb58 <__strftime+0x7f4>
 801eb78:	7826      	ldrb	r6, [r4, #0]
 801eb7a:	f7fb ffed 	bl	801ab58 <__locale_ctype_ptr>
 801eb7e:	4430      	add	r0, r6
 801eb80:	7843      	ldrb	r3, [r0, #1]
 801eb82:	f003 0303 	and.w	r3, r3, #3
 801eb86:	2b01      	cmp	r3, #1
 801eb88:	bf08      	it	eq
 801eb8a:	3620      	addeq	r6, #32
 801eb8c:	b2f3      	uxtb	r3, r6
 801eb8e:	e7e4      	b.n	801eb5a <__strftime+0x7f6>
 801eb90:	2325      	movs	r3, #37	; 0x25
 801eb92:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 801eb96:	2c00      	cmp	r4, #0
 801eb98:	f000 809a 	beq.w	801ecd0 <__strftime+0x96c>
 801eb9c:	2e05      	cmp	r6, #5
 801eb9e:	f88d 4029 	strb.w	r4, [sp, #41]	; 0x29
 801eba2:	f200 80da 	bhi.w	801ed5a <__strftime+0x9f6>
 801eba6:	f10d 042a 	add.w	r4, sp, #42	; 0x2a
 801ebaa:	4620      	mov	r0, r4
 801ebac:	49b4      	ldr	r1, [pc, #720]	; (801ee80 <__strftime+0xb1c>)
 801ebae:	f7fd fbe5 	bl	801c37c <strcpy>
 801ebb2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801ebb4:	9300      	str	r3, [sp, #0]
 801ebb6:	aa0a      	add	r2, sp, #40	; 0x28
 801ebb8:	4643      	mov	r3, r8
 801ebba:	e5aa      	b.n	801e712 <__strftime+0x3ae>
 801ebbc:	4ab1      	ldr	r2, [pc, #708]	; (801ee84 <__strftime+0xb20>)
 801ebbe:	f8d8 3014 	ldr.w	r3, [r8, #20]
 801ebc2:	9308      	str	r3, [sp, #32]
 801ebc4:	4293      	cmp	r3, r2
 801ebc6:	bfac      	ite	ge
 801ebc8:	2200      	movge	r2, #0
 801ebca:	2201      	movlt	r2, #1
 801ebcc:	4640      	mov	r0, r8
 801ebce:	9206      	str	r2, [sp, #24]
 801ebd0:	f7ff fb5e 	bl	801e290 <iso_year_adjust>
 801ebd4:	9b08      	ldr	r3, [sp, #32]
 801ebd6:	9a06      	ldr	r2, [sp, #24]
 801ebd8:	2b00      	cmp	r3, #0
 801ebda:	4601      	mov	r1, r0
 801ebdc:	f2c0 8123 	blt.w	801ee26 <__strftime+0xac2>
 801ebe0:	48a9      	ldr	r0, [pc, #676]	; (801ee88 <__strftime+0xb24>)
 801ebe2:	fb80 0703 	smull	r0, r7, r0, r3
 801ebe6:	17d8      	asrs	r0, r3, #31
 801ebe8:	ebc0 1767 	rsb	r7, r0, r7, asr #5
 801ebec:	3713      	adds	r7, #19
 801ebee:	469c      	mov	ip, r3
 801ebf0:	48a5      	ldr	r0, [pc, #660]	; (801ee88 <__strftime+0xb24>)
 801ebf2:	fb80 e00c 	smull	lr, r0, r0, ip
 801ebf6:	ea4f 7eec 	mov.w	lr, ip, asr #31
 801ebfa:	ebce 1e60 	rsb	lr, lr, r0, asr #5
 801ebfe:	2064      	movs	r0, #100	; 0x64
 801ec00:	fb00 ce1e 	mls	lr, r0, lr, ip
 801ec04:	2900      	cmp	r1, #0
 801ec06:	f2c0 80ca 	blt.w	801ed9e <__strftime+0xa3a>
 801ec0a:	f000 80aa 	beq.w	801ed62 <__strftime+0x9fe>
 801ec0e:	4a9d      	ldr	r2, [pc, #628]	; (801ee84 <__strftime+0xb20>)
 801ec10:	4293      	cmp	r3, r2
 801ec12:	bfb6      	itet	lt
 801ec14:	f04f 31ff 	movlt.w	r1, #4294967295	; 0xffffffff
 801ec18:	2200      	movge	r2, #0
 801ec1a:	2201      	movlt	r2, #1
 801ec1c:	448e      	add	lr, r1
 801ec1e:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
 801ec22:	f000 80a2 	beq.w	801ed6a <__strftime+0xa06>
 801ec26:	f1be 0f64 	cmp.w	lr, #100	; 0x64
 801ec2a:	bf04      	itt	eq
 801ec2c:	3701      	addeq	r7, #1
 801ec2e:	f04f 0e00 	moveq.w	lr, #0
 801ec32:	2364      	movs	r3, #100	; 0x64
 801ec34:	fb03 e307 	mla	r3, r3, r7, lr
 801ec38:	2a00      	cmp	r2, #0
 801ec3a:	d05d      	beq.n	801ecf8 <__strftime+0x994>
 801ec3c:	222d      	movs	r2, #45	; 0x2d
 801ec3e:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
 801ec42:	2e00      	cmp	r6, #0
 801ec44:	f43f af31 	beq.w	801eaaa <__strftime+0x746>
 801ec48:	3e01      	subs	r6, #1
 801ec4a:	e72e      	b.n	801eaaa <__strftime+0x746>
 801ec4c:	f8d8 2008 	ldr.w	r2, [r8, #8]
 801ec50:	2a00      	cmp	r2, #0
 801ec52:	d066      	beq.n	801ed22 <__strftime+0x9be>
 801ec54:	2a0c      	cmp	r2, #12
 801ec56:	f000 80b9 	beq.w	801edcc <__strftime+0xa68>
 801ec5a:	4b8c      	ldr	r3, [pc, #560]	; (801ee8c <__strftime+0xb28>)
 801ec5c:	fb83 3002 	smull	r3, r0, r3, r2
 801ec60:	17d3      	asrs	r3, r2, #31
 801ec62:	ebc3 0360 	rsb	r3, r3, r0, asr #1
 801ec66:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ec6a:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 801ec6e:	4888      	ldr	r0, [pc, #544]	; (801ee90 <__strftime+0xb2c>)
 801ec70:	4a88      	ldr	r2, [pc, #544]	; (801ee94 <__strftime+0xb30>)
 801ec72:	2949      	cmp	r1, #73	; 0x49
 801ec74:	bf18      	it	ne
 801ec76:	4602      	movne	r2, r0
 801ec78:	e433      	b.n	801e4e2 <__strftime+0x17e>
 801ec7a:	f242 720f 	movw	r2, #9999	; 0x270f
 801ec7e:	4293      	cmp	r3, r2
 801ec80:	d949      	bls.n	801ed16 <__strftime+0x9b2>
 801ec82:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
 801ec86:	2e00      	cmp	r6, #0
 801ec88:	d1de      	bne.n	801ec48 <__strftime+0x8e4>
 801ec8a:	a812      	add	r0, sp, #72	; 0x48
 801ec8c:	2225      	movs	r2, #37	; 0x25
 801ec8e:	f800 2d1f 	strb.w	r2, [r0, #-31]!
 801ec92:	af0a      	add	r7, sp, #40	; 0x28
 801ec94:	2230      	movs	r2, #48	; 0x30
 801ec96:	7042      	strb	r2, [r0, #1]
 801ec98:	3002      	adds	r0, #2
 801ec9a:	e70f      	b.n	801eabc <__strftime+0x758>
 801ec9c:	f7fc fe2c 	bl	801b8f8 <__tz_lock>
 801eca0:	9b03      	ldr	r3, [sp, #12]
 801eca2:	2b00      	cmp	r3, #0
 801eca4:	f000 808c 	beq.w	801edc0 <__strftime+0xa5c>
 801eca8:	f7fd f822 	bl	801bcf0 <__gettzinfo>
 801ecac:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801ecb0:	2b00      	cmp	r3, #0
 801ecb2:	bfcc      	ite	gt
 801ecb4:	231c      	movgt	r3, #28
 801ecb6:	2300      	movle	r3, #0
 801ecb8:	4403      	add	r3, r0
 801ecba:	2201      	movs	r2, #1
 801ecbc:	6a1e      	ldr	r6, [r3, #32]
 801ecbe:	9203      	str	r2, [sp, #12]
 801ecc0:	4276      	negs	r6, r6
 801ecc2:	f7fc fe1f 	bl	801b904 <__tz_unlock>
 801ecc6:	17f4      	asrs	r4, r6, #31
 801ecc8:	4633      	mov	r3, r6
 801ecca:	e9cd 3406 	strd	r3, r4, [sp, #24]
 801ecce:	e5e6      	b.n	801e89e <__strftime+0x53a>
 801ecd0:	232b      	movs	r3, #43	; 0x2b
 801ecd2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801ecd6:	2304      	movs	r3, #4
 801ecd8:	f10d 042a 	add.w	r4, sp, #42	; 0x2a
 801ecdc:	4620      	mov	r0, r4
 801ecde:	4a6e      	ldr	r2, [pc, #440]	; (801ee98 <__strftime+0xb34>)
 801ece0:	211e      	movs	r1, #30
 801ece2:	f003 f9a7 	bl	8022034 <sniprintf>
 801ece6:	2800      	cmp	r0, #0
 801ece8:	f77f af5f 	ble.w	801ebaa <__strftime+0x846>
 801ecec:	4420      	add	r0, r4
 801ecee:	e75d      	b.n	801ebac <__strftime+0x848>
 801ecf0:	2206      	movs	r2, #6
 801ecf2:	e6b8      	b.n	801ea66 <__strftime+0x702>
 801ecf4:	2106      	movs	r1, #6
 801ecf6:	e6c1      	b.n	801ea7c <__strftime+0x718>
 801ecf8:	2c2b      	cmp	r4, #43	; 0x2b
 801ecfa:	d0be      	beq.n	801ec7a <__strftime+0x916>
 801ecfc:	af0a      	add	r7, sp, #40	; 0x28
 801ecfe:	4638      	mov	r0, r7
 801ed00:	e6d6      	b.n	801eab0 <__strftime+0x74c>
 801ed02:	2c2b      	cmp	r4, #43	; 0x2b
 801ed04:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801ed08:	d1f8      	bne.n	801ecfc <__strftime+0x998>
 801ed0a:	f242 720f 	movw	r2, #9999	; 0x270f
 801ed0e:	4293      	cmp	r3, r2
 801ed10:	d8b7      	bhi.n	801ec82 <__strftime+0x91e>
 801ed12:	2e00      	cmp	r6, #0
 801ed14:	d0f2      	beq.n	801ecfc <__strftime+0x998>
 801ed16:	af12      	add	r7, sp, #72	; 0x48
 801ed18:	2225      	movs	r2, #37	; 0x25
 801ed1a:	f807 2d20 	strb.w	r2, [r7, #-32]!
 801ed1e:	4638      	mov	r0, r7
 801ed20:	e7b8      	b.n	801ec94 <__strftime+0x930>
 801ed22:	230c      	movs	r3, #12
 801ed24:	e7a3      	b.n	801ec6e <__strftime+0x90a>
 801ed26:	4c5d      	ldr	r4, [pc, #372]	; (801ee9c <__strftime+0xb38>)
 801ed28:	4a5d      	ldr	r2, [pc, #372]	; (801eea0 <__strftime+0xb3c>)
 801ed2a:	4856      	ldr	r0, [pc, #344]	; (801ee84 <__strftime+0xb20>)
 801ed2c:	9101      	str	r1, [sp, #4]
 801ed2e:	495d      	ldr	r1, [pc, #372]	; (801eea4 <__strftime+0xb40>)
 801ed30:	2e02      	cmp	r6, #2
 801ed32:	bf2c      	ite	cs
 801ed34:	ebc3 0606 	rsbcs	r6, r3, r6
 801ed38:	f1c3 0602 	rsbcc	r6, r3, #2
 801ed3c:	9600      	str	r6, [sp, #0]
 801ed3e:	4287      	cmp	r7, r0
 801ed40:	bfac      	ite	ge
 801ed42:	4623      	movge	r3, r4
 801ed44:	460b      	movlt	r3, r1
 801ed46:	e66c      	b.n	801ea22 <__strftime+0x6be>
 801ed48:	f8dd 9018 	ldr.w	r9, [sp, #24]
 801ed4c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801ed50:	f7ff bbd2 	b.w	801e4f8 <__strftime+0x194>
 801ed54:	4c51      	ldr	r4, [pc, #324]	; (801ee9c <__strftime+0xb38>)
 801ed56:	4a54      	ldr	r2, [pc, #336]	; (801eea8 <__strftime+0xb44>)
 801ed58:	e7e7      	b.n	801ed2a <__strftime+0x9c6>
 801ed5a:	1fb3      	subs	r3, r6, #6
 801ed5c:	f43f af23 	beq.w	801eba6 <__strftime+0x842>
 801ed60:	e7ba      	b.n	801ecd8 <__strftime+0x974>
 801ed62:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
 801ed66:	f47f af64 	bne.w	801ec32 <__strftime+0x8ce>
 801ed6a:	3f01      	subs	r7, #1
 801ed6c:	f04f 0e63 	mov.w	lr, #99	; 0x63
 801ed70:	e75f      	b.n	801ec32 <__strftime+0x8ce>
 801ed72:	4b4e      	ldr	r3, [pc, #312]	; (801eeac <__strftime+0xb48>)
 801ed74:	f8d8 1014 	ldr.w	r1, [r8, #20]
 801ed78:	4299      	cmp	r1, r3
 801ed7a:	bfb8      	it	lt
 801ed7c:	2401      	movlt	r4, #1
 801ed7e:	e4f9      	b.n	801e774 <__strftime+0x410>
 801ed80:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801ed84:	f040 8096 	bne.w	801eeb4 <__strftime+0xb50>
 801ed88:	330a      	adds	r3, #10
 801ed8a:	1a9b      	subs	r3, r3, r2
 801ed8c:	4a48      	ldr	r2, [pc, #288]	; (801eeb0 <__strftime+0xb4c>)
 801ed8e:	fb82 1203 	smull	r1, r2, r2, r3
 801ed92:	441a      	add	r2, r3
 801ed94:	17db      	asrs	r3, r3, #31
 801ed96:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 801ed9a:	f7ff bba1 	b.w	801e4e0 <__strftime+0x17c>
 801ed9e:	4843      	ldr	r0, [pc, #268]	; (801eeac <__strftime+0xb48>)
 801eda0:	f8d8 3014 	ldr.w	r3, [r8, #20]
 801eda4:	4283      	cmp	r3, r0
 801eda6:	f6bf af39 	bge.w	801ec1c <__strftime+0x8b8>
 801edaa:	2101      	movs	r1, #1
 801edac:	460a      	mov	r2, r1
 801edae:	e735      	b.n	801ec1c <__strftime+0x8b8>
 801edb0:	f1b6 0242 	subs.w	r2, r6, #66	; 0x42
 801edb4:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
 801edb8:	e582      	b.n	801e8c0 <__strftime+0x55c>
 801edba:	f7fc fda9 	bl	801b910 <_tzset_unlocked>
 801edbe:	e514      	b.n	801e7ea <__strftime+0x486>
 801edc0:	f7fc fda6 	bl	801b910 <_tzset_unlocked>
 801edc4:	e770      	b.n	801eca8 <__strftime+0x944>
 801edc6:	f7fc fda3 	bl	801b910 <_tzset_unlocked>
 801edca:	e42e      	b.n	801e62a <__strftime+0x2c6>
 801edcc:	4613      	mov	r3, r2
 801edce:	e74e      	b.n	801ec6e <__strftime+0x90a>
 801edd0:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 801edd4:	9308      	str	r3, [sp, #32]
 801edd6:	9106      	str	r1, [sp, #24]
 801edd8:	f001 fc7e 	bl	80206d8 <abs>
 801eddc:	4b2a      	ldr	r3, [pc, #168]	; (801ee88 <__strftime+0xb24>)
 801edde:	9906      	ldr	r1, [sp, #24]
 801ede0:	fb83 3700 	smull	r3, r7, r3, r0
 801ede4:	17c2      	asrs	r2, r0, #31
 801ede6:	ebc2 1267 	rsb	r2, r2, r7, asr #5
 801edea:	2764      	movs	r7, #100	; 0x64
 801edec:	fb07 0212 	mls	r2, r7, r2, r0
 801edf0:	9b08      	ldr	r3, [sp, #32]
 801edf2:	e405      	b.n	801e600 <__strftime+0x29c>
 801edf4:	f207 706c 	addw	r0, r7, #1900	; 0x76c
 801edf8:	9306      	str	r3, [sp, #24]
 801edfa:	f001 fc6d 	bl	80206d8 <abs>
 801edfe:	4b22      	ldr	r3, [pc, #136]	; (801ee88 <__strftime+0xb24>)
 801ee00:	17c1      	asrs	r1, r0, #31
 801ee02:	fb83 3200 	smull	r3, r2, r3, r0
 801ee06:	ebc1 1162 	rsb	r1, r1, r2, asr #5
 801ee0a:	9b06      	ldr	r3, [sp, #24]
 801ee0c:	f7ff bbd1 	b.w	801e5b2 <__strftime+0x24e>
 801ee10:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 801ee14:	f001 fc60 	bl	80206d8 <abs>
 801ee18:	f7ff bb59 	b.w	801e4ce <__strftime+0x16a>
 801ee1c:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 801ee20:	f001 fc5a 	bl	80206d8 <abs>
 801ee24:	e491      	b.n	801e74a <__strftime+0x3e6>
 801ee26:	9009      	str	r0, [sp, #36]	; 0x24
 801ee28:	f203 706c 	addw	r0, r3, #1900	; 0x76c
 801ee2c:	9208      	str	r2, [sp, #32]
 801ee2e:	9306      	str	r3, [sp, #24]
 801ee30:	f001 fc52 	bl	80206d8 <abs>
 801ee34:	4b14      	ldr	r3, [pc, #80]	; (801ee88 <__strftime+0xb24>)
 801ee36:	f8d8 c014 	ldr.w	ip, [r8, #20]
 801ee3a:	9a08      	ldr	r2, [sp, #32]
 801ee3c:	9909      	ldr	r1, [sp, #36]	; 0x24
 801ee3e:	fb83 3700 	smull	r3, r7, r3, r0
 801ee42:	f1bc 0f00 	cmp.w	ip, #0
 801ee46:	ea4f 70e0 	mov.w	r0, r0, asr #31
 801ee4a:	ebc0 1767 	rsb	r7, r0, r7, asr #5
 801ee4e:	9b06      	ldr	r3, [sp, #24]
 801ee50:	f6bf aece 	bge.w	801ebf0 <__strftime+0x88c>
 801ee54:	f20c 706c 	addw	r0, ip, #1900	; 0x76c
 801ee58:	9309      	str	r3, [sp, #36]	; 0x24
 801ee5a:	9108      	str	r1, [sp, #32]
 801ee5c:	9206      	str	r2, [sp, #24]
 801ee5e:	f001 fc3b 	bl	80206d8 <abs>
 801ee62:	4b09      	ldr	r3, [pc, #36]	; (801ee88 <__strftime+0xb24>)
 801ee64:	9908      	ldr	r1, [sp, #32]
 801ee66:	9a06      	ldr	r2, [sp, #24]
 801ee68:	fb83 3c00 	smull	r3, ip, r3, r0
 801ee6c:	ea4f 7ee0 	mov.w	lr, r0, asr #31
 801ee70:	ebce 1e6c 	rsb	lr, lr, ip, asr #5
 801ee74:	f04f 0c64 	mov.w	ip, #100	; 0x64
 801ee78:	fb0c 0e1e 	mls	lr, ip, lr, r0
 801ee7c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ee7e:	e6c1      	b.n	801ec04 <__strftime+0x8a0>
 801ee80:	08025144 	.word	0x08025144
 801ee84:	fffff894 	.word	0xfffff894
 801ee88:	51eb851f 	.word	0x51eb851f
 801ee8c:	2aaaaaab 	.word	0x2aaaaaab
 801ee90:	0802512c 	.word	0x0802512c
 801ee94:	08025124 	.word	0x08025124
 801ee98:	08025140 	.word	0x08025140
 801ee9c:	08023558 	.word	0x08023558
 801eea0:	08025110 	.word	0x08025110
 801eea4:	08023478 	.word	0x08023478
 801eea8:	08025118 	.word	0x08025118
 801eeac:	fffff895 	.word	0xfffff895
 801eeb0:	92492493 	.word	0x92492493
 801eeb4:	f8d8 0014 	ldr.w	r0, [r8, #20]
 801eeb8:	2800      	cmp	r0, #0
 801eeba:	f240 716b 	movw	r1, #1899	; 0x76b
 801eebe:	bfa8      	it	ge
 801eec0:	f06f 0164 	mvnge.w	r1, #100	; 0x64
 801eec4:	4408      	add	r0, r1
 801eec6:	1ad3      	subs	r3, r2, r3
 801eec8:	0782      	lsls	r2, r0, #30
 801eeca:	d013      	beq.n	801eef4 <__strftime+0xb90>
 801eecc:	17c1      	asrs	r1, r0, #31
 801eece:	4a10      	ldr	r2, [pc, #64]	; (801ef10 <__strftime+0xbac>)
 801eed0:	fb82 4200 	smull	r4, r2, r2, r0
 801eed4:	ebc1 11e2 	rsb	r1, r1, r2, asr #7
 801eed8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801eedc:	fb02 0111 	mls	r1, r2, r1, r0
 801eee0:	fab1 f181 	clz	r1, r1
 801eee4:	0949      	lsrs	r1, r1, #5
 801eee6:	1a5b      	subs	r3, r3, r1
 801eee8:	2b04      	cmp	r3, #4
 801eeea:	bfcc      	ite	gt
 801eeec:	2334      	movgt	r3, #52	; 0x34
 801eeee:	2335      	movle	r3, #53	; 0x35
 801eef0:	f7ff baf6 	b.w	801e4e0 <__strftime+0x17c>
 801eef4:	4a06      	ldr	r2, [pc, #24]	; (801ef10 <__strftime+0xbac>)
 801eef6:	fb82 1200 	smull	r1, r2, r2, r0
 801eefa:	17c1      	asrs	r1, r0, #31
 801eefc:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 801ef00:	2464      	movs	r4, #100	; 0x64
 801ef02:	fb04 0212 	mls	r2, r4, r2, r0
 801ef06:	2a00      	cmp	r2, #0
 801ef08:	d0e1      	beq.n	801eece <__strftime+0xb6a>
 801ef0a:	2101      	movs	r1, #1
 801ef0c:	e7eb      	b.n	801eee6 <__strftime+0xb82>
 801ef0e:	bf00      	nop
 801ef10:	51eb851f 	.word	0x51eb851f

0801ef14 <strftime>:
 801ef14:	b530      	push	{r4, r5, lr}
 801ef16:	4c06      	ldr	r4, [pc, #24]	; (801ef30 <strftime+0x1c>)
 801ef18:	4d06      	ldr	r5, [pc, #24]	; (801ef34 <strftime+0x20>)
 801ef1a:	6824      	ldr	r4, [r4, #0]
 801ef1c:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801ef1e:	b083      	sub	sp, #12
 801ef20:	2c00      	cmp	r4, #0
 801ef22:	bf08      	it	eq
 801ef24:	462c      	moveq	r4, r5
 801ef26:	9400      	str	r4, [sp, #0]
 801ef28:	f7ff fa1c 	bl	801e364 <__strftime>
 801ef2c:	b003      	add	sp, #12
 801ef2e:	bd30      	pop	{r4, r5, pc}
 801ef30:	20004474 	.word	0x20004474
 801ef34:	200048a0 	.word	0x200048a0

0801ef38 <strncat>:
 801ef38:	0783      	lsls	r3, r0, #30
 801ef3a:	b430      	push	{r4, r5}
 801ef3c:	d125      	bne.n	801ef8a <strncat+0x52>
 801ef3e:	6804      	ldr	r4, [r0, #0]
 801ef40:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 801ef44:	ea23 0304 	bic.w	r3, r3, r4
 801ef48:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801ef4c:	4603      	mov	r3, r0
 801ef4e:	d108      	bne.n	801ef62 <strncat+0x2a>
 801ef50:	f853 5f04 	ldr.w	r5, [r3, #4]!
 801ef54:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 801ef58:	ea24 0405 	bic.w	r4, r4, r5
 801ef5c:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801ef60:	d0f6      	beq.n	801ef50 <strncat+0x18>
 801ef62:	781c      	ldrb	r4, [r3, #0]
 801ef64:	b11c      	cbz	r4, 801ef6e <strncat+0x36>
 801ef66:	f813 4f01 	ldrb.w	r4, [r3, #1]!
 801ef6a:	2c00      	cmp	r4, #0
 801ef6c:	d1fb      	bne.n	801ef66 <strncat+0x2e>
 801ef6e:	188d      	adds	r5, r1, r2
 801ef70:	e005      	b.n	801ef7e <strncat+0x46>
 801ef72:	f811 4b01 	ldrb.w	r4, [r1], #1
 801ef76:	f803 4b01 	strb.w	r4, [r3], #1
 801ef7a:	b124      	cbz	r4, 801ef86 <strncat+0x4e>
 801ef7c:	b13a      	cbz	r2, 801ef8e <strncat+0x56>
 801ef7e:	42a9      	cmp	r1, r5
 801ef80:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 801ef84:	d1f5      	bne.n	801ef72 <strncat+0x3a>
 801ef86:	bc30      	pop	{r4, r5}
 801ef88:	4770      	bx	lr
 801ef8a:	4603      	mov	r3, r0
 801ef8c:	e7e9      	b.n	801ef62 <strncat+0x2a>
 801ef8e:	701a      	strb	r2, [r3, #0]
 801ef90:	e7f9      	b.n	801ef86 <strncat+0x4e>
 801ef92:	bf00      	nop

0801ef94 <strncpy>:
 801ef94:	ea40 0301 	orr.w	r3, r0, r1
 801ef98:	f013 0f03 	tst.w	r3, #3
 801ef9c:	b470      	push	{r4, r5, r6}
 801ef9e:	4603      	mov	r3, r0
 801efa0:	d024      	beq.n	801efec <strncpy+0x58>
 801efa2:	b1a2      	cbz	r2, 801efce <strncpy+0x3a>
 801efa4:	780c      	ldrb	r4, [r1, #0]
 801efa6:	701c      	strb	r4, [r3, #0]
 801efa8:	3a01      	subs	r2, #1
 801efaa:	3301      	adds	r3, #1
 801efac:	3101      	adds	r1, #1
 801efae:	b13c      	cbz	r4, 801efc0 <strncpy+0x2c>
 801efb0:	b16a      	cbz	r2, 801efce <strncpy+0x3a>
 801efb2:	f811 4b01 	ldrb.w	r4, [r1], #1
 801efb6:	f803 4b01 	strb.w	r4, [r3], #1
 801efba:	3a01      	subs	r2, #1
 801efbc:	2c00      	cmp	r4, #0
 801efbe:	d1f7      	bne.n	801efb0 <strncpy+0x1c>
 801efc0:	b12a      	cbz	r2, 801efce <strncpy+0x3a>
 801efc2:	441a      	add	r2, r3
 801efc4:	2100      	movs	r1, #0
 801efc6:	f803 1b01 	strb.w	r1, [r3], #1
 801efca:	429a      	cmp	r2, r3
 801efcc:	d1fb      	bne.n	801efc6 <strncpy+0x32>
 801efce:	bc70      	pop	{r4, r5, r6}
 801efd0:	4770      	bx	lr
 801efd2:	460e      	mov	r6, r1
 801efd4:	f851 5b04 	ldr.w	r5, [r1], #4
 801efd8:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 801efdc:	ea24 0405 	bic.w	r4, r4, r5
 801efe0:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801efe4:	d105      	bne.n	801eff2 <strncpy+0x5e>
 801efe6:	f843 5b04 	str.w	r5, [r3], #4
 801efea:	3a04      	subs	r2, #4
 801efec:	2a03      	cmp	r2, #3
 801efee:	d8f0      	bhi.n	801efd2 <strncpy+0x3e>
 801eff0:	e7d7      	b.n	801efa2 <strncpy+0xe>
 801eff2:	4631      	mov	r1, r6
 801eff4:	e7d6      	b.n	801efa4 <strncpy+0x10>
 801eff6:	bf00      	nop

0801eff8 <_vfprintf_r>:
 801eff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801effc:	b0c3      	sub	sp, #268	; 0x10c
 801effe:	461d      	mov	r5, r3
 801f000:	468a      	mov	sl, r1
 801f002:	4691      	mov	r9, r2
 801f004:	4604      	mov	r4, r0
 801f006:	9008      	str	r0, [sp, #32]
 801f008:	f002 fc94 	bl	8021934 <_localeconv_r>
 801f00c:	6803      	ldr	r3, [r0, #0]
 801f00e:	9315      	str	r3, [sp, #84]	; 0x54
 801f010:	4618      	mov	r0, r3
 801f012:	f7e5 fb15 	bl	8004640 <strlen>
 801f016:	950e      	str	r5, [sp, #56]	; 0x38
 801f018:	9014      	str	r0, [sp, #80]	; 0x50
 801f01a:	b11c      	cbz	r4, 801f024 <_vfprintf_r+0x2c>
 801f01c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801f01e:	2b00      	cmp	r3, #0
 801f020:	f000 8262 	beq.w	801f4e8 <_vfprintf_r+0x4f0>
 801f024:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
 801f028:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
 801f02c:	f013 0f01 	tst.w	r3, #1
 801f030:	b293      	uxth	r3, r2
 801f032:	d102      	bne.n	801f03a <_vfprintf_r+0x42>
 801f034:	0599      	lsls	r1, r3, #22
 801f036:	f140 8278 	bpl.w	801f52a <_vfprintf_r+0x532>
 801f03a:	049f      	lsls	r7, r3, #18
 801f03c:	d40a      	bmi.n	801f054 <_vfprintf_r+0x5c>
 801f03e:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
 801f042:	f442 5300 	orr.w	r3, r2, #8192	; 0x2000
 801f046:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 801f04a:	f8aa 300c 	strh.w	r3, [sl, #12]
 801f04e:	f8ca 1064 	str.w	r1, [sl, #100]	; 0x64
 801f052:	b29b      	uxth	r3, r3
 801f054:	071e      	lsls	r6, r3, #28
 801f056:	f140 8226 	bpl.w	801f4a6 <_vfprintf_r+0x4ae>
 801f05a:	f8da 2010 	ldr.w	r2, [sl, #16]
 801f05e:	2a00      	cmp	r2, #0
 801f060:	f000 8221 	beq.w	801f4a6 <_vfprintf_r+0x4ae>
 801f064:	f003 021a 	and.w	r2, r3, #26
 801f068:	2a0a      	cmp	r2, #10
 801f06a:	f000 8241 	beq.w	801f4f0 <_vfprintf_r+0x4f8>
 801f06e:	ed9f 7b8e 	vldr	d7, [pc, #568]	; 801f2a8 <_vfprintf_r+0x2b0>
 801f072:	2300      	movs	r3, #0
 801f074:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 801f078:	9311      	str	r3, [sp, #68]	; 0x44
 801f07a:	9327      	str	r3, [sp, #156]	; 0x9c
 801f07c:	9326      	str	r3, [sp, #152]	; 0x98
 801f07e:	9316      	str	r3, [sp, #88]	; 0x58
 801f080:	9317      	str	r3, [sp, #92]	; 0x5c
 801f082:	930b      	str	r3, [sp, #44]	; 0x2c
 801f084:	ab32      	add	r3, sp, #200	; 0xc8
 801f086:	9325      	str	r3, [sp, #148]	; 0x94
 801f088:	4698      	mov	r8, r3
 801f08a:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 801f08e:	f899 3000 	ldrb.w	r3, [r9]
 801f092:	464c      	mov	r4, r9
 801f094:	b1eb      	cbz	r3, 801f0d2 <_vfprintf_r+0xda>
 801f096:	2b25      	cmp	r3, #37	; 0x25
 801f098:	d102      	bne.n	801f0a0 <_vfprintf_r+0xa8>
 801f09a:	e01a      	b.n	801f0d2 <_vfprintf_r+0xda>
 801f09c:	2b25      	cmp	r3, #37	; 0x25
 801f09e:	d003      	beq.n	801f0a8 <_vfprintf_r+0xb0>
 801f0a0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 801f0a4:	2b00      	cmp	r3, #0
 801f0a6:	d1f9      	bne.n	801f09c <_vfprintf_r+0xa4>
 801f0a8:	eba4 0509 	sub.w	r5, r4, r9
 801f0ac:	b18d      	cbz	r5, 801f0d2 <_vfprintf_r+0xda>
 801f0ae:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f0b0:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 801f0b2:	f8c8 9000 	str.w	r9, [r8]
 801f0b6:	3301      	adds	r3, #1
 801f0b8:	442a      	add	r2, r5
 801f0ba:	2b07      	cmp	r3, #7
 801f0bc:	f8c8 5004 	str.w	r5, [r8, #4]
 801f0c0:	9227      	str	r2, [sp, #156]	; 0x9c
 801f0c2:	9326      	str	r3, [sp, #152]	; 0x98
 801f0c4:	f300 8205 	bgt.w	801f4d2 <_vfprintf_r+0x4da>
 801f0c8:	f108 0808 	add.w	r8, r8, #8
 801f0cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f0ce:	442b      	add	r3, r5
 801f0d0:	930b      	str	r3, [sp, #44]	; 0x2c
 801f0d2:	7823      	ldrb	r3, [r4, #0]
 801f0d4:	2b00      	cmp	r3, #0
 801f0d6:	f000 83fe 	beq.w	801f8d6 <_vfprintf_r+0x8de>
 801f0da:	2300      	movs	r3, #0
 801f0dc:	461a      	mov	r2, r3
 801f0de:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 801f0e2:	4619      	mov	r1, r3
 801f0e4:	930c      	str	r3, [sp, #48]	; 0x30
 801f0e6:	469b      	mov	fp, r3
 801f0e8:	7866      	ldrb	r6, [r4, #1]
 801f0ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801f0ee:	f104 0901 	add.w	r9, r4, #1
 801f0f2:	9309      	str	r3, [sp, #36]	; 0x24
 801f0f4:	f109 0901 	add.w	r9, r9, #1
 801f0f8:	f1a6 0320 	sub.w	r3, r6, #32
 801f0fc:	2b58      	cmp	r3, #88	; 0x58
 801f0fe:	f200 83cd 	bhi.w	801f89c <_vfprintf_r+0x8a4>
 801f102:	e8df f013 	tbh	[pc, r3, lsl #1]
 801f106:	02e5      	.short	0x02e5
 801f108:	03cb03cb 	.word	0x03cb03cb
 801f10c:	03cb0354 	.word	0x03cb0354
 801f110:	03cb03cb 	.word	0x03cb03cb
 801f114:	03cb03cb 	.word	0x03cb03cb
 801f118:	035903cb 	.word	0x035903cb
 801f11c:	03cb030d 	.word	0x03cb030d
 801f120:	02ed021e 	.word	0x02ed021e
 801f124:	030803cb 	.word	0x030803cb
 801f128:	033f033f 	.word	0x033f033f
 801f12c:	033f033f 	.word	0x033f033f
 801f130:	033f033f 	.word	0x033f033f
 801f134:	033f033f 	.word	0x033f033f
 801f138:	03cb033f 	.word	0x03cb033f
 801f13c:	03cb03cb 	.word	0x03cb03cb
 801f140:	03cb03cb 	.word	0x03cb03cb
 801f144:	03cb03cb 	.word	0x03cb03cb
 801f148:	03cb03cb 	.word	0x03cb03cb
 801f14c:	034e03cb 	.word	0x034e03cb
 801f150:	03cb0367 	.word	0x03cb0367
 801f154:	03cb0367 	.word	0x03cb0367
 801f158:	03cb03cb 	.word	0x03cb03cb
 801f15c:	03b003cb 	.word	0x03b003cb
 801f160:	03cb03cb 	.word	0x03cb03cb
 801f164:	03cb006f 	.word	0x03cb006f
 801f168:	03cb03cb 	.word	0x03cb03cb
 801f16c:	03cb03cb 	.word	0x03cb03cb
 801f170:	03cb0059 	.word	0x03cb0059
 801f174:	032303cb 	.word	0x032303cb
 801f178:	03cb03cb 	.word	0x03cb03cb
 801f17c:	03cb03cb 	.word	0x03cb03cb
 801f180:	03cb03cb 	.word	0x03cb03cb
 801f184:	03cb03cb 	.word	0x03cb03cb
 801f188:	03cb03cb 	.word	0x03cb03cb
 801f18c:	02780329 	.word	0x02780329
 801f190:	03670367 	.word	0x03670367
 801f194:	02bc0367 	.word	0x02bc0367
 801f198:	03cb0278 	.word	0x03cb0278
 801f19c:	02c103cb 	.word	0x02c103cb
 801f1a0:	02ce03cb 	.word	0x02ce03cb
 801f1a4:	03120071 	.word	0x03120071
 801f1a8:	03cb024b 	.word	0x03cb024b
 801f1ac:	03cb0257 	.word	0x03cb0257
 801f1b0:	03cb005b 	.word	0x03cb005b
 801f1b4:	022303cb 	.word	0x022303cb
 801f1b8:	f04b 0b10 	orr.w	fp, fp, #16
 801f1bc:	f01b 0f20 	tst.w	fp, #32
 801f1c0:	f040 8361 	bne.w	801f886 <_vfprintf_r+0x88e>
 801f1c4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f1c6:	f01b 0f10 	tst.w	fp, #16
 801f1ca:	4613      	mov	r3, r2
 801f1cc:	f040 85ca 	bne.w	801fd64 <_vfprintf_r+0xd6c>
 801f1d0:	f01b 0f40 	tst.w	fp, #64	; 0x40
 801f1d4:	f000 85c6 	beq.w	801fd64 <_vfprintf_r+0xd6c>
 801f1d8:	8814      	ldrh	r4, [r2, #0]
 801f1da:	3204      	adds	r2, #4
 801f1dc:	2500      	movs	r5, #0
 801f1de:	2301      	movs	r3, #1
 801f1e0:	920e      	str	r2, [sp, #56]	; 0x38
 801f1e2:	e014      	b.n	801f20e <_vfprintf_r+0x216>
 801f1e4:	f04b 0b10 	orr.w	fp, fp, #16
 801f1e8:	f01b 0320 	ands.w	r3, fp, #32
 801f1ec:	f040 8340 	bne.w	801f870 <_vfprintf_r+0x878>
 801f1f0:	f01b 0210 	ands.w	r2, fp, #16
 801f1f4:	f040 85a5 	bne.w	801fd42 <_vfprintf_r+0xd4a>
 801f1f8:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 801f1fc:	f000 85a1 	beq.w	801fd42 <_vfprintf_r+0xd4a>
 801f200:	990e      	ldr	r1, [sp, #56]	; 0x38
 801f202:	4613      	mov	r3, r2
 801f204:	460a      	mov	r2, r1
 801f206:	3204      	adds	r2, #4
 801f208:	880c      	ldrh	r4, [r1, #0]
 801f20a:	920e      	str	r2, [sp, #56]	; 0x38
 801f20c:	2500      	movs	r5, #0
 801f20e:	f04f 0a00 	mov.w	sl, #0
 801f212:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
 801f216:	9909      	ldr	r1, [sp, #36]	; 0x24
 801f218:	1c4a      	adds	r2, r1, #1
 801f21a:	f000 8210 	beq.w	801f63e <_vfprintf_r+0x646>
 801f21e:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
 801f222:	9206      	str	r2, [sp, #24]
 801f224:	ea54 0205 	orrs.w	r2, r4, r5
 801f228:	f040 820f 	bne.w	801f64a <_vfprintf_r+0x652>
 801f22c:	2900      	cmp	r1, #0
 801f22e:	f040 847c 	bne.w	801fb2a <_vfprintf_r+0xb32>
 801f232:	2b00      	cmp	r3, #0
 801f234:	f040 853a 	bne.w	801fcac <_vfprintf_r+0xcb4>
 801f238:	f01b 0301 	ands.w	r3, fp, #1
 801f23c:	930d      	str	r3, [sp, #52]	; 0x34
 801f23e:	f000 8676 	beq.w	801ff2e <_vfprintf_r+0xf36>
 801f242:	af42      	add	r7, sp, #264	; 0x108
 801f244:	2330      	movs	r3, #48	; 0x30
 801f246:	f807 3d41 	strb.w	r3, [r7, #-65]!
 801f24a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f24c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801f24e:	4293      	cmp	r3, r2
 801f250:	bfb8      	it	lt
 801f252:	4613      	movlt	r3, r2
 801f254:	9307      	str	r3, [sp, #28]
 801f256:	2300      	movs	r3, #0
 801f258:	9310      	str	r3, [sp, #64]	; 0x40
 801f25a:	f1ba 0f00 	cmp.w	sl, #0
 801f25e:	d002      	beq.n	801f266 <_vfprintf_r+0x26e>
 801f260:	9b07      	ldr	r3, [sp, #28]
 801f262:	3301      	adds	r3, #1
 801f264:	9307      	str	r3, [sp, #28]
 801f266:	9b06      	ldr	r3, [sp, #24]
 801f268:	f013 0302 	ands.w	r3, r3, #2
 801f26c:	930f      	str	r3, [sp, #60]	; 0x3c
 801f26e:	d002      	beq.n	801f276 <_vfprintf_r+0x27e>
 801f270:	9b07      	ldr	r3, [sp, #28]
 801f272:	3302      	adds	r3, #2
 801f274:	9307      	str	r3, [sp, #28]
 801f276:	9b06      	ldr	r3, [sp, #24]
 801f278:	f013 0584 	ands.w	r5, r3, #132	; 0x84
 801f27c:	f040 8329 	bne.w	801f8d2 <_vfprintf_r+0x8da>
 801f280:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f282:	9a07      	ldr	r2, [sp, #28]
 801f284:	eba3 0b02 	sub.w	fp, r3, r2
 801f288:	f1bb 0f00 	cmp.w	fp, #0
 801f28c:	f340 8321 	ble.w	801f8d2 <_vfprintf_r+0x8da>
 801f290:	f1bb 0f10 	cmp.w	fp, #16
 801f294:	9927      	ldr	r1, [sp, #156]	; 0x9c
 801f296:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801f298:	dd2c      	ble.n	801f2f4 <_vfprintf_r+0x2fc>
 801f29a:	4643      	mov	r3, r8
 801f29c:	2410      	movs	r4, #16
 801f29e:	46a8      	mov	r8, r5
 801f2a0:	f8dd a020 	ldr.w	sl, [sp, #32]
 801f2a4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f2a6:	e00a      	b.n	801f2be <_vfprintf_r+0x2c6>
	...
 801f2b0:	f1ab 0b10 	sub.w	fp, fp, #16
 801f2b4:	f1bb 0f10 	cmp.w	fp, #16
 801f2b8:	f103 0308 	add.w	r3, r3, #8
 801f2bc:	dd18      	ble.n	801f2f0 <_vfprintf_r+0x2f8>
 801f2be:	3201      	adds	r2, #1
 801f2c0:	48b9      	ldr	r0, [pc, #740]	; (801f5a8 <_vfprintf_r+0x5b0>)
 801f2c2:	9226      	str	r2, [sp, #152]	; 0x98
 801f2c4:	3110      	adds	r1, #16
 801f2c6:	2a07      	cmp	r2, #7
 801f2c8:	9127      	str	r1, [sp, #156]	; 0x9c
 801f2ca:	e883 0011 	stmia.w	r3, {r0, r4}
 801f2ce:	ddef      	ble.n	801f2b0 <_vfprintf_r+0x2b8>
 801f2d0:	aa25      	add	r2, sp, #148	; 0x94
 801f2d2:	4629      	mov	r1, r5
 801f2d4:	4650      	mov	r0, sl
 801f2d6:	f003 fce1 	bl	8022c9c <__sprint_r>
 801f2da:	2800      	cmp	r0, #0
 801f2dc:	f040 8374 	bne.w	801f9c8 <_vfprintf_r+0x9d0>
 801f2e0:	f1ab 0b10 	sub.w	fp, fp, #16
 801f2e4:	f1bb 0f10 	cmp.w	fp, #16
 801f2e8:	9927      	ldr	r1, [sp, #156]	; 0x9c
 801f2ea:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801f2ec:	ab32      	add	r3, sp, #200	; 0xc8
 801f2ee:	dce6      	bgt.n	801f2be <_vfprintf_r+0x2c6>
 801f2f0:	4645      	mov	r5, r8
 801f2f2:	4698      	mov	r8, r3
 801f2f4:	3201      	adds	r2, #1
 801f2f6:	4bac      	ldr	r3, [pc, #688]	; (801f5a8 <_vfprintf_r+0x5b0>)
 801f2f8:	9226      	str	r2, [sp, #152]	; 0x98
 801f2fa:	eb0b 0401 	add.w	r4, fp, r1
 801f2fe:	2a07      	cmp	r2, #7
 801f300:	9427      	str	r4, [sp, #156]	; 0x9c
 801f302:	e888 0808 	stmia.w	r8, {r3, fp}
 801f306:	f300 84d6 	bgt.w	801fcb6 <_vfprintf_r+0xcbe>
 801f30a:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 801f30e:	f108 0808 	add.w	r8, r8, #8
 801f312:	f1ba 0f00 	cmp.w	sl, #0
 801f316:	d00e      	beq.n	801f336 <_vfprintf_r+0x33e>
 801f318:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f31a:	3301      	adds	r3, #1
 801f31c:	3401      	adds	r4, #1
 801f31e:	f10d 0177 	add.w	r1, sp, #119	; 0x77
 801f322:	2201      	movs	r2, #1
 801f324:	2b07      	cmp	r3, #7
 801f326:	9427      	str	r4, [sp, #156]	; 0x9c
 801f328:	9326      	str	r3, [sp, #152]	; 0x98
 801f32a:	e888 0006 	stmia.w	r8, {r1, r2}
 801f32e:	f300 8413 	bgt.w	801fb58 <_vfprintf_r+0xb60>
 801f332:	f108 0808 	add.w	r8, r8, #8
 801f336:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801f338:	b16b      	cbz	r3, 801f356 <_vfprintf_r+0x35e>
 801f33a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f33c:	3301      	adds	r3, #1
 801f33e:	3402      	adds	r4, #2
 801f340:	a91e      	add	r1, sp, #120	; 0x78
 801f342:	2202      	movs	r2, #2
 801f344:	2b07      	cmp	r3, #7
 801f346:	9427      	str	r4, [sp, #156]	; 0x9c
 801f348:	9326      	str	r3, [sp, #152]	; 0x98
 801f34a:	e888 0006 	stmia.w	r8, {r1, r2}
 801f34e:	f300 840f 	bgt.w	801fb70 <_vfprintf_r+0xb78>
 801f352:	f108 0808 	add.w	r8, r8, #8
 801f356:	2d80      	cmp	r5, #128	; 0x80
 801f358:	f000 8338 	beq.w	801f9cc <_vfprintf_r+0x9d4>
 801f35c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f35e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801f360:	eba3 0a02 	sub.w	sl, r3, r2
 801f364:	f1ba 0f00 	cmp.w	sl, #0
 801f368:	dd3b      	ble.n	801f3e2 <_vfprintf_r+0x3ea>
 801f36a:	f1ba 0f10 	cmp.w	sl, #16
 801f36e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f370:	4d8e      	ldr	r5, [pc, #568]	; (801f5ac <_vfprintf_r+0x5b4>)
 801f372:	dd2b      	ble.n	801f3cc <_vfprintf_r+0x3d4>
 801f374:	4642      	mov	r2, r8
 801f376:	4621      	mov	r1, r4
 801f378:	46b0      	mov	r8, r6
 801f37a:	f04f 0b10 	mov.w	fp, #16
 801f37e:	462e      	mov	r6, r5
 801f380:	9c08      	ldr	r4, [sp, #32]
 801f382:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f384:	e006      	b.n	801f394 <_vfprintf_r+0x39c>
 801f386:	f1aa 0a10 	sub.w	sl, sl, #16
 801f38a:	f1ba 0f10 	cmp.w	sl, #16
 801f38e:	f102 0208 	add.w	r2, r2, #8
 801f392:	dd17      	ble.n	801f3c4 <_vfprintf_r+0x3cc>
 801f394:	3301      	adds	r3, #1
 801f396:	3110      	adds	r1, #16
 801f398:	2b07      	cmp	r3, #7
 801f39a:	9127      	str	r1, [sp, #156]	; 0x9c
 801f39c:	9326      	str	r3, [sp, #152]	; 0x98
 801f39e:	e882 0840 	stmia.w	r2, {r6, fp}
 801f3a2:	ddf0      	ble.n	801f386 <_vfprintf_r+0x38e>
 801f3a4:	aa25      	add	r2, sp, #148	; 0x94
 801f3a6:	4629      	mov	r1, r5
 801f3a8:	4620      	mov	r0, r4
 801f3aa:	f003 fc77 	bl	8022c9c <__sprint_r>
 801f3ae:	2800      	cmp	r0, #0
 801f3b0:	f040 830a 	bne.w	801f9c8 <_vfprintf_r+0x9d0>
 801f3b4:	f1aa 0a10 	sub.w	sl, sl, #16
 801f3b8:	f1ba 0f10 	cmp.w	sl, #16
 801f3bc:	9927      	ldr	r1, [sp, #156]	; 0x9c
 801f3be:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f3c0:	aa32      	add	r2, sp, #200	; 0xc8
 801f3c2:	dce7      	bgt.n	801f394 <_vfprintf_r+0x39c>
 801f3c4:	4635      	mov	r5, r6
 801f3c6:	460c      	mov	r4, r1
 801f3c8:	4646      	mov	r6, r8
 801f3ca:	4690      	mov	r8, r2
 801f3cc:	3301      	adds	r3, #1
 801f3ce:	4454      	add	r4, sl
 801f3d0:	2b07      	cmp	r3, #7
 801f3d2:	9427      	str	r4, [sp, #156]	; 0x9c
 801f3d4:	9326      	str	r3, [sp, #152]	; 0x98
 801f3d6:	e888 0420 	stmia.w	r8, {r5, sl}
 801f3da:	f300 83b2 	bgt.w	801fb42 <_vfprintf_r+0xb4a>
 801f3de:	f108 0808 	add.w	r8, r8, #8
 801f3e2:	9b06      	ldr	r3, [sp, #24]
 801f3e4:	05db      	lsls	r3, r3, #23
 801f3e6:	f100 828f 	bmi.w	801f908 <_vfprintf_r+0x910>
 801f3ea:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f3ec:	990d      	ldr	r1, [sp, #52]	; 0x34
 801f3ee:	f8c8 7000 	str.w	r7, [r8]
 801f3f2:	3301      	adds	r3, #1
 801f3f4:	440c      	add	r4, r1
 801f3f6:	2b07      	cmp	r3, #7
 801f3f8:	9427      	str	r4, [sp, #156]	; 0x9c
 801f3fa:	f8c8 1004 	str.w	r1, [r8, #4]
 801f3fe:	9326      	str	r3, [sp, #152]	; 0x98
 801f400:	f300 837e 	bgt.w	801fb00 <_vfprintf_r+0xb08>
 801f404:	f108 0808 	add.w	r8, r8, #8
 801f408:	9b06      	ldr	r3, [sp, #24]
 801f40a:	0759      	lsls	r1, r3, #29
 801f40c:	d53b      	bpl.n	801f486 <_vfprintf_r+0x48e>
 801f40e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f410:	9a07      	ldr	r2, [sp, #28]
 801f412:	1a9d      	subs	r5, r3, r2
 801f414:	2d00      	cmp	r5, #0
 801f416:	dd36      	ble.n	801f486 <_vfprintf_r+0x48e>
 801f418:	2d10      	cmp	r5, #16
 801f41a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f41c:	dd21      	ble.n	801f462 <_vfprintf_r+0x46a>
 801f41e:	2610      	movs	r6, #16
 801f420:	9f08      	ldr	r7, [sp, #32]
 801f422:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 801f426:	e004      	b.n	801f432 <_vfprintf_r+0x43a>
 801f428:	3d10      	subs	r5, #16
 801f42a:	2d10      	cmp	r5, #16
 801f42c:	f108 0808 	add.w	r8, r8, #8
 801f430:	dd17      	ble.n	801f462 <_vfprintf_r+0x46a>
 801f432:	3301      	adds	r3, #1
 801f434:	4a5c      	ldr	r2, [pc, #368]	; (801f5a8 <_vfprintf_r+0x5b0>)
 801f436:	9326      	str	r3, [sp, #152]	; 0x98
 801f438:	3410      	adds	r4, #16
 801f43a:	2b07      	cmp	r3, #7
 801f43c:	9427      	str	r4, [sp, #156]	; 0x9c
 801f43e:	e888 0044 	stmia.w	r8, {r2, r6}
 801f442:	ddf1      	ble.n	801f428 <_vfprintf_r+0x430>
 801f444:	aa25      	add	r2, sp, #148	; 0x94
 801f446:	4651      	mov	r1, sl
 801f448:	4638      	mov	r0, r7
 801f44a:	f003 fc27 	bl	8022c9c <__sprint_r>
 801f44e:	2800      	cmp	r0, #0
 801f450:	f040 8249 	bne.w	801f8e6 <_vfprintf_r+0x8ee>
 801f454:	3d10      	subs	r5, #16
 801f456:	2d10      	cmp	r5, #16
 801f458:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801f45a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f45c:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801f460:	dce7      	bgt.n	801f432 <_vfprintf_r+0x43a>
 801f462:	3301      	adds	r3, #1
 801f464:	4a50      	ldr	r2, [pc, #320]	; (801f5a8 <_vfprintf_r+0x5b0>)
 801f466:	9326      	str	r3, [sp, #152]	; 0x98
 801f468:	442c      	add	r4, r5
 801f46a:	2b07      	cmp	r3, #7
 801f46c:	9427      	str	r4, [sp, #156]	; 0x9c
 801f46e:	e888 0024 	stmia.w	r8, {r2, r5}
 801f472:	dd08      	ble.n	801f486 <_vfprintf_r+0x48e>
 801f474:	aa25      	add	r2, sp, #148	; 0x94
 801f476:	990a      	ldr	r1, [sp, #40]	; 0x28
 801f478:	9808      	ldr	r0, [sp, #32]
 801f47a:	f003 fc0f 	bl	8022c9c <__sprint_r>
 801f47e:	2800      	cmp	r0, #0
 801f480:	f040 8350 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801f484:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801f486:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f488:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801f48a:	9907      	ldr	r1, [sp, #28]
 801f48c:	428a      	cmp	r2, r1
 801f48e:	bfac      	ite	ge
 801f490:	189b      	addge	r3, r3, r2
 801f492:	185b      	addlt	r3, r3, r1
 801f494:	930b      	str	r3, [sp, #44]	; 0x2c
 801f496:	2c00      	cmp	r4, #0
 801f498:	f040 833c 	bne.w	801fb14 <_vfprintf_r+0xb1c>
 801f49c:	2300      	movs	r3, #0
 801f49e:	9326      	str	r3, [sp, #152]	; 0x98
 801f4a0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801f4a4:	e5f3      	b.n	801f08e <_vfprintf_r+0x96>
 801f4a6:	4651      	mov	r1, sl
 801f4a8:	9808      	ldr	r0, [sp, #32]
 801f4aa:	f001 f8b1 	bl	8020610 <__swsetup_r>
 801f4ae:	2800      	cmp	r0, #0
 801f4b0:	d038      	beq.n	801f524 <_vfprintf_r+0x52c>
 801f4b2:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
 801f4b6:	07dd      	lsls	r5, r3, #31
 801f4b8:	d404      	bmi.n	801f4c4 <_vfprintf_r+0x4cc>
 801f4ba:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801f4be:	059c      	lsls	r4, r3, #22
 801f4c0:	f140 85da 	bpl.w	8020078 <_vfprintf_r+0x1080>
 801f4c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801f4c8:	930b      	str	r3, [sp, #44]	; 0x2c
 801f4ca:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801f4cc:	b043      	add	sp, #268	; 0x10c
 801f4ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f4d2:	aa25      	add	r2, sp, #148	; 0x94
 801f4d4:	990a      	ldr	r1, [sp, #40]	; 0x28
 801f4d6:	9808      	ldr	r0, [sp, #32]
 801f4d8:	f003 fbe0 	bl	8022c9c <__sprint_r>
 801f4dc:	2800      	cmp	r0, #0
 801f4de:	f040 8321 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801f4e2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801f4e6:	e5f1      	b.n	801f0cc <_vfprintf_r+0xd4>
 801f4e8:	9808      	ldr	r0, [sp, #32]
 801f4ea:	f7fd ff9f 	bl	801d42c <__sinit>
 801f4ee:	e599      	b.n	801f024 <_vfprintf_r+0x2c>
 801f4f0:	f9ba 200e 	ldrsh.w	r2, [sl, #14]
 801f4f4:	2a00      	cmp	r2, #0
 801f4f6:	f6ff adba 	blt.w	801f06e <_vfprintf_r+0x76>
 801f4fa:	f8da 2064 	ldr.w	r2, [sl, #100]	; 0x64
 801f4fe:	07d0      	lsls	r0, r2, #31
 801f500:	d405      	bmi.n	801f50e <_vfprintf_r+0x516>
 801f502:	0599      	lsls	r1, r3, #22
 801f504:	d403      	bmi.n	801f50e <_vfprintf_r+0x516>
 801f506:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
 801f50a:	f7fc fbff 	bl	801bd0c <__retarget_lock_release_recursive>
 801f50e:	462b      	mov	r3, r5
 801f510:	464a      	mov	r2, r9
 801f512:	4651      	mov	r1, sl
 801f514:	9808      	ldr	r0, [sp, #32]
 801f516:	f001 f839 	bl	802058c <__sbprintf>
 801f51a:	900b      	str	r0, [sp, #44]	; 0x2c
 801f51c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801f51e:	b043      	add	sp, #268	; 0x10c
 801f520:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f524:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801f528:	e59c      	b.n	801f064 <_vfprintf_r+0x6c>
 801f52a:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
 801f52e:	f7fc fbe9 	bl	801bd04 <__retarget_lock_acquire_recursive>
 801f532:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
 801f536:	b293      	uxth	r3, r2
 801f538:	e57f      	b.n	801f03a <_vfprintf_r+0x42>
 801f53a:	980c      	ldr	r0, [sp, #48]	; 0x30
 801f53c:	930e      	str	r3, [sp, #56]	; 0x38
 801f53e:	4240      	negs	r0, r0
 801f540:	900c      	str	r0, [sp, #48]	; 0x30
 801f542:	f04b 0b04 	orr.w	fp, fp, #4
 801f546:	f899 6000 	ldrb.w	r6, [r9]
 801f54a:	e5d3      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f54c:	2a00      	cmp	r2, #0
 801f54e:	f040 87f7 	bne.w	8020540 <_vfprintf_r+0x1548>
 801f552:	4b17      	ldr	r3, [pc, #92]	; (801f5b0 <_vfprintf_r+0x5b8>)
 801f554:	9316      	str	r3, [sp, #88]	; 0x58
 801f556:	f01b 0f20 	tst.w	fp, #32
 801f55a:	f040 84cd 	bne.w	801fef8 <_vfprintf_r+0xf00>
 801f55e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f560:	f01b 0f10 	tst.w	fp, #16
 801f564:	4613      	mov	r3, r2
 801f566:	f040 83e7 	bne.w	801fd38 <_vfprintf_r+0xd40>
 801f56a:	f01b 0f40 	tst.w	fp, #64	; 0x40
 801f56e:	f000 83e3 	beq.w	801fd38 <_vfprintf_r+0xd40>
 801f572:	3304      	adds	r3, #4
 801f574:	8814      	ldrh	r4, [r2, #0]
 801f576:	930e      	str	r3, [sp, #56]	; 0x38
 801f578:	2500      	movs	r5, #0
 801f57a:	f01b 0f01 	tst.w	fp, #1
 801f57e:	f000 832b 	beq.w	801fbd8 <_vfprintf_r+0xbe0>
 801f582:	ea54 0305 	orrs.w	r3, r4, r5
 801f586:	f000 8327 	beq.w	801fbd8 <_vfprintf_r+0xbe0>
 801f58a:	2330      	movs	r3, #48	; 0x30
 801f58c:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
 801f590:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
 801f594:	f04b 0b02 	orr.w	fp, fp, #2
 801f598:	2302      	movs	r3, #2
 801f59a:	e638      	b.n	801f20e <_vfprintf_r+0x216>
 801f59c:	f04b 0b20 	orr.w	fp, fp, #32
 801f5a0:	f899 6000 	ldrb.w	r6, [r9]
 801f5a4:	e5a6      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f5a6:	bf00      	nop
 801f5a8:	080251c4 	.word	0x080251c4
 801f5ac:	080251d4 	.word	0x080251d4
 801f5b0:	080251ac 	.word	0x080251ac
 801f5b4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f5b6:	6817      	ldr	r7, [r2, #0]
 801f5b8:	2400      	movs	r4, #0
 801f5ba:	f88d 4077 	strb.w	r4, [sp, #119]	; 0x77
 801f5be:	1d15      	adds	r5, r2, #4
 801f5c0:	2f00      	cmp	r7, #0
 801f5c2:	f000 865d 	beq.w	8020280 <_vfprintf_r+0x1288>
 801f5c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f5c8:	1c53      	adds	r3, r2, #1
 801f5ca:	f000 85db 	beq.w	8020184 <_vfprintf_r+0x118c>
 801f5ce:	4621      	mov	r1, r4
 801f5d0:	4638      	mov	r0, r7
 801f5d2:	f7e5 ff0d 	bl	80053f0 <memchr>
 801f5d6:	2800      	cmp	r0, #0
 801f5d8:	f000 86da 	beq.w	8020390 <_vfprintf_r+0x1398>
 801f5dc:	1bc3      	subs	r3, r0, r7
 801f5de:	930d      	str	r3, [sp, #52]	; 0x34
 801f5e0:	9409      	str	r4, [sp, #36]	; 0x24
 801f5e2:	950e      	str	r5, [sp, #56]	; 0x38
 801f5e4:	f8cd b018 	str.w	fp, [sp, #24]
 801f5e8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801f5ec:	9307      	str	r3, [sp, #28]
 801f5ee:	9410      	str	r4, [sp, #64]	; 0x40
 801f5f0:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 801f5f4:	e631      	b.n	801f25a <_vfprintf_r+0x262>
 801f5f6:	2a00      	cmp	r2, #0
 801f5f8:	f040 87ad 	bne.w	8020556 <_vfprintf_r+0x155e>
 801f5fc:	f01b 0f20 	tst.w	fp, #32
 801f600:	f040 8488 	bne.w	801ff14 <_vfprintf_r+0xf1c>
 801f604:	f01b 0f10 	tst.w	fp, #16
 801f608:	f040 83a3 	bne.w	801fd52 <_vfprintf_r+0xd5a>
 801f60c:	f01b 0f40 	tst.w	fp, #64	; 0x40
 801f610:	f000 839f 	beq.w	801fd52 <_vfprintf_r+0xd5a>
 801f614:	990e      	ldr	r1, [sp, #56]	; 0x38
 801f616:	f9b1 4000 	ldrsh.w	r4, [r1]
 801f61a:	3104      	adds	r1, #4
 801f61c:	17e5      	asrs	r5, r4, #31
 801f61e:	4622      	mov	r2, r4
 801f620:	462b      	mov	r3, r5
 801f622:	910e      	str	r1, [sp, #56]	; 0x38
 801f624:	2a00      	cmp	r2, #0
 801f626:	f173 0300 	sbcs.w	r3, r3, #0
 801f62a:	f2c0 8490 	blt.w	801ff4e <_vfprintf_r+0xf56>
 801f62e:	9909      	ldr	r1, [sp, #36]	; 0x24
 801f630:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 801f634:	1c4a      	adds	r2, r1, #1
 801f636:	f04f 0301 	mov.w	r3, #1
 801f63a:	f47f adf0 	bne.w	801f21e <_vfprintf_r+0x226>
 801f63e:	ea54 0205 	orrs.w	r2, r4, r5
 801f642:	f000 8274 	beq.w	801fb2e <_vfprintf_r+0xb36>
 801f646:	f8cd b018 	str.w	fp, [sp, #24]
 801f64a:	2b01      	cmp	r3, #1
 801f64c:	f000 8310 	beq.w	801fc70 <_vfprintf_r+0xc78>
 801f650:	2b02      	cmp	r3, #2
 801f652:	f040 829d 	bne.w	801fb90 <_vfprintf_r+0xb98>
 801f656:	9816      	ldr	r0, [sp, #88]	; 0x58
 801f658:	af32      	add	r7, sp, #200	; 0xc8
 801f65a:	0923      	lsrs	r3, r4, #4
 801f65c:	f004 010f 	and.w	r1, r4, #15
 801f660:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 801f664:	092a      	lsrs	r2, r5, #4
 801f666:	461c      	mov	r4, r3
 801f668:	4615      	mov	r5, r2
 801f66a:	5c43      	ldrb	r3, [r0, r1]
 801f66c:	f807 3d01 	strb.w	r3, [r7, #-1]!
 801f670:	ea54 0305 	orrs.w	r3, r4, r5
 801f674:	d1f1      	bne.n	801f65a <_vfprintf_r+0x662>
 801f676:	ab32      	add	r3, sp, #200	; 0xc8
 801f678:	1bdb      	subs	r3, r3, r7
 801f67a:	930d      	str	r3, [sp, #52]	; 0x34
 801f67c:	e5e5      	b.n	801f24a <_vfprintf_r+0x252>
 801f67e:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
 801f682:	f899 6000 	ldrb.w	r6, [r9]
 801f686:	e535      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f688:	f899 6000 	ldrb.w	r6, [r9]
 801f68c:	2e6c      	cmp	r6, #108	; 0x6c
 801f68e:	bf03      	ittte	eq
 801f690:	f899 6001 	ldrbeq.w	r6, [r9, #1]
 801f694:	f04b 0b20 	orreq.w	fp, fp, #32
 801f698:	f109 0901 	addeq.w	r9, r9, #1
 801f69c:	f04b 0b10 	orrne.w	fp, fp, #16
 801f6a0:	e528      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f6a2:	2a00      	cmp	r2, #0
 801f6a4:	f040 8767 	bne.w	8020576 <_vfprintf_r+0x157e>
 801f6a8:	f01b 0f20 	tst.w	fp, #32
 801f6ac:	f040 854e 	bne.w	802014c <_vfprintf_r+0x1154>
 801f6b0:	f01b 0f10 	tst.w	fp, #16
 801f6b4:	f040 8105 	bne.w	801f8c2 <_vfprintf_r+0x8ca>
 801f6b8:	f01b 0f40 	tst.w	fp, #64	; 0x40
 801f6bc:	f000 8101 	beq.w	801f8c2 <_vfprintf_r+0x8ca>
 801f6c0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f6c2:	6813      	ldr	r3, [r2, #0]
 801f6c4:	3204      	adds	r2, #4
 801f6c6:	920e      	str	r2, [sp, #56]	; 0x38
 801f6c8:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
 801f6cc:	801a      	strh	r2, [r3, #0]
 801f6ce:	e4de      	b.n	801f08e <_vfprintf_r+0x96>
 801f6d0:	f899 6000 	ldrb.w	r6, [r9]
 801f6d4:	2900      	cmp	r1, #0
 801f6d6:	f47f ad0d 	bne.w	801f0f4 <_vfprintf_r+0xfc>
 801f6da:	2201      	movs	r2, #1
 801f6dc:	2120      	movs	r1, #32
 801f6de:	e509      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f6e0:	f899 6000 	ldrb.w	r6, [r9]
 801f6e4:	2e2a      	cmp	r6, #42	; 0x2a
 801f6e6:	f109 0001 	add.w	r0, r9, #1
 801f6ea:	f000 8707 	beq.w	80204fc <_vfprintf_r+0x1504>
 801f6ee:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 801f6f2:	2b09      	cmp	r3, #9
 801f6f4:	4681      	mov	r9, r0
 801f6f6:	bf98      	it	ls
 801f6f8:	2000      	movls	r0, #0
 801f6fa:	f200 865b 	bhi.w	80203b4 <_vfprintf_r+0x13bc>
 801f6fe:	f819 6b01 	ldrb.w	r6, [r9], #1
 801f702:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f706:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 801f70a:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 801f70e:	2b09      	cmp	r3, #9
 801f710:	d9f5      	bls.n	801f6fe <_vfprintf_r+0x706>
 801f712:	9009      	str	r0, [sp, #36]	; 0x24
 801f714:	e4f0      	b.n	801f0f8 <_vfprintf_r+0x100>
 801f716:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 801f71a:	f899 6000 	ldrb.w	r6, [r9]
 801f71e:	e4e9      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f720:	f899 6000 	ldrb.w	r6, [r9]
 801f724:	2201      	movs	r2, #1
 801f726:	212b      	movs	r1, #43	; 0x2b
 801f728:	e4e4      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f72a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f72c:	4bb2      	ldr	r3, [pc, #712]	; (801f9f8 <_vfprintf_r+0xa00>)
 801f72e:	6814      	ldr	r4, [r2, #0]
 801f730:	9316      	str	r3, [sp, #88]	; 0x58
 801f732:	2678      	movs	r6, #120	; 0x78
 801f734:	2330      	movs	r3, #48	; 0x30
 801f736:	3204      	adds	r2, #4
 801f738:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
 801f73c:	f04b 0b02 	orr.w	fp, fp, #2
 801f740:	920e      	str	r2, [sp, #56]	; 0x38
 801f742:	2500      	movs	r5, #0
 801f744:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
 801f748:	2302      	movs	r3, #2
 801f74a:	e560      	b.n	801f20e <_vfprintf_r+0x216>
 801f74c:	2a00      	cmp	r2, #0
 801f74e:	f040 870e 	bne.w	802056e <_vfprintf_r+0x1576>
 801f752:	4baa      	ldr	r3, [pc, #680]	; (801f9fc <_vfprintf_r+0xa04>)
 801f754:	9316      	str	r3, [sp, #88]	; 0x58
 801f756:	e6fe      	b.n	801f556 <_vfprintf_r+0x55e>
 801f758:	990e      	ldr	r1, [sp, #56]	; 0x38
 801f75a:	f8cd b018 	str.w	fp, [sp, #24]
 801f75e:	680a      	ldr	r2, [r1, #0]
 801f760:	f88d 20a0 	strb.w	r2, [sp, #160]	; 0xa0
 801f764:	2300      	movs	r3, #0
 801f766:	460a      	mov	r2, r1
 801f768:	469a      	mov	sl, r3
 801f76a:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 801f76e:	3204      	adds	r2, #4
 801f770:	2301      	movs	r3, #1
 801f772:	9307      	str	r3, [sp, #28]
 801f774:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 801f778:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
 801f77c:	920e      	str	r2, [sp, #56]	; 0x38
 801f77e:	930d      	str	r3, [sp, #52]	; 0x34
 801f780:	af28      	add	r7, sp, #160	; 0xa0
 801f782:	e570      	b.n	801f266 <_vfprintf_r+0x26e>
 801f784:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 801f788:	2000      	movs	r0, #0
 801f78a:	f819 6b01 	ldrb.w	r6, [r9], #1
 801f78e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f792:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 801f796:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 801f79a:	2b09      	cmp	r3, #9
 801f79c:	d9f5      	bls.n	801f78a <_vfprintf_r+0x792>
 801f79e:	900c      	str	r0, [sp, #48]	; 0x30
 801f7a0:	e4aa      	b.n	801f0f8 <_vfprintf_r+0x100>
 801f7a2:	2a00      	cmp	r2, #0
 801f7a4:	f040 86df 	bne.w	8020566 <_vfprintf_r+0x156e>
 801f7a8:	f04b 0b10 	orr.w	fp, fp, #16
 801f7ac:	e726      	b.n	801f5fc <_vfprintf_r+0x604>
 801f7ae:	f04b 0b01 	orr.w	fp, fp, #1
 801f7b2:	f899 6000 	ldrb.w	r6, [r9]
 801f7b6:	e49d      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f7b8:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 801f7ba:	6823      	ldr	r3, [r4, #0]
 801f7bc:	930c      	str	r3, [sp, #48]	; 0x30
 801f7be:	4618      	mov	r0, r3
 801f7c0:	2800      	cmp	r0, #0
 801f7c2:	4623      	mov	r3, r4
 801f7c4:	f103 0304 	add.w	r3, r3, #4
 801f7c8:	f6ff aeb7 	blt.w	801f53a <_vfprintf_r+0x542>
 801f7cc:	930e      	str	r3, [sp, #56]	; 0x38
 801f7ce:	f899 6000 	ldrb.w	r6, [r9]
 801f7d2:	e48f      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f7d4:	2a00      	cmp	r2, #0
 801f7d6:	f040 86b7 	bne.w	8020548 <_vfprintf_r+0x1550>
 801f7da:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801f7dc:	f01b 0f08 	tst.w	fp, #8
 801f7e0:	f105 0507 	add.w	r5, r5, #7
 801f7e4:	f000 843d 	beq.w	8020062 <_vfprintf_r+0x106a>
 801f7e8:	f025 0307 	bic.w	r3, r5, #7
 801f7ec:	ed93 7b00 	vldr	d7, [r3]
 801f7f0:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 801f7f4:	f103 0208 	add.w	r2, r3, #8
 801f7f8:	920e      	str	r2, [sp, #56]	; 0x38
 801f7fa:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
 801f7fe:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 801f802:	9118      	str	r1, [sp, #96]	; 0x60
 801f804:	9319      	str	r3, [sp, #100]	; 0x64
 801f806:	e9dd 4518 	ldrd	r4, r5, [sp, #96]	; 0x60
 801f80a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801f80e:	4620      	mov	r0, r4
 801f810:	4629      	mov	r1, r5
 801f812:	4b7b      	ldr	r3, [pc, #492]	; (801fa00 <_vfprintf_r+0xa08>)
 801f814:	f7e5 fec4 	bl	80055a0 <__aeabi_dcmpun>
 801f818:	2800      	cmp	r0, #0
 801f81a:	f040 83a2 	bne.w	801ff62 <_vfprintf_r+0xf6a>
 801f81e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 801f822:	4b77      	ldr	r3, [pc, #476]	; (801fa00 <_vfprintf_r+0xa08>)
 801f824:	4620      	mov	r0, r4
 801f826:	4629      	mov	r1, r5
 801f828:	f7e5 fe9c 	bl	8005564 <__aeabi_dcmple>
 801f82c:	2800      	cmp	r0, #0
 801f82e:	f040 8398 	bne.w	801ff62 <_vfprintf_r+0xf6a>
 801f832:	2200      	movs	r2, #0
 801f834:	2300      	movs	r3, #0
 801f836:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 801f83a:	f7e5 fe89 	bl	8005550 <__aeabi_dcmplt>
 801f83e:	2800      	cmp	r0, #0
 801f840:	f040 8438 	bne.w	80200b4 <_vfprintf_r+0x10bc>
 801f844:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 801f848:	4f6e      	ldr	r7, [pc, #440]	; (801fa04 <_vfprintf_r+0xa0c>)
 801f84a:	4b6f      	ldr	r3, [pc, #444]	; (801fa08 <_vfprintf_r+0xa10>)
 801f84c:	2203      	movs	r2, #3
 801f84e:	2100      	movs	r1, #0
 801f850:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
 801f854:	9207      	str	r2, [sp, #28]
 801f856:	9109      	str	r1, [sp, #36]	; 0x24
 801f858:	9006      	str	r0, [sp, #24]
 801f85a:	2e47      	cmp	r6, #71	; 0x47
 801f85c:	bfd8      	it	le
 801f85e:	461f      	movle	r7, r3
 801f860:	920d      	str	r2, [sp, #52]	; 0x34
 801f862:	9110      	str	r1, [sp, #64]	; 0x40
 801f864:	e4f9      	b.n	801f25a <_vfprintf_r+0x262>
 801f866:	f04b 0b08 	orr.w	fp, fp, #8
 801f86a:	f899 6000 	ldrb.w	r6, [r9]
 801f86e:	e441      	b.n	801f0f4 <_vfprintf_r+0xfc>
 801f870:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801f872:	3507      	adds	r5, #7
 801f874:	f025 0307 	bic.w	r3, r5, #7
 801f878:	f103 0208 	add.w	r2, r3, #8
 801f87c:	e9d3 4500 	ldrd	r4, r5, [r3]
 801f880:	920e      	str	r2, [sp, #56]	; 0x38
 801f882:	2300      	movs	r3, #0
 801f884:	e4c3      	b.n	801f20e <_vfprintf_r+0x216>
 801f886:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801f888:	3507      	adds	r5, #7
 801f88a:	f025 0307 	bic.w	r3, r5, #7
 801f88e:	f103 0208 	add.w	r2, r3, #8
 801f892:	e9d3 4500 	ldrd	r4, r5, [r3]
 801f896:	920e      	str	r2, [sp, #56]	; 0x38
 801f898:	2301      	movs	r3, #1
 801f89a:	e4b8      	b.n	801f20e <_vfprintf_r+0x216>
 801f89c:	2a00      	cmp	r2, #0
 801f89e:	f040 865e 	bne.w	802055e <_vfprintf_r+0x1566>
 801f8a2:	b1c6      	cbz	r6, 801f8d6 <_vfprintf_r+0x8de>
 801f8a4:	2300      	movs	r3, #0
 801f8a6:	2201      	movs	r2, #1
 801f8a8:	469a      	mov	sl, r3
 801f8aa:	9207      	str	r2, [sp, #28]
 801f8ac:	f88d 60a0 	strb.w	r6, [sp, #160]	; 0xa0
 801f8b0:	f8cd b018 	str.w	fp, [sp, #24]
 801f8b4:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 801f8b8:	9309      	str	r3, [sp, #36]	; 0x24
 801f8ba:	9310      	str	r3, [sp, #64]	; 0x40
 801f8bc:	920d      	str	r2, [sp, #52]	; 0x34
 801f8be:	af28      	add	r7, sp, #160	; 0xa0
 801f8c0:	e4d1      	b.n	801f266 <_vfprintf_r+0x26e>
 801f8c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801f8c4:	6813      	ldr	r3, [r2, #0]
 801f8c6:	3204      	adds	r2, #4
 801f8c8:	920e      	str	r2, [sp, #56]	; 0x38
 801f8ca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f8cc:	601a      	str	r2, [r3, #0]
 801f8ce:	f7ff bbde 	b.w	801f08e <_vfprintf_r+0x96>
 801f8d2:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801f8d4:	e51d      	b.n	801f312 <_vfprintf_r+0x31a>
 801f8d6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 801f8d8:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 801f8dc:	2b00      	cmp	r3, #0
 801f8de:	f040 856d 	bne.w	80203bc <_vfprintf_r+0x13c4>
 801f8e2:	2300      	movs	r3, #0
 801f8e4:	9326      	str	r3, [sp, #152]	; 0x98
 801f8e6:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
 801f8ea:	f013 0f01 	tst.w	r3, #1
 801f8ee:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801f8f2:	d102      	bne.n	801f8fa <_vfprintf_r+0x902>
 801f8f4:	059a      	lsls	r2, r3, #22
 801f8f6:	f140 8248 	bpl.w	801fd8a <_vfprintf_r+0xd92>
 801f8fa:	065b      	lsls	r3, r3, #25
 801f8fc:	f53f ade2 	bmi.w	801f4c4 <_vfprintf_r+0x4cc>
 801f900:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801f902:	b043      	add	sp, #268	; 0x10c
 801f904:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f908:	2e65      	cmp	r6, #101	; 0x65
 801f90a:	f340 80b1 	ble.w	801fa70 <_vfprintf_r+0xa78>
 801f90e:	2200      	movs	r2, #0
 801f910:	2300      	movs	r3, #0
 801f912:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 801f916:	f7e5 fe11 	bl	800553c <__aeabi_dcmpeq>
 801f91a:	2800      	cmp	r0, #0
 801f91c:	f000 815f 	beq.w	801fbde <_vfprintf_r+0xbe6>
 801f920:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f922:	4a3a      	ldr	r2, [pc, #232]	; (801fa0c <_vfprintf_r+0xa14>)
 801f924:	f8c8 2000 	str.w	r2, [r8]
 801f928:	3301      	adds	r3, #1
 801f92a:	3401      	adds	r4, #1
 801f92c:	2201      	movs	r2, #1
 801f92e:	2b07      	cmp	r3, #7
 801f930:	9427      	str	r4, [sp, #156]	; 0x9c
 801f932:	9326      	str	r3, [sp, #152]	; 0x98
 801f934:	f8c8 2004 	str.w	r2, [r8, #4]
 801f938:	f300 83c5 	bgt.w	80200c6 <_vfprintf_r+0x10ce>
 801f93c:	f108 0808 	add.w	r8, r8, #8
 801f940:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801f942:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801f944:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801f946:	4293      	cmp	r3, r2
 801f948:	db03      	blt.n	801f952 <_vfprintf_r+0x95a>
 801f94a:	9b06      	ldr	r3, [sp, #24]
 801f94c:	07df      	lsls	r7, r3, #31
 801f94e:	f57f ad5b 	bpl.w	801f408 <_vfprintf_r+0x410>
 801f952:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f954:	9914      	ldr	r1, [sp, #80]	; 0x50
 801f956:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801f958:	f8c8 2000 	str.w	r2, [r8]
 801f95c:	3301      	adds	r3, #1
 801f95e:	440c      	add	r4, r1
 801f960:	2b07      	cmp	r3, #7
 801f962:	f8c8 1004 	str.w	r1, [r8, #4]
 801f966:	9427      	str	r4, [sp, #156]	; 0x9c
 801f968:	9326      	str	r3, [sp, #152]	; 0x98
 801f96a:	f300 83fe 	bgt.w	802016a <_vfprintf_r+0x1172>
 801f96e:	f108 0808 	add.w	r8, r8, #8
 801f972:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801f974:	1e5e      	subs	r6, r3, #1
 801f976:	2e00      	cmp	r6, #0
 801f978:	f77f ad46 	ble.w	801f408 <_vfprintf_r+0x410>
 801f97c:	2e10      	cmp	r6, #16
 801f97e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f980:	4d23      	ldr	r5, [pc, #140]	; (801fa10 <_vfprintf_r+0xa18>)
 801f982:	f340 81cf 	ble.w	801fd24 <_vfprintf_r+0xd2c>
 801f986:	2710      	movs	r7, #16
 801f988:	f8dd a020 	ldr.w	sl, [sp, #32]
 801f98c:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 801f990:	e005      	b.n	801f99e <_vfprintf_r+0x9a6>
 801f992:	f108 0808 	add.w	r8, r8, #8
 801f996:	3e10      	subs	r6, #16
 801f998:	2e10      	cmp	r6, #16
 801f99a:	f340 81c3 	ble.w	801fd24 <_vfprintf_r+0xd2c>
 801f99e:	3301      	adds	r3, #1
 801f9a0:	3410      	adds	r4, #16
 801f9a2:	2b07      	cmp	r3, #7
 801f9a4:	9427      	str	r4, [sp, #156]	; 0x9c
 801f9a6:	9326      	str	r3, [sp, #152]	; 0x98
 801f9a8:	e888 00a0 	stmia.w	r8, {r5, r7}
 801f9ac:	ddf1      	ble.n	801f992 <_vfprintf_r+0x99a>
 801f9ae:	aa25      	add	r2, sp, #148	; 0x94
 801f9b0:	4659      	mov	r1, fp
 801f9b2:	4650      	mov	r0, sl
 801f9b4:	f003 f972 	bl	8022c9c <__sprint_r>
 801f9b8:	2800      	cmp	r0, #0
 801f9ba:	f040 83d3 	bne.w	8020164 <_vfprintf_r+0x116c>
 801f9be:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801f9c0:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f9c2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801f9c6:	e7e6      	b.n	801f996 <_vfprintf_r+0x99e>
 801f9c8:	46aa      	mov	sl, r5
 801f9ca:	e78c      	b.n	801f8e6 <_vfprintf_r+0x8ee>
 801f9cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f9ce:	9a07      	ldr	r2, [sp, #28]
 801f9d0:	eba3 0a02 	sub.w	sl, r3, r2
 801f9d4:	f1ba 0f00 	cmp.w	sl, #0
 801f9d8:	f77f acc0 	ble.w	801f35c <_vfprintf_r+0x364>
 801f9dc:	f1ba 0f10 	cmp.w	sl, #16
 801f9e0:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f9e2:	4d0b      	ldr	r5, [pc, #44]	; (801fa10 <_vfprintf_r+0xa18>)
 801f9e4:	dd38      	ble.n	801fa58 <_vfprintf_r+0xa60>
 801f9e6:	4642      	mov	r2, r8
 801f9e8:	4621      	mov	r1, r4
 801f9ea:	46b0      	mov	r8, r6
 801f9ec:	f04f 0b10 	mov.w	fp, #16
 801f9f0:	462e      	mov	r6, r5
 801f9f2:	9c08      	ldr	r4, [sp, #32]
 801f9f4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f9f6:	e014      	b.n	801fa22 <_vfprintf_r+0xa2a>
 801f9f8:	080251ac 	.word	0x080251ac
 801f9fc:	08025198 	.word	0x08025198
 801fa00:	7fefffff 	.word	0x7fefffff
 801fa04:	0802518c 	.word	0x0802518c
 801fa08:	08025188 	.word	0x08025188
 801fa0c:	080251c0 	.word	0x080251c0
 801fa10:	080251d4 	.word	0x080251d4
 801fa14:	f1aa 0a10 	sub.w	sl, sl, #16
 801fa18:	f1ba 0f10 	cmp.w	sl, #16
 801fa1c:	f102 0208 	add.w	r2, r2, #8
 801fa20:	dd16      	ble.n	801fa50 <_vfprintf_r+0xa58>
 801fa22:	3301      	adds	r3, #1
 801fa24:	3110      	adds	r1, #16
 801fa26:	2b07      	cmp	r3, #7
 801fa28:	9127      	str	r1, [sp, #156]	; 0x9c
 801fa2a:	9326      	str	r3, [sp, #152]	; 0x98
 801fa2c:	e882 0840 	stmia.w	r2, {r6, fp}
 801fa30:	ddf0      	ble.n	801fa14 <_vfprintf_r+0xa1c>
 801fa32:	aa25      	add	r2, sp, #148	; 0x94
 801fa34:	4629      	mov	r1, r5
 801fa36:	4620      	mov	r0, r4
 801fa38:	f003 f930 	bl	8022c9c <__sprint_r>
 801fa3c:	2800      	cmp	r0, #0
 801fa3e:	d1c3      	bne.n	801f9c8 <_vfprintf_r+0x9d0>
 801fa40:	f1aa 0a10 	sub.w	sl, sl, #16
 801fa44:	f1ba 0f10 	cmp.w	sl, #16
 801fa48:	9927      	ldr	r1, [sp, #156]	; 0x9c
 801fa4a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fa4c:	aa32      	add	r2, sp, #200	; 0xc8
 801fa4e:	dce8      	bgt.n	801fa22 <_vfprintf_r+0xa2a>
 801fa50:	4635      	mov	r5, r6
 801fa52:	460c      	mov	r4, r1
 801fa54:	4646      	mov	r6, r8
 801fa56:	4690      	mov	r8, r2
 801fa58:	3301      	adds	r3, #1
 801fa5a:	4454      	add	r4, sl
 801fa5c:	2b07      	cmp	r3, #7
 801fa5e:	9427      	str	r4, [sp, #156]	; 0x9c
 801fa60:	9326      	str	r3, [sp, #152]	; 0x98
 801fa62:	e888 0420 	stmia.w	r8, {r5, sl}
 801fa66:	f300 8265 	bgt.w	801ff34 <_vfprintf_r+0xf3c>
 801fa6a:	f108 0808 	add.w	r8, r8, #8
 801fa6e:	e475      	b.n	801f35c <_vfprintf_r+0x364>
 801fa70:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801fa72:	9e26      	ldr	r6, [sp, #152]	; 0x98
 801fa74:	2b01      	cmp	r3, #1
 801fa76:	f340 81fe 	ble.w	801fe76 <_vfprintf_r+0xe7e>
 801fa7a:	3601      	adds	r6, #1
 801fa7c:	3401      	adds	r4, #1
 801fa7e:	2301      	movs	r3, #1
 801fa80:	2e07      	cmp	r6, #7
 801fa82:	9427      	str	r4, [sp, #156]	; 0x9c
 801fa84:	9626      	str	r6, [sp, #152]	; 0x98
 801fa86:	f8c8 7000 	str.w	r7, [r8]
 801fa8a:	f8c8 3004 	str.w	r3, [r8, #4]
 801fa8e:	f300 820f 	bgt.w	801feb0 <_vfprintf_r+0xeb8>
 801fa92:	f108 0808 	add.w	r8, r8, #8
 801fa96:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801fa98:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801fa9a:	f8c8 3000 	str.w	r3, [r8]
 801fa9e:	3601      	adds	r6, #1
 801faa0:	4414      	add	r4, r2
 801faa2:	2e07      	cmp	r6, #7
 801faa4:	9427      	str	r4, [sp, #156]	; 0x9c
 801faa6:	9626      	str	r6, [sp, #152]	; 0x98
 801faa8:	f8c8 2004 	str.w	r2, [r8, #4]
 801faac:	f300 820d 	bgt.w	801feca <_vfprintf_r+0xed2>
 801fab0:	f108 0808 	add.w	r8, r8, #8
 801fab4:	2300      	movs	r3, #0
 801fab6:	2200      	movs	r2, #0
 801fab8:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 801fabc:	f7e5 fd3e 	bl	800553c <__aeabi_dcmpeq>
 801fac0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801fac2:	2800      	cmp	r0, #0
 801fac4:	f040 8106 	bne.w	801fcd4 <_vfprintf_r+0xcdc>
 801fac8:	3b01      	subs	r3, #1
 801faca:	3601      	adds	r6, #1
 801facc:	3701      	adds	r7, #1
 801face:	441c      	add	r4, r3
 801fad0:	2e07      	cmp	r6, #7
 801fad2:	9626      	str	r6, [sp, #152]	; 0x98
 801fad4:	9427      	str	r4, [sp, #156]	; 0x9c
 801fad6:	f8c8 7000 	str.w	r7, [r8]
 801fada:	f8c8 3004 	str.w	r3, [r8, #4]
 801fade:	f300 81da 	bgt.w	801fe96 <_vfprintf_r+0xe9e>
 801fae2:	f108 0808 	add.w	r8, r8, #8
 801fae6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801fae8:	f8c8 2004 	str.w	r2, [r8, #4]
 801faec:	3601      	adds	r6, #1
 801faee:	4414      	add	r4, r2
 801faf0:	ab21      	add	r3, sp, #132	; 0x84
 801faf2:	2e07      	cmp	r6, #7
 801faf4:	9427      	str	r4, [sp, #156]	; 0x9c
 801faf6:	9626      	str	r6, [sp, #152]	; 0x98
 801faf8:	f8c8 3000 	str.w	r3, [r8]
 801fafc:	f77f ac82 	ble.w	801f404 <_vfprintf_r+0x40c>
 801fb00:	aa25      	add	r2, sp, #148	; 0x94
 801fb02:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fb04:	9808      	ldr	r0, [sp, #32]
 801fb06:	f003 f8c9 	bl	8022c9c <__sprint_r>
 801fb0a:	b958      	cbnz	r0, 801fb24 <_vfprintf_r+0xb2c>
 801fb0c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fb0e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fb12:	e479      	b.n	801f408 <_vfprintf_r+0x410>
 801fb14:	aa25      	add	r2, sp, #148	; 0x94
 801fb16:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fb18:	9808      	ldr	r0, [sp, #32]
 801fb1a:	f003 f8bf 	bl	8022c9c <__sprint_r>
 801fb1e:	2800      	cmp	r0, #0
 801fb20:	f43f acbc 	beq.w	801f49c <_vfprintf_r+0x4a4>
 801fb24:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 801fb28:	e6dd      	b.n	801f8e6 <_vfprintf_r+0x8ee>
 801fb2a:	f8dd b018 	ldr.w	fp, [sp, #24]
 801fb2e:	2b01      	cmp	r3, #1
 801fb30:	f000 8121 	beq.w	801fd76 <_vfprintf_r+0xd7e>
 801fb34:	2b02      	cmp	r3, #2
 801fb36:	d127      	bne.n	801fb88 <_vfprintf_r+0xb90>
 801fb38:	f8cd b018 	str.w	fp, [sp, #24]
 801fb3c:	2400      	movs	r4, #0
 801fb3e:	2500      	movs	r5, #0
 801fb40:	e589      	b.n	801f656 <_vfprintf_r+0x65e>
 801fb42:	aa25      	add	r2, sp, #148	; 0x94
 801fb44:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fb46:	9808      	ldr	r0, [sp, #32]
 801fb48:	f003 f8a8 	bl	8022c9c <__sprint_r>
 801fb4c:	2800      	cmp	r0, #0
 801fb4e:	d1e9      	bne.n	801fb24 <_vfprintf_r+0xb2c>
 801fb50:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fb52:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fb56:	e444      	b.n	801f3e2 <_vfprintf_r+0x3ea>
 801fb58:	aa25      	add	r2, sp, #148	; 0x94
 801fb5a:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fb5c:	9808      	ldr	r0, [sp, #32]
 801fb5e:	f003 f89d 	bl	8022c9c <__sprint_r>
 801fb62:	2800      	cmp	r0, #0
 801fb64:	d1de      	bne.n	801fb24 <_vfprintf_r+0xb2c>
 801fb66:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fb68:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fb6c:	f7ff bbe3 	b.w	801f336 <_vfprintf_r+0x33e>
 801fb70:	aa25      	add	r2, sp, #148	; 0x94
 801fb72:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fb74:	9808      	ldr	r0, [sp, #32]
 801fb76:	f003 f891 	bl	8022c9c <__sprint_r>
 801fb7a:	2800      	cmp	r0, #0
 801fb7c:	d1d2      	bne.n	801fb24 <_vfprintf_r+0xb2c>
 801fb7e:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fb80:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fb84:	f7ff bbe7 	b.w	801f356 <_vfprintf_r+0x35e>
 801fb88:	f8cd b018 	str.w	fp, [sp, #24]
 801fb8c:	2400      	movs	r4, #0
 801fb8e:	2500      	movs	r5, #0
 801fb90:	a932      	add	r1, sp, #200	; 0xc8
 801fb92:	e000      	b.n	801fb96 <_vfprintf_r+0xb9e>
 801fb94:	4639      	mov	r1, r7
 801fb96:	08e2      	lsrs	r2, r4, #3
 801fb98:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 801fb9c:	08e8      	lsrs	r0, r5, #3
 801fb9e:	f004 0307 	and.w	r3, r4, #7
 801fba2:	4605      	mov	r5, r0
 801fba4:	4614      	mov	r4, r2
 801fba6:	3330      	adds	r3, #48	; 0x30
 801fba8:	ea54 0205 	orrs.w	r2, r4, r5
 801fbac:	f801 3c01 	strb.w	r3, [r1, #-1]
 801fbb0:	f101 37ff 	add.w	r7, r1, #4294967295	; 0xffffffff
 801fbb4:	d1ee      	bne.n	801fb94 <_vfprintf_r+0xb9c>
 801fbb6:	9a06      	ldr	r2, [sp, #24]
 801fbb8:	07d2      	lsls	r2, r2, #31
 801fbba:	f57f ad5c 	bpl.w	801f676 <_vfprintf_r+0x67e>
 801fbbe:	2b30      	cmp	r3, #48	; 0x30
 801fbc0:	f43f ad59 	beq.w	801f676 <_vfprintf_r+0x67e>
 801fbc4:	2330      	movs	r3, #48	; 0x30
 801fbc6:	3902      	subs	r1, #2
 801fbc8:	f807 3c01 	strb.w	r3, [r7, #-1]
 801fbcc:	ab32      	add	r3, sp, #200	; 0xc8
 801fbce:	1a5b      	subs	r3, r3, r1
 801fbd0:	930d      	str	r3, [sp, #52]	; 0x34
 801fbd2:	460f      	mov	r7, r1
 801fbd4:	f7ff bb39 	b.w	801f24a <_vfprintf_r+0x252>
 801fbd8:	2302      	movs	r3, #2
 801fbda:	f7ff bb18 	b.w	801f20e <_vfprintf_r+0x216>
 801fbde:	991f      	ldr	r1, [sp, #124]	; 0x7c
 801fbe0:	2900      	cmp	r1, #0
 801fbe2:	f340 827b 	ble.w	80200dc <_vfprintf_r+0x10e4>
 801fbe6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801fbe8:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801fbea:	4293      	cmp	r3, r2
 801fbec:	bfa8      	it	ge
 801fbee:	4613      	movge	r3, r2
 801fbf0:	2b00      	cmp	r3, #0
 801fbf2:	461e      	mov	r6, r3
 801fbf4:	dd0d      	ble.n	801fc12 <_vfprintf_r+0xc1a>
 801fbf6:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fbf8:	f8c8 7000 	str.w	r7, [r8]
 801fbfc:	3301      	adds	r3, #1
 801fbfe:	4434      	add	r4, r6
 801fc00:	2b07      	cmp	r3, #7
 801fc02:	9427      	str	r4, [sp, #156]	; 0x9c
 801fc04:	f8c8 6004 	str.w	r6, [r8, #4]
 801fc08:	9326      	str	r3, [sp, #152]	; 0x98
 801fc0a:	f300 832d 	bgt.w	8020268 <_vfprintf_r+0x1270>
 801fc0e:	f108 0808 	add.w	r8, r8, #8
 801fc12:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801fc14:	2e00      	cmp	r6, #0
 801fc16:	bfa8      	it	ge
 801fc18:	1b9b      	subge	r3, r3, r6
 801fc1a:	2b00      	cmp	r3, #0
 801fc1c:	461e      	mov	r6, r3
 801fc1e:	f340 80d0 	ble.w	801fdc2 <_vfprintf_r+0xdca>
 801fc22:	2e10      	cmp	r6, #16
 801fc24:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fc26:	4dba      	ldr	r5, [pc, #744]	; (801ff10 <_vfprintf_r+0xf18>)
 801fc28:	f340 80b7 	ble.w	801fd9a <_vfprintf_r+0xda2>
 801fc2c:	4622      	mov	r2, r4
 801fc2e:	f04f 0a10 	mov.w	sl, #16
 801fc32:	f8dd b020 	ldr.w	fp, [sp, #32]
 801fc36:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801fc38:	e005      	b.n	801fc46 <_vfprintf_r+0xc4e>
 801fc3a:	f108 0808 	add.w	r8, r8, #8
 801fc3e:	3e10      	subs	r6, #16
 801fc40:	2e10      	cmp	r6, #16
 801fc42:	f340 80a9 	ble.w	801fd98 <_vfprintf_r+0xda0>
 801fc46:	3301      	adds	r3, #1
 801fc48:	3210      	adds	r2, #16
 801fc4a:	2b07      	cmp	r3, #7
 801fc4c:	9227      	str	r2, [sp, #156]	; 0x9c
 801fc4e:	9326      	str	r3, [sp, #152]	; 0x98
 801fc50:	e888 0420 	stmia.w	r8, {r5, sl}
 801fc54:	ddf1      	ble.n	801fc3a <_vfprintf_r+0xc42>
 801fc56:	aa25      	add	r2, sp, #148	; 0x94
 801fc58:	4621      	mov	r1, r4
 801fc5a:	4658      	mov	r0, fp
 801fc5c:	f003 f81e 	bl	8022c9c <__sprint_r>
 801fc60:	2800      	cmp	r0, #0
 801fc62:	f040 832b 	bne.w	80202bc <_vfprintf_r+0x12c4>
 801fc66:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 801fc68:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fc6a:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fc6e:	e7e6      	b.n	801fc3e <_vfprintf_r+0xc46>
 801fc70:	2d00      	cmp	r5, #0
 801fc72:	bf08      	it	eq
 801fc74:	2c0a      	cmpeq	r4, #10
 801fc76:	d37c      	bcc.n	801fd72 <_vfprintf_r+0xd7a>
 801fc78:	af32      	add	r7, sp, #200	; 0xc8
 801fc7a:	4620      	mov	r0, r4
 801fc7c:	4629      	mov	r1, r5
 801fc7e:	220a      	movs	r2, #10
 801fc80:	2300      	movs	r3, #0
 801fc82:	f7e4 fde5 	bl	8004850 <__aeabi_uldivmod>
 801fc86:	3230      	adds	r2, #48	; 0x30
 801fc88:	f807 2d01 	strb.w	r2, [r7, #-1]!
 801fc8c:	4620      	mov	r0, r4
 801fc8e:	4629      	mov	r1, r5
 801fc90:	2300      	movs	r3, #0
 801fc92:	220a      	movs	r2, #10
 801fc94:	f7e4 fddc 	bl	8004850 <__aeabi_uldivmod>
 801fc98:	4604      	mov	r4, r0
 801fc9a:	460d      	mov	r5, r1
 801fc9c:	ea54 0305 	orrs.w	r3, r4, r5
 801fca0:	d1eb      	bne.n	801fc7a <_vfprintf_r+0xc82>
 801fca2:	ab32      	add	r3, sp, #200	; 0xc8
 801fca4:	1bdb      	subs	r3, r3, r7
 801fca6:	930d      	str	r3, [sp, #52]	; 0x34
 801fca8:	f7ff bacf 	b.w	801f24a <_vfprintf_r+0x252>
 801fcac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fcae:	930d      	str	r3, [sp, #52]	; 0x34
 801fcb0:	af32      	add	r7, sp, #200	; 0xc8
 801fcb2:	f7ff baca 	b.w	801f24a <_vfprintf_r+0x252>
 801fcb6:	aa25      	add	r2, sp, #148	; 0x94
 801fcb8:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fcba:	9808      	ldr	r0, [sp, #32]
 801fcbc:	f002 ffee 	bl	8022c9c <__sprint_r>
 801fcc0:	2800      	cmp	r0, #0
 801fcc2:	f47f af2f 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801fcc6:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 801fcca:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fccc:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fcd0:	f7ff bb1f 	b.w	801f312 <_vfprintf_r+0x31a>
 801fcd4:	1e5f      	subs	r7, r3, #1
 801fcd6:	2f00      	cmp	r7, #0
 801fcd8:	f77f af05 	ble.w	801fae6 <_vfprintf_r+0xaee>
 801fcdc:	2f10      	cmp	r7, #16
 801fcde:	4d8c      	ldr	r5, [pc, #560]	; (801ff10 <_vfprintf_r+0xf18>)
 801fce0:	f340 8100 	ble.w	801fee4 <_vfprintf_r+0xeec>
 801fce4:	f04f 0a10 	mov.w	sl, #16
 801fce8:	f8dd b020 	ldr.w	fp, [sp, #32]
 801fcec:	e005      	b.n	801fcfa <_vfprintf_r+0xd02>
 801fcee:	f108 0808 	add.w	r8, r8, #8
 801fcf2:	3f10      	subs	r7, #16
 801fcf4:	2f10      	cmp	r7, #16
 801fcf6:	f340 80f5 	ble.w	801fee4 <_vfprintf_r+0xeec>
 801fcfa:	3601      	adds	r6, #1
 801fcfc:	3410      	adds	r4, #16
 801fcfe:	2e07      	cmp	r6, #7
 801fd00:	9427      	str	r4, [sp, #156]	; 0x9c
 801fd02:	9626      	str	r6, [sp, #152]	; 0x98
 801fd04:	e888 0420 	stmia.w	r8, {r5, sl}
 801fd08:	ddf1      	ble.n	801fcee <_vfprintf_r+0xcf6>
 801fd0a:	aa25      	add	r2, sp, #148	; 0x94
 801fd0c:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fd0e:	4658      	mov	r0, fp
 801fd10:	f002 ffc4 	bl	8022c9c <__sprint_r>
 801fd14:	2800      	cmp	r0, #0
 801fd16:	f47f af05 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801fd1a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fd1c:	9e26      	ldr	r6, [sp, #152]	; 0x98
 801fd1e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fd22:	e7e6      	b.n	801fcf2 <_vfprintf_r+0xcfa>
 801fd24:	3301      	adds	r3, #1
 801fd26:	4434      	add	r4, r6
 801fd28:	2b07      	cmp	r3, #7
 801fd2a:	9427      	str	r4, [sp, #156]	; 0x9c
 801fd2c:	9326      	str	r3, [sp, #152]	; 0x98
 801fd2e:	e888 0060 	stmia.w	r8, {r5, r6}
 801fd32:	f77f ab67 	ble.w	801f404 <_vfprintf_r+0x40c>
 801fd36:	e6e3      	b.n	801fb00 <_vfprintf_r+0xb08>
 801fd38:	681c      	ldr	r4, [r3, #0]
 801fd3a:	3304      	adds	r3, #4
 801fd3c:	930e      	str	r3, [sp, #56]	; 0x38
 801fd3e:	2500      	movs	r5, #0
 801fd40:	e41b      	b.n	801f57a <_vfprintf_r+0x582>
 801fd42:	990e      	ldr	r1, [sp, #56]	; 0x38
 801fd44:	460a      	mov	r2, r1
 801fd46:	3204      	adds	r2, #4
 801fd48:	680c      	ldr	r4, [r1, #0]
 801fd4a:	920e      	str	r2, [sp, #56]	; 0x38
 801fd4c:	2500      	movs	r5, #0
 801fd4e:	f7ff ba5e 	b.w	801f20e <_vfprintf_r+0x216>
 801fd52:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801fd54:	6814      	ldr	r4, [r2, #0]
 801fd56:	4613      	mov	r3, r2
 801fd58:	3304      	adds	r3, #4
 801fd5a:	17e5      	asrs	r5, r4, #31
 801fd5c:	930e      	str	r3, [sp, #56]	; 0x38
 801fd5e:	4622      	mov	r2, r4
 801fd60:	462b      	mov	r3, r5
 801fd62:	e45f      	b.n	801f624 <_vfprintf_r+0x62c>
 801fd64:	3204      	adds	r2, #4
 801fd66:	681c      	ldr	r4, [r3, #0]
 801fd68:	920e      	str	r2, [sp, #56]	; 0x38
 801fd6a:	2301      	movs	r3, #1
 801fd6c:	2500      	movs	r5, #0
 801fd6e:	f7ff ba4e 	b.w	801f20e <_vfprintf_r+0x216>
 801fd72:	f8dd b018 	ldr.w	fp, [sp, #24]
 801fd76:	f8cd b018 	str.w	fp, [sp, #24]
 801fd7a:	af42      	add	r7, sp, #264	; 0x108
 801fd7c:	3430      	adds	r4, #48	; 0x30
 801fd7e:	2301      	movs	r3, #1
 801fd80:	f807 4d41 	strb.w	r4, [r7, #-65]!
 801fd84:	930d      	str	r3, [sp, #52]	; 0x34
 801fd86:	f7ff ba60 	b.w	801f24a <_vfprintf_r+0x252>
 801fd8a:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
 801fd8e:	f7fb ffbd 	bl	801bd0c <__retarget_lock_release_recursive>
 801fd92:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801fd96:	e5b0      	b.n	801f8fa <_vfprintf_r+0x902>
 801fd98:	4614      	mov	r4, r2
 801fd9a:	3301      	adds	r3, #1
 801fd9c:	4434      	add	r4, r6
 801fd9e:	2b07      	cmp	r3, #7
 801fda0:	9427      	str	r4, [sp, #156]	; 0x9c
 801fda2:	9326      	str	r3, [sp, #152]	; 0x98
 801fda4:	e888 0060 	stmia.w	r8, {r5, r6}
 801fda8:	f340 8174 	ble.w	8020094 <_vfprintf_r+0x109c>
 801fdac:	aa25      	add	r2, sp, #148	; 0x94
 801fdae:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fdb0:	9808      	ldr	r0, [sp, #32]
 801fdb2:	f002 ff73 	bl	8022c9c <__sprint_r>
 801fdb6:	2800      	cmp	r0, #0
 801fdb8:	f47f aeb4 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801fdbc:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fdbe:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fdc2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801fdc4:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801fdc6:	4293      	cmp	r3, r2
 801fdc8:	f280 815f 	bge.w	802008a <_vfprintf_r+0x1092>
 801fdcc:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801fdce:	9814      	ldr	r0, [sp, #80]	; 0x50
 801fdd0:	9915      	ldr	r1, [sp, #84]	; 0x54
 801fdd2:	f8c8 1000 	str.w	r1, [r8]
 801fdd6:	3201      	adds	r2, #1
 801fdd8:	4404      	add	r4, r0
 801fdda:	2a07      	cmp	r2, #7
 801fddc:	9427      	str	r4, [sp, #156]	; 0x9c
 801fdde:	f8c8 0004 	str.w	r0, [r8, #4]
 801fde2:	9226      	str	r2, [sp, #152]	; 0x98
 801fde4:	f300 8159 	bgt.w	802009a <_vfprintf_r+0x10a2>
 801fde8:	f108 0808 	add.w	r8, r8, #8
 801fdec:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801fdee:	9910      	ldr	r1, [sp, #64]	; 0x40
 801fdf0:	1ad3      	subs	r3, r2, r3
 801fdf2:	1a56      	subs	r6, r2, r1
 801fdf4:	429e      	cmp	r6, r3
 801fdf6:	bfa8      	it	ge
 801fdf8:	461e      	movge	r6, r3
 801fdfa:	2e00      	cmp	r6, #0
 801fdfc:	dd0e      	ble.n	801fe1c <_vfprintf_r+0xe24>
 801fdfe:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801fe00:	f8c8 6004 	str.w	r6, [r8, #4]
 801fe04:	3201      	adds	r2, #1
 801fe06:	440f      	add	r7, r1
 801fe08:	4434      	add	r4, r6
 801fe0a:	2a07      	cmp	r2, #7
 801fe0c:	f8c8 7000 	str.w	r7, [r8]
 801fe10:	9427      	str	r4, [sp, #156]	; 0x9c
 801fe12:	9226      	str	r2, [sp, #152]	; 0x98
 801fe14:	f300 8243 	bgt.w	802029e <_vfprintf_r+0x12a6>
 801fe18:	f108 0808 	add.w	r8, r8, #8
 801fe1c:	2e00      	cmp	r6, #0
 801fe1e:	bfac      	ite	ge
 801fe20:	1b9e      	subge	r6, r3, r6
 801fe22:	461e      	movlt	r6, r3
 801fe24:	2e00      	cmp	r6, #0
 801fe26:	f77f aaef 	ble.w	801f408 <_vfprintf_r+0x410>
 801fe2a:	2e10      	cmp	r6, #16
 801fe2c:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fe2e:	4d38      	ldr	r5, [pc, #224]	; (801ff10 <_vfprintf_r+0xf18>)
 801fe30:	f77f af78 	ble.w	801fd24 <_vfprintf_r+0xd2c>
 801fe34:	2710      	movs	r7, #16
 801fe36:	f8dd a020 	ldr.w	sl, [sp, #32]
 801fe3a:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 801fe3e:	e005      	b.n	801fe4c <_vfprintf_r+0xe54>
 801fe40:	f108 0808 	add.w	r8, r8, #8
 801fe44:	3e10      	subs	r6, #16
 801fe46:	2e10      	cmp	r6, #16
 801fe48:	f77f af6c 	ble.w	801fd24 <_vfprintf_r+0xd2c>
 801fe4c:	3301      	adds	r3, #1
 801fe4e:	3410      	adds	r4, #16
 801fe50:	2b07      	cmp	r3, #7
 801fe52:	9427      	str	r4, [sp, #156]	; 0x9c
 801fe54:	9326      	str	r3, [sp, #152]	; 0x98
 801fe56:	e888 00a0 	stmia.w	r8, {r5, r7}
 801fe5a:	ddf1      	ble.n	801fe40 <_vfprintf_r+0xe48>
 801fe5c:	aa25      	add	r2, sp, #148	; 0x94
 801fe5e:	4659      	mov	r1, fp
 801fe60:	4650      	mov	r0, sl
 801fe62:	f002 ff1b 	bl	8022c9c <__sprint_r>
 801fe66:	2800      	cmp	r0, #0
 801fe68:	f040 817c 	bne.w	8020164 <_vfprintf_r+0x116c>
 801fe6c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fe6e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fe70:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fe74:	e7e6      	b.n	801fe44 <_vfprintf_r+0xe4c>
 801fe76:	9b06      	ldr	r3, [sp, #24]
 801fe78:	07d8      	lsls	r0, r3, #31
 801fe7a:	f53f adfe 	bmi.w	801fa7a <_vfprintf_r+0xa82>
 801fe7e:	3601      	adds	r6, #1
 801fe80:	3401      	adds	r4, #1
 801fe82:	2301      	movs	r3, #1
 801fe84:	2e07      	cmp	r6, #7
 801fe86:	9427      	str	r4, [sp, #156]	; 0x9c
 801fe88:	9626      	str	r6, [sp, #152]	; 0x98
 801fe8a:	f8c8 7000 	str.w	r7, [r8]
 801fe8e:	f8c8 3004 	str.w	r3, [r8, #4]
 801fe92:	f77f ae26 	ble.w	801fae2 <_vfprintf_r+0xaea>
 801fe96:	aa25      	add	r2, sp, #148	; 0x94
 801fe98:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fe9a:	9808      	ldr	r0, [sp, #32]
 801fe9c:	f002 fefe 	bl	8022c9c <__sprint_r>
 801fea0:	2800      	cmp	r0, #0
 801fea2:	f47f ae3f 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801fea6:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fea8:	9e26      	ldr	r6, [sp, #152]	; 0x98
 801feaa:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801feae:	e61a      	b.n	801fae6 <_vfprintf_r+0xaee>
 801feb0:	aa25      	add	r2, sp, #148	; 0x94
 801feb2:	990a      	ldr	r1, [sp, #40]	; 0x28
 801feb4:	9808      	ldr	r0, [sp, #32]
 801feb6:	f002 fef1 	bl	8022c9c <__sprint_r>
 801feba:	2800      	cmp	r0, #0
 801febc:	f47f ae32 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801fec0:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fec2:	9e26      	ldr	r6, [sp, #152]	; 0x98
 801fec4:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fec8:	e5e5      	b.n	801fa96 <_vfprintf_r+0xa9e>
 801feca:	aa25      	add	r2, sp, #148	; 0x94
 801fecc:	990a      	ldr	r1, [sp, #40]	; 0x28
 801fece:	9808      	ldr	r0, [sp, #32]
 801fed0:	f002 fee4 	bl	8022c9c <__sprint_r>
 801fed4:	2800      	cmp	r0, #0
 801fed6:	f47f ae25 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801feda:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801fedc:	9e26      	ldr	r6, [sp, #152]	; 0x98
 801fede:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801fee2:	e5e7      	b.n	801fab4 <_vfprintf_r+0xabc>
 801fee4:	3601      	adds	r6, #1
 801fee6:	443c      	add	r4, r7
 801fee8:	2e07      	cmp	r6, #7
 801feea:	9427      	str	r4, [sp, #156]	; 0x9c
 801feec:	9626      	str	r6, [sp, #152]	; 0x98
 801feee:	e888 00a0 	stmia.w	r8, {r5, r7}
 801fef2:	f77f adf6 	ble.w	801fae2 <_vfprintf_r+0xaea>
 801fef6:	e7ce      	b.n	801fe96 <_vfprintf_r+0xe9e>
 801fef8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801fefa:	3507      	adds	r5, #7
 801fefc:	f025 0307 	bic.w	r3, r5, #7
 801ff00:	f103 0208 	add.w	r2, r3, #8
 801ff04:	920e      	str	r2, [sp, #56]	; 0x38
 801ff06:	e9d3 4500 	ldrd	r4, r5, [r3]
 801ff0a:	f7ff bb36 	b.w	801f57a <_vfprintf_r+0x582>
 801ff0e:	bf00      	nop
 801ff10:	080251d4 	.word	0x080251d4
 801ff14:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801ff16:	3507      	adds	r5, #7
 801ff18:	f025 0507 	bic.w	r5, r5, #7
 801ff1c:	e9d5 2300 	ldrd	r2, r3, [r5]
 801ff20:	f105 0108 	add.w	r1, r5, #8
 801ff24:	910e      	str	r1, [sp, #56]	; 0x38
 801ff26:	4614      	mov	r4, r2
 801ff28:	461d      	mov	r5, r3
 801ff2a:	f7ff bb7b 	b.w	801f624 <_vfprintf_r+0x62c>
 801ff2e:	af32      	add	r7, sp, #200	; 0xc8
 801ff30:	f7ff b98b 	b.w	801f24a <_vfprintf_r+0x252>
 801ff34:	aa25      	add	r2, sp, #148	; 0x94
 801ff36:	990a      	ldr	r1, [sp, #40]	; 0x28
 801ff38:	9808      	ldr	r0, [sp, #32]
 801ff3a:	f002 feaf 	bl	8022c9c <__sprint_r>
 801ff3e:	2800      	cmp	r0, #0
 801ff40:	f47f adf0 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 801ff44:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 801ff46:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 801ff4a:	f7ff ba07 	b.w	801f35c <_vfprintf_r+0x364>
 801ff4e:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
 801ff52:	4264      	negs	r4, r4
 801ff54:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 801ff58:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
 801ff5c:	2301      	movs	r3, #1
 801ff5e:	f7ff b95a 	b.w	801f216 <_vfprintf_r+0x21e>
 801ff62:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 801ff66:	4602      	mov	r2, r0
 801ff68:	460b      	mov	r3, r1
 801ff6a:	f7e5 fb19 	bl	80055a0 <__aeabi_dcmpun>
 801ff6e:	2800      	cmp	r0, #0
 801ff70:	f040 828d 	bne.w	802048e <_vfprintf_r+0x1496>
 801ff74:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ff76:	3301      	adds	r3, #1
 801ff78:	f026 0a20 	bic.w	sl, r6, #32
 801ff7c:	f000 80a0 	beq.w	80200c0 <_vfprintf_r+0x10c8>
 801ff80:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 801ff84:	d104      	bne.n	801ff90 <_vfprintf_r+0xf98>
 801ff86:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ff88:	2b00      	cmp	r3, #0
 801ff8a:	bf08      	it	eq
 801ff8c:	2301      	moveq	r3, #1
 801ff8e:	9309      	str	r3, [sp, #36]	; 0x24
 801ff90:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801ff92:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
 801ff96:	2b00      	cmp	r3, #0
 801ff98:	9206      	str	r2, [sp, #24]
 801ff9a:	f2c0 81aa 	blt.w	80202f2 <_vfprintf_r+0x12fa>
 801ff9e:	ed9d 7b12 	vldr	d7, [sp, #72]	; 0x48
 801ffa2:	ed8d 7b1a 	vstr	d7, [sp, #104]	; 0x68
 801ffa6:	2300      	movs	r3, #0
 801ffa8:	930f      	str	r3, [sp, #60]	; 0x3c
 801ffaa:	2e66      	cmp	r6, #102	; 0x66
 801ffac:	f000 8189 	beq.w	80202c2 <_vfprintf_r+0x12ca>
 801ffb0:	2e46      	cmp	r6, #70	; 0x46
 801ffb2:	f000 81db 	beq.w	802036c <_vfprintf_r+0x1374>
 801ffb6:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
 801ffba:	bf0a      	itet	eq
 801ffbc:	9b09      	ldreq	r3, [sp, #36]	; 0x24
 801ffbe:	9d09      	ldrne	r5, [sp, #36]	; 0x24
 801ffc0:	1c5d      	addeq	r5, r3, #1
 801ffc2:	a823      	add	r0, sp, #140	; 0x8c
 801ffc4:	a920      	add	r1, sp, #128	; 0x80
 801ffc6:	aa1f      	add	r2, sp, #124	; 0x7c
 801ffc8:	2302      	movs	r3, #2
 801ffca:	9004      	str	r0, [sp, #16]
 801ffcc:	9202      	str	r2, [sp, #8]
 801ffce:	9300      	str	r3, [sp, #0]
 801ffd0:	9501      	str	r5, [sp, #4]
 801ffd2:	9103      	str	r1, [sp, #12]
 801ffd4:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 801ffd8:	9808      	ldr	r0, [sp, #32]
 801ffda:	f000 fc15 	bl	8020808 <_dtoa_r>
 801ffde:	2e67      	cmp	r6, #103	; 0x67
 801ffe0:	4607      	mov	r7, r0
 801ffe2:	f040 81aa 	bne.w	802033a <_vfprintf_r+0x1342>
 801ffe6:	f01b 0f01 	tst.w	fp, #1
 801ffea:	f000 8246 	beq.w	802047a <_vfprintf_r+0x1482>
 801ffee:	197c      	adds	r4, r7, r5
 801fff0:	2200      	movs	r2, #0
 801fff2:	2300      	movs	r3, #0
 801fff4:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
 801fff8:	f7e5 faa0 	bl	800553c <__aeabi_dcmpeq>
 801fffc:	2800      	cmp	r0, #0
 801fffe:	f040 8131 	bne.w	8020264 <_vfprintf_r+0x126c>
 8020002:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8020004:	42a3      	cmp	r3, r4
 8020006:	d206      	bcs.n	8020016 <_vfprintf_r+0x101e>
 8020008:	2130      	movs	r1, #48	; 0x30
 802000a:	1c5a      	adds	r2, r3, #1
 802000c:	9223      	str	r2, [sp, #140]	; 0x8c
 802000e:	7019      	strb	r1, [r3, #0]
 8020010:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8020012:	429c      	cmp	r4, r3
 8020014:	d8f9      	bhi.n	802000a <_vfprintf_r+0x1012>
 8020016:	1bdb      	subs	r3, r3, r7
 8020018:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 802001c:	9311      	str	r3, [sp, #68]	; 0x44
 802001e:	f000 80c4 	beq.w	80201aa <_vfprintf_r+0x11b2>
 8020022:	2e65      	cmp	r6, #101	; 0x65
 8020024:	f340 8289 	ble.w	802053a <_vfprintf_r+0x1542>
 8020028:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 802002a:	9310      	str	r3, [sp, #64]	; 0x40
 802002c:	2e66      	cmp	r6, #102	; 0x66
 802002e:	f000 8176 	beq.w	802031e <_vfprintf_r+0x1326>
 8020032:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8020034:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020036:	4619      	mov	r1, r3
 8020038:	4291      	cmp	r1, r2
 802003a:	f300 8163 	bgt.w	8020304 <_vfprintf_r+0x130c>
 802003e:	f01b 0f01 	tst.w	fp, #1
 8020042:	f040 8211 	bne.w	8020468 <_vfprintf_r+0x1470>
 8020046:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 802004a:	9307      	str	r3, [sp, #28]
 802004c:	920d      	str	r2, [sp, #52]	; 0x34
 802004e:	2667      	movs	r6, #103	; 0x67
 8020050:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020052:	2b00      	cmp	r3, #0
 8020054:	f040 80a1 	bne.w	802019a <_vfprintf_r+0x11a2>
 8020058:	9309      	str	r3, [sp, #36]	; 0x24
 802005a:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 802005e:	f7ff b8fc 	b.w	801f25a <_vfprintf_r+0x262>
 8020062:	f025 0507 	bic.w	r5, r5, #7
 8020066:	ed95 7b00 	vldr	d7, [r5]
 802006a:	f105 0308 	add.w	r3, r5, #8
 802006e:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 8020072:	930e      	str	r3, [sp, #56]	; 0x38
 8020074:	f7ff bbc1 	b.w	801f7fa <_vfprintf_r+0x802>
 8020078:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
 802007c:	f7fb fe46 	bl	801bd0c <__retarget_lock_release_recursive>
 8020080:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8020084:	930b      	str	r3, [sp, #44]	; 0x2c
 8020086:	f7ff ba20 	b.w	801f4ca <_vfprintf_r+0x4d2>
 802008a:	9a06      	ldr	r2, [sp, #24]
 802008c:	07d5      	lsls	r5, r2, #31
 802008e:	f57f aead 	bpl.w	801fdec <_vfprintf_r+0xdf4>
 8020092:	e69b      	b.n	801fdcc <_vfprintf_r+0xdd4>
 8020094:	f108 0808 	add.w	r8, r8, #8
 8020098:	e693      	b.n	801fdc2 <_vfprintf_r+0xdca>
 802009a:	aa25      	add	r2, sp, #148	; 0x94
 802009c:	990a      	ldr	r1, [sp, #40]	; 0x28
 802009e:	9808      	ldr	r0, [sp, #32]
 80200a0:	f002 fdfc 	bl	8022c9c <__sprint_r>
 80200a4:	2800      	cmp	r0, #0
 80200a6:	f47f ad3d 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 80200aa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80200ac:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 80200ae:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 80200b2:	e69b      	b.n	801fdec <_vfprintf_r+0xdf4>
 80200b4:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
 80200b8:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
 80200bc:	f7ff bbc4 	b.w	801f848 <_vfprintf_r+0x850>
 80200c0:	2306      	movs	r3, #6
 80200c2:	9309      	str	r3, [sp, #36]	; 0x24
 80200c4:	e764      	b.n	801ff90 <_vfprintf_r+0xf98>
 80200c6:	aa25      	add	r2, sp, #148	; 0x94
 80200c8:	990a      	ldr	r1, [sp, #40]	; 0x28
 80200ca:	9808      	ldr	r0, [sp, #32]
 80200cc:	f002 fde6 	bl	8022c9c <__sprint_r>
 80200d0:	2800      	cmp	r0, #0
 80200d2:	f47f ad27 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 80200d6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 80200da:	e431      	b.n	801f940 <_vfprintf_r+0x948>
 80200dc:	9b26      	ldr	r3, [sp, #152]	; 0x98
 80200de:	4ab2      	ldr	r2, [pc, #712]	; (80203a8 <_vfprintf_r+0x13b0>)
 80200e0:	f8c8 2000 	str.w	r2, [r8]
 80200e4:	3301      	adds	r3, #1
 80200e6:	3401      	adds	r4, #1
 80200e8:	2201      	movs	r2, #1
 80200ea:	2b07      	cmp	r3, #7
 80200ec:	9427      	str	r4, [sp, #156]	; 0x9c
 80200ee:	9326      	str	r3, [sp, #152]	; 0x98
 80200f0:	f8c8 2004 	str.w	r2, [r8, #4]
 80200f4:	f300 812d 	bgt.w	8020352 <_vfprintf_r+0x135a>
 80200f8:	f108 0808 	add.w	r8, r8, #8
 80200fc:	b929      	cbnz	r1, 802010a <_vfprintf_r+0x1112>
 80200fe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8020100:	b91b      	cbnz	r3, 802010a <_vfprintf_r+0x1112>
 8020102:	9b06      	ldr	r3, [sp, #24]
 8020104:	07de      	lsls	r6, r3, #31
 8020106:	f57f a97f 	bpl.w	801f408 <_vfprintf_r+0x410>
 802010a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 802010c:	9814      	ldr	r0, [sp, #80]	; 0x50
 802010e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8020110:	f8c8 2000 	str.w	r2, [r8]
 8020114:	3301      	adds	r3, #1
 8020116:	4602      	mov	r2, r0
 8020118:	4422      	add	r2, r4
 802011a:	2b07      	cmp	r3, #7
 802011c:	9227      	str	r2, [sp, #156]	; 0x9c
 802011e:	f8c8 0004 	str.w	r0, [r8, #4]
 8020122:	9326      	str	r3, [sp, #152]	; 0x98
 8020124:	f300 817a 	bgt.w	802041c <_vfprintf_r+0x1424>
 8020128:	f108 0808 	add.w	r8, r8, #8
 802012c:	2900      	cmp	r1, #0
 802012e:	f2c0 814f 	blt.w	80203d0 <_vfprintf_r+0x13d8>
 8020132:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020134:	f8c8 7000 	str.w	r7, [r8]
 8020138:	3301      	adds	r3, #1
 802013a:	188c      	adds	r4, r1, r2
 802013c:	2b07      	cmp	r3, #7
 802013e:	9427      	str	r4, [sp, #156]	; 0x9c
 8020140:	9326      	str	r3, [sp, #152]	; 0x98
 8020142:	f8c8 1004 	str.w	r1, [r8, #4]
 8020146:	f77f a95d 	ble.w	801f404 <_vfprintf_r+0x40c>
 802014a:	e4d9      	b.n	801fb00 <_vfprintf_r+0xb08>
 802014c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802014e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8020150:	6813      	ldr	r3, [r2, #0]
 8020152:	17cd      	asrs	r5, r1, #31
 8020154:	4608      	mov	r0, r1
 8020156:	3204      	adds	r2, #4
 8020158:	4629      	mov	r1, r5
 802015a:	920e      	str	r2, [sp, #56]	; 0x38
 802015c:	e9c3 0100 	strd	r0, r1, [r3]
 8020160:	f7fe bf95 	b.w	801f08e <_vfprintf_r+0x96>
 8020164:	46da      	mov	sl, fp
 8020166:	f7ff bbbe 	b.w	801f8e6 <_vfprintf_r+0x8ee>
 802016a:	aa25      	add	r2, sp, #148	; 0x94
 802016c:	990a      	ldr	r1, [sp, #40]	; 0x28
 802016e:	9808      	ldr	r0, [sp, #32]
 8020170:	f002 fd94 	bl	8022c9c <__sprint_r>
 8020174:	2800      	cmp	r0, #0
 8020176:	f47f acd5 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 802017a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 802017c:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 8020180:	f7ff bbf7 	b.w	801f972 <_vfprintf_r+0x97a>
 8020184:	4638      	mov	r0, r7
 8020186:	9409      	str	r4, [sp, #36]	; 0x24
 8020188:	f7e4 fa5a 	bl	8004640 <strlen>
 802018c:	950e      	str	r5, [sp, #56]	; 0x38
 802018e:	900d      	str	r0, [sp, #52]	; 0x34
 8020190:	f8cd b018 	str.w	fp, [sp, #24]
 8020194:	4603      	mov	r3, r0
 8020196:	f7ff ba27 	b.w	801f5e8 <_vfprintf_r+0x5f0>
 802019a:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
 802019e:	2300      	movs	r3, #0
 80201a0:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
 80201a4:	9309      	str	r3, [sp, #36]	; 0x24
 80201a6:	f7ff b85b 	b.w	801f260 <_vfprintf_r+0x268>
 80201aa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80201ac:	9310      	str	r3, [sp, #64]	; 0x40
 80201ae:	461a      	mov	r2, r3
 80201b0:	3303      	adds	r3, #3
 80201b2:	db04      	blt.n	80201be <_vfprintf_r+0x11c6>
 80201b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80201b6:	4619      	mov	r1, r3
 80201b8:	4291      	cmp	r1, r2
 80201ba:	f6bf af3a 	bge.w	8020032 <_vfprintf_r+0x103a>
 80201be:	3e02      	subs	r6, #2
 80201c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80201c2:	f88d 6084 	strb.w	r6, [sp, #132]	; 0x84
 80201c6:	3b01      	subs	r3, #1
 80201c8:	2b00      	cmp	r3, #0
 80201ca:	931f      	str	r3, [sp, #124]	; 0x7c
 80201cc:	bfbd      	ittte	lt
 80201ce:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
 80201d0:	f1c3 0301 	rsblt	r3, r3, #1
 80201d4:	222d      	movlt	r2, #45	; 0x2d
 80201d6:	222b      	movge	r2, #43	; 0x2b
 80201d8:	2b09      	cmp	r3, #9
 80201da:	f88d 2085 	strb.w	r2, [sp, #133]	; 0x85
 80201de:	f340 814e 	ble.w	802047e <_vfprintf_r+0x1486>
 80201e2:	f10d 0493 	add.w	r4, sp, #147	; 0x93
 80201e6:	4620      	mov	r0, r4
 80201e8:	4d70      	ldr	r5, [pc, #448]	; (80203ac <_vfprintf_r+0x13b4>)
 80201ea:	e000      	b.n	80201ee <_vfprintf_r+0x11f6>
 80201ec:	4610      	mov	r0, r2
 80201ee:	fb85 1203 	smull	r1, r2, r5, r3
 80201f2:	17d9      	asrs	r1, r3, #31
 80201f4:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
 80201f8:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 80201fc:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
 8020200:	3230      	adds	r2, #48	; 0x30
 8020202:	2909      	cmp	r1, #9
 8020204:	f800 2c01 	strb.w	r2, [r0, #-1]
 8020208:	460b      	mov	r3, r1
 802020a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 802020e:	dced      	bgt.n	80201ec <_vfprintf_r+0x11f4>
 8020210:	3330      	adds	r3, #48	; 0x30
 8020212:	3802      	subs	r0, #2
 8020214:	b2d9      	uxtb	r1, r3
 8020216:	4284      	cmp	r4, r0
 8020218:	f802 1c01 	strb.w	r1, [r2, #-1]
 802021c:	f240 8198 	bls.w	8020550 <_vfprintf_r+0x1558>
 8020220:	f10d 0086 	add.w	r0, sp, #134	; 0x86
 8020224:	4613      	mov	r3, r2
 8020226:	e001      	b.n	802022c <_vfprintf_r+0x1234>
 8020228:	f813 1b01 	ldrb.w	r1, [r3], #1
 802022c:	f800 1b01 	strb.w	r1, [r0], #1
 8020230:	42a3      	cmp	r3, r4
 8020232:	d1f9      	bne.n	8020228 <_vfprintf_r+0x1230>
 8020234:	3301      	adds	r3, #1
 8020236:	1a9b      	subs	r3, r3, r2
 8020238:	f10d 0286 	add.w	r2, sp, #134	; 0x86
 802023c:	4413      	add	r3, r2
 802023e:	aa21      	add	r2, sp, #132	; 0x84
 8020240:	1a9b      	subs	r3, r3, r2
 8020242:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8020244:	9317      	str	r3, [sp, #92]	; 0x5c
 8020246:	2a01      	cmp	r2, #1
 8020248:	4413      	add	r3, r2
 802024a:	930d      	str	r3, [sp, #52]	; 0x34
 802024c:	f340 814c 	ble.w	80204e8 <_vfprintf_r+0x14f0>
 8020250:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8020252:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8020254:	4413      	add	r3, r2
 8020256:	930d      	str	r3, [sp, #52]	; 0x34
 8020258:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 802025c:	9307      	str	r3, [sp, #28]
 802025e:	2300      	movs	r3, #0
 8020260:	9310      	str	r3, [sp, #64]	; 0x40
 8020262:	e6f5      	b.n	8020050 <_vfprintf_r+0x1058>
 8020264:	4623      	mov	r3, r4
 8020266:	e6d6      	b.n	8020016 <_vfprintf_r+0x101e>
 8020268:	aa25      	add	r2, sp, #148	; 0x94
 802026a:	990a      	ldr	r1, [sp, #40]	; 0x28
 802026c:	9808      	ldr	r0, [sp, #32]
 802026e:	f002 fd15 	bl	8022c9c <__sprint_r>
 8020272:	2800      	cmp	r0, #0
 8020274:	f47f ac56 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 8020278:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 802027a:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 802027e:	e4c8      	b.n	801fc12 <_vfprintf_r+0xc1a>
 8020280:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020282:	9710      	str	r7, [sp, #64]	; 0x40
 8020284:	2b06      	cmp	r3, #6
 8020286:	bf28      	it	cs
 8020288:	2306      	movcs	r3, #6
 802028a:	9709      	str	r7, [sp, #36]	; 0x24
 802028c:	46ba      	mov	sl, r7
 802028e:	9307      	str	r3, [sp, #28]
 8020290:	950e      	str	r5, [sp, #56]	; 0x38
 8020292:	f8cd b018 	str.w	fp, [sp, #24]
 8020296:	930d      	str	r3, [sp, #52]	; 0x34
 8020298:	4f45      	ldr	r7, [pc, #276]	; (80203b0 <_vfprintf_r+0x13b8>)
 802029a:	f7fe bfde 	b.w	801f25a <_vfprintf_r+0x262>
 802029e:	aa25      	add	r2, sp, #148	; 0x94
 80202a0:	990a      	ldr	r1, [sp, #40]	; 0x28
 80202a2:	9808      	ldr	r0, [sp, #32]
 80202a4:	f002 fcfa 	bl	8022c9c <__sprint_r>
 80202a8:	2800      	cmp	r0, #0
 80202aa:	f47f ac3b 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 80202ae:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80202b0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80202b2:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 80202b4:	1ad3      	subs	r3, r2, r3
 80202b6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 80202ba:	e5af      	b.n	801fe1c <_vfprintf_r+0xe24>
 80202bc:	46a2      	mov	sl, r4
 80202be:	f7ff bb12 	b.w	801f8e6 <_vfprintf_r+0x8ee>
 80202c2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80202c4:	9501      	str	r5, [sp, #4]
 80202c6:	a823      	add	r0, sp, #140	; 0x8c
 80202c8:	a920      	add	r1, sp, #128	; 0x80
 80202ca:	aa1f      	add	r2, sp, #124	; 0x7c
 80202cc:	2303      	movs	r3, #3
 80202ce:	9004      	str	r0, [sp, #16]
 80202d0:	9202      	str	r2, [sp, #8]
 80202d2:	9300      	str	r3, [sp, #0]
 80202d4:	9103      	str	r1, [sp, #12]
 80202d6:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 80202da:	9808      	ldr	r0, [sp, #32]
 80202dc:	f000 fa94 	bl	8020808 <_dtoa_r>
 80202e0:	4607      	mov	r7, r0
 80202e2:	1944      	adds	r4, r0, r5
 80202e4:	783b      	ldrb	r3, [r7, #0]
 80202e6:	2b30      	cmp	r3, #48	; 0x30
 80202e8:	f000 80de 	beq.w	80204a8 <_vfprintf_r+0x14b0>
 80202ec:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
 80202ee:	442c      	add	r4, r5
 80202f0:	e67e      	b.n	801fff0 <_vfprintf_r+0xff8>
 80202f2:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
 80202f6:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 80202fa:	931b      	str	r3, [sp, #108]	; 0x6c
 80202fc:	232d      	movs	r3, #45	; 0x2d
 80202fe:	911a      	str	r1, [sp, #104]	; 0x68
 8020300:	930f      	str	r3, [sp, #60]	; 0x3c
 8020302:	e652      	b.n	801ffaa <_vfprintf_r+0xfb2>
 8020304:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8020306:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8020308:	4413      	add	r3, r2
 802030a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802030c:	930d      	str	r3, [sp, #52]	; 0x34
 802030e:	2a00      	cmp	r2, #0
 8020310:	f340 80e2 	ble.w	80204d8 <_vfprintf_r+0x14e0>
 8020314:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8020318:	9307      	str	r3, [sp, #28]
 802031a:	2667      	movs	r6, #103	; 0x67
 802031c:	e698      	b.n	8020050 <_vfprintf_r+0x1058>
 802031e:	2b00      	cmp	r3, #0
 8020320:	f340 80f9 	ble.w	8020516 <_vfprintf_r+0x151e>
 8020324:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8020326:	2a00      	cmp	r2, #0
 8020328:	f040 80cc 	bne.w	80204c4 <_vfprintf_r+0x14cc>
 802032c:	f01b 0f01 	tst.w	fp, #1
 8020330:	f040 80c8 	bne.w	80204c4 <_vfprintf_r+0x14cc>
 8020334:	9307      	str	r3, [sp, #28]
 8020336:	930d      	str	r3, [sp, #52]	; 0x34
 8020338:	e68a      	b.n	8020050 <_vfprintf_r+0x1058>
 802033a:	2e47      	cmp	r6, #71	; 0x47
 802033c:	f47f ae57 	bne.w	801ffee <_vfprintf_r+0xff6>
 8020340:	f01b 0f01 	tst.w	fp, #1
 8020344:	f000 80f1 	beq.w	802052a <_vfprintf_r+0x1532>
 8020348:	2e46      	cmp	r6, #70	; 0x46
 802034a:	eb07 0405 	add.w	r4, r7, r5
 802034e:	d0c9      	beq.n	80202e4 <_vfprintf_r+0x12ec>
 8020350:	e64e      	b.n	801fff0 <_vfprintf_r+0xff8>
 8020352:	aa25      	add	r2, sp, #148	; 0x94
 8020354:	990a      	ldr	r1, [sp, #40]	; 0x28
 8020356:	9808      	ldr	r0, [sp, #32]
 8020358:	f002 fca0 	bl	8022c9c <__sprint_r>
 802035c:	2800      	cmp	r0, #0
 802035e:	f47f abe1 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 8020362:	991f      	ldr	r1, [sp, #124]	; 0x7c
 8020364:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 8020366:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 802036a:	e6c7      	b.n	80200fc <_vfprintf_r+0x1104>
 802036c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802036e:	9401      	str	r4, [sp, #4]
 8020370:	a823      	add	r0, sp, #140	; 0x8c
 8020372:	a920      	add	r1, sp, #128	; 0x80
 8020374:	aa1f      	add	r2, sp, #124	; 0x7c
 8020376:	2303      	movs	r3, #3
 8020378:	9004      	str	r0, [sp, #16]
 802037a:	9202      	str	r2, [sp, #8]
 802037c:	9300      	str	r3, [sp, #0]
 802037e:	9103      	str	r1, [sp, #12]
 8020380:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 8020384:	9808      	ldr	r0, [sp, #32]
 8020386:	f000 fa3f 	bl	8020808 <_dtoa_r>
 802038a:	4625      	mov	r5, r4
 802038c:	4607      	mov	r7, r0
 802038e:	e7db      	b.n	8020348 <_vfprintf_r+0x1350>
 8020390:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020392:	9307      	str	r3, [sp, #28]
 8020394:	930d      	str	r3, [sp, #52]	; 0x34
 8020396:	9009      	str	r0, [sp, #36]	; 0x24
 8020398:	950e      	str	r5, [sp, #56]	; 0x38
 802039a:	f8cd b018 	str.w	fp, [sp, #24]
 802039e:	9010      	str	r0, [sp, #64]	; 0x40
 80203a0:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
 80203a4:	f7fe bf59 	b.w	801f25a <_vfprintf_r+0x262>
 80203a8:	080251c0 	.word	0x080251c0
 80203ac:	66666667 	.word	0x66666667
 80203b0:	08024c88 	.word	0x08024c88
 80203b4:	2300      	movs	r3, #0
 80203b6:	9309      	str	r3, [sp, #36]	; 0x24
 80203b8:	f7fe be9e 	b.w	801f0f8 <_vfprintf_r+0x100>
 80203bc:	9808      	ldr	r0, [sp, #32]
 80203be:	aa25      	add	r2, sp, #148	; 0x94
 80203c0:	4651      	mov	r1, sl
 80203c2:	f002 fc6b 	bl	8022c9c <__sprint_r>
 80203c6:	2800      	cmp	r0, #0
 80203c8:	f43f aa8b 	beq.w	801f8e2 <_vfprintf_r+0x8ea>
 80203cc:	f7ff ba8b 	b.w	801f8e6 <_vfprintf_r+0x8ee>
 80203d0:	424e      	negs	r6, r1
 80203d2:	3110      	adds	r1, #16
 80203d4:	4d6a      	ldr	r5, [pc, #424]	; (8020580 <_vfprintf_r+0x1588>)
 80203d6:	da2f      	bge.n	8020438 <_vfprintf_r+0x1440>
 80203d8:	2410      	movs	r4, #16
 80203da:	f8dd a020 	ldr.w	sl, [sp, #32]
 80203de:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80203e2:	e004      	b.n	80203ee <_vfprintf_r+0x13f6>
 80203e4:	f108 0808 	add.w	r8, r8, #8
 80203e8:	3e10      	subs	r6, #16
 80203ea:	2e10      	cmp	r6, #16
 80203ec:	dd24      	ble.n	8020438 <_vfprintf_r+0x1440>
 80203ee:	3301      	adds	r3, #1
 80203f0:	3210      	adds	r2, #16
 80203f2:	2b07      	cmp	r3, #7
 80203f4:	9227      	str	r2, [sp, #156]	; 0x9c
 80203f6:	9326      	str	r3, [sp, #152]	; 0x98
 80203f8:	f8c8 5000 	str.w	r5, [r8]
 80203fc:	f8c8 4004 	str.w	r4, [r8, #4]
 8020400:	ddf0      	ble.n	80203e4 <_vfprintf_r+0x13ec>
 8020402:	aa25      	add	r2, sp, #148	; 0x94
 8020404:	4659      	mov	r1, fp
 8020406:	4650      	mov	r0, sl
 8020408:	f002 fc48 	bl	8022c9c <__sprint_r>
 802040c:	2800      	cmp	r0, #0
 802040e:	f47f aea9 	bne.w	8020164 <_vfprintf_r+0x116c>
 8020412:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8020414:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8020416:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 802041a:	e7e5      	b.n	80203e8 <_vfprintf_r+0x13f0>
 802041c:	aa25      	add	r2, sp, #148	; 0x94
 802041e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8020420:	9808      	ldr	r0, [sp, #32]
 8020422:	f002 fc3b 	bl	8022c9c <__sprint_r>
 8020426:	2800      	cmp	r0, #0
 8020428:	f47f ab7c 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 802042c:	991f      	ldr	r1, [sp, #124]	; 0x7c
 802042e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8020430:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8020432:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 8020436:	e679      	b.n	802012c <_vfprintf_r+0x1134>
 8020438:	3301      	adds	r3, #1
 802043a:	4432      	add	r2, r6
 802043c:	2b07      	cmp	r3, #7
 802043e:	e888 0060 	stmia.w	r8, {r5, r6}
 8020442:	9227      	str	r2, [sp, #156]	; 0x9c
 8020444:	9326      	str	r3, [sp, #152]	; 0x98
 8020446:	f108 0808 	add.w	r8, r8, #8
 802044a:	f77f ae72 	ble.w	8020132 <_vfprintf_r+0x113a>
 802044e:	aa25      	add	r2, sp, #148	; 0x94
 8020450:	990a      	ldr	r1, [sp, #40]	; 0x28
 8020452:	9808      	ldr	r0, [sp, #32]
 8020454:	f002 fc22 	bl	8022c9c <__sprint_r>
 8020458:	2800      	cmp	r0, #0
 802045a:	f47f ab63 	bne.w	801fb24 <_vfprintf_r+0xb2c>
 802045e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8020460:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8020462:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 8020466:	e664      	b.n	8020132 <_vfprintf_r+0x113a>
 8020468:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802046a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802046c:	4413      	add	r3, r2
 802046e:	930d      	str	r3, [sp, #52]	; 0x34
 8020470:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8020474:	9307      	str	r3, [sp, #28]
 8020476:	2667      	movs	r6, #103	; 0x67
 8020478:	e5ea      	b.n	8020050 <_vfprintf_r+0x1058>
 802047a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802047c:	e5cb      	b.n	8020016 <_vfprintf_r+0x101e>
 802047e:	3330      	adds	r3, #48	; 0x30
 8020480:	2230      	movs	r2, #48	; 0x30
 8020482:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
 8020486:	f88d 2086 	strb.w	r2, [sp, #134]	; 0x86
 802048a:	ab22      	add	r3, sp, #136	; 0x88
 802048c:	e6d7      	b.n	802023e <_vfprintf_r+0x1246>
 802048e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020490:	4f3c      	ldr	r7, [pc, #240]	; (8020584 <_vfprintf_r+0x158c>)
 8020492:	2b00      	cmp	r3, #0
 8020494:	bfb6      	itet	lt
 8020496:	f04f 0a2d 	movlt.w	sl, #45	; 0x2d
 802049a:	f89d a077 	ldrbge.w	sl, [sp, #119]	; 0x77
 802049e:	f88d a077 	strblt.w	sl, [sp, #119]	; 0x77
 80204a2:	4b39      	ldr	r3, [pc, #228]	; (8020588 <_vfprintf_r+0x1590>)
 80204a4:	f7ff b9d2 	b.w	801f84c <_vfprintf_r+0x854>
 80204a8:	2200      	movs	r2, #0
 80204aa:	2300      	movs	r3, #0
 80204ac:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
 80204b0:	f7e5 f844 	bl	800553c <__aeabi_dcmpeq>
 80204b4:	2800      	cmp	r0, #0
 80204b6:	f47f af19 	bne.w	80202ec <_vfprintf_r+0x12f4>
 80204ba:	f1c5 0501 	rsb	r5, r5, #1
 80204be:	951f      	str	r5, [sp, #124]	; 0x7c
 80204c0:	442c      	add	r4, r5
 80204c2:	e595      	b.n	801fff0 <_vfprintf_r+0xff8>
 80204c4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80204c6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80204c8:	4413      	add	r3, r2
 80204ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80204cc:	441a      	add	r2, r3
 80204ce:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 80204d2:	920d      	str	r2, [sp, #52]	; 0x34
 80204d4:	9307      	str	r3, [sp, #28]
 80204d6:	e5bb      	b.n	8020050 <_vfprintf_r+0x1058>
 80204d8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80204da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80204dc:	f1c3 0301 	rsb	r3, r3, #1
 80204e0:	441a      	add	r2, r3
 80204e2:	4613      	mov	r3, r2
 80204e4:	920d      	str	r2, [sp, #52]	; 0x34
 80204e6:	e715      	b.n	8020314 <_vfprintf_r+0x131c>
 80204e8:	f01b 0301 	ands.w	r3, fp, #1
 80204ec:	9310      	str	r3, [sp, #64]	; 0x40
 80204ee:	f47f aeaf 	bne.w	8020250 <_vfprintf_r+0x1258>
 80204f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80204f4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80204f8:	9307      	str	r3, [sp, #28]
 80204fa:	e5a9      	b.n	8020050 <_vfprintf_r+0x1058>
 80204fc:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 80204fe:	f899 6001 	ldrb.w	r6, [r9, #1]
 8020502:	6823      	ldr	r3, [r4, #0]
 8020504:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8020508:	9309      	str	r3, [sp, #36]	; 0x24
 802050a:	4623      	mov	r3, r4
 802050c:	3304      	adds	r3, #4
 802050e:	4681      	mov	r9, r0
 8020510:	930e      	str	r3, [sp, #56]	; 0x38
 8020512:	f7fe bdef 	b.w	801f0f4 <_vfprintf_r+0xfc>
 8020516:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020518:	b913      	cbnz	r3, 8020520 <_vfprintf_r+0x1528>
 802051a:	f01b 0f01 	tst.w	fp, #1
 802051e:	d002      	beq.n	8020526 <_vfprintf_r+0x152e>
 8020520:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8020522:	3301      	adds	r3, #1
 8020524:	e7d1      	b.n	80204ca <_vfprintf_r+0x14d2>
 8020526:	2301      	movs	r3, #1
 8020528:	e704      	b.n	8020334 <_vfprintf_r+0x133c>
 802052a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802052c:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 8020530:	eba3 0307 	sub.w	r3, r3, r7
 8020534:	9311      	str	r3, [sp, #68]	; 0x44
 8020536:	f43f ae38 	beq.w	80201aa <_vfprintf_r+0x11b2>
 802053a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 802053c:	9310      	str	r3, [sp, #64]	; 0x40
 802053e:	e63f      	b.n	80201c0 <_vfprintf_r+0x11c8>
 8020540:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 8020544:	f7ff b805 	b.w	801f552 <_vfprintf_r+0x55a>
 8020548:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 802054c:	f7ff b945 	b.w	801f7da <_vfprintf_r+0x7e2>
 8020550:	f10d 0386 	add.w	r3, sp, #134	; 0x86
 8020554:	e673      	b.n	802023e <_vfprintf_r+0x1246>
 8020556:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 802055a:	f7ff b84f 	b.w	801f5fc <_vfprintf_r+0x604>
 802055e:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 8020562:	f7ff b99e 	b.w	801f8a2 <_vfprintf_r+0x8aa>
 8020566:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 802056a:	f7ff b91d 	b.w	801f7a8 <_vfprintf_r+0x7b0>
 802056e:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 8020572:	f7ff b8ee 	b.w	801f752 <_vfprintf_r+0x75a>
 8020576:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
 802057a:	f7ff b895 	b.w	801f6a8 <_vfprintf_r+0x6b0>
 802057e:	bf00      	nop
 8020580:	080251d4 	.word	0x080251d4
 8020584:	08025194 	.word	0x08025194
 8020588:	08025190 	.word	0x08025190

0802058c <__sbprintf>:
 802058c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020590:	460c      	mov	r4, r1
 8020592:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
 8020596:	8989      	ldrh	r1, [r1, #12]
 8020598:	6e66      	ldr	r6, [r4, #100]	; 0x64
 802059a:	89e5      	ldrh	r5, [r4, #14]
 802059c:	9619      	str	r6, [sp, #100]	; 0x64
 802059e:	f021 0102 	bic.w	r1, r1, #2
 80205a2:	4606      	mov	r6, r0
 80205a4:	69e0      	ldr	r0, [r4, #28]
 80205a6:	f8ad 100c 	strh.w	r1, [sp, #12]
 80205aa:	4617      	mov	r7, r2
 80205ac:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80205b0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80205b2:	f8ad 500e 	strh.w	r5, [sp, #14]
 80205b6:	4698      	mov	r8, r3
 80205b8:	ad1a      	add	r5, sp, #104	; 0x68
 80205ba:	2300      	movs	r3, #0
 80205bc:	9007      	str	r0, [sp, #28]
 80205be:	a816      	add	r0, sp, #88	; 0x58
 80205c0:	9209      	str	r2, [sp, #36]	; 0x24
 80205c2:	9306      	str	r3, [sp, #24]
 80205c4:	9500      	str	r5, [sp, #0]
 80205c6:	9504      	str	r5, [sp, #16]
 80205c8:	9102      	str	r1, [sp, #8]
 80205ca:	9105      	str	r1, [sp, #20]
 80205cc:	f7fb fb94 	bl	801bcf8 <__retarget_lock_init_recursive>
 80205d0:	4643      	mov	r3, r8
 80205d2:	463a      	mov	r2, r7
 80205d4:	4669      	mov	r1, sp
 80205d6:	4630      	mov	r0, r6
 80205d8:	f7fe fd0e 	bl	801eff8 <_vfprintf_r>
 80205dc:	1e05      	subs	r5, r0, #0
 80205de:	db07      	blt.n	80205f0 <__sbprintf+0x64>
 80205e0:	4630      	mov	r0, r6
 80205e2:	4669      	mov	r1, sp
 80205e4:	f7fc feca 	bl	801d37c <_fflush_r>
 80205e8:	2800      	cmp	r0, #0
 80205ea:	bf18      	it	ne
 80205ec:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
 80205f0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80205f4:	065b      	lsls	r3, r3, #25
 80205f6:	d503      	bpl.n	8020600 <__sbprintf+0x74>
 80205f8:	89a3      	ldrh	r3, [r4, #12]
 80205fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80205fe:	81a3      	strh	r3, [r4, #12]
 8020600:	9816      	ldr	r0, [sp, #88]	; 0x58
 8020602:	f7fb fb7b 	bl	801bcfc <__retarget_lock_close_recursive>
 8020606:	4628      	mov	r0, r5
 8020608:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
 802060c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08020610 <__swsetup_r>:
 8020610:	b538      	push	{r3, r4, r5, lr}
 8020612:	4b30      	ldr	r3, [pc, #192]	; (80206d4 <__swsetup_r+0xc4>)
 8020614:	681b      	ldr	r3, [r3, #0]
 8020616:	4605      	mov	r5, r0
 8020618:	460c      	mov	r4, r1
 802061a:	b113      	cbz	r3, 8020622 <__swsetup_r+0x12>
 802061c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802061e:	2a00      	cmp	r2, #0
 8020620:	d038      	beq.n	8020694 <__swsetup_r+0x84>
 8020622:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8020626:	b293      	uxth	r3, r2
 8020628:	0718      	lsls	r0, r3, #28
 802062a:	d50c      	bpl.n	8020646 <__swsetup_r+0x36>
 802062c:	6920      	ldr	r0, [r4, #16]
 802062e:	b1a8      	cbz	r0, 802065c <__swsetup_r+0x4c>
 8020630:	f013 0201 	ands.w	r2, r3, #1
 8020634:	d01e      	beq.n	8020674 <__swsetup_r+0x64>
 8020636:	6963      	ldr	r3, [r4, #20]
 8020638:	2200      	movs	r2, #0
 802063a:	425b      	negs	r3, r3
 802063c:	61a3      	str	r3, [r4, #24]
 802063e:	60a2      	str	r2, [r4, #8]
 8020640:	b1f0      	cbz	r0, 8020680 <__swsetup_r+0x70>
 8020642:	2000      	movs	r0, #0
 8020644:	bd38      	pop	{r3, r4, r5, pc}
 8020646:	06d9      	lsls	r1, r3, #27
 8020648:	d53c      	bpl.n	80206c4 <__swsetup_r+0xb4>
 802064a:	0758      	lsls	r0, r3, #29
 802064c:	d426      	bmi.n	802069c <__swsetup_r+0x8c>
 802064e:	6920      	ldr	r0, [r4, #16]
 8020650:	f042 0308 	orr.w	r3, r2, #8
 8020654:	81a3      	strh	r3, [r4, #12]
 8020656:	b29b      	uxth	r3, r3
 8020658:	2800      	cmp	r0, #0
 802065a:	d1e9      	bne.n	8020630 <__swsetup_r+0x20>
 802065c:	f403 7220 	and.w	r2, r3, #640	; 0x280
 8020660:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8020664:	d0e4      	beq.n	8020630 <__swsetup_r+0x20>
 8020666:	4628      	mov	r0, r5
 8020668:	4621      	mov	r1, r4
 802066a:	f001 f99f 	bl	80219ac <__smakebuf_r>
 802066e:	89a3      	ldrh	r3, [r4, #12]
 8020670:	6920      	ldr	r0, [r4, #16]
 8020672:	e7dd      	b.n	8020630 <__swsetup_r+0x20>
 8020674:	0799      	lsls	r1, r3, #30
 8020676:	bf58      	it	pl
 8020678:	6962      	ldrpl	r2, [r4, #20]
 802067a:	60a2      	str	r2, [r4, #8]
 802067c:	2800      	cmp	r0, #0
 802067e:	d1e0      	bne.n	8020642 <__swsetup_r+0x32>
 8020680:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8020684:	061a      	lsls	r2, r3, #24
 8020686:	d5dd      	bpl.n	8020644 <__swsetup_r+0x34>
 8020688:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802068c:	81a3      	strh	r3, [r4, #12]
 802068e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8020692:	bd38      	pop	{r3, r4, r5, pc}
 8020694:	4618      	mov	r0, r3
 8020696:	f7fc fec9 	bl	801d42c <__sinit>
 802069a:	e7c2      	b.n	8020622 <__swsetup_r+0x12>
 802069c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802069e:	b151      	cbz	r1, 80206b6 <__swsetup_r+0xa6>
 80206a0:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80206a4:	4299      	cmp	r1, r3
 80206a6:	d004      	beq.n	80206b2 <__swsetup_r+0xa2>
 80206a8:	4628      	mov	r0, r5
 80206aa:	f7fc ff47 	bl	801d53c <_free_r>
 80206ae:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80206b2:	2300      	movs	r3, #0
 80206b4:	6323      	str	r3, [r4, #48]	; 0x30
 80206b6:	2300      	movs	r3, #0
 80206b8:	6920      	ldr	r0, [r4, #16]
 80206ba:	6063      	str	r3, [r4, #4]
 80206bc:	f022 0224 	bic.w	r2, r2, #36	; 0x24
 80206c0:	6020      	str	r0, [r4, #0]
 80206c2:	e7c5      	b.n	8020650 <__swsetup_r+0x40>
 80206c4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80206c8:	2309      	movs	r3, #9
 80206ca:	602b      	str	r3, [r5, #0]
 80206cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80206d0:	81a2      	strh	r2, [r4, #12]
 80206d2:	bd38      	pop	{r3, r4, r5, pc}
 80206d4:	20004474 	.word	0x20004474

080206d8 <abs>:
 80206d8:	2800      	cmp	r0, #0
 80206da:	bfb8      	it	lt
 80206dc:	4240      	neglt	r0, r0
 80206de:	4770      	bx	lr

080206e0 <quorem>:
 80206e0:	6902      	ldr	r2, [r0, #16]
 80206e2:	690b      	ldr	r3, [r1, #16]
 80206e4:	4293      	cmp	r3, r2
 80206e6:	f300 808d 	bgt.w	8020804 <quorem+0x124>
 80206ea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80206ee:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 80206f2:	f101 0714 	add.w	r7, r1, #20
 80206f6:	f100 0b14 	add.w	fp, r0, #20
 80206fa:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
 80206fe:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
 8020702:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8020706:	b083      	sub	sp, #12
 8020708:	3201      	adds	r2, #1
 802070a:	fbb3 f9f2 	udiv	r9, r3, r2
 802070e:	eb0b 0304 	add.w	r3, fp, r4
 8020712:	9400      	str	r4, [sp, #0]
 8020714:	eb07 0a04 	add.w	sl, r7, r4
 8020718:	9301      	str	r3, [sp, #4]
 802071a:	f1b9 0f00 	cmp.w	r9, #0
 802071e:	d039      	beq.n	8020794 <quorem+0xb4>
 8020720:	2500      	movs	r5, #0
 8020722:	462e      	mov	r6, r5
 8020724:	46bc      	mov	ip, r7
 8020726:	46de      	mov	lr, fp
 8020728:	f85c 4b04 	ldr.w	r4, [ip], #4
 802072c:	f8de 3000 	ldr.w	r3, [lr]
 8020730:	b2a2      	uxth	r2, r4
 8020732:	fb09 5502 	mla	r5, r9, r2, r5
 8020736:	0c22      	lsrs	r2, r4, #16
 8020738:	0c2c      	lsrs	r4, r5, #16
 802073a:	fb09 4202 	mla	r2, r9, r2, r4
 802073e:	b2ad      	uxth	r5, r5
 8020740:	1b75      	subs	r5, r6, r5
 8020742:	b296      	uxth	r6, r2
 8020744:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
 8020748:	fa15 f383 	uxtah	r3, r5, r3
 802074c:	eb06 4623 	add.w	r6, r6, r3, asr #16
 8020750:	b29b      	uxth	r3, r3
 8020752:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8020756:	45e2      	cmp	sl, ip
 8020758:	ea4f 4512 	mov.w	r5, r2, lsr #16
 802075c:	f84e 3b04 	str.w	r3, [lr], #4
 8020760:	ea4f 4626 	mov.w	r6, r6, asr #16
 8020764:	d2e0      	bcs.n	8020728 <quorem+0x48>
 8020766:	9b00      	ldr	r3, [sp, #0]
 8020768:	f85b 3003 	ldr.w	r3, [fp, r3]
 802076c:	b993      	cbnz	r3, 8020794 <quorem+0xb4>
 802076e:	9c01      	ldr	r4, [sp, #4]
 8020770:	1f23      	subs	r3, r4, #4
 8020772:	459b      	cmp	fp, r3
 8020774:	d20c      	bcs.n	8020790 <quorem+0xb0>
 8020776:	f854 3c04 	ldr.w	r3, [r4, #-4]
 802077a:	b94b      	cbnz	r3, 8020790 <quorem+0xb0>
 802077c:	f1a4 0308 	sub.w	r3, r4, #8
 8020780:	e002      	b.n	8020788 <quorem+0xa8>
 8020782:	681a      	ldr	r2, [r3, #0]
 8020784:	3b04      	subs	r3, #4
 8020786:	b91a      	cbnz	r2, 8020790 <quorem+0xb0>
 8020788:	459b      	cmp	fp, r3
 802078a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 802078e:	d3f8      	bcc.n	8020782 <quorem+0xa2>
 8020790:	f8c0 8010 	str.w	r8, [r0, #16]
 8020794:	4604      	mov	r4, r0
 8020796:	f001 fb51 	bl	8021e3c <__mcmp>
 802079a:	2800      	cmp	r0, #0
 802079c:	db2e      	blt.n	80207fc <quorem+0x11c>
 802079e:	f109 0901 	add.w	r9, r9, #1
 80207a2:	465d      	mov	r5, fp
 80207a4:	2300      	movs	r3, #0
 80207a6:	f857 1b04 	ldr.w	r1, [r7], #4
 80207aa:	6828      	ldr	r0, [r5, #0]
 80207ac:	b28a      	uxth	r2, r1
 80207ae:	1a9a      	subs	r2, r3, r2
 80207b0:	0c0b      	lsrs	r3, r1, #16
 80207b2:	fa12 f280 	uxtah	r2, r2, r0
 80207b6:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
 80207ba:	eb03 4322 	add.w	r3, r3, r2, asr #16
 80207be:	b292      	uxth	r2, r2
 80207c0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 80207c4:	45ba      	cmp	sl, r7
 80207c6:	f845 2b04 	str.w	r2, [r5], #4
 80207ca:	ea4f 4323 	mov.w	r3, r3, asr #16
 80207ce:	d2ea      	bcs.n	80207a6 <quorem+0xc6>
 80207d0:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
 80207d4:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
 80207d8:	b982      	cbnz	r2, 80207fc <quorem+0x11c>
 80207da:	1f1a      	subs	r2, r3, #4
 80207dc:	4593      	cmp	fp, r2
 80207de:	d20b      	bcs.n	80207f8 <quorem+0x118>
 80207e0:	f853 2c04 	ldr.w	r2, [r3, #-4]
 80207e4:	b942      	cbnz	r2, 80207f8 <quorem+0x118>
 80207e6:	3b08      	subs	r3, #8
 80207e8:	e002      	b.n	80207f0 <quorem+0x110>
 80207ea:	681a      	ldr	r2, [r3, #0]
 80207ec:	3b04      	subs	r3, #4
 80207ee:	b91a      	cbnz	r2, 80207f8 <quorem+0x118>
 80207f0:	459b      	cmp	fp, r3
 80207f2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80207f6:	d3f8      	bcc.n	80207ea <quorem+0x10a>
 80207f8:	f8c4 8010 	str.w	r8, [r4, #16]
 80207fc:	4648      	mov	r0, r9
 80207fe:	b003      	add	sp, #12
 8020800:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020804:	2000      	movs	r0, #0
 8020806:	4770      	bx	lr

08020808 <_dtoa_r>:
 8020808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802080c:	6c01      	ldr	r1, [r0, #64]	; 0x40
 802080e:	b09b      	sub	sp, #108	; 0x6c
 8020810:	4604      	mov	r4, r0
 8020812:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 8020814:	4692      	mov	sl, r2
 8020816:	469b      	mov	fp, r3
 8020818:	b141      	cbz	r1, 802082c <_dtoa_r+0x24>
 802081a:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802081c:	604a      	str	r2, [r1, #4]
 802081e:	2301      	movs	r3, #1
 8020820:	4093      	lsls	r3, r2
 8020822:	608b      	str	r3, [r1, #8]
 8020824:	f001 f932 	bl	8021a8c <_Bfree>
 8020828:	2300      	movs	r3, #0
 802082a:	6423      	str	r3, [r4, #64]	; 0x40
 802082c:	f1bb 0f00 	cmp.w	fp, #0
 8020830:	465d      	mov	r5, fp
 8020832:	db35      	blt.n	80208a0 <_dtoa_r+0x98>
 8020834:	2300      	movs	r3, #0
 8020836:	6033      	str	r3, [r6, #0]
 8020838:	4b9d      	ldr	r3, [pc, #628]	; (8020ab0 <_dtoa_r+0x2a8>)
 802083a:	43ab      	bics	r3, r5
 802083c:	d015      	beq.n	802086a <_dtoa_r+0x62>
 802083e:	2200      	movs	r2, #0
 8020840:	2300      	movs	r3, #0
 8020842:	4650      	mov	r0, sl
 8020844:	4659      	mov	r1, fp
 8020846:	f7e4 fe79 	bl	800553c <__aeabi_dcmpeq>
 802084a:	4680      	mov	r8, r0
 802084c:	2800      	cmp	r0, #0
 802084e:	d02d      	beq.n	80208ac <_dtoa_r+0xa4>
 8020850:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8020852:	2301      	movs	r3, #1
 8020854:	6013      	str	r3, [r2, #0]
 8020856:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8020858:	2b00      	cmp	r3, #0
 802085a:	f000 80bd 	beq.w	80209d8 <_dtoa_r+0x1d0>
 802085e:	4895      	ldr	r0, [pc, #596]	; (8020ab4 <_dtoa_r+0x2ac>)
 8020860:	6018      	str	r0, [r3, #0]
 8020862:	3801      	subs	r0, #1
 8020864:	b01b      	add	sp, #108	; 0x6c
 8020866:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802086a:	9a26      	ldr	r2, [sp, #152]	; 0x98
 802086c:	f242 730f 	movw	r3, #9999	; 0x270f
 8020870:	6013      	str	r3, [r2, #0]
 8020872:	f1ba 0f00 	cmp.w	sl, #0
 8020876:	d10d      	bne.n	8020894 <_dtoa_r+0x8c>
 8020878:	f3c5 0513 	ubfx	r5, r5, #0, #20
 802087c:	b955      	cbnz	r5, 8020894 <_dtoa_r+0x8c>
 802087e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8020880:	488d      	ldr	r0, [pc, #564]	; (8020ab8 <_dtoa_r+0x2b0>)
 8020882:	2b00      	cmp	r3, #0
 8020884:	d0ee      	beq.n	8020864 <_dtoa_r+0x5c>
 8020886:	f100 0308 	add.w	r3, r0, #8
 802088a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 802088c:	6013      	str	r3, [r2, #0]
 802088e:	b01b      	add	sp, #108	; 0x6c
 8020890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020894:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8020896:	4889      	ldr	r0, [pc, #548]	; (8020abc <_dtoa_r+0x2b4>)
 8020898:	2b00      	cmp	r3, #0
 802089a:	d0e3      	beq.n	8020864 <_dtoa_r+0x5c>
 802089c:	1cc3      	adds	r3, r0, #3
 802089e:	e7f4      	b.n	802088a <_dtoa_r+0x82>
 80208a0:	2301      	movs	r3, #1
 80208a2:	f02b 4500 	bic.w	r5, fp, #2147483648	; 0x80000000
 80208a6:	6033      	str	r3, [r6, #0]
 80208a8:	46ab      	mov	fp, r5
 80208aa:	e7c5      	b.n	8020838 <_dtoa_r+0x30>
 80208ac:	aa18      	add	r2, sp, #96	; 0x60
 80208ae:	ab19      	add	r3, sp, #100	; 0x64
 80208b0:	9201      	str	r2, [sp, #4]
 80208b2:	9300      	str	r3, [sp, #0]
 80208b4:	4652      	mov	r2, sl
 80208b6:	465b      	mov	r3, fp
 80208b8:	4620      	mov	r0, r4
 80208ba:	f001 fb5f 	bl	8021f7c <__d2b>
 80208be:	0d2b      	lsrs	r3, r5, #20
 80208c0:	4681      	mov	r9, r0
 80208c2:	d071      	beq.n	80209a8 <_dtoa_r+0x1a0>
 80208c4:	f3cb 0213 	ubfx	r2, fp, #0, #20
 80208c8:	f042 517f 	orr.w	r1, r2, #1069547520	; 0x3fc00000
 80208cc:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80208ce:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
 80208d2:	4650      	mov	r0, sl
 80208d4:	f2a3 36ff 	subw	r6, r3, #1023	; 0x3ff
 80208d8:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 80208dc:	2200      	movs	r2, #0
 80208de:	4b78      	ldr	r3, [pc, #480]	; (8020ac0 <_dtoa_r+0x2b8>)
 80208e0:	f7e4 f942 	bl	8004b68 <__aeabi_dsub>
 80208e4:	a36c      	add	r3, pc, #432	; (adr r3, 8020a98 <_dtoa_r+0x290>)
 80208e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208ea:	f7e4 faf1 	bl	8004ed0 <__aeabi_dmul>
 80208ee:	a36c      	add	r3, pc, #432	; (adr r3, 8020aa0 <_dtoa_r+0x298>)
 80208f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208f4:	f7e4 f93a 	bl	8004b6c <__adddf3>
 80208f8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80208fc:	4630      	mov	r0, r6
 80208fe:	f7e4 fa81 	bl	8004e04 <__aeabi_i2d>
 8020902:	a369      	add	r3, pc, #420	; (adr r3, 8020aa8 <_dtoa_r+0x2a0>)
 8020904:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020908:	f7e4 fae2 	bl	8004ed0 <__aeabi_dmul>
 802090c:	4602      	mov	r2, r0
 802090e:	460b      	mov	r3, r1
 8020910:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020914:	f7e4 f92a 	bl	8004b6c <__adddf3>
 8020918:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802091c:	f7e4 fcea 	bl	80052f4 <__aeabi_d2iz>
 8020920:	2200      	movs	r2, #0
 8020922:	9002      	str	r0, [sp, #8]
 8020924:	2300      	movs	r3, #0
 8020926:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802092a:	f7e4 fe11 	bl	8005550 <__aeabi_dcmplt>
 802092e:	2800      	cmp	r0, #0
 8020930:	f040 8173 	bne.w	8020c1a <_dtoa_r+0x412>
 8020934:	9d02      	ldr	r5, [sp, #8]
 8020936:	2d16      	cmp	r5, #22
 8020938:	f200 815d 	bhi.w	8020bf6 <_dtoa_r+0x3ee>
 802093c:	4b61      	ldr	r3, [pc, #388]	; (8020ac4 <_dtoa_r+0x2bc>)
 802093e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8020942:	e9d3 0100 	ldrd	r0, r1, [r3]
 8020946:	4652      	mov	r2, sl
 8020948:	465b      	mov	r3, fp
 802094a:	f7e4 fe1f 	bl	800558c <__aeabi_dcmpgt>
 802094e:	2800      	cmp	r0, #0
 8020950:	f000 81c5 	beq.w	8020cde <_dtoa_r+0x4d6>
 8020954:	1e6b      	subs	r3, r5, #1
 8020956:	9302      	str	r3, [sp, #8]
 8020958:	2300      	movs	r3, #0
 802095a:	930e      	str	r3, [sp, #56]	; 0x38
 802095c:	1bbf      	subs	r7, r7, r6
 802095e:	1e7b      	subs	r3, r7, #1
 8020960:	9308      	str	r3, [sp, #32]
 8020962:	f100 8154 	bmi.w	8020c0e <_dtoa_r+0x406>
 8020966:	2300      	movs	r3, #0
 8020968:	930b      	str	r3, [sp, #44]	; 0x2c
 802096a:	9b02      	ldr	r3, [sp, #8]
 802096c:	2b00      	cmp	r3, #0
 802096e:	f2c0 8145 	blt.w	8020bfc <_dtoa_r+0x3f4>
 8020972:	9a08      	ldr	r2, [sp, #32]
 8020974:	930d      	str	r3, [sp, #52]	; 0x34
 8020976:	4611      	mov	r1, r2
 8020978:	4419      	add	r1, r3
 802097a:	2300      	movs	r3, #0
 802097c:	9108      	str	r1, [sp, #32]
 802097e:	9306      	str	r3, [sp, #24]
 8020980:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8020982:	2b09      	cmp	r3, #9
 8020984:	d82a      	bhi.n	80209dc <_dtoa_r+0x1d4>
 8020986:	2b05      	cmp	r3, #5
 8020988:	f340 863c 	ble.w	8021604 <_dtoa_r+0xdfc>
 802098c:	3b04      	subs	r3, #4
 802098e:	9324      	str	r3, [sp, #144]	; 0x90
 8020990:	2500      	movs	r5, #0
 8020992:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8020994:	3b02      	subs	r3, #2
 8020996:	2b03      	cmp	r3, #3
 8020998:	f200 863c 	bhi.w	8021614 <_dtoa_r+0xe0c>
 802099c:	e8df f013 	tbh	[pc, r3, lsl #1]
 80209a0:	02ca03d5 	.word	0x02ca03d5
 80209a4:	046203e0 	.word	0x046203e0
 80209a8:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80209aa:	9e19      	ldr	r6, [sp, #100]	; 0x64
 80209ac:	443e      	add	r6, r7
 80209ae:	f206 4332 	addw	r3, r6, #1074	; 0x432
 80209b2:	2b20      	cmp	r3, #32
 80209b4:	f340 818e 	ble.w	8020cd4 <_dtoa_r+0x4cc>
 80209b8:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 80209bc:	f206 4012 	addw	r0, r6, #1042	; 0x412
 80209c0:	409d      	lsls	r5, r3
 80209c2:	fa2a f000 	lsr.w	r0, sl, r0
 80209c6:	4328      	orrs	r0, r5
 80209c8:	f7e4 fa0c 	bl	8004de4 <__aeabi_ui2d>
 80209cc:	2301      	movs	r3, #1
 80209ce:	3e01      	subs	r6, #1
 80209d0:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 80209d4:	9314      	str	r3, [sp, #80]	; 0x50
 80209d6:	e781      	b.n	80208dc <_dtoa_r+0xd4>
 80209d8:	483b      	ldr	r0, [pc, #236]	; (8020ac8 <_dtoa_r+0x2c0>)
 80209da:	e743      	b.n	8020864 <_dtoa_r+0x5c>
 80209dc:	2100      	movs	r1, #0
 80209de:	6461      	str	r1, [r4, #68]	; 0x44
 80209e0:	4620      	mov	r0, r4
 80209e2:	9125      	str	r1, [sp, #148]	; 0x94
 80209e4:	f001 f82c 	bl	8021a40 <_Balloc>
 80209e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80209ec:	930a      	str	r3, [sp, #40]	; 0x28
 80209ee:	9a25      	ldr	r2, [sp, #148]	; 0x94
 80209f0:	930f      	str	r3, [sp, #60]	; 0x3c
 80209f2:	2301      	movs	r3, #1
 80209f4:	9004      	str	r0, [sp, #16]
 80209f6:	6420      	str	r0, [r4, #64]	; 0x40
 80209f8:	9224      	str	r2, [sp, #144]	; 0x90
 80209fa:	930c      	str	r3, [sp, #48]	; 0x30
 80209fc:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80209fe:	2b00      	cmp	r3, #0
 8020a00:	f2c0 80d9 	blt.w	8020bb6 <_dtoa_r+0x3ae>
 8020a04:	9a02      	ldr	r2, [sp, #8]
 8020a06:	2a0e      	cmp	r2, #14
 8020a08:	f300 80d5 	bgt.w	8020bb6 <_dtoa_r+0x3ae>
 8020a0c:	4b2d      	ldr	r3, [pc, #180]	; (8020ac4 <_dtoa_r+0x2bc>)
 8020a0e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8020a12:	ed93 7b00 	vldr	d7, [r3]
 8020a16:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8020a18:	2b00      	cmp	r3, #0
 8020a1a:	ed8d 7b08 	vstr	d7, [sp, #32]
 8020a1e:	f2c0 83bb 	blt.w	8021198 <_dtoa_r+0x990>
 8020a22:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
 8020a26:	4650      	mov	r0, sl
 8020a28:	462a      	mov	r2, r5
 8020a2a:	4633      	mov	r3, r6
 8020a2c:	4659      	mov	r1, fp
 8020a2e:	f7e4 fb79 	bl	8005124 <__aeabi_ddiv>
 8020a32:	f7e4 fc5f 	bl	80052f4 <__aeabi_d2iz>
 8020a36:	4680      	mov	r8, r0
 8020a38:	f7e4 f9e4 	bl	8004e04 <__aeabi_i2d>
 8020a3c:	462a      	mov	r2, r5
 8020a3e:	4633      	mov	r3, r6
 8020a40:	f7e4 fa46 	bl	8004ed0 <__aeabi_dmul>
 8020a44:	460b      	mov	r3, r1
 8020a46:	4602      	mov	r2, r0
 8020a48:	4659      	mov	r1, fp
 8020a4a:	4650      	mov	r0, sl
 8020a4c:	f7e4 f88c 	bl	8004b68 <__aeabi_dsub>
 8020a50:	9d04      	ldr	r5, [sp, #16]
 8020a52:	f108 0330 	add.w	r3, r8, #48	; 0x30
 8020a56:	702b      	strb	r3, [r5, #0]
 8020a58:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020a5a:	2b01      	cmp	r3, #1
 8020a5c:	4606      	mov	r6, r0
 8020a5e:	460f      	mov	r7, r1
 8020a60:	f105 0501 	add.w	r5, r5, #1
 8020a64:	d068      	beq.n	8020b38 <_dtoa_r+0x330>
 8020a66:	2200      	movs	r2, #0
 8020a68:	4b18      	ldr	r3, [pc, #96]	; (8020acc <_dtoa_r+0x2c4>)
 8020a6a:	f7e4 fa31 	bl	8004ed0 <__aeabi_dmul>
 8020a6e:	2200      	movs	r2, #0
 8020a70:	2300      	movs	r3, #0
 8020a72:	4606      	mov	r6, r0
 8020a74:	460f      	mov	r7, r1
 8020a76:	f7e4 fd61 	bl	800553c <__aeabi_dcmpeq>
 8020a7a:	2800      	cmp	r0, #0
 8020a7c:	f040 8088 	bne.w	8020b90 <_dtoa_r+0x388>
 8020a80:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8020a84:	f04f 0a00 	mov.w	sl, #0
 8020a88:	f8df b040 	ldr.w	fp, [pc, #64]	; 8020acc <_dtoa_r+0x2c4>
 8020a8c:	940c      	str	r4, [sp, #48]	; 0x30
 8020a8e:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
 8020a92:	e028      	b.n	8020ae6 <_dtoa_r+0x2de>
 8020a94:	f3af 8000 	nop.w
 8020a98:	636f4361 	.word	0x636f4361
 8020a9c:	3fd287a7 	.word	0x3fd287a7
 8020aa0:	8b60c8b3 	.word	0x8b60c8b3
 8020aa4:	3fc68a28 	.word	0x3fc68a28
 8020aa8:	509f79fb 	.word	0x509f79fb
 8020aac:	3fd34413 	.word	0x3fd34413
 8020ab0:	7ff00000 	.word	0x7ff00000
 8020ab4:	080251c1 	.word	0x080251c1
 8020ab8:	080251e4 	.word	0x080251e4
 8020abc:	080251f0 	.word	0x080251f0
 8020ac0:	3ff80000 	.word	0x3ff80000
 8020ac4:	08025220 	.word	0x08025220
 8020ac8:	080251c0 	.word	0x080251c0
 8020acc:	40240000 	.word	0x40240000
 8020ad0:	f7e4 f9fe 	bl	8004ed0 <__aeabi_dmul>
 8020ad4:	2200      	movs	r2, #0
 8020ad6:	2300      	movs	r3, #0
 8020ad8:	4606      	mov	r6, r0
 8020ada:	460f      	mov	r7, r1
 8020adc:	f7e4 fd2e 	bl	800553c <__aeabi_dcmpeq>
 8020ae0:	2800      	cmp	r0, #0
 8020ae2:	f040 83c2 	bne.w	802126a <_dtoa_r+0xa62>
 8020ae6:	4642      	mov	r2, r8
 8020ae8:	464b      	mov	r3, r9
 8020aea:	4630      	mov	r0, r6
 8020aec:	4639      	mov	r1, r7
 8020aee:	f7e4 fb19 	bl	8005124 <__aeabi_ddiv>
 8020af2:	f7e4 fbff 	bl	80052f4 <__aeabi_d2iz>
 8020af6:	4604      	mov	r4, r0
 8020af8:	f7e4 f984 	bl	8004e04 <__aeabi_i2d>
 8020afc:	4642      	mov	r2, r8
 8020afe:	464b      	mov	r3, r9
 8020b00:	f7e4 f9e6 	bl	8004ed0 <__aeabi_dmul>
 8020b04:	4602      	mov	r2, r0
 8020b06:	460b      	mov	r3, r1
 8020b08:	4630      	mov	r0, r6
 8020b0a:	4639      	mov	r1, r7
 8020b0c:	f7e4 f82c 	bl	8004b68 <__aeabi_dsub>
 8020b10:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8020b14:	9e04      	ldr	r6, [sp, #16]
 8020b16:	f805 eb01 	strb.w	lr, [r5], #1
 8020b1a:	eba5 0e06 	sub.w	lr, r5, r6
 8020b1e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8020b20:	45b6      	cmp	lr, r6
 8020b22:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8020b26:	4652      	mov	r2, sl
 8020b28:	465b      	mov	r3, fp
 8020b2a:	d1d1      	bne.n	8020ad0 <_dtoa_r+0x2c8>
 8020b2c:	46a0      	mov	r8, r4
 8020b2e:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8020b32:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8020b34:	4606      	mov	r6, r0
 8020b36:	460f      	mov	r7, r1
 8020b38:	4632      	mov	r2, r6
 8020b3a:	463b      	mov	r3, r7
 8020b3c:	4630      	mov	r0, r6
 8020b3e:	4639      	mov	r1, r7
 8020b40:	f7e4 f814 	bl	8004b6c <__adddf3>
 8020b44:	4606      	mov	r6, r0
 8020b46:	460f      	mov	r7, r1
 8020b48:	4602      	mov	r2, r0
 8020b4a:	460b      	mov	r3, r1
 8020b4c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8020b50:	f7e4 fcfe 	bl	8005550 <__aeabi_dcmplt>
 8020b54:	b948      	cbnz	r0, 8020b6a <_dtoa_r+0x362>
 8020b56:	4632      	mov	r2, r6
 8020b58:	463b      	mov	r3, r7
 8020b5a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8020b5e:	f7e4 fced 	bl	800553c <__aeabi_dcmpeq>
 8020b62:	b1a8      	cbz	r0, 8020b90 <_dtoa_r+0x388>
 8020b64:	f018 0f01 	tst.w	r8, #1
 8020b68:	d012      	beq.n	8020b90 <_dtoa_r+0x388>
 8020b6a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 8020b6e:	9a04      	ldr	r2, [sp, #16]
 8020b70:	1e6b      	subs	r3, r5, #1
 8020b72:	e004      	b.n	8020b7e <_dtoa_r+0x376>
 8020b74:	429a      	cmp	r2, r3
 8020b76:	f000 8402 	beq.w	802137e <_dtoa_r+0xb76>
 8020b7a:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
 8020b7e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 8020b82:	f103 0501 	add.w	r5, r3, #1
 8020b86:	d0f5      	beq.n	8020b74 <_dtoa_r+0x36c>
 8020b88:	f108 0801 	add.w	r8, r8, #1
 8020b8c:	f883 8000 	strb.w	r8, [r3]
 8020b90:	4649      	mov	r1, r9
 8020b92:	4620      	mov	r0, r4
 8020b94:	f000 ff7a 	bl	8021a8c <_Bfree>
 8020b98:	2200      	movs	r2, #0
 8020b9a:	9b02      	ldr	r3, [sp, #8]
 8020b9c:	702a      	strb	r2, [r5, #0]
 8020b9e:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8020ba0:	3301      	adds	r3, #1
 8020ba2:	6013      	str	r3, [r2, #0]
 8020ba4:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 8020ba6:	2b00      	cmp	r3, #0
 8020ba8:	f000 839c 	beq.w	80212e4 <_dtoa_r+0xadc>
 8020bac:	9804      	ldr	r0, [sp, #16]
 8020bae:	601d      	str	r5, [r3, #0]
 8020bb0:	b01b      	add	sp, #108	; 0x6c
 8020bb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020bb6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8020bb8:	2a00      	cmp	r2, #0
 8020bba:	d03e      	beq.n	8020c3a <_dtoa_r+0x432>
 8020bbc:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8020bbe:	2a01      	cmp	r2, #1
 8020bc0:	f340 8312 	ble.w	80211e8 <_dtoa_r+0x9e0>
 8020bc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020bc6:	9a06      	ldr	r2, [sp, #24]
 8020bc8:	1e5f      	subs	r7, r3, #1
 8020bca:	42ba      	cmp	r2, r7
 8020bcc:	f2c0 838d 	blt.w	80212ea <_dtoa_r+0xae2>
 8020bd0:	1bd7      	subs	r7, r2, r7
 8020bd2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020bd4:	2b00      	cmp	r3, #0
 8020bd6:	f2c0 8485 	blt.w	80214e4 <_dtoa_r+0xcdc>
 8020bda:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8020bdc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020bde:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020be0:	441a      	add	r2, r3
 8020be2:	920b      	str	r2, [sp, #44]	; 0x2c
 8020be4:	9a08      	ldr	r2, [sp, #32]
 8020be6:	2101      	movs	r1, #1
 8020be8:	441a      	add	r2, r3
 8020bea:	4620      	mov	r0, r4
 8020bec:	9208      	str	r2, [sp, #32]
 8020bee:	f000 ffe7 	bl	8021bc0 <__i2b>
 8020bf2:	4606      	mov	r6, r0
 8020bf4:	e024      	b.n	8020c40 <_dtoa_r+0x438>
 8020bf6:	2301      	movs	r3, #1
 8020bf8:	930e      	str	r3, [sp, #56]	; 0x38
 8020bfa:	e6af      	b.n	802095c <_dtoa_r+0x154>
 8020bfc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020bfe:	9b02      	ldr	r3, [sp, #8]
 8020c00:	1ad2      	subs	r2, r2, r3
 8020c02:	425b      	negs	r3, r3
 8020c04:	9306      	str	r3, [sp, #24]
 8020c06:	2300      	movs	r3, #0
 8020c08:	920b      	str	r2, [sp, #44]	; 0x2c
 8020c0a:	930d      	str	r3, [sp, #52]	; 0x34
 8020c0c:	e6b8      	b.n	8020980 <_dtoa_r+0x178>
 8020c0e:	f1c7 0301 	rsb	r3, r7, #1
 8020c12:	930b      	str	r3, [sp, #44]	; 0x2c
 8020c14:	2300      	movs	r3, #0
 8020c16:	9308      	str	r3, [sp, #32]
 8020c18:	e6a7      	b.n	802096a <_dtoa_r+0x162>
 8020c1a:	9d02      	ldr	r5, [sp, #8]
 8020c1c:	4628      	mov	r0, r5
 8020c1e:	f7e4 f8f1 	bl	8004e04 <__aeabi_i2d>
 8020c22:	4602      	mov	r2, r0
 8020c24:	460b      	mov	r3, r1
 8020c26:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020c2a:	f7e4 fc87 	bl	800553c <__aeabi_dcmpeq>
 8020c2e:	2800      	cmp	r0, #0
 8020c30:	f47f ae80 	bne.w	8020934 <_dtoa_r+0x12c>
 8020c34:	1e6b      	subs	r3, r5, #1
 8020c36:	9302      	str	r3, [sp, #8]
 8020c38:	e67c      	b.n	8020934 <_dtoa_r+0x12c>
 8020c3a:	9f06      	ldr	r7, [sp, #24]
 8020c3c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8020c3e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8020c40:	2d00      	cmp	r5, #0
 8020c42:	dd0c      	ble.n	8020c5e <_dtoa_r+0x456>
 8020c44:	9908      	ldr	r1, [sp, #32]
 8020c46:	2900      	cmp	r1, #0
 8020c48:	460b      	mov	r3, r1
 8020c4a:	dd08      	ble.n	8020c5e <_dtoa_r+0x456>
 8020c4c:	42a9      	cmp	r1, r5
 8020c4e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020c50:	bfa8      	it	ge
 8020c52:	462b      	movge	r3, r5
 8020c54:	1ad2      	subs	r2, r2, r3
 8020c56:	1aed      	subs	r5, r5, r3
 8020c58:	1acb      	subs	r3, r1, r3
 8020c5a:	920b      	str	r2, [sp, #44]	; 0x2c
 8020c5c:	9308      	str	r3, [sp, #32]
 8020c5e:	9b06      	ldr	r3, [sp, #24]
 8020c60:	b1d3      	cbz	r3, 8020c98 <_dtoa_r+0x490>
 8020c62:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020c64:	2b00      	cmp	r3, #0
 8020c66:	f000 82b8 	beq.w	80211da <_dtoa_r+0x9d2>
 8020c6a:	2f00      	cmp	r7, #0
 8020c6c:	dd10      	ble.n	8020c90 <_dtoa_r+0x488>
 8020c6e:	4631      	mov	r1, r6
 8020c70:	463a      	mov	r2, r7
 8020c72:	4620      	mov	r0, r4
 8020c74:	f001 f840 	bl	8021cf8 <__pow5mult>
 8020c78:	464a      	mov	r2, r9
 8020c7a:	4601      	mov	r1, r0
 8020c7c:	4606      	mov	r6, r0
 8020c7e:	4620      	mov	r0, r4
 8020c80:	f000 ffa8 	bl	8021bd4 <__multiply>
 8020c84:	4649      	mov	r1, r9
 8020c86:	4680      	mov	r8, r0
 8020c88:	4620      	mov	r0, r4
 8020c8a:	f000 feff 	bl	8021a8c <_Bfree>
 8020c8e:	46c1      	mov	r9, r8
 8020c90:	9b06      	ldr	r3, [sp, #24]
 8020c92:	1bda      	subs	r2, r3, r7
 8020c94:	f040 82a2 	bne.w	80211dc <_dtoa_r+0x9d4>
 8020c98:	2101      	movs	r1, #1
 8020c9a:	4620      	mov	r0, r4
 8020c9c:	f000 ff90 	bl	8021bc0 <__i2b>
 8020ca0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8020ca2:	9006      	str	r0, [sp, #24]
 8020ca4:	2b00      	cmp	r3, #0
 8020ca6:	dd1c      	ble.n	8020ce2 <_dtoa_r+0x4da>
 8020ca8:	4601      	mov	r1, r0
 8020caa:	461a      	mov	r2, r3
 8020cac:	4620      	mov	r0, r4
 8020cae:	f001 f823 	bl	8021cf8 <__pow5mult>
 8020cb2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8020cb4:	9006      	str	r0, [sp, #24]
 8020cb6:	2b01      	cmp	r3, #1
 8020cb8:	f340 8255 	ble.w	8021166 <_dtoa_r+0x95e>
 8020cbc:	f04f 0800 	mov.w	r8, #0
 8020cc0:	9a06      	ldr	r2, [sp, #24]
 8020cc2:	6913      	ldr	r3, [r2, #16]
 8020cc4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8020cc8:	6918      	ldr	r0, [r3, #16]
 8020cca:	f000 ff29 	bl	8021b20 <__hi0bits>
 8020cce:	f1c0 0020 	rsb	r0, r0, #32
 8020cd2:	e010      	b.n	8020cf6 <_dtoa_r+0x4ee>
 8020cd4:	f1c3 0520 	rsb	r5, r3, #32
 8020cd8:	fa0a f005 	lsl.w	r0, sl, r5
 8020cdc:	e674      	b.n	80209c8 <_dtoa_r+0x1c0>
 8020cde:	900e      	str	r0, [sp, #56]	; 0x38
 8020ce0:	e63c      	b.n	802095c <_dtoa_r+0x154>
 8020ce2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8020ce4:	2b01      	cmp	r3, #1
 8020ce6:	f340 8288 	ble.w	80211fa <_dtoa_r+0x9f2>
 8020cea:	f04f 0800 	mov.w	r8, #0
 8020cee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8020cf0:	2001      	movs	r0, #1
 8020cf2:	2b00      	cmp	r3, #0
 8020cf4:	d1e4      	bne.n	8020cc0 <_dtoa_r+0x4b8>
 8020cf6:	9a08      	ldr	r2, [sp, #32]
 8020cf8:	4410      	add	r0, r2
 8020cfa:	f010 001f 	ands.w	r0, r0, #31
 8020cfe:	f000 80a0 	beq.w	8020e42 <_dtoa_r+0x63a>
 8020d02:	f1c0 0320 	rsb	r3, r0, #32
 8020d06:	2b04      	cmp	r3, #4
 8020d08:	f340 847f 	ble.w	802160a <_dtoa_r+0xe02>
 8020d0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020d0e:	f1c0 001c 	rsb	r0, r0, #28
 8020d12:	4403      	add	r3, r0
 8020d14:	930b      	str	r3, [sp, #44]	; 0x2c
 8020d16:	4613      	mov	r3, r2
 8020d18:	4403      	add	r3, r0
 8020d1a:	4405      	add	r5, r0
 8020d1c:	9308      	str	r3, [sp, #32]
 8020d1e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020d20:	2b00      	cmp	r3, #0
 8020d22:	dd05      	ble.n	8020d30 <_dtoa_r+0x528>
 8020d24:	4649      	mov	r1, r9
 8020d26:	461a      	mov	r2, r3
 8020d28:	4620      	mov	r0, r4
 8020d2a:	f001 f835 	bl	8021d98 <__lshift>
 8020d2e:	4681      	mov	r9, r0
 8020d30:	9b08      	ldr	r3, [sp, #32]
 8020d32:	2b00      	cmp	r3, #0
 8020d34:	dd05      	ble.n	8020d42 <_dtoa_r+0x53a>
 8020d36:	461a      	mov	r2, r3
 8020d38:	9906      	ldr	r1, [sp, #24]
 8020d3a:	4620      	mov	r0, r4
 8020d3c:	f001 f82c 	bl	8021d98 <__lshift>
 8020d40:	9006      	str	r0, [sp, #24]
 8020d42:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020d44:	2b00      	cmp	r3, #0
 8020d46:	f040 8085 	bne.w	8020e54 <_dtoa_r+0x64c>
 8020d4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020d4c:	2b00      	cmp	r3, #0
 8020d4e:	f340 8267 	ble.w	8021220 <_dtoa_r+0xa18>
 8020d52:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020d54:	2b00      	cmp	r3, #0
 8020d56:	f000 8097 	beq.w	8020e88 <_dtoa_r+0x680>
 8020d5a:	2d00      	cmp	r5, #0
 8020d5c:	dd05      	ble.n	8020d6a <_dtoa_r+0x562>
 8020d5e:	4631      	mov	r1, r6
 8020d60:	462a      	mov	r2, r5
 8020d62:	4620      	mov	r0, r4
 8020d64:	f001 f818 	bl	8021d98 <__lshift>
 8020d68:	4606      	mov	r6, r0
 8020d6a:	f1b8 0f00 	cmp.w	r8, #0
 8020d6e:	f040 8338 	bne.w	80213e2 <_dtoa_r+0xbda>
 8020d72:	46b0      	mov	r8, r6
 8020d74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020d76:	9a04      	ldr	r2, [sp, #16]
 8020d78:	3b01      	subs	r3, #1
 8020d7a:	18d3      	adds	r3, r2, r3
 8020d7c:	930b      	str	r3, [sp, #44]	; 0x2c
 8020d7e:	f00a 0301 	and.w	r3, sl, #1
 8020d82:	930c      	str	r3, [sp, #48]	; 0x30
 8020d84:	4617      	mov	r7, r2
 8020d86:	f8dd b018 	ldr.w	fp, [sp, #24]
 8020d8a:	4648      	mov	r0, r9
 8020d8c:	4659      	mov	r1, fp
 8020d8e:	f7ff fca7 	bl	80206e0 <quorem>
 8020d92:	4631      	mov	r1, r6
 8020d94:	4605      	mov	r5, r0
 8020d96:	4648      	mov	r0, r9
 8020d98:	f001 f850 	bl	8021e3c <__mcmp>
 8020d9c:	4642      	mov	r2, r8
 8020d9e:	4659      	mov	r1, fp
 8020da0:	4682      	mov	sl, r0
 8020da2:	4620      	mov	r0, r4
 8020da4:	f001 f866 	bl	8021e74 <__mdiff>
 8020da8:	68c2      	ldr	r2, [r0, #12]
 8020daa:	4683      	mov	fp, r0
 8020dac:	f105 0330 	add.w	r3, r5, #48	; 0x30
 8020db0:	2a00      	cmp	r2, #0
 8020db2:	f040 822d 	bne.w	8021210 <_dtoa_r+0xa08>
 8020db6:	4601      	mov	r1, r0
 8020db8:	4648      	mov	r0, r9
 8020dba:	9308      	str	r3, [sp, #32]
 8020dbc:	f001 f83e 	bl	8021e3c <__mcmp>
 8020dc0:	4659      	mov	r1, fp
 8020dc2:	900a      	str	r0, [sp, #40]	; 0x28
 8020dc4:	4620      	mov	r0, r4
 8020dc6:	f000 fe61 	bl	8021a8c <_Bfree>
 8020dca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020dcc:	9b08      	ldr	r3, [sp, #32]
 8020dce:	b932      	cbnz	r2, 8020dde <_dtoa_r+0x5d6>
 8020dd0:	9924      	ldr	r1, [sp, #144]	; 0x90
 8020dd2:	b921      	cbnz	r1, 8020dde <_dtoa_r+0x5d6>
 8020dd4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8020dd6:	2a00      	cmp	r2, #0
 8020dd8:	f000 83dd 	beq.w	8021596 <_dtoa_r+0xd8e>
 8020ddc:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8020dde:	f1ba 0f00 	cmp.w	sl, #0
 8020de2:	f2c0 829e 	blt.w	8021322 <_dtoa_r+0xb1a>
 8020de6:	d105      	bne.n	8020df4 <_dtoa_r+0x5ec>
 8020de8:	9924      	ldr	r1, [sp, #144]	; 0x90
 8020dea:	b919      	cbnz	r1, 8020df4 <_dtoa_r+0x5ec>
 8020dec:	990c      	ldr	r1, [sp, #48]	; 0x30
 8020dee:	2900      	cmp	r1, #0
 8020df0:	f000 8297 	beq.w	8021322 <_dtoa_r+0xb1a>
 8020df4:	2a00      	cmp	r2, #0
 8020df6:	f300 8308 	bgt.w	802140a <_dtoa_r+0xc02>
 8020dfa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020dfc:	703b      	strb	r3, [r7, #0]
 8020dfe:	f107 0a01 	add.w	sl, r7, #1
 8020e02:	4297      	cmp	r7, r2
 8020e04:	4655      	mov	r5, sl
 8020e06:	f000 8309 	beq.w	802141c <_dtoa_r+0xc14>
 8020e0a:	4649      	mov	r1, r9
 8020e0c:	2300      	movs	r3, #0
 8020e0e:	220a      	movs	r2, #10
 8020e10:	4620      	mov	r0, r4
 8020e12:	f000 fe45 	bl	8021aa0 <__multadd>
 8020e16:	4546      	cmp	r6, r8
 8020e18:	4681      	mov	r9, r0
 8020e1a:	4631      	mov	r1, r6
 8020e1c:	f04f 0300 	mov.w	r3, #0
 8020e20:	f04f 020a 	mov.w	r2, #10
 8020e24:	4620      	mov	r0, r4
 8020e26:	f000 81ed 	beq.w	8021204 <_dtoa_r+0x9fc>
 8020e2a:	f000 fe39 	bl	8021aa0 <__multadd>
 8020e2e:	4641      	mov	r1, r8
 8020e30:	4606      	mov	r6, r0
 8020e32:	2300      	movs	r3, #0
 8020e34:	220a      	movs	r2, #10
 8020e36:	4620      	mov	r0, r4
 8020e38:	f000 fe32 	bl	8021aa0 <__multadd>
 8020e3c:	4657      	mov	r7, sl
 8020e3e:	4680      	mov	r8, r0
 8020e40:	e7a1      	b.n	8020d86 <_dtoa_r+0x57e>
 8020e42:	201c      	movs	r0, #28
 8020e44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020e46:	4403      	add	r3, r0
 8020e48:	930b      	str	r3, [sp, #44]	; 0x2c
 8020e4a:	9b08      	ldr	r3, [sp, #32]
 8020e4c:	4403      	add	r3, r0
 8020e4e:	4405      	add	r5, r0
 8020e50:	9308      	str	r3, [sp, #32]
 8020e52:	e764      	b.n	8020d1e <_dtoa_r+0x516>
 8020e54:	9906      	ldr	r1, [sp, #24]
 8020e56:	4648      	mov	r0, r9
 8020e58:	f000 fff0 	bl	8021e3c <__mcmp>
 8020e5c:	2800      	cmp	r0, #0
 8020e5e:	f6bf af74 	bge.w	8020d4a <_dtoa_r+0x542>
 8020e62:	9f02      	ldr	r7, [sp, #8]
 8020e64:	4649      	mov	r1, r9
 8020e66:	2300      	movs	r3, #0
 8020e68:	220a      	movs	r2, #10
 8020e6a:	4620      	mov	r0, r4
 8020e6c:	3f01      	subs	r7, #1
 8020e6e:	9702      	str	r7, [sp, #8]
 8020e70:	f000 fe16 	bl	8021aa0 <__multadd>
 8020e74:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020e76:	4681      	mov	r9, r0
 8020e78:	2b00      	cmp	r3, #0
 8020e7a:	f040 83a9 	bne.w	80215d0 <_dtoa_r+0xdc8>
 8020e7e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020e80:	2b00      	cmp	r3, #0
 8020e82:	f340 83b2 	ble.w	80215ea <_dtoa_r+0xde2>
 8020e86:	930a      	str	r3, [sp, #40]	; 0x28
 8020e88:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8020e8c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8020e8e:	f8dd b018 	ldr.w	fp, [sp, #24]
 8020e92:	4645      	mov	r5, r8
 8020e94:	e002      	b.n	8020e9c <_dtoa_r+0x694>
 8020e96:	f000 fe03 	bl	8021aa0 <__multadd>
 8020e9a:	4681      	mov	r9, r0
 8020e9c:	4659      	mov	r1, fp
 8020e9e:	4648      	mov	r0, r9
 8020ea0:	f7ff fc1e 	bl	80206e0 <quorem>
 8020ea4:	f100 0a30 	add.w	sl, r0, #48	; 0x30
 8020ea8:	f805 ab01 	strb.w	sl, [r5], #1
 8020eac:	eba5 0308 	sub.w	r3, r5, r8
 8020eb0:	42bb      	cmp	r3, r7
 8020eb2:	f04f 020a 	mov.w	r2, #10
 8020eb6:	f04f 0300 	mov.w	r3, #0
 8020eba:	4649      	mov	r1, r9
 8020ebc:	4620      	mov	r0, r4
 8020ebe:	dbea      	blt.n	8020e96 <_dtoa_r+0x68e>
 8020ec0:	9b04      	ldr	r3, [sp, #16]
 8020ec2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020ec4:	2a01      	cmp	r2, #1
 8020ec6:	bfac      	ite	ge
 8020ec8:	189b      	addge	r3, r3, r2
 8020eca:	3301      	addlt	r3, #1
 8020ecc:	461d      	mov	r5, r3
 8020ece:	f04f 0b00 	mov.w	fp, #0
 8020ed2:	4649      	mov	r1, r9
 8020ed4:	2201      	movs	r2, #1
 8020ed6:	4620      	mov	r0, r4
 8020ed8:	f000 ff5e 	bl	8021d98 <__lshift>
 8020edc:	9906      	ldr	r1, [sp, #24]
 8020ede:	4681      	mov	r9, r0
 8020ee0:	f000 ffac 	bl	8021e3c <__mcmp>
 8020ee4:	2800      	cmp	r0, #0
 8020ee6:	f340 8237 	ble.w	8021358 <_dtoa_r+0xb50>
 8020eea:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8020eee:	9904      	ldr	r1, [sp, #16]
 8020ef0:	1e6b      	subs	r3, r5, #1
 8020ef2:	e004      	b.n	8020efe <_dtoa_r+0x6f6>
 8020ef4:	428b      	cmp	r3, r1
 8020ef6:	f000 81ae 	beq.w	8021256 <_dtoa_r+0xa4e>
 8020efa:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8020efe:	2a39      	cmp	r2, #57	; 0x39
 8020f00:	f103 0501 	add.w	r5, r3, #1
 8020f04:	d0f6      	beq.n	8020ef4 <_dtoa_r+0x6ec>
 8020f06:	3201      	adds	r2, #1
 8020f08:	701a      	strb	r2, [r3, #0]
 8020f0a:	9906      	ldr	r1, [sp, #24]
 8020f0c:	4620      	mov	r0, r4
 8020f0e:	f000 fdbd 	bl	8021a8c <_Bfree>
 8020f12:	2e00      	cmp	r6, #0
 8020f14:	f43f ae3c 	beq.w	8020b90 <_dtoa_r+0x388>
 8020f18:	f1bb 0f00 	cmp.w	fp, #0
 8020f1c:	d005      	beq.n	8020f2a <_dtoa_r+0x722>
 8020f1e:	45b3      	cmp	fp, r6
 8020f20:	d003      	beq.n	8020f2a <_dtoa_r+0x722>
 8020f22:	4659      	mov	r1, fp
 8020f24:	4620      	mov	r0, r4
 8020f26:	f000 fdb1 	bl	8021a8c <_Bfree>
 8020f2a:	4631      	mov	r1, r6
 8020f2c:	4620      	mov	r0, r4
 8020f2e:	f000 fdad 	bl	8021a8c <_Bfree>
 8020f32:	e62d      	b.n	8020b90 <_dtoa_r+0x388>
 8020f34:	2300      	movs	r3, #0
 8020f36:	930c      	str	r3, [sp, #48]	; 0x30
 8020f38:	9b02      	ldr	r3, [sp, #8]
 8020f3a:	9a25      	ldr	r2, [sp, #148]	; 0x94
 8020f3c:	4413      	add	r3, r2
 8020f3e:	930f      	str	r3, [sp, #60]	; 0x3c
 8020f40:	3301      	adds	r3, #1
 8020f42:	2b01      	cmp	r3, #1
 8020f44:	461f      	mov	r7, r3
 8020f46:	461e      	mov	r6, r3
 8020f48:	930a      	str	r3, [sp, #40]	; 0x28
 8020f4a:	bfb8      	it	lt
 8020f4c:	2701      	movlt	r7, #1
 8020f4e:	2100      	movs	r1, #0
 8020f50:	2f17      	cmp	r7, #23
 8020f52:	6461      	str	r1, [r4, #68]	; 0x44
 8020f54:	d90a      	bls.n	8020f6c <_dtoa_r+0x764>
 8020f56:	2201      	movs	r2, #1
 8020f58:	2304      	movs	r3, #4
 8020f5a:	005b      	lsls	r3, r3, #1
 8020f5c:	f103 0014 	add.w	r0, r3, #20
 8020f60:	4287      	cmp	r7, r0
 8020f62:	4611      	mov	r1, r2
 8020f64:	f102 0201 	add.w	r2, r2, #1
 8020f68:	d2f7      	bcs.n	8020f5a <_dtoa_r+0x752>
 8020f6a:	6461      	str	r1, [r4, #68]	; 0x44
 8020f6c:	4620      	mov	r0, r4
 8020f6e:	f000 fd67 	bl	8021a40 <_Balloc>
 8020f72:	2e0e      	cmp	r6, #14
 8020f74:	9004      	str	r0, [sp, #16]
 8020f76:	6420      	str	r0, [r4, #64]	; 0x40
 8020f78:	f63f ad40 	bhi.w	80209fc <_dtoa_r+0x1f4>
 8020f7c:	2d00      	cmp	r5, #0
 8020f7e:	f43f ad3d 	beq.w	80209fc <_dtoa_r+0x1f4>
 8020f82:	9902      	ldr	r1, [sp, #8]
 8020f84:	2900      	cmp	r1, #0
 8020f86:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
 8020f8a:	f340 8202 	ble.w	8021392 <_dtoa_r+0xb8a>
 8020f8e:	4bb9      	ldr	r3, [pc, #740]	; (8021274 <_dtoa_r+0xa6c>)
 8020f90:	f001 020f 	and.w	r2, r1, #15
 8020f94:	110d      	asrs	r5, r1, #4
 8020f96:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8020f9a:	06e9      	lsls	r1, r5, #27
 8020f9c:	e9d3 6700 	ldrd	r6, r7, [r3]
 8020fa0:	f140 81ab 	bpl.w	80212fa <_dtoa_r+0xaf2>
 8020fa4:	4bb4      	ldr	r3, [pc, #720]	; (8021278 <_dtoa_r+0xa70>)
 8020fa6:	4650      	mov	r0, sl
 8020fa8:	4659      	mov	r1, fp
 8020faa:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8020fae:	f7e4 f8b9 	bl	8005124 <__aeabi_ddiv>
 8020fb2:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8020fb6:	f005 050f 	and.w	r5, r5, #15
 8020fba:	f04f 0a03 	mov.w	sl, #3
 8020fbe:	b18d      	cbz	r5, 8020fe4 <_dtoa_r+0x7dc>
 8020fc0:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 8021278 <_dtoa_r+0xa70>
 8020fc4:	07ea      	lsls	r2, r5, #31
 8020fc6:	d509      	bpl.n	8020fdc <_dtoa_r+0x7d4>
 8020fc8:	4630      	mov	r0, r6
 8020fca:	4639      	mov	r1, r7
 8020fcc:	e9d8 2300 	ldrd	r2, r3, [r8]
 8020fd0:	f7e3 ff7e 	bl	8004ed0 <__aeabi_dmul>
 8020fd4:	f10a 0a01 	add.w	sl, sl, #1
 8020fd8:	4606      	mov	r6, r0
 8020fda:	460f      	mov	r7, r1
 8020fdc:	106d      	asrs	r5, r5, #1
 8020fde:	f108 0808 	add.w	r8, r8, #8
 8020fe2:	d1ef      	bne.n	8020fc4 <_dtoa_r+0x7bc>
 8020fe4:	463b      	mov	r3, r7
 8020fe6:	4632      	mov	r2, r6
 8020fe8:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8020fec:	f7e4 f89a 	bl	8005124 <__aeabi_ddiv>
 8020ff0:	4607      	mov	r7, r0
 8020ff2:	4688      	mov	r8, r1
 8020ff4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020ff6:	b143      	cbz	r3, 802100a <_dtoa_r+0x802>
 8020ff8:	2200      	movs	r2, #0
 8020ffa:	4ba0      	ldr	r3, [pc, #640]	; (802127c <_dtoa_r+0xa74>)
 8020ffc:	4638      	mov	r0, r7
 8020ffe:	4641      	mov	r1, r8
 8021000:	f7e4 faa6 	bl	8005550 <__aeabi_dcmplt>
 8021004:	2800      	cmp	r0, #0
 8021006:	f040 827f 	bne.w	8021508 <_dtoa_r+0xd00>
 802100a:	4650      	mov	r0, sl
 802100c:	f7e3 fefa 	bl	8004e04 <__aeabi_i2d>
 8021010:	463a      	mov	r2, r7
 8021012:	4643      	mov	r3, r8
 8021014:	f7e3 ff5c 	bl	8004ed0 <__aeabi_dmul>
 8021018:	4b99      	ldr	r3, [pc, #612]	; (8021280 <_dtoa_r+0xa78>)
 802101a:	2200      	movs	r2, #0
 802101c:	f7e3 fda6 	bl	8004b6c <__adddf3>
 8021020:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021022:	4682      	mov	sl, r0
 8021024:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
 8021028:	2b00      	cmp	r3, #0
 802102a:	f000 813f 	beq.w	80212ac <_dtoa_r+0xaa4>
 802102e:	9b02      	ldr	r3, [sp, #8]
 8021030:	9315      	str	r3, [sp, #84]	; 0x54
 8021032:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021034:	9312      	str	r3, [sp, #72]	; 0x48
 8021036:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8021038:	2b00      	cmp	r3, #0
 802103a:	f000 81f7 	beq.w	802142c <_dtoa_r+0xc24>
 802103e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8021040:	4b8c      	ldr	r3, [pc, #560]	; (8021274 <_dtoa_r+0xa6c>)
 8021042:	4990      	ldr	r1, [pc, #576]	; (8021284 <_dtoa_r+0xa7c>)
 8021044:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8021048:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 802104c:	2000      	movs	r0, #0
 802104e:	f7e4 f869 	bl	8005124 <__aeabi_ddiv>
 8021052:	4652      	mov	r2, sl
 8021054:	465b      	mov	r3, fp
 8021056:	f7e3 fd87 	bl	8004b68 <__aeabi_dsub>
 802105a:	4682      	mov	sl, r0
 802105c:	468b      	mov	fp, r1
 802105e:	4638      	mov	r0, r7
 8021060:	4641      	mov	r1, r8
 8021062:	f7e4 f947 	bl	80052f4 <__aeabi_d2iz>
 8021066:	4605      	mov	r5, r0
 8021068:	f7e3 fecc 	bl	8004e04 <__aeabi_i2d>
 802106c:	4602      	mov	r2, r0
 802106e:	460b      	mov	r3, r1
 8021070:	4638      	mov	r0, r7
 8021072:	4641      	mov	r1, r8
 8021074:	f7e3 fd78 	bl	8004b68 <__aeabi_dsub>
 8021078:	3530      	adds	r5, #48	; 0x30
 802107a:	fa5f f885 	uxtb.w	r8, r5
 802107e:	9d04      	ldr	r5, [sp, #16]
 8021080:	4606      	mov	r6, r0
 8021082:	460f      	mov	r7, r1
 8021084:	f885 8000 	strb.w	r8, [r5]
 8021088:	4602      	mov	r2, r0
 802108a:	460b      	mov	r3, r1
 802108c:	4650      	mov	r0, sl
 802108e:	4659      	mov	r1, fp
 8021090:	3501      	adds	r5, #1
 8021092:	f7e4 fa7b 	bl	800558c <__aeabi_dcmpgt>
 8021096:	2800      	cmp	r0, #0
 8021098:	d154      	bne.n	8021144 <_dtoa_r+0x93c>
 802109a:	4632      	mov	r2, r6
 802109c:	463b      	mov	r3, r7
 802109e:	2000      	movs	r0, #0
 80210a0:	4976      	ldr	r1, [pc, #472]	; (802127c <_dtoa_r+0xa74>)
 80210a2:	f7e3 fd61 	bl	8004b68 <__aeabi_dsub>
 80210a6:	4602      	mov	r2, r0
 80210a8:	460b      	mov	r3, r1
 80210aa:	4650      	mov	r0, sl
 80210ac:	4659      	mov	r1, fp
 80210ae:	f7e4 fa6d 	bl	800558c <__aeabi_dcmpgt>
 80210b2:	2800      	cmp	r0, #0
 80210b4:	f040 8268 	bne.w	8021588 <_dtoa_r+0xd80>
 80210b8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80210ba:	2a01      	cmp	r2, #1
 80210bc:	f000 815b 	beq.w	8021376 <_dtoa_r+0xb6e>
 80210c0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80210c2:	9a04      	ldr	r2, [sp, #16]
 80210c4:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 80210c8:	4413      	add	r3, r2
 80210ca:	4699      	mov	r9, r3
 80210cc:	e00d      	b.n	80210ea <_dtoa_r+0x8e2>
 80210ce:	2000      	movs	r0, #0
 80210d0:	496a      	ldr	r1, [pc, #424]	; (802127c <_dtoa_r+0xa74>)
 80210d2:	f7e3 fd49 	bl	8004b68 <__aeabi_dsub>
 80210d6:	4652      	mov	r2, sl
 80210d8:	465b      	mov	r3, fp
 80210da:	f7e4 fa39 	bl	8005550 <__aeabi_dcmplt>
 80210de:	2800      	cmp	r0, #0
 80210e0:	f040 8250 	bne.w	8021584 <_dtoa_r+0xd7c>
 80210e4:	454d      	cmp	r5, r9
 80210e6:	f000 8144 	beq.w	8021372 <_dtoa_r+0xb6a>
 80210ea:	4650      	mov	r0, sl
 80210ec:	4659      	mov	r1, fp
 80210ee:	2200      	movs	r2, #0
 80210f0:	4b65      	ldr	r3, [pc, #404]	; (8021288 <_dtoa_r+0xa80>)
 80210f2:	f7e3 feed 	bl	8004ed0 <__aeabi_dmul>
 80210f6:	2200      	movs	r2, #0
 80210f8:	4b63      	ldr	r3, [pc, #396]	; (8021288 <_dtoa_r+0xa80>)
 80210fa:	4682      	mov	sl, r0
 80210fc:	468b      	mov	fp, r1
 80210fe:	4630      	mov	r0, r6
 8021100:	4639      	mov	r1, r7
 8021102:	f7e3 fee5 	bl	8004ed0 <__aeabi_dmul>
 8021106:	460f      	mov	r7, r1
 8021108:	4606      	mov	r6, r0
 802110a:	f7e4 f8f3 	bl	80052f4 <__aeabi_d2iz>
 802110e:	4680      	mov	r8, r0
 8021110:	f7e3 fe78 	bl	8004e04 <__aeabi_i2d>
 8021114:	4602      	mov	r2, r0
 8021116:	460b      	mov	r3, r1
 8021118:	4630      	mov	r0, r6
 802111a:	4639      	mov	r1, r7
 802111c:	f7e3 fd24 	bl	8004b68 <__aeabi_dsub>
 8021120:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8021124:	fa5f f888 	uxtb.w	r8, r8
 8021128:	4652      	mov	r2, sl
 802112a:	465b      	mov	r3, fp
 802112c:	f805 8b01 	strb.w	r8, [r5], #1
 8021130:	4606      	mov	r6, r0
 8021132:	460f      	mov	r7, r1
 8021134:	f7e4 fa0c 	bl	8005550 <__aeabi_dcmplt>
 8021138:	4632      	mov	r2, r6
 802113a:	463b      	mov	r3, r7
 802113c:	2800      	cmp	r0, #0
 802113e:	d0c6      	beq.n	80210ce <_dtoa_r+0x8c6>
 8021140:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 8021144:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021146:	9302      	str	r3, [sp, #8]
 8021148:	e522      	b.n	8020b90 <_dtoa_r+0x388>
 802114a:	2300      	movs	r3, #0
 802114c:	930c      	str	r3, [sp, #48]	; 0x30
 802114e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8021150:	2b00      	cmp	r3, #0
 8021152:	f340 80d9 	ble.w	8021308 <_dtoa_r+0xb00>
 8021156:	461f      	mov	r7, r3
 8021158:	461e      	mov	r6, r3
 802115a:	930f      	str	r3, [sp, #60]	; 0x3c
 802115c:	930a      	str	r3, [sp, #40]	; 0x28
 802115e:	e6f6      	b.n	8020f4e <_dtoa_r+0x746>
 8021160:	2301      	movs	r3, #1
 8021162:	930c      	str	r3, [sp, #48]	; 0x30
 8021164:	e7f3      	b.n	802114e <_dtoa_r+0x946>
 8021166:	f1ba 0f00 	cmp.w	sl, #0
 802116a:	f47f ada7 	bne.w	8020cbc <_dtoa_r+0x4b4>
 802116e:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8021172:	2b00      	cmp	r3, #0
 8021174:	f47f adb9 	bne.w	8020cea <_dtoa_r+0x4e2>
 8021178:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
 802117c:	0d3f      	lsrs	r7, r7, #20
 802117e:	053f      	lsls	r7, r7, #20
 8021180:	2f00      	cmp	r7, #0
 8021182:	f000 8205 	beq.w	8021590 <_dtoa_r+0xd88>
 8021186:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8021188:	3301      	adds	r3, #1
 802118a:	930b      	str	r3, [sp, #44]	; 0x2c
 802118c:	9b08      	ldr	r3, [sp, #32]
 802118e:	3301      	adds	r3, #1
 8021190:	9308      	str	r3, [sp, #32]
 8021192:	f04f 0801 	mov.w	r8, #1
 8021196:	e5aa      	b.n	8020cee <_dtoa_r+0x4e6>
 8021198:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802119a:	2b00      	cmp	r3, #0
 802119c:	f73f ac41 	bgt.w	8020a22 <_dtoa_r+0x21a>
 80211a0:	f040 809c 	bne.w	80212dc <_dtoa_r+0xad4>
 80211a4:	2200      	movs	r2, #0
 80211a6:	4b39      	ldr	r3, [pc, #228]	; (802128c <_dtoa_r+0xa84>)
 80211a8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80211ac:	f7e3 fe90 	bl	8004ed0 <__aeabi_dmul>
 80211b0:	465b      	mov	r3, fp
 80211b2:	4652      	mov	r2, sl
 80211b4:	f7e4 f9e0 	bl	8005578 <__aeabi_dcmpge>
 80211b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80211ba:	9306      	str	r3, [sp, #24]
 80211bc:	461e      	mov	r6, r3
 80211be:	2800      	cmp	r0, #0
 80211c0:	d041      	beq.n	8021246 <_dtoa_r+0xa3e>
 80211c2:	9b25      	ldr	r3, [sp, #148]	; 0x94
 80211c4:	9d04      	ldr	r5, [sp, #16]
 80211c6:	43db      	mvns	r3, r3
 80211c8:	9302      	str	r3, [sp, #8]
 80211ca:	9906      	ldr	r1, [sp, #24]
 80211cc:	4620      	mov	r0, r4
 80211ce:	f000 fc5d 	bl	8021a8c <_Bfree>
 80211d2:	2e00      	cmp	r6, #0
 80211d4:	f43f acdc 	beq.w	8020b90 <_dtoa_r+0x388>
 80211d8:	e6a7      	b.n	8020f2a <_dtoa_r+0x722>
 80211da:	9a06      	ldr	r2, [sp, #24]
 80211dc:	4649      	mov	r1, r9
 80211de:	4620      	mov	r0, r4
 80211e0:	f000 fd8a 	bl	8021cf8 <__pow5mult>
 80211e4:	4681      	mov	r9, r0
 80211e6:	e557      	b.n	8020c98 <_dtoa_r+0x490>
 80211e8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80211ea:	2a00      	cmp	r2, #0
 80211ec:	f000 8180 	beq.w	80214f0 <_dtoa_r+0xce8>
 80211f0:	f203 4333 	addw	r3, r3, #1075	; 0x433
 80211f4:	9f06      	ldr	r7, [sp, #24]
 80211f6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80211f8:	e4f1      	b.n	8020bde <_dtoa_r+0x3d6>
 80211fa:	f1ba 0f00 	cmp.w	sl, #0
 80211fe:	f47f ad74 	bne.w	8020cea <_dtoa_r+0x4e2>
 8021202:	e7b4      	b.n	802116e <_dtoa_r+0x966>
 8021204:	f000 fc4c 	bl	8021aa0 <__multadd>
 8021208:	4657      	mov	r7, sl
 802120a:	4606      	mov	r6, r0
 802120c:	4680      	mov	r8, r0
 802120e:	e5ba      	b.n	8020d86 <_dtoa_r+0x57e>
 8021210:	4601      	mov	r1, r0
 8021212:	4620      	mov	r0, r4
 8021214:	930a      	str	r3, [sp, #40]	; 0x28
 8021216:	f000 fc39 	bl	8021a8c <_Bfree>
 802121a:	2201      	movs	r2, #1
 802121c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802121e:	e5de      	b.n	8020dde <_dtoa_r+0x5d6>
 8021220:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8021222:	2b02      	cmp	r3, #2
 8021224:	f77f ad95 	ble.w	8020d52 <_dtoa_r+0x54a>
 8021228:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802122a:	2b00      	cmp	r3, #0
 802122c:	d1c9      	bne.n	80211c2 <_dtoa_r+0x9ba>
 802122e:	9906      	ldr	r1, [sp, #24]
 8021230:	2205      	movs	r2, #5
 8021232:	4620      	mov	r0, r4
 8021234:	f000 fc34 	bl	8021aa0 <__multadd>
 8021238:	4601      	mov	r1, r0
 802123a:	9006      	str	r0, [sp, #24]
 802123c:	4648      	mov	r0, r9
 802123e:	f000 fdfd 	bl	8021e3c <__mcmp>
 8021242:	2800      	cmp	r0, #0
 8021244:	ddbd      	ble.n	80211c2 <_dtoa_r+0x9ba>
 8021246:	9a02      	ldr	r2, [sp, #8]
 8021248:	9904      	ldr	r1, [sp, #16]
 802124a:	2331      	movs	r3, #49	; 0x31
 802124c:	3201      	adds	r2, #1
 802124e:	9202      	str	r2, [sp, #8]
 8021250:	700b      	strb	r3, [r1, #0]
 8021252:	1c4d      	adds	r5, r1, #1
 8021254:	e7b9      	b.n	80211ca <_dtoa_r+0x9c2>
 8021256:	9a02      	ldr	r2, [sp, #8]
 8021258:	3201      	adds	r2, #1
 802125a:	9202      	str	r2, [sp, #8]
 802125c:	9a04      	ldr	r2, [sp, #16]
 802125e:	2331      	movs	r3, #49	; 0x31
 8021260:	7013      	strb	r3, [r2, #0]
 8021262:	e652      	b.n	8020f0a <_dtoa_r+0x702>
 8021264:	2301      	movs	r3, #1
 8021266:	930c      	str	r3, [sp, #48]	; 0x30
 8021268:	e666      	b.n	8020f38 <_dtoa_r+0x730>
 802126a:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 802126e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8021270:	e48e      	b.n	8020b90 <_dtoa_r+0x388>
 8021272:	bf00      	nop
 8021274:	08025220 	.word	0x08025220
 8021278:	080251f8 	.word	0x080251f8
 802127c:	3ff00000 	.word	0x3ff00000
 8021280:	401c0000 	.word	0x401c0000
 8021284:	3fe00000 	.word	0x3fe00000
 8021288:	40240000 	.word	0x40240000
 802128c:	40140000 	.word	0x40140000
 8021290:	4650      	mov	r0, sl
 8021292:	f7e3 fdb7 	bl	8004e04 <__aeabi_i2d>
 8021296:	463a      	mov	r2, r7
 8021298:	4643      	mov	r3, r8
 802129a:	f7e3 fe19 	bl	8004ed0 <__aeabi_dmul>
 802129e:	2200      	movs	r2, #0
 80212a0:	4bc5      	ldr	r3, [pc, #788]	; (80215b8 <_dtoa_r+0xdb0>)
 80212a2:	f7e3 fc63 	bl	8004b6c <__adddf3>
 80212a6:	4682      	mov	sl, r0
 80212a8:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
 80212ac:	4638      	mov	r0, r7
 80212ae:	2200      	movs	r2, #0
 80212b0:	4bc2      	ldr	r3, [pc, #776]	; (80215bc <_dtoa_r+0xdb4>)
 80212b2:	4641      	mov	r1, r8
 80212b4:	f7e3 fc58 	bl	8004b68 <__aeabi_dsub>
 80212b8:	4652      	mov	r2, sl
 80212ba:	465b      	mov	r3, fp
 80212bc:	4606      	mov	r6, r0
 80212be:	460f      	mov	r7, r1
 80212c0:	f7e4 f964 	bl	800558c <__aeabi_dcmpgt>
 80212c4:	2800      	cmp	r0, #0
 80212c6:	f040 80ad 	bne.w	8021424 <_dtoa_r+0xc1c>
 80212ca:	4652      	mov	r2, sl
 80212cc:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 80212d0:	4630      	mov	r0, r6
 80212d2:	4639      	mov	r1, r7
 80212d4:	f7e4 f93c 	bl	8005550 <__aeabi_dcmplt>
 80212d8:	2800      	cmp	r0, #0
 80212da:	d04c      	beq.n	8021376 <_dtoa_r+0xb6e>
 80212dc:	2300      	movs	r3, #0
 80212de:	9306      	str	r3, [sp, #24]
 80212e0:	461e      	mov	r6, r3
 80212e2:	e76e      	b.n	80211c2 <_dtoa_r+0x9ba>
 80212e4:	9804      	ldr	r0, [sp, #16]
 80212e6:	f7ff babd 	b.w	8020864 <_dtoa_r+0x5c>
 80212ea:	9b06      	ldr	r3, [sp, #24]
 80212ec:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80212ee:	9706      	str	r7, [sp, #24]
 80212f0:	1afb      	subs	r3, r7, r3
 80212f2:	441a      	add	r2, r3
 80212f4:	920d      	str	r2, [sp, #52]	; 0x34
 80212f6:	2700      	movs	r7, #0
 80212f8:	e46b      	b.n	8020bd2 <_dtoa_r+0x3ca>
 80212fa:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 80212fe:	f04f 0a02 	mov.w	sl, #2
 8021302:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 8021306:	e65a      	b.n	8020fbe <_dtoa_r+0x7b6>
 8021308:	2100      	movs	r1, #0
 802130a:	2301      	movs	r3, #1
 802130c:	6461      	str	r1, [r4, #68]	; 0x44
 802130e:	4620      	mov	r0, r4
 8021310:	9325      	str	r3, [sp, #148]	; 0x94
 8021312:	f000 fb95 	bl	8021a40 <_Balloc>
 8021316:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8021318:	9004      	str	r0, [sp, #16]
 802131a:	6420      	str	r0, [r4, #64]	; 0x40
 802131c:	930a      	str	r3, [sp, #40]	; 0x28
 802131e:	930f      	str	r3, [sp, #60]	; 0x3c
 8021320:	e62c      	b.n	8020f7c <_dtoa_r+0x774>
 8021322:	2a00      	cmp	r2, #0
 8021324:	469a      	mov	sl, r3
 8021326:	dd11      	ble.n	802134c <_dtoa_r+0xb44>
 8021328:	4649      	mov	r1, r9
 802132a:	2201      	movs	r2, #1
 802132c:	4620      	mov	r0, r4
 802132e:	f000 fd33 	bl	8021d98 <__lshift>
 8021332:	9906      	ldr	r1, [sp, #24]
 8021334:	4681      	mov	r9, r0
 8021336:	f000 fd81 	bl	8021e3c <__mcmp>
 802133a:	2800      	cmp	r0, #0
 802133c:	f340 8134 	ble.w	80215a8 <_dtoa_r+0xda0>
 8021340:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 8021344:	f000 8104 	beq.w	8021550 <_dtoa_r+0xd48>
 8021348:	f105 0a31 	add.w	sl, r5, #49	; 0x31
 802134c:	46b3      	mov	fp, r6
 802134e:	f887 a000 	strb.w	sl, [r7]
 8021352:	1c7d      	adds	r5, r7, #1
 8021354:	4646      	mov	r6, r8
 8021356:	e5d8      	b.n	8020f0a <_dtoa_r+0x702>
 8021358:	d104      	bne.n	8021364 <_dtoa_r+0xb5c>
 802135a:	f01a 0f01 	tst.w	sl, #1
 802135e:	d001      	beq.n	8021364 <_dtoa_r+0xb5c>
 8021360:	e5c3      	b.n	8020eea <_dtoa_r+0x6e2>
 8021362:	4615      	mov	r5, r2
 8021364:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8021368:	2b30      	cmp	r3, #48	; 0x30
 802136a:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 802136e:	d0f8      	beq.n	8021362 <_dtoa_r+0xb5a>
 8021370:	e5cb      	b.n	8020f0a <_dtoa_r+0x702>
 8021372:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 8021376:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 802137a:	f7ff bb3f 	b.w	80209fc <_dtoa_r+0x1f4>
 802137e:	9904      	ldr	r1, [sp, #16]
 8021380:	2230      	movs	r2, #48	; 0x30
 8021382:	700a      	strb	r2, [r1, #0]
 8021384:	9a02      	ldr	r2, [sp, #8]
 8021386:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 802138a:	3201      	adds	r2, #1
 802138c:	9202      	str	r2, [sp, #8]
 802138e:	f7ff bbfb 	b.w	8020b88 <_dtoa_r+0x380>
 8021392:	f000 80b4 	beq.w	80214fe <_dtoa_r+0xcf6>
 8021396:	9b02      	ldr	r3, [sp, #8]
 8021398:	425d      	negs	r5, r3
 802139a:	4b89      	ldr	r3, [pc, #548]	; (80215c0 <_dtoa_r+0xdb8>)
 802139c:	f005 020f 	and.w	r2, r5, #15
 80213a0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80213a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80213a8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80213ac:	f7e3 fd90 	bl	8004ed0 <__aeabi_dmul>
 80213b0:	112d      	asrs	r5, r5, #4
 80213b2:	4607      	mov	r7, r0
 80213b4:	4688      	mov	r8, r1
 80213b6:	f000 811d 	beq.w	80215f4 <_dtoa_r+0xdec>
 80213ba:	4e82      	ldr	r6, [pc, #520]	; (80215c4 <_dtoa_r+0xdbc>)
 80213bc:	f04f 0a02 	mov.w	sl, #2
 80213c0:	07eb      	lsls	r3, r5, #31
 80213c2:	d509      	bpl.n	80213d8 <_dtoa_r+0xbd0>
 80213c4:	4638      	mov	r0, r7
 80213c6:	4641      	mov	r1, r8
 80213c8:	e9d6 2300 	ldrd	r2, r3, [r6]
 80213cc:	f7e3 fd80 	bl	8004ed0 <__aeabi_dmul>
 80213d0:	f10a 0a01 	add.w	sl, sl, #1
 80213d4:	4607      	mov	r7, r0
 80213d6:	4688      	mov	r8, r1
 80213d8:	106d      	asrs	r5, r5, #1
 80213da:	f106 0608 	add.w	r6, r6, #8
 80213de:	d1ef      	bne.n	80213c0 <_dtoa_r+0xbb8>
 80213e0:	e608      	b.n	8020ff4 <_dtoa_r+0x7ec>
 80213e2:	6871      	ldr	r1, [r6, #4]
 80213e4:	4620      	mov	r0, r4
 80213e6:	f000 fb2b 	bl	8021a40 <_Balloc>
 80213ea:	6933      	ldr	r3, [r6, #16]
 80213ec:	3302      	adds	r3, #2
 80213ee:	009a      	lsls	r2, r3, #2
 80213f0:	4605      	mov	r5, r0
 80213f2:	f106 010c 	add.w	r1, r6, #12
 80213f6:	300c      	adds	r0, #12
 80213f8:	f7e3 f990 	bl	800471c <memcpy>
 80213fc:	4629      	mov	r1, r5
 80213fe:	2201      	movs	r2, #1
 8021400:	4620      	mov	r0, r4
 8021402:	f000 fcc9 	bl	8021d98 <__lshift>
 8021406:	4680      	mov	r8, r0
 8021408:	e4b4      	b.n	8020d74 <_dtoa_r+0x56c>
 802140a:	2b39      	cmp	r3, #57	; 0x39
 802140c:	f000 80a0 	beq.w	8021550 <_dtoa_r+0xd48>
 8021410:	3301      	adds	r3, #1
 8021412:	46b3      	mov	fp, r6
 8021414:	703b      	strb	r3, [r7, #0]
 8021416:	1c7d      	adds	r5, r7, #1
 8021418:	4646      	mov	r6, r8
 802141a:	e576      	b.n	8020f0a <_dtoa_r+0x702>
 802141c:	46b3      	mov	fp, r6
 802141e:	469a      	mov	sl, r3
 8021420:	4646      	mov	r6, r8
 8021422:	e556      	b.n	8020ed2 <_dtoa_r+0x6ca>
 8021424:	2300      	movs	r3, #0
 8021426:	9306      	str	r3, [sp, #24]
 8021428:	461e      	mov	r6, r3
 802142a:	e70c      	b.n	8021246 <_dtoa_r+0xa3e>
 802142c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802142e:	4964      	ldr	r1, [pc, #400]	; (80215c0 <_dtoa_r+0xdb8>)
 8021430:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8021434:	4652      	mov	r2, sl
 8021436:	465b      	mov	r3, fp
 8021438:	e951 0102 	ldrd	r0, r1, [r1, #-8]
 802143c:	f7e3 fd48 	bl	8004ed0 <__aeabi_dmul>
 8021440:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
 8021444:	4638      	mov	r0, r7
 8021446:	4641      	mov	r1, r8
 8021448:	f7e3 ff54 	bl	80052f4 <__aeabi_d2iz>
 802144c:	4605      	mov	r5, r0
 802144e:	f7e3 fcd9 	bl	8004e04 <__aeabi_i2d>
 8021452:	460b      	mov	r3, r1
 8021454:	4602      	mov	r2, r0
 8021456:	4641      	mov	r1, r8
 8021458:	4638      	mov	r0, r7
 802145a:	f7e3 fb85 	bl	8004b68 <__aeabi_dsub>
 802145e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021460:	460f      	mov	r7, r1
 8021462:	9904      	ldr	r1, [sp, #16]
 8021464:	3530      	adds	r5, #48	; 0x30
 8021466:	2b01      	cmp	r3, #1
 8021468:	700d      	strb	r5, [r1, #0]
 802146a:	4606      	mov	r6, r0
 802146c:	f101 0501 	add.w	r5, r1, #1
 8021470:	d026      	beq.n	80214c0 <_dtoa_r+0xcb8>
 8021472:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021474:	9a04      	ldr	r2, [sp, #16]
 8021476:	f8df b154 	ldr.w	fp, [pc, #340]	; 80215cc <_dtoa_r+0xdc4>
 802147a:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 802147e:	4413      	add	r3, r2
 8021480:	f04f 0a00 	mov.w	sl, #0
 8021484:	4699      	mov	r9, r3
 8021486:	4652      	mov	r2, sl
 8021488:	465b      	mov	r3, fp
 802148a:	4630      	mov	r0, r6
 802148c:	4639      	mov	r1, r7
 802148e:	f7e3 fd1f 	bl	8004ed0 <__aeabi_dmul>
 8021492:	460f      	mov	r7, r1
 8021494:	4606      	mov	r6, r0
 8021496:	f7e3 ff2d 	bl	80052f4 <__aeabi_d2iz>
 802149a:	4680      	mov	r8, r0
 802149c:	f7e3 fcb2 	bl	8004e04 <__aeabi_i2d>
 80214a0:	f108 0830 	add.w	r8, r8, #48	; 0x30
 80214a4:	4602      	mov	r2, r0
 80214a6:	460b      	mov	r3, r1
 80214a8:	4630      	mov	r0, r6
 80214aa:	4639      	mov	r1, r7
 80214ac:	f7e3 fb5c 	bl	8004b68 <__aeabi_dsub>
 80214b0:	f805 8b01 	strb.w	r8, [r5], #1
 80214b4:	454d      	cmp	r5, r9
 80214b6:	4606      	mov	r6, r0
 80214b8:	460f      	mov	r7, r1
 80214ba:	d1e4      	bne.n	8021486 <_dtoa_r+0xc7e>
 80214bc:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 80214c0:	4b41      	ldr	r3, [pc, #260]	; (80215c8 <_dtoa_r+0xdc0>)
 80214c2:	2200      	movs	r2, #0
 80214c4:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 80214c8:	f7e3 fb50 	bl	8004b6c <__adddf3>
 80214cc:	4632      	mov	r2, r6
 80214ce:	463b      	mov	r3, r7
 80214d0:	f7e4 f83e 	bl	8005550 <__aeabi_dcmplt>
 80214d4:	2800      	cmp	r0, #0
 80214d6:	d041      	beq.n	802155c <_dtoa_r+0xd54>
 80214d8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80214da:	9302      	str	r3, [sp, #8]
 80214dc:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 80214e0:	f7ff bb45 	b.w	8020b6e <_dtoa_r+0x366>
 80214e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80214e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80214e8:	1a9d      	subs	r5, r3, r2
 80214ea:	2300      	movs	r3, #0
 80214ec:	f7ff bb77 	b.w	8020bde <_dtoa_r+0x3d6>
 80214f0:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80214f2:	9f06      	ldr	r7, [sp, #24]
 80214f4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80214f6:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80214fa:	f7ff bb70 	b.w	8020bde <_dtoa_r+0x3d6>
 80214fe:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
 8021502:	f04f 0a02 	mov.w	sl, #2
 8021506:	e575      	b.n	8020ff4 <_dtoa_r+0x7ec>
 8021508:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802150a:	2b00      	cmp	r3, #0
 802150c:	f43f aec0 	beq.w	8021290 <_dtoa_r+0xa88>
 8021510:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8021512:	2d00      	cmp	r5, #0
 8021514:	f77f af2f 	ble.w	8021376 <_dtoa_r+0xb6e>
 8021518:	2200      	movs	r2, #0
 802151a:	4b2c      	ldr	r3, [pc, #176]	; (80215cc <_dtoa_r+0xdc4>)
 802151c:	4638      	mov	r0, r7
 802151e:	4641      	mov	r1, r8
 8021520:	f7e3 fcd6 	bl	8004ed0 <__aeabi_dmul>
 8021524:	4607      	mov	r7, r0
 8021526:	4688      	mov	r8, r1
 8021528:	f10a 0001 	add.w	r0, sl, #1
 802152c:	f7e3 fc6a 	bl	8004e04 <__aeabi_i2d>
 8021530:	463a      	mov	r2, r7
 8021532:	4643      	mov	r3, r8
 8021534:	f7e3 fccc 	bl	8004ed0 <__aeabi_dmul>
 8021538:	4b1f      	ldr	r3, [pc, #124]	; (80215b8 <_dtoa_r+0xdb0>)
 802153a:	2200      	movs	r2, #0
 802153c:	f7e3 fb16 	bl	8004b6c <__adddf3>
 8021540:	9b02      	ldr	r3, [sp, #8]
 8021542:	9512      	str	r5, [sp, #72]	; 0x48
 8021544:	3b01      	subs	r3, #1
 8021546:	4682      	mov	sl, r0
 8021548:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
 802154c:	9315      	str	r3, [sp, #84]	; 0x54
 802154e:	e572      	b.n	8021036 <_dtoa_r+0x82e>
 8021550:	2239      	movs	r2, #57	; 0x39
 8021552:	46b3      	mov	fp, r6
 8021554:	703a      	strb	r2, [r7, #0]
 8021556:	4646      	mov	r6, r8
 8021558:	1c7d      	adds	r5, r7, #1
 802155a:	e4c8      	b.n	8020eee <_dtoa_r+0x6e6>
 802155c:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 8021560:	2000      	movs	r0, #0
 8021562:	4919      	ldr	r1, [pc, #100]	; (80215c8 <_dtoa_r+0xdc0>)
 8021564:	f7e3 fb00 	bl	8004b68 <__aeabi_dsub>
 8021568:	4632      	mov	r2, r6
 802156a:	463b      	mov	r3, r7
 802156c:	f7e4 f80e 	bl	800558c <__aeabi_dcmpgt>
 8021570:	b908      	cbnz	r0, 8021576 <_dtoa_r+0xd6e>
 8021572:	e700      	b.n	8021376 <_dtoa_r+0xb6e>
 8021574:	4615      	mov	r5, r2
 8021576:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 802157a:	2b30      	cmp	r3, #48	; 0x30
 802157c:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 8021580:	d0f8      	beq.n	8021574 <_dtoa_r+0xd6c>
 8021582:	e5df      	b.n	8021144 <_dtoa_r+0x93c>
 8021584:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 8021588:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802158a:	9302      	str	r3, [sp, #8]
 802158c:	f7ff baef 	b.w	8020b6e <_dtoa_r+0x366>
 8021590:	46b8      	mov	r8, r7
 8021592:	f7ff bbac 	b.w	8020cee <_dtoa_r+0x4e6>
 8021596:	2b39      	cmp	r3, #57	; 0x39
 8021598:	46d3      	mov	fp, sl
 802159a:	469a      	mov	sl, r3
 802159c:	d0d8      	beq.n	8021550 <_dtoa_r+0xd48>
 802159e:	f1bb 0f00 	cmp.w	fp, #0
 80215a2:	f73f aed1 	bgt.w	8021348 <_dtoa_r+0xb40>
 80215a6:	e6d1      	b.n	802134c <_dtoa_r+0xb44>
 80215a8:	f47f aed0 	bne.w	802134c <_dtoa_r+0xb44>
 80215ac:	f01a 0f01 	tst.w	sl, #1
 80215b0:	f43f aecc 	beq.w	802134c <_dtoa_r+0xb44>
 80215b4:	e6c4      	b.n	8021340 <_dtoa_r+0xb38>
 80215b6:	bf00      	nop
 80215b8:	401c0000 	.word	0x401c0000
 80215bc:	40140000 	.word	0x40140000
 80215c0:	08025220 	.word	0x08025220
 80215c4:	080251f8 	.word	0x080251f8
 80215c8:	3fe00000 	.word	0x3fe00000
 80215cc:	40240000 	.word	0x40240000
 80215d0:	4631      	mov	r1, r6
 80215d2:	2300      	movs	r3, #0
 80215d4:	220a      	movs	r2, #10
 80215d6:	4620      	mov	r0, r4
 80215d8:	f000 fa62 	bl	8021aa0 <__multadd>
 80215dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80215de:	2b00      	cmp	r3, #0
 80215e0:	4606      	mov	r6, r0
 80215e2:	dd0a      	ble.n	80215fa <_dtoa_r+0xdf2>
 80215e4:	930a      	str	r3, [sp, #40]	; 0x28
 80215e6:	f7ff bbb8 	b.w	8020d5a <_dtoa_r+0x552>
 80215ea:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80215ec:	2b02      	cmp	r3, #2
 80215ee:	dc22      	bgt.n	8021636 <_dtoa_r+0xe2e>
 80215f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80215f2:	e448      	b.n	8020e86 <_dtoa_r+0x67e>
 80215f4:	f04f 0a02 	mov.w	sl, #2
 80215f8:	e4fc      	b.n	8020ff4 <_dtoa_r+0x7ec>
 80215fa:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80215fc:	2b02      	cmp	r3, #2
 80215fe:	dc1a      	bgt.n	8021636 <_dtoa_r+0xe2e>
 8021600:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021602:	e7ef      	b.n	80215e4 <_dtoa_r+0xddc>
 8021604:	2501      	movs	r5, #1
 8021606:	f7ff b9c4 	b.w	8020992 <_dtoa_r+0x18a>
 802160a:	f43f ab88 	beq.w	8020d1e <_dtoa_r+0x516>
 802160e:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 8021612:	e417      	b.n	8020e44 <_dtoa_r+0x63c>
 8021614:	2500      	movs	r5, #0
 8021616:	6465      	str	r5, [r4, #68]	; 0x44
 8021618:	4629      	mov	r1, r5
 802161a:	4620      	mov	r0, r4
 802161c:	f000 fa10 	bl	8021a40 <_Balloc>
 8021620:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8021624:	930a      	str	r3, [sp, #40]	; 0x28
 8021626:	930f      	str	r3, [sp, #60]	; 0x3c
 8021628:	2301      	movs	r3, #1
 802162a:	9004      	str	r0, [sp, #16]
 802162c:	9525      	str	r5, [sp, #148]	; 0x94
 802162e:	6420      	str	r0, [r4, #64]	; 0x40
 8021630:	930c      	str	r3, [sp, #48]	; 0x30
 8021632:	f7ff b9e3 	b.w	80209fc <_dtoa_r+0x1f4>
 8021636:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021638:	930a      	str	r3, [sp, #40]	; 0x28
 802163a:	e5f5      	b.n	8021228 <_dtoa_r+0xa20>

0802163c <__sfvwrite_r>:
 802163c:	6893      	ldr	r3, [r2, #8]
 802163e:	2b00      	cmp	r3, #0
 8021640:	d073      	beq.n	802172a <__sfvwrite_r+0xee>
 8021642:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021646:	898b      	ldrh	r3, [r1, #12]
 8021648:	b083      	sub	sp, #12
 802164a:	460c      	mov	r4, r1
 802164c:	0719      	lsls	r1, r3, #28
 802164e:	9000      	str	r0, [sp, #0]
 8021650:	4616      	mov	r6, r2
 8021652:	d526      	bpl.n	80216a2 <__sfvwrite_r+0x66>
 8021654:	6922      	ldr	r2, [r4, #16]
 8021656:	b322      	cbz	r2, 80216a2 <__sfvwrite_r+0x66>
 8021658:	f013 0002 	ands.w	r0, r3, #2
 802165c:	6835      	ldr	r5, [r6, #0]
 802165e:	d02c      	beq.n	80216ba <__sfvwrite_r+0x7e>
 8021660:	f04f 0900 	mov.w	r9, #0
 8021664:	4fb0      	ldr	r7, [pc, #704]	; (8021928 <__sfvwrite_r+0x2ec>)
 8021666:	46c8      	mov	r8, r9
 8021668:	46b2      	mov	sl, r6
 802166a:	45b8      	cmp	r8, r7
 802166c:	4643      	mov	r3, r8
 802166e:	464a      	mov	r2, r9
 8021670:	bf28      	it	cs
 8021672:	463b      	movcs	r3, r7
 8021674:	9800      	ldr	r0, [sp, #0]
 8021676:	f1b8 0f00 	cmp.w	r8, #0
 802167a:	d050      	beq.n	802171e <__sfvwrite_r+0xe2>
 802167c:	69e1      	ldr	r1, [r4, #28]
 802167e:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8021680:	47b0      	blx	r6
 8021682:	2800      	cmp	r0, #0
 8021684:	dd58      	ble.n	8021738 <__sfvwrite_r+0xfc>
 8021686:	f8da 3008 	ldr.w	r3, [sl, #8]
 802168a:	1a1b      	subs	r3, r3, r0
 802168c:	4481      	add	r9, r0
 802168e:	eba8 0800 	sub.w	r8, r8, r0
 8021692:	f8ca 3008 	str.w	r3, [sl, #8]
 8021696:	2b00      	cmp	r3, #0
 8021698:	d1e7      	bne.n	802166a <__sfvwrite_r+0x2e>
 802169a:	2000      	movs	r0, #0
 802169c:	b003      	add	sp, #12
 802169e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80216a2:	4621      	mov	r1, r4
 80216a4:	9800      	ldr	r0, [sp, #0]
 80216a6:	f7fe ffb3 	bl	8020610 <__swsetup_r>
 80216aa:	2800      	cmp	r0, #0
 80216ac:	f040 8133 	bne.w	8021916 <__sfvwrite_r+0x2da>
 80216b0:	89a3      	ldrh	r3, [r4, #12]
 80216b2:	6835      	ldr	r5, [r6, #0]
 80216b4:	f013 0002 	ands.w	r0, r3, #2
 80216b8:	d1d2      	bne.n	8021660 <__sfvwrite_r+0x24>
 80216ba:	f013 0901 	ands.w	r9, r3, #1
 80216be:	d145      	bne.n	802174c <__sfvwrite_r+0x110>
 80216c0:	464f      	mov	r7, r9
 80216c2:	9601      	str	r6, [sp, #4]
 80216c4:	b337      	cbz	r7, 8021714 <__sfvwrite_r+0xd8>
 80216c6:	059a      	lsls	r2, r3, #22
 80216c8:	f8d4 8008 	ldr.w	r8, [r4, #8]
 80216cc:	f140 8083 	bpl.w	80217d6 <__sfvwrite_r+0x19a>
 80216d0:	4547      	cmp	r7, r8
 80216d2:	46c3      	mov	fp, r8
 80216d4:	f0c0 80ab 	bcc.w	802182e <__sfvwrite_r+0x1f2>
 80216d8:	f413 6f90 	tst.w	r3, #1152	; 0x480
 80216dc:	f040 80ac 	bne.w	8021838 <__sfvwrite_r+0x1fc>
 80216e0:	6820      	ldr	r0, [r4, #0]
 80216e2:	46ba      	mov	sl, r7
 80216e4:	465a      	mov	r2, fp
 80216e6:	4649      	mov	r1, r9
 80216e8:	f7fc fcd4 	bl	801e094 <memmove>
 80216ec:	68a2      	ldr	r2, [r4, #8]
 80216ee:	6823      	ldr	r3, [r4, #0]
 80216f0:	eba2 0208 	sub.w	r2, r2, r8
 80216f4:	445b      	add	r3, fp
 80216f6:	60a2      	str	r2, [r4, #8]
 80216f8:	6023      	str	r3, [r4, #0]
 80216fa:	9a01      	ldr	r2, [sp, #4]
 80216fc:	6893      	ldr	r3, [r2, #8]
 80216fe:	eba3 030a 	sub.w	r3, r3, sl
 8021702:	44d1      	add	r9, sl
 8021704:	eba7 070a 	sub.w	r7, r7, sl
 8021708:	6093      	str	r3, [r2, #8]
 802170a:	2b00      	cmp	r3, #0
 802170c:	d0c5      	beq.n	802169a <__sfvwrite_r+0x5e>
 802170e:	89a3      	ldrh	r3, [r4, #12]
 8021710:	2f00      	cmp	r7, #0
 8021712:	d1d8      	bne.n	80216c6 <__sfvwrite_r+0x8a>
 8021714:	f8d5 9000 	ldr.w	r9, [r5]
 8021718:	686f      	ldr	r7, [r5, #4]
 802171a:	3508      	adds	r5, #8
 802171c:	e7d2      	b.n	80216c4 <__sfvwrite_r+0x88>
 802171e:	f8d5 9000 	ldr.w	r9, [r5]
 8021722:	f8d5 8004 	ldr.w	r8, [r5, #4]
 8021726:	3508      	adds	r5, #8
 8021728:	e79f      	b.n	802166a <__sfvwrite_r+0x2e>
 802172a:	2000      	movs	r0, #0
 802172c:	4770      	bx	lr
 802172e:	4621      	mov	r1, r4
 8021730:	9800      	ldr	r0, [sp, #0]
 8021732:	f7fb fe23 	bl	801d37c <_fflush_r>
 8021736:	b370      	cbz	r0, 8021796 <__sfvwrite_r+0x15a>
 8021738:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802173c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021740:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8021744:	81a3      	strh	r3, [r4, #12]
 8021746:	b003      	add	sp, #12
 8021748:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802174c:	4681      	mov	r9, r0
 802174e:	4633      	mov	r3, r6
 8021750:	464e      	mov	r6, r9
 8021752:	46a8      	mov	r8, r5
 8021754:	469a      	mov	sl, r3
 8021756:	464d      	mov	r5, r9
 8021758:	b34e      	cbz	r6, 80217ae <__sfvwrite_r+0x172>
 802175a:	b380      	cbz	r0, 80217be <__sfvwrite_r+0x182>
 802175c:	6820      	ldr	r0, [r4, #0]
 802175e:	6923      	ldr	r3, [r4, #16]
 8021760:	6962      	ldr	r2, [r4, #20]
 8021762:	45b1      	cmp	r9, r6
 8021764:	46cb      	mov	fp, r9
 8021766:	bf28      	it	cs
 8021768:	46b3      	movcs	fp, r6
 802176a:	4298      	cmp	r0, r3
 802176c:	465f      	mov	r7, fp
 802176e:	d904      	bls.n	802177a <__sfvwrite_r+0x13e>
 8021770:	68a3      	ldr	r3, [r4, #8]
 8021772:	4413      	add	r3, r2
 8021774:	459b      	cmp	fp, r3
 8021776:	f300 80a6 	bgt.w	80218c6 <__sfvwrite_r+0x28a>
 802177a:	4593      	cmp	fp, r2
 802177c:	db4b      	blt.n	8021816 <__sfvwrite_r+0x1da>
 802177e:	4613      	mov	r3, r2
 8021780:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8021782:	69e1      	ldr	r1, [r4, #28]
 8021784:	9800      	ldr	r0, [sp, #0]
 8021786:	462a      	mov	r2, r5
 8021788:	47b8      	blx	r7
 802178a:	1e07      	subs	r7, r0, #0
 802178c:	ddd4      	ble.n	8021738 <__sfvwrite_r+0xfc>
 802178e:	ebb9 0907 	subs.w	r9, r9, r7
 8021792:	d0cc      	beq.n	802172e <__sfvwrite_r+0xf2>
 8021794:	2001      	movs	r0, #1
 8021796:	f8da 3008 	ldr.w	r3, [sl, #8]
 802179a:	1bdb      	subs	r3, r3, r7
 802179c:	443d      	add	r5, r7
 802179e:	1bf6      	subs	r6, r6, r7
 80217a0:	f8ca 3008 	str.w	r3, [sl, #8]
 80217a4:	2b00      	cmp	r3, #0
 80217a6:	f43f af78 	beq.w	802169a <__sfvwrite_r+0x5e>
 80217aa:	2e00      	cmp	r6, #0
 80217ac:	d1d5      	bne.n	802175a <__sfvwrite_r+0x11e>
 80217ae:	f108 0308 	add.w	r3, r8, #8
 80217b2:	e913 0060 	ldmdb	r3, {r5, r6}
 80217b6:	4698      	mov	r8, r3
 80217b8:	3308      	adds	r3, #8
 80217ba:	2e00      	cmp	r6, #0
 80217bc:	d0f9      	beq.n	80217b2 <__sfvwrite_r+0x176>
 80217be:	4632      	mov	r2, r6
 80217c0:	210a      	movs	r1, #10
 80217c2:	4628      	mov	r0, r5
 80217c4:	f7e3 fe14 	bl	80053f0 <memchr>
 80217c8:	2800      	cmp	r0, #0
 80217ca:	f000 80a1 	beq.w	8021910 <__sfvwrite_r+0x2d4>
 80217ce:	3001      	adds	r0, #1
 80217d0:	eba0 0905 	sub.w	r9, r0, r5
 80217d4:	e7c2      	b.n	802175c <__sfvwrite_r+0x120>
 80217d6:	6820      	ldr	r0, [r4, #0]
 80217d8:	6923      	ldr	r3, [r4, #16]
 80217da:	4298      	cmp	r0, r3
 80217dc:	d802      	bhi.n	80217e4 <__sfvwrite_r+0x1a8>
 80217de:	6963      	ldr	r3, [r4, #20]
 80217e0:	429f      	cmp	r7, r3
 80217e2:	d25d      	bcs.n	80218a0 <__sfvwrite_r+0x264>
 80217e4:	45b8      	cmp	r8, r7
 80217e6:	bf28      	it	cs
 80217e8:	46b8      	movcs	r8, r7
 80217ea:	4642      	mov	r2, r8
 80217ec:	4649      	mov	r1, r9
 80217ee:	f7fc fc51 	bl	801e094 <memmove>
 80217f2:	68a3      	ldr	r3, [r4, #8]
 80217f4:	6822      	ldr	r2, [r4, #0]
 80217f6:	eba3 0308 	sub.w	r3, r3, r8
 80217fa:	4442      	add	r2, r8
 80217fc:	60a3      	str	r3, [r4, #8]
 80217fe:	6022      	str	r2, [r4, #0]
 8021800:	b10b      	cbz	r3, 8021806 <__sfvwrite_r+0x1ca>
 8021802:	46c2      	mov	sl, r8
 8021804:	e779      	b.n	80216fa <__sfvwrite_r+0xbe>
 8021806:	4621      	mov	r1, r4
 8021808:	9800      	ldr	r0, [sp, #0]
 802180a:	f7fb fdb7 	bl	801d37c <_fflush_r>
 802180e:	2800      	cmp	r0, #0
 8021810:	d192      	bne.n	8021738 <__sfvwrite_r+0xfc>
 8021812:	46c2      	mov	sl, r8
 8021814:	e771      	b.n	80216fa <__sfvwrite_r+0xbe>
 8021816:	465a      	mov	r2, fp
 8021818:	4629      	mov	r1, r5
 802181a:	f7fc fc3b 	bl	801e094 <memmove>
 802181e:	68a2      	ldr	r2, [r4, #8]
 8021820:	6823      	ldr	r3, [r4, #0]
 8021822:	eba2 020b 	sub.w	r2, r2, fp
 8021826:	445b      	add	r3, fp
 8021828:	60a2      	str	r2, [r4, #8]
 802182a:	6023      	str	r3, [r4, #0]
 802182c:	e7af      	b.n	802178e <__sfvwrite_r+0x152>
 802182e:	6820      	ldr	r0, [r4, #0]
 8021830:	46b8      	mov	r8, r7
 8021832:	46ba      	mov	sl, r7
 8021834:	46bb      	mov	fp, r7
 8021836:	e755      	b.n	80216e4 <__sfvwrite_r+0xa8>
 8021838:	6962      	ldr	r2, [r4, #20]
 802183a:	6820      	ldr	r0, [r4, #0]
 802183c:	6921      	ldr	r1, [r4, #16]
 802183e:	eb02 0842 	add.w	r8, r2, r2, lsl #1
 8021842:	eba0 0a01 	sub.w	sl, r0, r1
 8021846:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
 802184a:	f10a 0001 	add.w	r0, sl, #1
 802184e:	ea4f 0868 	mov.w	r8, r8, asr #1
 8021852:	4438      	add	r0, r7
 8021854:	4540      	cmp	r0, r8
 8021856:	4642      	mov	r2, r8
 8021858:	bf84      	itt	hi
 802185a:	4680      	movhi	r8, r0
 802185c:	4642      	movhi	r2, r8
 802185e:	055b      	lsls	r3, r3, #21
 8021860:	d544      	bpl.n	80218ec <__sfvwrite_r+0x2b0>
 8021862:	4611      	mov	r1, r2
 8021864:	9800      	ldr	r0, [sp, #0]
 8021866:	f7fa fa5b 	bl	801bd20 <_malloc_r>
 802186a:	4683      	mov	fp, r0
 802186c:	2800      	cmp	r0, #0
 802186e:	d055      	beq.n	802191c <__sfvwrite_r+0x2e0>
 8021870:	4652      	mov	r2, sl
 8021872:	6921      	ldr	r1, [r4, #16]
 8021874:	f7e2 ff52 	bl	800471c <memcpy>
 8021878:	89a3      	ldrh	r3, [r4, #12]
 802187a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 802187e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8021882:	81a3      	strh	r3, [r4, #12]
 8021884:	eb0b 000a 	add.w	r0, fp, sl
 8021888:	eba8 030a 	sub.w	r3, r8, sl
 802188c:	f8c4 b010 	str.w	fp, [r4, #16]
 8021890:	f8c4 8014 	str.w	r8, [r4, #20]
 8021894:	6020      	str	r0, [r4, #0]
 8021896:	60a3      	str	r3, [r4, #8]
 8021898:	46b8      	mov	r8, r7
 802189a:	46ba      	mov	sl, r7
 802189c:	46bb      	mov	fp, r7
 802189e:	e721      	b.n	80216e4 <__sfvwrite_r+0xa8>
 80218a0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80218a4:	42b9      	cmp	r1, r7
 80218a6:	bf28      	it	cs
 80218a8:	4639      	movcs	r1, r7
 80218aa:	464a      	mov	r2, r9
 80218ac:	fb91 f1f3 	sdiv	r1, r1, r3
 80218b0:	9800      	ldr	r0, [sp, #0]
 80218b2:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80218b4:	fb03 f301 	mul.w	r3, r3, r1
 80218b8:	69e1      	ldr	r1, [r4, #28]
 80218ba:	47b0      	blx	r6
 80218bc:	f1b0 0a00 	subs.w	sl, r0, #0
 80218c0:	f73f af1b 	bgt.w	80216fa <__sfvwrite_r+0xbe>
 80218c4:	e738      	b.n	8021738 <__sfvwrite_r+0xfc>
 80218c6:	461a      	mov	r2, r3
 80218c8:	4629      	mov	r1, r5
 80218ca:	9301      	str	r3, [sp, #4]
 80218cc:	f7fc fbe2 	bl	801e094 <memmove>
 80218d0:	6822      	ldr	r2, [r4, #0]
 80218d2:	9b01      	ldr	r3, [sp, #4]
 80218d4:	9800      	ldr	r0, [sp, #0]
 80218d6:	441a      	add	r2, r3
 80218d8:	6022      	str	r2, [r4, #0]
 80218da:	4621      	mov	r1, r4
 80218dc:	f7fb fd4e 	bl	801d37c <_fflush_r>
 80218e0:	9b01      	ldr	r3, [sp, #4]
 80218e2:	2800      	cmp	r0, #0
 80218e4:	f47f af28 	bne.w	8021738 <__sfvwrite_r+0xfc>
 80218e8:	461f      	mov	r7, r3
 80218ea:	e750      	b.n	802178e <__sfvwrite_r+0x152>
 80218ec:	9800      	ldr	r0, [sp, #0]
 80218ee:	f7fb ffbf 	bl	801d870 <_realloc_r>
 80218f2:	4683      	mov	fp, r0
 80218f4:	2800      	cmp	r0, #0
 80218f6:	d1c5      	bne.n	8021884 <__sfvwrite_r+0x248>
 80218f8:	9d00      	ldr	r5, [sp, #0]
 80218fa:	6921      	ldr	r1, [r4, #16]
 80218fc:	4628      	mov	r0, r5
 80218fe:	f7fb fe1d 	bl	801d53c <_free_r>
 8021902:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8021906:	220c      	movs	r2, #12
 8021908:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802190c:	602a      	str	r2, [r5, #0]
 802190e:	e715      	b.n	802173c <__sfvwrite_r+0x100>
 8021910:	f106 0901 	add.w	r9, r6, #1
 8021914:	e722      	b.n	802175c <__sfvwrite_r+0x120>
 8021916:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802191a:	e6bf      	b.n	802169c <__sfvwrite_r+0x60>
 802191c:	9a00      	ldr	r2, [sp, #0]
 802191e:	230c      	movs	r3, #12
 8021920:	6013      	str	r3, [r2, #0]
 8021922:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8021926:	e709      	b.n	802173c <__sfvwrite_r+0x100>
 8021928:	7ffffc00 	.word	0x7ffffc00

0802192c <labs>:
 802192c:	2800      	cmp	r0, #0
 802192e:	bfb8      	it	lt
 8021930:	4240      	neglt	r0, r0
 8021932:	4770      	bx	lr

08021934 <_localeconv_r>:
 8021934:	4a04      	ldr	r2, [pc, #16]	; (8021948 <_localeconv_r+0x14>)
 8021936:	4b05      	ldr	r3, [pc, #20]	; (802194c <_localeconv_r+0x18>)
 8021938:	6812      	ldr	r2, [r2, #0]
 802193a:	6b50      	ldr	r0, [r2, #52]	; 0x34
 802193c:	2800      	cmp	r0, #0
 802193e:	bf08      	it	eq
 8021940:	4618      	moveq	r0, r3
 8021942:	30f0      	adds	r0, #240	; 0xf0
 8021944:	4770      	bx	lr
 8021946:	bf00      	nop
 8021948:	20004474 	.word	0x20004474
 802194c:	200048a0 	.word	0x200048a0

08021950 <__swhatbuf_r>:
 8021950:	b570      	push	{r4, r5, r6, lr}
 8021952:	460c      	mov	r4, r1
 8021954:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021958:	2900      	cmp	r1, #0
 802195a:	b090      	sub	sp, #64	; 0x40
 802195c:	4615      	mov	r5, r2
 802195e:	461e      	mov	r6, r3
 8021960:	db14      	blt.n	802198c <__swhatbuf_r+0x3c>
 8021962:	aa01      	add	r2, sp, #4
 8021964:	f7e3 fe94 	bl	8005690 <_fstat_r>
 8021968:	2800      	cmp	r0, #0
 802196a:	db0f      	blt.n	802198c <__swhatbuf_r+0x3c>
 802196c:	9a02      	ldr	r2, [sp, #8]
 802196e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8021972:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
 8021976:	fab2 f282 	clz	r2, r2
 802197a:	0952      	lsrs	r2, r2, #5
 802197c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8021980:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8021984:	6032      	str	r2, [r6, #0]
 8021986:	602b      	str	r3, [r5, #0]
 8021988:	b010      	add	sp, #64	; 0x40
 802198a:	bd70      	pop	{r4, r5, r6, pc}
 802198c:	89a2      	ldrh	r2, [r4, #12]
 802198e:	2300      	movs	r3, #0
 8021990:	f012 0080 	ands.w	r0, r2, #128	; 0x80
 8021994:	6033      	str	r3, [r6, #0]
 8021996:	d004      	beq.n	80219a2 <__swhatbuf_r+0x52>
 8021998:	2240      	movs	r2, #64	; 0x40
 802199a:	4618      	mov	r0, r3
 802199c:	602a      	str	r2, [r5, #0]
 802199e:	b010      	add	sp, #64	; 0x40
 80219a0:	bd70      	pop	{r4, r5, r6, pc}
 80219a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80219a6:	602b      	str	r3, [r5, #0]
 80219a8:	b010      	add	sp, #64	; 0x40
 80219aa:	bd70      	pop	{r4, r5, r6, pc}

080219ac <__smakebuf_r>:
 80219ac:	898a      	ldrh	r2, [r1, #12]
 80219ae:	0792      	lsls	r2, r2, #30
 80219b0:	460b      	mov	r3, r1
 80219b2:	d506      	bpl.n	80219c2 <__smakebuf_r+0x16>
 80219b4:	f101 0243 	add.w	r2, r1, #67	; 0x43
 80219b8:	2101      	movs	r1, #1
 80219ba:	601a      	str	r2, [r3, #0]
 80219bc:	611a      	str	r2, [r3, #16]
 80219be:	6159      	str	r1, [r3, #20]
 80219c0:	4770      	bx	lr
 80219c2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80219c4:	b083      	sub	sp, #12
 80219c6:	ab01      	add	r3, sp, #4
 80219c8:	466a      	mov	r2, sp
 80219ca:	460c      	mov	r4, r1
 80219cc:	4606      	mov	r6, r0
 80219ce:	f7ff ffbf 	bl	8021950 <__swhatbuf_r>
 80219d2:	9900      	ldr	r1, [sp, #0]
 80219d4:	4605      	mov	r5, r0
 80219d6:	4630      	mov	r0, r6
 80219d8:	f7fa f9a2 	bl	801bd20 <_malloc_r>
 80219dc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80219e0:	b1d8      	cbz	r0, 8021a1a <__smakebuf_r+0x6e>
 80219e2:	9a01      	ldr	r2, [sp, #4]
 80219e4:	4f15      	ldr	r7, [pc, #84]	; (8021a3c <__smakebuf_r+0x90>)
 80219e6:	9900      	ldr	r1, [sp, #0]
 80219e8:	63f7      	str	r7, [r6, #60]	; 0x3c
 80219ea:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80219ee:	81a3      	strh	r3, [r4, #12]
 80219f0:	6020      	str	r0, [r4, #0]
 80219f2:	6120      	str	r0, [r4, #16]
 80219f4:	6161      	str	r1, [r4, #20]
 80219f6:	b91a      	cbnz	r2, 8021a00 <__smakebuf_r+0x54>
 80219f8:	432b      	orrs	r3, r5
 80219fa:	81a3      	strh	r3, [r4, #12]
 80219fc:	b003      	add	sp, #12
 80219fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021a00:	4630      	mov	r0, r6
 8021a02:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8021a06:	f7e3 fe5b 	bl	80056c0 <_isatty_r>
 8021a0a:	b1a0      	cbz	r0, 8021a36 <__smakebuf_r+0x8a>
 8021a0c:	89a3      	ldrh	r3, [r4, #12]
 8021a0e:	f023 0303 	bic.w	r3, r3, #3
 8021a12:	f043 0301 	orr.w	r3, r3, #1
 8021a16:	b21b      	sxth	r3, r3
 8021a18:	e7ee      	b.n	80219f8 <__smakebuf_r+0x4c>
 8021a1a:	059a      	lsls	r2, r3, #22
 8021a1c:	d4ee      	bmi.n	80219fc <__smakebuf_r+0x50>
 8021a1e:	f023 0303 	bic.w	r3, r3, #3
 8021a22:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8021a26:	f043 0302 	orr.w	r3, r3, #2
 8021a2a:	2101      	movs	r1, #1
 8021a2c:	81a3      	strh	r3, [r4, #12]
 8021a2e:	6022      	str	r2, [r4, #0]
 8021a30:	6122      	str	r2, [r4, #16]
 8021a32:	6161      	str	r1, [r4, #20]
 8021a34:	e7e2      	b.n	80219fc <__smakebuf_r+0x50>
 8021a36:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8021a3a:	e7dd      	b.n	80219f8 <__smakebuf_r+0x4c>
 8021a3c:	0801d3d1 	.word	0x0801d3d1

08021a40 <_Balloc>:
 8021a40:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021a42:	b570      	push	{r4, r5, r6, lr}
 8021a44:	4605      	mov	r5, r0
 8021a46:	460c      	mov	r4, r1
 8021a48:	b14b      	cbz	r3, 8021a5e <_Balloc+0x1e>
 8021a4a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8021a4e:	b180      	cbz	r0, 8021a72 <_Balloc+0x32>
 8021a50:	6802      	ldr	r2, [r0, #0]
 8021a52:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8021a56:	2300      	movs	r3, #0
 8021a58:	6103      	str	r3, [r0, #16]
 8021a5a:	60c3      	str	r3, [r0, #12]
 8021a5c:	bd70      	pop	{r4, r5, r6, pc}
 8021a5e:	2221      	movs	r2, #33	; 0x21
 8021a60:	2104      	movs	r1, #4
 8021a62:	f001 f925 	bl	8022cb0 <_calloc_r>
 8021a66:	64e8      	str	r0, [r5, #76]	; 0x4c
 8021a68:	4603      	mov	r3, r0
 8021a6a:	2800      	cmp	r0, #0
 8021a6c:	d1ed      	bne.n	8021a4a <_Balloc+0xa>
 8021a6e:	2000      	movs	r0, #0
 8021a70:	bd70      	pop	{r4, r5, r6, pc}
 8021a72:	2101      	movs	r1, #1
 8021a74:	fa01 f604 	lsl.w	r6, r1, r4
 8021a78:	1d72      	adds	r2, r6, #5
 8021a7a:	4628      	mov	r0, r5
 8021a7c:	0092      	lsls	r2, r2, #2
 8021a7e:	f001 f917 	bl	8022cb0 <_calloc_r>
 8021a82:	2800      	cmp	r0, #0
 8021a84:	d0f3      	beq.n	8021a6e <_Balloc+0x2e>
 8021a86:	6044      	str	r4, [r0, #4]
 8021a88:	6086      	str	r6, [r0, #8]
 8021a8a:	e7e4      	b.n	8021a56 <_Balloc+0x16>

08021a8c <_Bfree>:
 8021a8c:	b131      	cbz	r1, 8021a9c <_Bfree+0x10>
 8021a8e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021a90:	684a      	ldr	r2, [r1, #4]
 8021a92:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8021a96:	6008      	str	r0, [r1, #0]
 8021a98:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8021a9c:	4770      	bx	lr
 8021a9e:	bf00      	nop

08021aa0 <__multadd>:
 8021aa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021aa2:	690c      	ldr	r4, [r1, #16]
 8021aa4:	b083      	sub	sp, #12
 8021aa6:	460d      	mov	r5, r1
 8021aa8:	4606      	mov	r6, r0
 8021aaa:	f101 0e14 	add.w	lr, r1, #20
 8021aae:	2700      	movs	r7, #0
 8021ab0:	f8de 0000 	ldr.w	r0, [lr]
 8021ab4:	b281      	uxth	r1, r0
 8021ab6:	fb02 3301 	mla	r3, r2, r1, r3
 8021aba:	0c01      	lsrs	r1, r0, #16
 8021abc:	0c18      	lsrs	r0, r3, #16
 8021abe:	fb02 0101 	mla	r1, r2, r1, r0
 8021ac2:	b29b      	uxth	r3, r3
 8021ac4:	3701      	adds	r7, #1
 8021ac6:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8021aca:	42bc      	cmp	r4, r7
 8021acc:	f84e 3b04 	str.w	r3, [lr], #4
 8021ad0:	ea4f 4311 	mov.w	r3, r1, lsr #16
 8021ad4:	dcec      	bgt.n	8021ab0 <__multadd+0x10>
 8021ad6:	b13b      	cbz	r3, 8021ae8 <__multadd+0x48>
 8021ad8:	68aa      	ldr	r2, [r5, #8]
 8021ada:	4294      	cmp	r4, r2
 8021adc:	da07      	bge.n	8021aee <__multadd+0x4e>
 8021ade:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8021ae2:	3401      	adds	r4, #1
 8021ae4:	6153      	str	r3, [r2, #20]
 8021ae6:	612c      	str	r4, [r5, #16]
 8021ae8:	4628      	mov	r0, r5
 8021aea:	b003      	add	sp, #12
 8021aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021aee:	6869      	ldr	r1, [r5, #4]
 8021af0:	9301      	str	r3, [sp, #4]
 8021af2:	3101      	adds	r1, #1
 8021af4:	4630      	mov	r0, r6
 8021af6:	f7ff ffa3 	bl	8021a40 <_Balloc>
 8021afa:	692a      	ldr	r2, [r5, #16]
 8021afc:	3202      	adds	r2, #2
 8021afe:	f105 010c 	add.w	r1, r5, #12
 8021b02:	4607      	mov	r7, r0
 8021b04:	0092      	lsls	r2, r2, #2
 8021b06:	300c      	adds	r0, #12
 8021b08:	f7e2 fe08 	bl	800471c <memcpy>
 8021b0c:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 8021b0e:	6869      	ldr	r1, [r5, #4]
 8021b10:	9b01      	ldr	r3, [sp, #4]
 8021b12:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 8021b16:	6028      	str	r0, [r5, #0]
 8021b18:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 8021b1c:	463d      	mov	r5, r7
 8021b1e:	e7de      	b.n	8021ade <__multadd+0x3e>

08021b20 <__hi0bits>:
 8021b20:	0c02      	lsrs	r2, r0, #16
 8021b22:	0412      	lsls	r2, r2, #16
 8021b24:	4603      	mov	r3, r0
 8021b26:	b9b2      	cbnz	r2, 8021b56 <__hi0bits+0x36>
 8021b28:	0403      	lsls	r3, r0, #16
 8021b2a:	2010      	movs	r0, #16
 8021b2c:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 8021b30:	bf04      	itt	eq
 8021b32:	021b      	lsleq	r3, r3, #8
 8021b34:	3008      	addeq	r0, #8
 8021b36:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 8021b3a:	bf04      	itt	eq
 8021b3c:	011b      	lsleq	r3, r3, #4
 8021b3e:	3004      	addeq	r0, #4
 8021b40:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 8021b44:	bf04      	itt	eq
 8021b46:	009b      	lsleq	r3, r3, #2
 8021b48:	3002      	addeq	r0, #2
 8021b4a:	2b00      	cmp	r3, #0
 8021b4c:	db02      	blt.n	8021b54 <__hi0bits+0x34>
 8021b4e:	005b      	lsls	r3, r3, #1
 8021b50:	d403      	bmi.n	8021b5a <__hi0bits+0x3a>
 8021b52:	2020      	movs	r0, #32
 8021b54:	4770      	bx	lr
 8021b56:	2000      	movs	r0, #0
 8021b58:	e7e8      	b.n	8021b2c <__hi0bits+0xc>
 8021b5a:	3001      	adds	r0, #1
 8021b5c:	4770      	bx	lr
 8021b5e:	bf00      	nop

08021b60 <__lo0bits>:
 8021b60:	6803      	ldr	r3, [r0, #0]
 8021b62:	f013 0207 	ands.w	r2, r3, #7
 8021b66:	4601      	mov	r1, r0
 8021b68:	d007      	beq.n	8021b7a <__lo0bits+0x1a>
 8021b6a:	07da      	lsls	r2, r3, #31
 8021b6c:	d421      	bmi.n	8021bb2 <__lo0bits+0x52>
 8021b6e:	0798      	lsls	r0, r3, #30
 8021b70:	d421      	bmi.n	8021bb6 <__lo0bits+0x56>
 8021b72:	089b      	lsrs	r3, r3, #2
 8021b74:	600b      	str	r3, [r1, #0]
 8021b76:	2002      	movs	r0, #2
 8021b78:	4770      	bx	lr
 8021b7a:	b298      	uxth	r0, r3
 8021b7c:	b198      	cbz	r0, 8021ba6 <__lo0bits+0x46>
 8021b7e:	4610      	mov	r0, r2
 8021b80:	f013 0fff 	tst.w	r3, #255	; 0xff
 8021b84:	bf04      	itt	eq
 8021b86:	0a1b      	lsreq	r3, r3, #8
 8021b88:	3008      	addeq	r0, #8
 8021b8a:	071a      	lsls	r2, r3, #28
 8021b8c:	bf04      	itt	eq
 8021b8e:	091b      	lsreq	r3, r3, #4
 8021b90:	3004      	addeq	r0, #4
 8021b92:	079a      	lsls	r2, r3, #30
 8021b94:	bf04      	itt	eq
 8021b96:	089b      	lsreq	r3, r3, #2
 8021b98:	3002      	addeq	r0, #2
 8021b9a:	07da      	lsls	r2, r3, #31
 8021b9c:	d407      	bmi.n	8021bae <__lo0bits+0x4e>
 8021b9e:	085b      	lsrs	r3, r3, #1
 8021ba0:	d104      	bne.n	8021bac <__lo0bits+0x4c>
 8021ba2:	2020      	movs	r0, #32
 8021ba4:	4770      	bx	lr
 8021ba6:	0c1b      	lsrs	r3, r3, #16
 8021ba8:	2010      	movs	r0, #16
 8021baa:	e7e9      	b.n	8021b80 <__lo0bits+0x20>
 8021bac:	3001      	adds	r0, #1
 8021bae:	600b      	str	r3, [r1, #0]
 8021bb0:	4770      	bx	lr
 8021bb2:	2000      	movs	r0, #0
 8021bb4:	4770      	bx	lr
 8021bb6:	085b      	lsrs	r3, r3, #1
 8021bb8:	600b      	str	r3, [r1, #0]
 8021bba:	2001      	movs	r0, #1
 8021bbc:	4770      	bx	lr
 8021bbe:	bf00      	nop

08021bc0 <__i2b>:
 8021bc0:	b510      	push	{r4, lr}
 8021bc2:	460c      	mov	r4, r1
 8021bc4:	2101      	movs	r1, #1
 8021bc6:	f7ff ff3b 	bl	8021a40 <_Balloc>
 8021bca:	2201      	movs	r2, #1
 8021bcc:	6144      	str	r4, [r0, #20]
 8021bce:	6102      	str	r2, [r0, #16]
 8021bd0:	bd10      	pop	{r4, pc}
 8021bd2:	bf00      	nop

08021bd4 <__multiply>:
 8021bd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021bd8:	690c      	ldr	r4, [r1, #16]
 8021bda:	6915      	ldr	r5, [r2, #16]
 8021bdc:	42ac      	cmp	r4, r5
 8021bde:	b083      	sub	sp, #12
 8021be0:	468b      	mov	fp, r1
 8021be2:	4616      	mov	r6, r2
 8021be4:	da04      	bge.n	8021bf0 <__multiply+0x1c>
 8021be6:	4622      	mov	r2, r4
 8021be8:	46b3      	mov	fp, r6
 8021bea:	462c      	mov	r4, r5
 8021bec:	460e      	mov	r6, r1
 8021bee:	4615      	mov	r5, r2
 8021bf0:	f8db 3008 	ldr.w	r3, [fp, #8]
 8021bf4:	f8db 1004 	ldr.w	r1, [fp, #4]
 8021bf8:	eb04 0805 	add.w	r8, r4, r5
 8021bfc:	4598      	cmp	r8, r3
 8021bfe:	bfc8      	it	gt
 8021c00:	3101      	addgt	r1, #1
 8021c02:	f7ff ff1d 	bl	8021a40 <_Balloc>
 8021c06:	f100 0914 	add.w	r9, r0, #20
 8021c0a:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
 8021c0e:	45d1      	cmp	r9, sl
 8021c10:	9000      	str	r0, [sp, #0]
 8021c12:	d205      	bcs.n	8021c20 <__multiply+0x4c>
 8021c14:	464b      	mov	r3, r9
 8021c16:	2100      	movs	r1, #0
 8021c18:	f843 1b04 	str.w	r1, [r3], #4
 8021c1c:	459a      	cmp	sl, r3
 8021c1e:	d8fb      	bhi.n	8021c18 <__multiply+0x44>
 8021c20:	f106 0c14 	add.w	ip, r6, #20
 8021c24:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
 8021c28:	f10b 0b14 	add.w	fp, fp, #20
 8021c2c:	459c      	cmp	ip, r3
 8021c2e:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
 8021c32:	d24c      	bcs.n	8021cce <__multiply+0xfa>
 8021c34:	f8cd a004 	str.w	sl, [sp, #4]
 8021c38:	469a      	mov	sl, r3
 8021c3a:	f8dc 5000 	ldr.w	r5, [ip]
 8021c3e:	b2af      	uxth	r7, r5
 8021c40:	b1ef      	cbz	r7, 8021c7e <__multiply+0xaa>
 8021c42:	2100      	movs	r1, #0
 8021c44:	464d      	mov	r5, r9
 8021c46:	465e      	mov	r6, fp
 8021c48:	460c      	mov	r4, r1
 8021c4a:	f856 2b04 	ldr.w	r2, [r6], #4
 8021c4e:	6828      	ldr	r0, [r5, #0]
 8021c50:	b293      	uxth	r3, r2
 8021c52:	b281      	uxth	r1, r0
 8021c54:	fb07 1303 	mla	r3, r7, r3, r1
 8021c58:	0c12      	lsrs	r2, r2, #16
 8021c5a:	0c01      	lsrs	r1, r0, #16
 8021c5c:	4423      	add	r3, r4
 8021c5e:	fb07 1102 	mla	r1, r7, r2, r1
 8021c62:	eb01 4113 	add.w	r1, r1, r3, lsr #16
 8021c66:	b29b      	uxth	r3, r3
 8021c68:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8021c6c:	45b6      	cmp	lr, r6
 8021c6e:	f845 3b04 	str.w	r3, [r5], #4
 8021c72:	ea4f 4411 	mov.w	r4, r1, lsr #16
 8021c76:	d8e8      	bhi.n	8021c4a <__multiply+0x76>
 8021c78:	602c      	str	r4, [r5, #0]
 8021c7a:	f8dc 5000 	ldr.w	r5, [ip]
 8021c7e:	0c2d      	lsrs	r5, r5, #16
 8021c80:	d01d      	beq.n	8021cbe <__multiply+0xea>
 8021c82:	f8d9 3000 	ldr.w	r3, [r9]
 8021c86:	4648      	mov	r0, r9
 8021c88:	461c      	mov	r4, r3
 8021c8a:	4659      	mov	r1, fp
 8021c8c:	2200      	movs	r2, #0
 8021c8e:	880e      	ldrh	r6, [r1, #0]
 8021c90:	0c24      	lsrs	r4, r4, #16
 8021c92:	fb05 4406 	mla	r4, r5, r6, r4
 8021c96:	4422      	add	r2, r4
 8021c98:	b29b      	uxth	r3, r3
 8021c9a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8021c9e:	f840 3b04 	str.w	r3, [r0], #4
 8021ca2:	f851 3b04 	ldr.w	r3, [r1], #4
 8021ca6:	6804      	ldr	r4, [r0, #0]
 8021ca8:	0c1b      	lsrs	r3, r3, #16
 8021caa:	b2a6      	uxth	r6, r4
 8021cac:	fb05 6303 	mla	r3, r5, r3, r6
 8021cb0:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 8021cb4:	458e      	cmp	lr, r1
 8021cb6:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8021cba:	d8e8      	bhi.n	8021c8e <__multiply+0xba>
 8021cbc:	6003      	str	r3, [r0, #0]
 8021cbe:	f10c 0c04 	add.w	ip, ip, #4
 8021cc2:	45e2      	cmp	sl, ip
 8021cc4:	f109 0904 	add.w	r9, r9, #4
 8021cc8:	d8b7      	bhi.n	8021c3a <__multiply+0x66>
 8021cca:	f8dd a004 	ldr.w	sl, [sp, #4]
 8021cce:	f1b8 0f00 	cmp.w	r8, #0
 8021cd2:	dd0b      	ble.n	8021cec <__multiply+0x118>
 8021cd4:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 8021cd8:	f1aa 0a04 	sub.w	sl, sl, #4
 8021cdc:	b11b      	cbz	r3, 8021ce6 <__multiply+0x112>
 8021cde:	e005      	b.n	8021cec <__multiply+0x118>
 8021ce0:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
 8021ce4:	b913      	cbnz	r3, 8021cec <__multiply+0x118>
 8021ce6:	f1b8 0801 	subs.w	r8, r8, #1
 8021cea:	d1f9      	bne.n	8021ce0 <__multiply+0x10c>
 8021cec:	9800      	ldr	r0, [sp, #0]
 8021cee:	f8c0 8010 	str.w	r8, [r0, #16]
 8021cf2:	b003      	add	sp, #12
 8021cf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08021cf8 <__pow5mult>:
 8021cf8:	f012 0303 	ands.w	r3, r2, #3
 8021cfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021d00:	4614      	mov	r4, r2
 8021d02:	4607      	mov	r7, r0
 8021d04:	d12e      	bne.n	8021d64 <__pow5mult+0x6c>
 8021d06:	460d      	mov	r5, r1
 8021d08:	10a4      	asrs	r4, r4, #2
 8021d0a:	d01c      	beq.n	8021d46 <__pow5mult+0x4e>
 8021d0c:	6cbe      	ldr	r6, [r7, #72]	; 0x48
 8021d0e:	b396      	cbz	r6, 8021d76 <__pow5mult+0x7e>
 8021d10:	07e3      	lsls	r3, r4, #31
 8021d12:	f04f 0800 	mov.w	r8, #0
 8021d16:	d406      	bmi.n	8021d26 <__pow5mult+0x2e>
 8021d18:	1064      	asrs	r4, r4, #1
 8021d1a:	d014      	beq.n	8021d46 <__pow5mult+0x4e>
 8021d1c:	6830      	ldr	r0, [r6, #0]
 8021d1e:	b1a8      	cbz	r0, 8021d4c <__pow5mult+0x54>
 8021d20:	4606      	mov	r6, r0
 8021d22:	07e3      	lsls	r3, r4, #31
 8021d24:	d5f8      	bpl.n	8021d18 <__pow5mult+0x20>
 8021d26:	4632      	mov	r2, r6
 8021d28:	4629      	mov	r1, r5
 8021d2a:	4638      	mov	r0, r7
 8021d2c:	f7ff ff52 	bl	8021bd4 <__multiply>
 8021d30:	b1b5      	cbz	r5, 8021d60 <__pow5mult+0x68>
 8021d32:	686a      	ldr	r2, [r5, #4]
 8021d34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8021d36:	1064      	asrs	r4, r4, #1
 8021d38:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8021d3c:	6029      	str	r1, [r5, #0]
 8021d3e:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 8021d42:	4605      	mov	r5, r0
 8021d44:	d1ea      	bne.n	8021d1c <__pow5mult+0x24>
 8021d46:	4628      	mov	r0, r5
 8021d48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021d4c:	4632      	mov	r2, r6
 8021d4e:	4631      	mov	r1, r6
 8021d50:	4638      	mov	r0, r7
 8021d52:	f7ff ff3f 	bl	8021bd4 <__multiply>
 8021d56:	6030      	str	r0, [r6, #0]
 8021d58:	f8c0 8000 	str.w	r8, [r0]
 8021d5c:	4606      	mov	r6, r0
 8021d5e:	e7e0      	b.n	8021d22 <__pow5mult+0x2a>
 8021d60:	4605      	mov	r5, r0
 8021d62:	e7d9      	b.n	8021d18 <__pow5mult+0x20>
 8021d64:	1e5a      	subs	r2, r3, #1
 8021d66:	4d0b      	ldr	r5, [pc, #44]	; (8021d94 <__pow5mult+0x9c>)
 8021d68:	2300      	movs	r3, #0
 8021d6a:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8021d6e:	f7ff fe97 	bl	8021aa0 <__multadd>
 8021d72:	4605      	mov	r5, r0
 8021d74:	e7c8      	b.n	8021d08 <__pow5mult+0x10>
 8021d76:	2101      	movs	r1, #1
 8021d78:	4638      	mov	r0, r7
 8021d7a:	f7ff fe61 	bl	8021a40 <_Balloc>
 8021d7e:	f240 2171 	movw	r1, #625	; 0x271
 8021d82:	2201      	movs	r2, #1
 8021d84:	2300      	movs	r3, #0
 8021d86:	6141      	str	r1, [r0, #20]
 8021d88:	6102      	str	r2, [r0, #16]
 8021d8a:	4606      	mov	r6, r0
 8021d8c:	64b8      	str	r0, [r7, #72]	; 0x48
 8021d8e:	6003      	str	r3, [r0, #0]
 8021d90:	e7be      	b.n	8021d10 <__pow5mult+0x18>
 8021d92:	bf00      	nop
 8021d94:	080252e8 	.word	0x080252e8

08021d98 <__lshift>:
 8021d98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8021d9c:	4691      	mov	r9, r2
 8021d9e:	690a      	ldr	r2, [r1, #16]
 8021da0:	688b      	ldr	r3, [r1, #8]
 8021da2:	ea4f 1469 	mov.w	r4, r9, asr #5
 8021da6:	eb04 0802 	add.w	r8, r4, r2
 8021daa:	f108 0501 	add.w	r5, r8, #1
 8021dae:	429d      	cmp	r5, r3
 8021db0:	460e      	mov	r6, r1
 8021db2:	4607      	mov	r7, r0
 8021db4:	6849      	ldr	r1, [r1, #4]
 8021db6:	dd04      	ble.n	8021dc2 <__lshift+0x2a>
 8021db8:	005b      	lsls	r3, r3, #1
 8021dba:	429d      	cmp	r5, r3
 8021dbc:	f101 0101 	add.w	r1, r1, #1
 8021dc0:	dcfa      	bgt.n	8021db8 <__lshift+0x20>
 8021dc2:	4638      	mov	r0, r7
 8021dc4:	f7ff fe3c 	bl	8021a40 <_Balloc>
 8021dc8:	2c00      	cmp	r4, #0
 8021dca:	f100 0314 	add.w	r3, r0, #20
 8021dce:	dd06      	ble.n	8021dde <__lshift+0x46>
 8021dd0:	eb03 0284 	add.w	r2, r3, r4, lsl #2
 8021dd4:	2100      	movs	r1, #0
 8021dd6:	f843 1b04 	str.w	r1, [r3], #4
 8021dda:	429a      	cmp	r2, r3
 8021ddc:	d1fb      	bne.n	8021dd6 <__lshift+0x3e>
 8021dde:	6934      	ldr	r4, [r6, #16]
 8021de0:	f106 0114 	add.w	r1, r6, #20
 8021de4:	f019 091f 	ands.w	r9, r9, #31
 8021de8:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
 8021dec:	d01d      	beq.n	8021e2a <__lshift+0x92>
 8021dee:	f1c9 0c20 	rsb	ip, r9, #32
 8021df2:	2200      	movs	r2, #0
 8021df4:	680c      	ldr	r4, [r1, #0]
 8021df6:	fa04 f409 	lsl.w	r4, r4, r9
 8021dfa:	4314      	orrs	r4, r2
 8021dfc:	f843 4b04 	str.w	r4, [r3], #4
 8021e00:	f851 2b04 	ldr.w	r2, [r1], #4
 8021e04:	458e      	cmp	lr, r1
 8021e06:	fa22 f20c 	lsr.w	r2, r2, ip
 8021e0a:	d8f3      	bhi.n	8021df4 <__lshift+0x5c>
 8021e0c:	601a      	str	r2, [r3, #0]
 8021e0e:	b10a      	cbz	r2, 8021e14 <__lshift+0x7c>
 8021e10:	f108 0502 	add.w	r5, r8, #2
 8021e14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8021e16:	6872      	ldr	r2, [r6, #4]
 8021e18:	3d01      	subs	r5, #1
 8021e1a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8021e1e:	6105      	str	r5, [r0, #16]
 8021e20:	6031      	str	r1, [r6, #0]
 8021e22:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 8021e26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8021e2a:	3b04      	subs	r3, #4
 8021e2c:	f851 2b04 	ldr.w	r2, [r1], #4
 8021e30:	f843 2f04 	str.w	r2, [r3, #4]!
 8021e34:	458e      	cmp	lr, r1
 8021e36:	d8f9      	bhi.n	8021e2c <__lshift+0x94>
 8021e38:	e7ec      	b.n	8021e14 <__lshift+0x7c>
 8021e3a:	bf00      	nop

08021e3c <__mcmp>:
 8021e3c:	b430      	push	{r4, r5}
 8021e3e:	690b      	ldr	r3, [r1, #16]
 8021e40:	4605      	mov	r5, r0
 8021e42:	6900      	ldr	r0, [r0, #16]
 8021e44:	1ac0      	subs	r0, r0, r3
 8021e46:	d10f      	bne.n	8021e68 <__mcmp+0x2c>
 8021e48:	009b      	lsls	r3, r3, #2
 8021e4a:	3514      	adds	r5, #20
 8021e4c:	3114      	adds	r1, #20
 8021e4e:	4419      	add	r1, r3
 8021e50:	442b      	add	r3, r5
 8021e52:	e001      	b.n	8021e58 <__mcmp+0x1c>
 8021e54:	429d      	cmp	r5, r3
 8021e56:	d207      	bcs.n	8021e68 <__mcmp+0x2c>
 8021e58:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8021e5c:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8021e60:	4294      	cmp	r4, r2
 8021e62:	d0f7      	beq.n	8021e54 <__mcmp+0x18>
 8021e64:	d302      	bcc.n	8021e6c <__mcmp+0x30>
 8021e66:	2001      	movs	r0, #1
 8021e68:	bc30      	pop	{r4, r5}
 8021e6a:	4770      	bx	lr
 8021e6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8021e70:	e7fa      	b.n	8021e68 <__mcmp+0x2c>
 8021e72:	bf00      	nop

08021e74 <__mdiff>:
 8021e74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021e78:	690f      	ldr	r7, [r1, #16]
 8021e7a:	460e      	mov	r6, r1
 8021e7c:	6911      	ldr	r1, [r2, #16]
 8021e7e:	1a7f      	subs	r7, r7, r1
 8021e80:	2f00      	cmp	r7, #0
 8021e82:	4690      	mov	r8, r2
 8021e84:	d117      	bne.n	8021eb6 <__mdiff+0x42>
 8021e86:	0089      	lsls	r1, r1, #2
 8021e88:	f106 0514 	add.w	r5, r6, #20
 8021e8c:	f102 0e14 	add.w	lr, r2, #20
 8021e90:	186b      	adds	r3, r5, r1
 8021e92:	4471      	add	r1, lr
 8021e94:	e001      	b.n	8021e9a <__mdiff+0x26>
 8021e96:	429d      	cmp	r5, r3
 8021e98:	d25c      	bcs.n	8021f54 <__mdiff+0xe0>
 8021e9a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8021e9e:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 8021ea2:	42a2      	cmp	r2, r4
 8021ea4:	d0f7      	beq.n	8021e96 <__mdiff+0x22>
 8021ea6:	d25e      	bcs.n	8021f66 <__mdiff+0xf2>
 8021ea8:	4633      	mov	r3, r6
 8021eaa:	462c      	mov	r4, r5
 8021eac:	4646      	mov	r6, r8
 8021eae:	4675      	mov	r5, lr
 8021eb0:	4698      	mov	r8, r3
 8021eb2:	2701      	movs	r7, #1
 8021eb4:	e005      	b.n	8021ec2 <__mdiff+0x4e>
 8021eb6:	db58      	blt.n	8021f6a <__mdiff+0xf6>
 8021eb8:	f106 0514 	add.w	r5, r6, #20
 8021ebc:	f108 0414 	add.w	r4, r8, #20
 8021ec0:	2700      	movs	r7, #0
 8021ec2:	6871      	ldr	r1, [r6, #4]
 8021ec4:	f7ff fdbc 	bl	8021a40 <_Balloc>
 8021ec8:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8021ecc:	6936      	ldr	r6, [r6, #16]
 8021ece:	60c7      	str	r7, [r0, #12]
 8021ed0:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
 8021ed4:	46a6      	mov	lr, r4
 8021ed6:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 8021eda:	f100 0414 	add.w	r4, r0, #20
 8021ede:	2300      	movs	r3, #0
 8021ee0:	f85e 1b04 	ldr.w	r1, [lr], #4
 8021ee4:	f855 8b04 	ldr.w	r8, [r5], #4
 8021ee8:	b28a      	uxth	r2, r1
 8021eea:	fa13 f388 	uxtah	r3, r3, r8
 8021eee:	0c09      	lsrs	r1, r1, #16
 8021ef0:	1a9a      	subs	r2, r3, r2
 8021ef2:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
 8021ef6:	eb03 4322 	add.w	r3, r3, r2, asr #16
 8021efa:	b292      	uxth	r2, r2
 8021efc:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8021f00:	45f4      	cmp	ip, lr
 8021f02:	f844 2b04 	str.w	r2, [r4], #4
 8021f06:	ea4f 4323 	mov.w	r3, r3, asr #16
 8021f0a:	d8e9      	bhi.n	8021ee0 <__mdiff+0x6c>
 8021f0c:	42af      	cmp	r7, r5
 8021f0e:	d917      	bls.n	8021f40 <__mdiff+0xcc>
 8021f10:	46a4      	mov	ip, r4
 8021f12:	46ae      	mov	lr, r5
 8021f14:	f85e 2b04 	ldr.w	r2, [lr], #4
 8021f18:	fa13 f382 	uxtah	r3, r3, r2
 8021f1c:	1419      	asrs	r1, r3, #16
 8021f1e:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 8021f22:	b29b      	uxth	r3, r3
 8021f24:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
 8021f28:	4577      	cmp	r7, lr
 8021f2a:	f84c 2b04 	str.w	r2, [ip], #4
 8021f2e:	ea4f 4321 	mov.w	r3, r1, asr #16
 8021f32:	d8ef      	bhi.n	8021f14 <__mdiff+0xa0>
 8021f34:	43ed      	mvns	r5, r5
 8021f36:	442f      	add	r7, r5
 8021f38:	f027 0703 	bic.w	r7, r7, #3
 8021f3c:	3704      	adds	r7, #4
 8021f3e:	443c      	add	r4, r7
 8021f40:	3c04      	subs	r4, #4
 8021f42:	b922      	cbnz	r2, 8021f4e <__mdiff+0xda>
 8021f44:	f854 3d04 	ldr.w	r3, [r4, #-4]!
 8021f48:	3e01      	subs	r6, #1
 8021f4a:	2b00      	cmp	r3, #0
 8021f4c:	d0fa      	beq.n	8021f44 <__mdiff+0xd0>
 8021f4e:	6106      	str	r6, [r0, #16]
 8021f50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021f54:	2100      	movs	r1, #0
 8021f56:	f7ff fd73 	bl	8021a40 <_Balloc>
 8021f5a:	2201      	movs	r2, #1
 8021f5c:	2300      	movs	r3, #0
 8021f5e:	6102      	str	r2, [r0, #16]
 8021f60:	6143      	str	r3, [r0, #20]
 8021f62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021f66:	4674      	mov	r4, lr
 8021f68:	e7ab      	b.n	8021ec2 <__mdiff+0x4e>
 8021f6a:	4633      	mov	r3, r6
 8021f6c:	f106 0414 	add.w	r4, r6, #20
 8021f70:	f102 0514 	add.w	r5, r2, #20
 8021f74:	4616      	mov	r6, r2
 8021f76:	2701      	movs	r7, #1
 8021f78:	4698      	mov	r8, r3
 8021f7a:	e7a2      	b.n	8021ec2 <__mdiff+0x4e>

08021f7c <__d2b>:
 8021f7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021f80:	b083      	sub	sp, #12
 8021f82:	2101      	movs	r1, #1
 8021f84:	461c      	mov	r4, r3
 8021f86:	f3c3 550a 	ubfx	r5, r3, #20, #11
 8021f8a:	4617      	mov	r7, r2
 8021f8c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8021f8e:	f7ff fd57 	bl	8021a40 <_Balloc>
 8021f92:	f3c4 0413 	ubfx	r4, r4, #0, #20
 8021f96:	4681      	mov	r9, r0
 8021f98:	b10d      	cbz	r5, 8021f9e <__d2b+0x22>
 8021f9a:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 8021f9e:	9401      	str	r4, [sp, #4]
 8021fa0:	b31f      	cbz	r7, 8021fea <__d2b+0x6e>
 8021fa2:	a802      	add	r0, sp, #8
 8021fa4:	f840 7d08 	str.w	r7, [r0, #-8]!
 8021fa8:	f7ff fdda 	bl	8021b60 <__lo0bits>
 8021fac:	2800      	cmp	r0, #0
 8021fae:	d135      	bne.n	802201c <__d2b+0xa0>
 8021fb0:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8021fb4:	f8c9 2014 	str.w	r2, [r9, #20]
 8021fb8:	2b00      	cmp	r3, #0
 8021fba:	bf0c      	ite	eq
 8021fbc:	2101      	moveq	r1, #1
 8021fbe:	2102      	movne	r1, #2
 8021fc0:	f8c9 3018 	str.w	r3, [r9, #24]
 8021fc4:	f8c9 1010 	str.w	r1, [r9, #16]
 8021fc8:	b9dd      	cbnz	r5, 8022002 <__d2b+0x86>
 8021fca:	eb09 0381 	add.w	r3, r9, r1, lsl #2
 8021fce:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8021fd2:	6030      	str	r0, [r6, #0]
 8021fd4:	6918      	ldr	r0, [r3, #16]
 8021fd6:	f7ff fda3 	bl	8021b20 <__hi0bits>
 8021fda:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8021fdc:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 8021fe0:	6018      	str	r0, [r3, #0]
 8021fe2:	4648      	mov	r0, r9
 8021fe4:	b003      	add	sp, #12
 8021fe6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021fea:	a801      	add	r0, sp, #4
 8021fec:	f7ff fdb8 	bl	8021b60 <__lo0bits>
 8021ff0:	9b01      	ldr	r3, [sp, #4]
 8021ff2:	f8c9 3014 	str.w	r3, [r9, #20]
 8021ff6:	2101      	movs	r1, #1
 8021ff8:	3020      	adds	r0, #32
 8021ffa:	f8c9 1010 	str.w	r1, [r9, #16]
 8021ffe:	2d00      	cmp	r5, #0
 8022000:	d0e3      	beq.n	8021fca <__d2b+0x4e>
 8022002:	f2a5 4833 	subw	r8, r5, #1075	; 0x433
 8022006:	eb08 0300 	add.w	r3, r8, r0
 802200a:	6033      	str	r3, [r6, #0]
 802200c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802200e:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8022012:	6018      	str	r0, [r3, #0]
 8022014:	4648      	mov	r0, r9
 8022016:	b003      	add	sp, #12
 8022018:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802201c:	e89d 000a 	ldmia.w	sp, {r1, r3}
 8022020:	f1c0 0220 	rsb	r2, r0, #32
 8022024:	fa03 f202 	lsl.w	r2, r3, r2
 8022028:	430a      	orrs	r2, r1
 802202a:	40c3      	lsrs	r3, r0
 802202c:	9301      	str	r3, [sp, #4]
 802202e:	f8c9 2014 	str.w	r2, [r9, #20]
 8022032:	e7c1      	b.n	8021fb8 <__d2b+0x3c>

08022034 <sniprintf>:
 8022034:	b40c      	push	{r2, r3}
 8022036:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022038:	4b23      	ldr	r3, [pc, #140]	; (80220c8 <sniprintf+0x94>)
 802203a:	1e0c      	subs	r4, r1, #0
 802203c:	b09d      	sub	sp, #116	; 0x74
 802203e:	681d      	ldr	r5, [r3, #0]
 8022040:	db3d      	blt.n	80220be <sniprintf+0x8a>
 8022042:	f44f 7302 	mov.w	r3, #520	; 0x208
 8022046:	9002      	str	r0, [sp, #8]
 8022048:	9006      	str	r0, [sp, #24]
 802204a:	f8ad 3014 	strh.w	r3, [sp, #20]
 802204e:	ae23      	add	r6, sp, #140	; 0x8c
 8022050:	d017      	beq.n	8022082 <sniprintf+0x4e>
 8022052:	3c01      	subs	r4, #1
 8022054:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8022056:	9404      	str	r4, [sp, #16]
 8022058:	4633      	mov	r3, r6
 802205a:	f64f 77ff 	movw	r7, #65535	; 0xffff
 802205e:	a902      	add	r1, sp, #8
 8022060:	4628      	mov	r0, r5
 8022062:	9407      	str	r4, [sp, #28]
 8022064:	9601      	str	r6, [sp, #4]
 8022066:	f8ad 7016 	strh.w	r7, [sp, #22]
 802206a:	f000 f8ad 	bl	80221c8 <_svfiprintf_r>
 802206e:	1c42      	adds	r2, r0, #1
 8022070:	db1b      	blt.n	80220aa <sniprintf+0x76>
 8022072:	9b02      	ldr	r3, [sp, #8]
 8022074:	2200      	movs	r2, #0
 8022076:	701a      	strb	r2, [r3, #0]
 8022078:	b01d      	add	sp, #116	; 0x74
 802207a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 802207e:	b002      	add	sp, #8
 8022080:	4770      	bx	lr
 8022082:	4633      	mov	r3, r6
 8022084:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8022088:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802208a:	9404      	str	r4, [sp, #16]
 802208c:	a902      	add	r1, sp, #8
 802208e:	4628      	mov	r0, r5
 8022090:	9407      	str	r4, [sp, #28]
 8022092:	9601      	str	r6, [sp, #4]
 8022094:	f8ad 7016 	strh.w	r7, [sp, #22]
 8022098:	f000 f896 	bl	80221c8 <_svfiprintf_r>
 802209c:	1c43      	adds	r3, r0, #1
 802209e:	db07      	blt.n	80220b0 <sniprintf+0x7c>
 80220a0:	b01d      	add	sp, #116	; 0x74
 80220a2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80220a6:	b002      	add	sp, #8
 80220a8:	4770      	bx	lr
 80220aa:	238b      	movs	r3, #139	; 0x8b
 80220ac:	602b      	str	r3, [r5, #0]
 80220ae:	e7e0      	b.n	8022072 <sniprintf+0x3e>
 80220b0:	238b      	movs	r3, #139	; 0x8b
 80220b2:	602b      	str	r3, [r5, #0]
 80220b4:	b01d      	add	sp, #116	; 0x74
 80220b6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80220ba:	b002      	add	sp, #8
 80220bc:	4770      	bx	lr
 80220be:	238b      	movs	r3, #139	; 0x8b
 80220c0:	602b      	str	r3, [r5, #0]
 80220c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80220c6:	e7eb      	b.n	80220a0 <sniprintf+0x6c>
 80220c8:	20004474 	.word	0x20004474

080220cc <__ssprint_r>:
 80220cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80220d0:	6893      	ldr	r3, [r2, #8]
 80220d2:	b083      	sub	sp, #12
 80220d4:	4690      	mov	r8, r2
 80220d6:	2b00      	cmp	r3, #0
 80220d8:	d070      	beq.n	80221bc <__ssprint_r+0xf0>
 80220da:	4682      	mov	sl, r0
 80220dc:	460c      	mov	r4, r1
 80220de:	6817      	ldr	r7, [r2, #0]
 80220e0:	688d      	ldr	r5, [r1, #8]
 80220e2:	6808      	ldr	r0, [r1, #0]
 80220e4:	e042      	b.n	802216c <__ssprint_r+0xa0>
 80220e6:	89a3      	ldrh	r3, [r4, #12]
 80220e8:	f413 6f90 	tst.w	r3, #1152	; 0x480
 80220ec:	d02e      	beq.n	802214c <__ssprint_r+0x80>
 80220ee:	6965      	ldr	r5, [r4, #20]
 80220f0:	6921      	ldr	r1, [r4, #16]
 80220f2:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80220f6:	eba0 0b01 	sub.w	fp, r0, r1
 80220fa:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80220fe:	f10b 0001 	add.w	r0, fp, #1
 8022102:	106d      	asrs	r5, r5, #1
 8022104:	4430      	add	r0, r6
 8022106:	42a8      	cmp	r0, r5
 8022108:	462a      	mov	r2, r5
 802210a:	bf84      	itt	hi
 802210c:	4605      	movhi	r5, r0
 802210e:	462a      	movhi	r2, r5
 8022110:	055b      	lsls	r3, r3, #21
 8022112:	d538      	bpl.n	8022186 <__ssprint_r+0xba>
 8022114:	4611      	mov	r1, r2
 8022116:	4650      	mov	r0, sl
 8022118:	f7f9 fe02 	bl	801bd20 <_malloc_r>
 802211c:	2800      	cmp	r0, #0
 802211e:	d03c      	beq.n	802219a <__ssprint_r+0xce>
 8022120:	465a      	mov	r2, fp
 8022122:	6921      	ldr	r1, [r4, #16]
 8022124:	9001      	str	r0, [sp, #4]
 8022126:	f7e2 faf9 	bl	800471c <memcpy>
 802212a:	89a2      	ldrh	r2, [r4, #12]
 802212c:	9b01      	ldr	r3, [sp, #4]
 802212e:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8022132:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8022136:	81a2      	strh	r2, [r4, #12]
 8022138:	eba5 020b 	sub.w	r2, r5, fp
 802213c:	eb03 000b 	add.w	r0, r3, fp
 8022140:	6165      	str	r5, [r4, #20]
 8022142:	6123      	str	r3, [r4, #16]
 8022144:	6020      	str	r0, [r4, #0]
 8022146:	60a2      	str	r2, [r4, #8]
 8022148:	4635      	mov	r5, r6
 802214a:	46b3      	mov	fp, r6
 802214c:	465a      	mov	r2, fp
 802214e:	4649      	mov	r1, r9
 8022150:	f7fb ffa0 	bl	801e094 <memmove>
 8022154:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8022158:	68a2      	ldr	r2, [r4, #8]
 802215a:	6820      	ldr	r0, [r4, #0]
 802215c:	1b55      	subs	r5, r2, r5
 802215e:	4458      	add	r0, fp
 8022160:	1b9e      	subs	r6, r3, r6
 8022162:	60a5      	str	r5, [r4, #8]
 8022164:	6020      	str	r0, [r4, #0]
 8022166:	f8c8 6008 	str.w	r6, [r8, #8]
 802216a:	b33e      	cbz	r6, 80221bc <__ssprint_r+0xf0>
 802216c:	687e      	ldr	r6, [r7, #4]
 802216e:	463b      	mov	r3, r7
 8022170:	3708      	adds	r7, #8
 8022172:	2e00      	cmp	r6, #0
 8022174:	d0fa      	beq.n	802216c <__ssprint_r+0xa0>
 8022176:	42ae      	cmp	r6, r5
 8022178:	f8d3 9000 	ldr.w	r9, [r3]
 802217c:	46ab      	mov	fp, r5
 802217e:	d2b2      	bcs.n	80220e6 <__ssprint_r+0x1a>
 8022180:	4635      	mov	r5, r6
 8022182:	46b3      	mov	fp, r6
 8022184:	e7e2      	b.n	802214c <__ssprint_r+0x80>
 8022186:	4650      	mov	r0, sl
 8022188:	f7fb fb72 	bl	801d870 <_realloc_r>
 802218c:	4603      	mov	r3, r0
 802218e:	2800      	cmp	r0, #0
 8022190:	d1d2      	bne.n	8022138 <__ssprint_r+0x6c>
 8022192:	6921      	ldr	r1, [r4, #16]
 8022194:	4650      	mov	r0, sl
 8022196:	f7fb f9d1 	bl	801d53c <_free_r>
 802219a:	230c      	movs	r3, #12
 802219c:	f8ca 3000 	str.w	r3, [sl]
 80221a0:	89a3      	ldrh	r3, [r4, #12]
 80221a2:	2200      	movs	r2, #0
 80221a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80221a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80221ac:	81a3      	strh	r3, [r4, #12]
 80221ae:	f8c8 2008 	str.w	r2, [r8, #8]
 80221b2:	f8c8 2004 	str.w	r2, [r8, #4]
 80221b6:	b003      	add	sp, #12
 80221b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80221bc:	2000      	movs	r0, #0
 80221be:	f8c8 0004 	str.w	r0, [r8, #4]
 80221c2:	b003      	add	sp, #12
 80221c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080221c8 <_svfiprintf_r>:
 80221c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80221cc:	b0ad      	sub	sp, #180	; 0xb4
 80221ce:	460c      	mov	r4, r1
 80221d0:	9105      	str	r1, [sp, #20]
 80221d2:	8989      	ldrh	r1, [r1, #12]
 80221d4:	9307      	str	r3, [sp, #28]
 80221d6:	060d      	lsls	r5, r1, #24
 80221d8:	900a      	str	r0, [sp, #40]	; 0x28
 80221da:	d503      	bpl.n	80221e4 <_svfiprintf_r+0x1c>
 80221dc:	6923      	ldr	r3, [r4, #16]
 80221de:	2b00      	cmp	r3, #0
 80221e0:	f000 84d6 	beq.w	8022b90 <_svfiprintf_r+0x9c8>
 80221e4:	2300      	movs	r3, #0
 80221e6:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
 80221ea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80221ec:	930b      	str	r3, [sp, #44]	; 0x2c
 80221ee:	4693      	mov	fp, r2
 80221f0:	9311      	str	r3, [sp, #68]	; 0x44
 80221f2:	9310      	str	r3, [sp, #64]	; 0x40
 80221f4:	9302      	str	r3, [sp, #8]
 80221f6:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
 80221fa:	46d1      	mov	r9, sl
 80221fc:	f89b 3000 	ldrb.w	r3, [fp]
 8022200:	465c      	mov	r4, fp
 8022202:	b1eb      	cbz	r3, 8022240 <_svfiprintf_r+0x78>
 8022204:	2b25      	cmp	r3, #37	; 0x25
 8022206:	d102      	bne.n	802220e <_svfiprintf_r+0x46>
 8022208:	e01a      	b.n	8022240 <_svfiprintf_r+0x78>
 802220a:	2b25      	cmp	r3, #37	; 0x25
 802220c:	d003      	beq.n	8022216 <_svfiprintf_r+0x4e>
 802220e:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8022212:	2b00      	cmp	r3, #0
 8022214:	d1f9      	bne.n	802220a <_svfiprintf_r+0x42>
 8022216:	eba4 050b 	sub.w	r5, r4, fp
 802221a:	b18d      	cbz	r5, 8022240 <_svfiprintf_r+0x78>
 802221c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802221e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8022220:	f8c9 b000 	str.w	fp, [r9]
 8022224:	3301      	adds	r3, #1
 8022226:	442a      	add	r2, r5
 8022228:	2b07      	cmp	r3, #7
 802222a:	f8c9 5004 	str.w	r5, [r9, #4]
 802222e:	9211      	str	r2, [sp, #68]	; 0x44
 8022230:	9310      	str	r3, [sp, #64]	; 0x40
 8022232:	f300 83c3 	bgt.w	80229bc <_svfiprintf_r+0x7f4>
 8022236:	f109 0908 	add.w	r9, r9, #8
 802223a:	9b02      	ldr	r3, [sp, #8]
 802223c:	442b      	add	r3, r5
 802223e:	9302      	str	r3, [sp, #8]
 8022240:	7823      	ldrb	r3, [r4, #0]
 8022242:	2b00      	cmp	r3, #0
 8022244:	f000 834b 	beq.w	80228de <_svfiprintf_r+0x716>
 8022248:	2000      	movs	r0, #0
 802224a:	f04f 0300 	mov.w	r3, #0
 802224e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8022252:	f104 0b01 	add.w	fp, r4, #1
 8022256:	7862      	ldrb	r2, [r4, #1]
 8022258:	4605      	mov	r5, r0
 802225a:	4603      	mov	r3, r0
 802225c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 8022260:	4604      	mov	r4, r0
 8022262:	f10b 0b01 	add.w	fp, fp, #1
 8022266:	f1a2 0120 	sub.w	r1, r2, #32
 802226a:	2958      	cmp	r1, #88	; 0x58
 802226c:	f200 826b 	bhi.w	8022746 <_svfiprintf_r+0x57e>
 8022270:	e8df f011 	tbh	[pc, r1, lsl #1]
 8022274:	026900bd 	.word	0x026900bd
 8022278:	00b80269 	.word	0x00b80269
 802227c:	02690269 	.word	0x02690269
 8022280:	02690269 	.word	0x02690269
 8022284:	02690269 	.word	0x02690269
 8022288:	00b30059 	.word	0x00b30059
 802228c:	00630269 	.word	0x00630269
 8022290:	026901c0 	.word	0x026901c0
 8022294:	01ad01bb 	.word	0x01ad01bb
 8022298:	01ad01ad 	.word	0x01ad01ad
 802229c:	01ad01ad 	.word	0x01ad01ad
 80222a0:	01ad01ad 	.word	0x01ad01ad
 80222a4:	01ad01ad 	.word	0x01ad01ad
 80222a8:	02690269 	.word	0x02690269
 80222ac:	02690269 	.word	0x02690269
 80222b0:	02690269 	.word	0x02690269
 80222b4:	02690269 	.word	0x02690269
 80222b8:	02690269 	.word	0x02690269
 80222bc:	0269015f 	.word	0x0269015f
 80222c0:	02690269 	.word	0x02690269
 80222c4:	02690269 	.word	0x02690269
 80222c8:	02690269 	.word	0x02690269
 80222cc:	02690269 	.word	0x02690269
 80222d0:	014d0269 	.word	0x014d0269
 80222d4:	02690269 	.word	0x02690269
 80222d8:	02690269 	.word	0x02690269
 80222dc:	013c0269 	.word	0x013c0269
 80222e0:	02690269 	.word	0x02690269
 80222e4:	02690125 	.word	0x02690125
 80222e8:	02690269 	.word	0x02690269
 80222ec:	02690269 	.word	0x02690269
 80222f0:	02690269 	.word	0x02690269
 80222f4:	02690269 	.word	0x02690269
 80222f8:	00c50269 	.word	0x00c50269
 80222fc:	02690200 	.word	0x02690200
 8022300:	02690269 	.word	0x02690269
 8022304:	020001fb 	.word	0x020001fb
 8022308:	02690269 	.word	0x02690269
 802230c:	026901ee 	.word	0x026901ee
 8022310:	007a01da 	.word	0x007a01da
 8022314:	02310236 	.word	0x02310236
 8022318:	020e0269 	.word	0x020e0269
 802231c:	00680269 	.word	0x00680269
 8022320:	02690269 	.word	0x02690269
 8022324:	008f      	.short	0x008f
 8022326:	9907      	ldr	r1, [sp, #28]
 8022328:	680c      	ldr	r4, [r1, #0]
 802232a:	460a      	mov	r2, r1
 802232c:	2c00      	cmp	r4, #0
 802232e:	f102 0204 	add.w	r2, r2, #4
 8022332:	f280 83c9 	bge.w	8022ac8 <_svfiprintf_r+0x900>
 8022336:	4264      	negs	r4, r4
 8022338:	9207      	str	r2, [sp, #28]
 802233a:	f043 0304 	orr.w	r3, r3, #4
 802233e:	f89b 2000 	ldrb.w	r2, [fp]
 8022342:	e78e      	b.n	8022262 <_svfiprintf_r+0x9a>
 8022344:	9406      	str	r4, [sp, #24]
 8022346:	069c      	lsls	r4, r3, #26
 8022348:	f100 80d6 	bmi.w	80224f8 <_svfiprintf_r+0x330>
 802234c:	9907      	ldr	r1, [sp, #28]
 802234e:	06d8      	lsls	r0, r3, #27
 8022350:	460a      	mov	r2, r1
 8022352:	f100 820a 	bmi.w	802276a <_svfiprintf_r+0x5a2>
 8022356:	065e      	lsls	r6, r3, #25
 8022358:	f140 8207 	bpl.w	802276a <_svfiprintf_r+0x5a2>
 802235c:	880c      	ldrh	r4, [r1, #0]
 802235e:	3104      	adds	r1, #4
 8022360:	2500      	movs	r5, #0
 8022362:	2201      	movs	r2, #1
 8022364:	9107      	str	r1, [sp, #28]
 8022366:	e1cc      	b.n	8022702 <_svfiprintf_r+0x53a>
 8022368:	f013 0220 	ands.w	r2, r3, #32
 802236c:	9406      	str	r4, [sp, #24]
 802236e:	f040 80d5 	bne.w	802251c <_svfiprintf_r+0x354>
 8022372:	f013 0110 	ands.w	r1, r3, #16
 8022376:	f040 81fe 	bne.w	8022776 <_svfiprintf_r+0x5ae>
 802237a:	f013 0240 	ands.w	r2, r3, #64	; 0x40
 802237e:	f000 81fa 	beq.w	8022776 <_svfiprintf_r+0x5ae>
 8022382:	9807      	ldr	r0, [sp, #28]
 8022384:	460a      	mov	r2, r1
 8022386:	4601      	mov	r1, r0
 8022388:	3104      	adds	r1, #4
 802238a:	8804      	ldrh	r4, [r0, #0]
 802238c:	9107      	str	r1, [sp, #28]
 802238e:	2500      	movs	r5, #0
 8022390:	e1b7      	b.n	8022702 <_svfiprintf_r+0x53a>
 8022392:	9406      	str	r4, [sp, #24]
 8022394:	2800      	cmp	r0, #0
 8022396:	f040 8431 	bne.w	8022bfc <_svfiprintf_r+0xa34>
 802239a:	49ba      	ldr	r1, [pc, #744]	; (8022684 <_svfiprintf_r+0x4bc>)
 802239c:	910b      	str	r1, [sp, #44]	; 0x2c
 802239e:	069d      	lsls	r5, r3, #26
 80223a0:	f100 8096 	bmi.w	80224d0 <_svfiprintf_r+0x308>
 80223a4:	9807      	ldr	r0, [sp, #28]
 80223a6:	06dc      	lsls	r4, r3, #27
 80223a8:	4601      	mov	r1, r0
 80223aa:	d402      	bmi.n	80223b2 <_svfiprintf_r+0x1ea>
 80223ac:	0658      	lsls	r0, r3, #25
 80223ae:	f100 83a9 	bmi.w	8022b04 <_svfiprintf_r+0x93c>
 80223b2:	680c      	ldr	r4, [r1, #0]
 80223b4:	3104      	adds	r1, #4
 80223b6:	9107      	str	r1, [sp, #28]
 80223b8:	2500      	movs	r5, #0
 80223ba:	07d9      	lsls	r1, r3, #31
 80223bc:	f140 8094 	bpl.w	80224e8 <_svfiprintf_r+0x320>
 80223c0:	ea54 0105 	orrs.w	r1, r4, r5
 80223c4:	f000 8090 	beq.w	80224e8 <_svfiprintf_r+0x320>
 80223c8:	2130      	movs	r1, #48	; 0x30
 80223ca:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
 80223ce:	f043 0302 	orr.w	r3, r3, #2
 80223d2:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
 80223d6:	2202      	movs	r2, #2
 80223d8:	e193      	b.n	8022702 <_svfiprintf_r+0x53a>
 80223da:	f89b 2000 	ldrb.w	r2, [fp]
 80223de:	2001      	movs	r0, #1
 80223e0:	252b      	movs	r5, #43	; 0x2b
 80223e2:	e73e      	b.n	8022262 <_svfiprintf_r+0x9a>
 80223e4:	f043 0301 	orr.w	r3, r3, #1
 80223e8:	f89b 2000 	ldrb.w	r2, [fp]
 80223ec:	e739      	b.n	8022262 <_svfiprintf_r+0x9a>
 80223ee:	f89b 2000 	ldrb.w	r2, [fp]
 80223f2:	2d00      	cmp	r5, #0
 80223f4:	f47f af35 	bne.w	8022262 <_svfiprintf_r+0x9a>
 80223f8:	2001      	movs	r0, #1
 80223fa:	2520      	movs	r5, #32
 80223fc:	e731      	b.n	8022262 <_svfiprintf_r+0x9a>
 80223fe:	9907      	ldr	r1, [sp, #28]
 8022400:	9406      	str	r4, [sp, #24]
 8022402:	680a      	ldr	r2, [r1, #0]
 8022404:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
 8022408:	f04f 0000 	mov.w	r0, #0
 802240c:	460a      	mov	r2, r1
 802240e:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
 8022412:	3204      	adds	r2, #4
 8022414:	2001      	movs	r0, #1
 8022416:	9000      	str	r0, [sp, #0]
 8022418:	9207      	str	r2, [sp, #28]
 802241a:	9004      	str	r0, [sp, #16]
 802241c:	ae12      	add	r6, sp, #72	; 0x48
 802241e:	9301      	str	r3, [sp, #4]
 8022420:	f04f 0800 	mov.w	r8, #0
 8022424:	9b01      	ldr	r3, [sp, #4]
 8022426:	f013 0302 	ands.w	r3, r3, #2
 802242a:	9308      	str	r3, [sp, #32]
 802242c:	d002      	beq.n	8022434 <_svfiprintf_r+0x26c>
 802242e:	9b00      	ldr	r3, [sp, #0]
 8022430:	3302      	adds	r3, #2
 8022432:	9300      	str	r3, [sp, #0]
 8022434:	9b01      	ldr	r3, [sp, #4]
 8022436:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 802243a:	9309      	str	r3, [sp, #36]	; 0x24
 802243c:	f040 81a2 	bne.w	8022784 <_svfiprintf_r+0x5bc>
 8022440:	9b06      	ldr	r3, [sp, #24]
 8022442:	9a00      	ldr	r2, [sp, #0]
 8022444:	1a9c      	subs	r4, r3, r2
 8022446:	2c00      	cmp	r4, #0
 8022448:	f340 819c 	ble.w	8022784 <_svfiprintf_r+0x5bc>
 802244c:	2c10      	cmp	r4, #16
 802244e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022450:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022452:	4d8d      	ldr	r5, [pc, #564]	; (8022688 <_svfiprintf_r+0x4c0>)
 8022454:	dd25      	ble.n	80224a2 <_svfiprintf_r+0x2da>
 8022456:	4648      	mov	r0, r9
 8022458:	2310      	movs	r3, #16
 802245a:	46c1      	mov	r9, r8
 802245c:	46b0      	mov	r8, r6
 802245e:	9e05      	ldr	r6, [sp, #20]
 8022460:	e004      	b.n	802246c <_svfiprintf_r+0x2a4>
 8022462:	3c10      	subs	r4, #16
 8022464:	2c10      	cmp	r4, #16
 8022466:	f100 0008 	add.w	r0, r0, #8
 802246a:	dd17      	ble.n	802249c <_svfiprintf_r+0x2d4>
 802246c:	3201      	adds	r2, #1
 802246e:	3110      	adds	r1, #16
 8022470:	2a07      	cmp	r2, #7
 8022472:	9111      	str	r1, [sp, #68]	; 0x44
 8022474:	9210      	str	r2, [sp, #64]	; 0x40
 8022476:	6005      	str	r5, [r0, #0]
 8022478:	6043      	str	r3, [r0, #4]
 802247a:	ddf2      	ble.n	8022462 <_svfiprintf_r+0x29a>
 802247c:	aa0f      	add	r2, sp, #60	; 0x3c
 802247e:	4631      	mov	r1, r6
 8022480:	4638      	mov	r0, r7
 8022482:	9303      	str	r3, [sp, #12]
 8022484:	f7ff fe22 	bl	80220cc <__ssprint_r>
 8022488:	2800      	cmp	r0, #0
 802248a:	f040 822f 	bne.w	80228ec <_svfiprintf_r+0x724>
 802248e:	3c10      	subs	r4, #16
 8022490:	2c10      	cmp	r4, #16
 8022492:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022494:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022496:	9b03      	ldr	r3, [sp, #12]
 8022498:	4650      	mov	r0, sl
 802249a:	dce7      	bgt.n	802246c <_svfiprintf_r+0x2a4>
 802249c:	4646      	mov	r6, r8
 802249e:	46c8      	mov	r8, r9
 80224a0:	4681      	mov	r9, r0
 80224a2:	1c53      	adds	r3, r2, #1
 80224a4:	4421      	add	r1, r4
 80224a6:	2b07      	cmp	r3, #7
 80224a8:	9111      	str	r1, [sp, #68]	; 0x44
 80224aa:	9310      	str	r3, [sp, #64]	; 0x40
 80224ac:	f8c9 5000 	str.w	r5, [r9]
 80224b0:	f8c9 4004 	str.w	r4, [r9, #4]
 80224b4:	f300 82f2 	bgt.w	8022a9c <_svfiprintf_r+0x8d4>
 80224b8:	f109 0908 	add.w	r9, r9, #8
 80224bc:	e164      	b.n	8022788 <_svfiprintf_r+0x5c0>
 80224be:	9406      	str	r4, [sp, #24]
 80224c0:	2800      	cmp	r0, #0
 80224c2:	f040 83a5 	bne.w	8022c10 <_svfiprintf_r+0xa48>
 80224c6:	4971      	ldr	r1, [pc, #452]	; (802268c <_svfiprintf_r+0x4c4>)
 80224c8:	910b      	str	r1, [sp, #44]	; 0x2c
 80224ca:	069d      	lsls	r5, r3, #26
 80224cc:	f57f af6a 	bpl.w	80223a4 <_svfiprintf_r+0x1dc>
 80224d0:	9c07      	ldr	r4, [sp, #28]
 80224d2:	3407      	adds	r4, #7
 80224d4:	f024 0107 	bic.w	r1, r4, #7
 80224d8:	f101 0008 	add.w	r0, r1, #8
 80224dc:	e9d1 4500 	ldrd	r4, r5, [r1]
 80224e0:	07d9      	lsls	r1, r3, #31
 80224e2:	9007      	str	r0, [sp, #28]
 80224e4:	f53f af6c 	bmi.w	80223c0 <_svfiprintf_r+0x1f8>
 80224e8:	2202      	movs	r2, #2
 80224ea:	e10a      	b.n	8022702 <_svfiprintf_r+0x53a>
 80224ec:	f043 0310 	orr.w	r3, r3, #16
 80224f0:	9406      	str	r4, [sp, #24]
 80224f2:	069c      	lsls	r4, r3, #26
 80224f4:	f57f af2a 	bpl.w	802234c <_svfiprintf_r+0x184>
 80224f8:	9c07      	ldr	r4, [sp, #28]
 80224fa:	3407      	adds	r4, #7
 80224fc:	f024 0207 	bic.w	r2, r4, #7
 8022500:	f102 0108 	add.w	r1, r2, #8
 8022504:	e9d2 4500 	ldrd	r4, r5, [r2]
 8022508:	9107      	str	r1, [sp, #28]
 802250a:	2201      	movs	r2, #1
 802250c:	e0f9      	b.n	8022702 <_svfiprintf_r+0x53a>
 802250e:	f043 0310 	orr.w	r3, r3, #16
 8022512:	f013 0220 	ands.w	r2, r3, #32
 8022516:	9406      	str	r4, [sp, #24]
 8022518:	f43f af2b 	beq.w	8022372 <_svfiprintf_r+0x1aa>
 802251c:	9c07      	ldr	r4, [sp, #28]
 802251e:	3407      	adds	r4, #7
 8022520:	f024 0207 	bic.w	r2, r4, #7
 8022524:	f102 0108 	add.w	r1, r2, #8
 8022528:	e9d2 4500 	ldrd	r4, r5, [r2]
 802252c:	9107      	str	r1, [sp, #28]
 802252e:	2200      	movs	r2, #0
 8022530:	e0e7      	b.n	8022702 <_svfiprintf_r+0x53a>
 8022532:	9406      	str	r4, [sp, #24]
 8022534:	2800      	cmp	r0, #0
 8022536:	f040 8365 	bne.w	8022c04 <_svfiprintf_r+0xa3c>
 802253a:	f043 0310 	orr.w	r3, r3, #16
 802253e:	069c      	lsls	r4, r3, #26
 8022540:	f100 82fa 	bmi.w	8022b38 <_svfiprintf_r+0x970>
 8022544:	06d8      	lsls	r0, r3, #27
 8022546:	d402      	bmi.n	802254e <_svfiprintf_r+0x386>
 8022548:	0659      	lsls	r1, r3, #25
 802254a:	f100 82c4 	bmi.w	8022ad6 <_svfiprintf_r+0x90e>
 802254e:	9907      	ldr	r1, [sp, #28]
 8022550:	680c      	ldr	r4, [r1, #0]
 8022552:	460a      	mov	r2, r1
 8022554:	17e5      	asrs	r5, r4, #31
 8022556:	3204      	adds	r2, #4
 8022558:	9207      	str	r2, [sp, #28]
 802255a:	4620      	mov	r0, r4
 802255c:	4629      	mov	r1, r5
 802255e:	2800      	cmp	r0, #0
 8022560:	f171 0200 	sbcs.w	r2, r1, #0
 8022564:	f2c0 82c5 	blt.w	8022af2 <_svfiprintf_r+0x92a>
 8022568:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 802256c:	9203      	str	r2, [sp, #12]
 802256e:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8022572:	f04f 0201 	mov.w	r2, #1
 8022576:	f040 80ce 	bne.w	8022716 <_svfiprintf_r+0x54e>
 802257a:	ea54 0105 	orrs.w	r1, r4, r5
 802257e:	f000 820d 	beq.w	802299c <_svfiprintf_r+0x7d4>
 8022582:	9301      	str	r3, [sp, #4]
 8022584:	2a01      	cmp	r2, #1
 8022586:	f000 826b 	beq.w	8022a60 <_svfiprintf_r+0x898>
 802258a:	2a02      	cmp	r2, #2
 802258c:	f040 822d 	bne.w	80229ea <_svfiprintf_r+0x822>
 8022590:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8022592:	4656      	mov	r6, sl
 8022594:	0923      	lsrs	r3, r4, #4
 8022596:	f004 010f 	and.w	r1, r4, #15
 802259a:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 802259e:	092a      	lsrs	r2, r5, #4
 80225a0:	461c      	mov	r4, r3
 80225a2:	4615      	mov	r5, r2
 80225a4:	5c43      	ldrb	r3, [r0, r1]
 80225a6:	f806 3d01 	strb.w	r3, [r6, #-1]!
 80225aa:	ea54 0305 	orrs.w	r3, r4, r5
 80225ae:	d1f1      	bne.n	8022594 <_svfiprintf_r+0x3cc>
 80225b0:	ebaa 0306 	sub.w	r3, sl, r6
 80225b4:	9304      	str	r3, [sp, #16]
 80225b6:	9b04      	ldr	r3, [sp, #16]
 80225b8:	9a03      	ldr	r2, [sp, #12]
 80225ba:	4543      	cmp	r3, r8
 80225bc:	bfb8      	it	lt
 80225be:	4643      	movlt	r3, r8
 80225c0:	9300      	str	r3, [sp, #0]
 80225c2:	2a00      	cmp	r2, #0
 80225c4:	f43f af2e 	beq.w	8022424 <_svfiprintf_r+0x25c>
 80225c8:	3301      	adds	r3, #1
 80225ca:	9300      	str	r3, [sp, #0]
 80225cc:	e72a      	b.n	8022424 <_svfiprintf_r+0x25c>
 80225ce:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 80225d2:	2400      	movs	r4, #0
 80225d4:	f81b 2b01 	ldrb.w	r2, [fp], #1
 80225d8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 80225dc:	eb01 0444 	add.w	r4, r1, r4, lsl #1
 80225e0:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 80225e4:	2909      	cmp	r1, #9
 80225e6:	d9f5      	bls.n	80225d4 <_svfiprintf_r+0x40c>
 80225e8:	e63d      	b.n	8022266 <_svfiprintf_r+0x9e>
 80225ea:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80225ee:	f89b 2000 	ldrb.w	r2, [fp]
 80225f2:	e636      	b.n	8022262 <_svfiprintf_r+0x9a>
 80225f4:	f89b 2000 	ldrb.w	r2, [fp]
 80225f8:	2a2a      	cmp	r2, #42	; 0x2a
 80225fa:	f10b 0601 	add.w	r6, fp, #1
 80225fe:	f000 82e7 	beq.w	8022bd0 <_svfiprintf_r+0xa08>
 8022602:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8022606:	2909      	cmp	r1, #9
 8022608:	46b3      	mov	fp, r6
 802260a:	f04f 0800 	mov.w	r8, #0
 802260e:	f63f ae2a 	bhi.w	8022266 <_svfiprintf_r+0x9e>
 8022612:	f81b 2b01 	ldrb.w	r2, [fp], #1
 8022616:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 802261a:	eb01 0848 	add.w	r8, r1, r8, lsl #1
 802261e:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8022622:	2909      	cmp	r1, #9
 8022624:	d9f5      	bls.n	8022612 <_svfiprintf_r+0x44a>
 8022626:	e61e      	b.n	8022266 <_svfiprintf_r+0x9e>
 8022628:	2800      	cmp	r0, #0
 802262a:	f040 82dd 	bne.w	8022be8 <_svfiprintf_r+0xa20>
 802262e:	069a      	lsls	r2, r3, #26
 8022630:	f100 8276 	bmi.w	8022b20 <_svfiprintf_r+0x958>
 8022634:	06de      	lsls	r6, r3, #27
 8022636:	f100 8297 	bmi.w	8022b68 <_svfiprintf_r+0x9a0>
 802263a:	065d      	lsls	r5, r3, #25
 802263c:	f140 8294 	bpl.w	8022b68 <_svfiprintf_r+0x9a0>
 8022640:	9a07      	ldr	r2, [sp, #28]
 8022642:	6813      	ldr	r3, [r2, #0]
 8022644:	3204      	adds	r2, #4
 8022646:	9207      	str	r2, [sp, #28]
 8022648:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 802264c:	801a      	strh	r2, [r3, #0]
 802264e:	e5d5      	b.n	80221fc <_svfiprintf_r+0x34>
 8022650:	f89b 2000 	ldrb.w	r2, [fp]
 8022654:	2a6c      	cmp	r2, #108	; 0x6c
 8022656:	bf03      	ittte	eq
 8022658:	f89b 2001 	ldrbeq.w	r2, [fp, #1]
 802265c:	f043 0320 	orreq.w	r3, r3, #32
 8022660:	f10b 0b01 	addeq.w	fp, fp, #1
 8022664:	f043 0310 	orrne.w	r3, r3, #16
 8022668:	e5fb      	b.n	8022262 <_svfiprintf_r+0x9a>
 802266a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802266e:	f89b 2000 	ldrb.w	r2, [fp]
 8022672:	e5f6      	b.n	8022262 <_svfiprintf_r+0x9a>
 8022674:	9406      	str	r4, [sp, #24]
 8022676:	2800      	cmp	r0, #0
 8022678:	f43f af61 	beq.w	802253e <_svfiprintf_r+0x376>
 802267c:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022680:	e75d      	b.n	802253e <_svfiprintf_r+0x376>
 8022682:	bf00      	nop
 8022684:	080251ac 	.word	0x080251ac
 8022688:	080252f4 	.word	0x080252f4
 802268c:	08025198 	.word	0x08025198
 8022690:	9907      	ldr	r1, [sp, #28]
 8022692:	9406      	str	r4, [sp, #24]
 8022694:	680e      	ldr	r6, [r1, #0]
 8022696:	f04f 0200 	mov.w	r2, #0
 802269a:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 802269e:	1d0c      	adds	r4, r1, #4
 80226a0:	2e00      	cmp	r6, #0
 80226a2:	f000 8283 	beq.w	8022bac <_svfiprintf_r+0x9e4>
 80226a6:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 80226aa:	f000 8265 	beq.w	8022b78 <_svfiprintf_r+0x9b0>
 80226ae:	4642      	mov	r2, r8
 80226b0:	2100      	movs	r1, #0
 80226b2:	4630      	mov	r0, r6
 80226b4:	9300      	str	r3, [sp, #0]
 80226b6:	f7e2 fe9b 	bl	80053f0 <memchr>
 80226ba:	9b00      	ldr	r3, [sp, #0]
 80226bc:	2800      	cmp	r0, #0
 80226be:	f000 827e 	beq.w	8022bbe <_svfiprintf_r+0x9f6>
 80226c2:	1b82      	subs	r2, r0, r6
 80226c4:	9301      	str	r3, [sp, #4]
 80226c6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80226ca:	9204      	str	r2, [sp, #16]
 80226cc:	9407      	str	r4, [sp, #28]
 80226ce:	9303      	str	r3, [sp, #12]
 80226d0:	f04f 0800 	mov.w	r8, #0
 80226d4:	e76f      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 80226d6:	f043 0320 	orr.w	r3, r3, #32
 80226da:	f89b 2000 	ldrb.w	r2, [fp]
 80226de:	e5c0      	b.n	8022262 <_svfiprintf_r+0x9a>
 80226e0:	9807      	ldr	r0, [sp, #28]
 80226e2:	4ab3      	ldr	r2, [pc, #716]	; (80229b0 <_svfiprintf_r+0x7e8>)
 80226e4:	9406      	str	r4, [sp, #24]
 80226e6:	920b      	str	r2, [sp, #44]	; 0x2c
 80226e8:	6804      	ldr	r4, [r0, #0]
 80226ea:	2278      	movs	r2, #120	; 0x78
 80226ec:	2130      	movs	r1, #48	; 0x30
 80226ee:	3004      	adds	r0, #4
 80226f0:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
 80226f4:	f043 0302 	orr.w	r3, r3, #2
 80226f8:	9007      	str	r0, [sp, #28]
 80226fa:	2500      	movs	r5, #0
 80226fc:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
 8022700:	2202      	movs	r2, #2
 8022702:	f04f 0100 	mov.w	r1, #0
 8022706:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802270a:	2100      	movs	r1, #0
 802270c:	9103      	str	r1, [sp, #12]
 802270e:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8022712:	f43f af32 	beq.w	802257a <_svfiprintf_r+0x3b2>
 8022716:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 802271a:	9101      	str	r1, [sp, #4]
 802271c:	ea54 0105 	orrs.w	r1, r4, r5
 8022720:	f47f af30 	bne.w	8022584 <_svfiprintf_r+0x3bc>
 8022724:	f1b8 0f00 	cmp.w	r8, #0
 8022728:	f040 8137 	bne.w	802299a <_svfiprintf_r+0x7d2>
 802272c:	2a00      	cmp	r2, #0
 802272e:	f040 81b1 	bne.w	8022a94 <_svfiprintf_r+0x8cc>
 8022732:	f013 0301 	ands.w	r3, r3, #1
 8022736:	9304      	str	r3, [sp, #16]
 8022738:	f000 81cb 	beq.w	8022ad2 <_svfiprintf_r+0x90a>
 802273c:	ae2c      	add	r6, sp, #176	; 0xb0
 802273e:	2330      	movs	r3, #48	; 0x30
 8022740:	f806 3d41 	strb.w	r3, [r6, #-65]!
 8022744:	e737      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022746:	9406      	str	r4, [sp, #24]
 8022748:	2800      	cmp	r0, #0
 802274a:	f040 825e 	bne.w	8022c0a <_svfiprintf_r+0xa42>
 802274e:	2a00      	cmp	r2, #0
 8022750:	f000 80c5 	beq.w	80228de <_svfiprintf_r+0x716>
 8022754:	2101      	movs	r1, #1
 8022756:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
 802275a:	f04f 0200 	mov.w	r2, #0
 802275e:	9100      	str	r1, [sp, #0]
 8022760:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 8022764:	9104      	str	r1, [sp, #16]
 8022766:	ae12      	add	r6, sp, #72	; 0x48
 8022768:	e659      	b.n	802241e <_svfiprintf_r+0x256>
 802276a:	3104      	adds	r1, #4
 802276c:	6814      	ldr	r4, [r2, #0]
 802276e:	9107      	str	r1, [sp, #28]
 8022770:	2201      	movs	r2, #1
 8022772:	2500      	movs	r5, #0
 8022774:	e7c5      	b.n	8022702 <_svfiprintf_r+0x53a>
 8022776:	9807      	ldr	r0, [sp, #28]
 8022778:	4601      	mov	r1, r0
 802277a:	3104      	adds	r1, #4
 802277c:	6804      	ldr	r4, [r0, #0]
 802277e:	9107      	str	r1, [sp, #28]
 8022780:	2500      	movs	r5, #0
 8022782:	e7be      	b.n	8022702 <_svfiprintf_r+0x53a>
 8022784:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022786:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022788:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 802278c:	b16a      	cbz	r2, 80227aa <_svfiprintf_r+0x5e2>
 802278e:	3301      	adds	r3, #1
 8022790:	3101      	adds	r1, #1
 8022792:	f10d 0037 	add.w	r0, sp, #55	; 0x37
 8022796:	2201      	movs	r2, #1
 8022798:	2b07      	cmp	r3, #7
 802279a:	9111      	str	r1, [sp, #68]	; 0x44
 802279c:	9310      	str	r3, [sp, #64]	; 0x40
 802279e:	e889 0005 	stmia.w	r9, {r0, r2}
 80227a2:	f300 8145 	bgt.w	8022a30 <_svfiprintf_r+0x868>
 80227a6:	f109 0908 	add.w	r9, r9, #8
 80227aa:	9a08      	ldr	r2, [sp, #32]
 80227ac:	b162      	cbz	r2, 80227c8 <_svfiprintf_r+0x600>
 80227ae:	3301      	adds	r3, #1
 80227b0:	3102      	adds	r1, #2
 80227b2:	a80e      	add	r0, sp, #56	; 0x38
 80227b4:	2202      	movs	r2, #2
 80227b6:	2b07      	cmp	r3, #7
 80227b8:	9111      	str	r1, [sp, #68]	; 0x44
 80227ba:	9310      	str	r3, [sp, #64]	; 0x40
 80227bc:	e889 0005 	stmia.w	r9, {r0, r2}
 80227c0:	f300 8142 	bgt.w	8022a48 <_svfiprintf_r+0x880>
 80227c4:	f109 0908 	add.w	r9, r9, #8
 80227c8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80227ca:	2a80      	cmp	r2, #128	; 0x80
 80227cc:	f000 809b 	beq.w	8022906 <_svfiprintf_r+0x73e>
 80227d0:	9a04      	ldr	r2, [sp, #16]
 80227d2:	eba8 0502 	sub.w	r5, r8, r2
 80227d6:	2d00      	cmp	r5, #0
 80227d8:	dd31      	ble.n	802283e <_svfiprintf_r+0x676>
 80227da:	2d10      	cmp	r5, #16
 80227dc:	4c75      	ldr	r4, [pc, #468]	; (80229b4 <_svfiprintf_r+0x7ec>)
 80227de:	dd23      	ble.n	8022828 <_svfiprintf_r+0x660>
 80227e0:	464a      	mov	r2, r9
 80227e2:	f04f 0810 	mov.w	r8, #16
 80227e6:	46b1      	mov	r9, r6
 80227e8:	4626      	mov	r6, r4
 80227ea:	9c05      	ldr	r4, [sp, #20]
 80227ec:	e004      	b.n	80227f8 <_svfiprintf_r+0x630>
 80227ee:	3d10      	subs	r5, #16
 80227f0:	2d10      	cmp	r5, #16
 80227f2:	f102 0208 	add.w	r2, r2, #8
 80227f6:	dd14      	ble.n	8022822 <_svfiprintf_r+0x65a>
 80227f8:	3301      	adds	r3, #1
 80227fa:	3110      	adds	r1, #16
 80227fc:	2b07      	cmp	r3, #7
 80227fe:	9111      	str	r1, [sp, #68]	; 0x44
 8022800:	9310      	str	r3, [sp, #64]	; 0x40
 8022802:	e882 0140 	stmia.w	r2, {r6, r8}
 8022806:	ddf2      	ble.n	80227ee <_svfiprintf_r+0x626>
 8022808:	aa0f      	add	r2, sp, #60	; 0x3c
 802280a:	4621      	mov	r1, r4
 802280c:	4638      	mov	r0, r7
 802280e:	f7ff fc5d 	bl	80220cc <__ssprint_r>
 8022812:	2800      	cmp	r0, #0
 8022814:	d16a      	bne.n	80228ec <_svfiprintf_r+0x724>
 8022816:	3d10      	subs	r5, #16
 8022818:	2d10      	cmp	r5, #16
 802281a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802281c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802281e:	4652      	mov	r2, sl
 8022820:	dcea      	bgt.n	80227f8 <_svfiprintf_r+0x630>
 8022822:	4634      	mov	r4, r6
 8022824:	464e      	mov	r6, r9
 8022826:	4691      	mov	r9, r2
 8022828:	3301      	adds	r3, #1
 802282a:	4429      	add	r1, r5
 802282c:	2b07      	cmp	r3, #7
 802282e:	9111      	str	r1, [sp, #68]	; 0x44
 8022830:	9310      	str	r3, [sp, #64]	; 0x40
 8022832:	e889 0030 	stmia.w	r9, {r4, r5}
 8022836:	f300 80ca 	bgt.w	80229ce <_svfiprintf_r+0x806>
 802283a:	f109 0908 	add.w	r9, r9, #8
 802283e:	9804      	ldr	r0, [sp, #16]
 8022840:	f8c9 6000 	str.w	r6, [r9]
 8022844:	3301      	adds	r3, #1
 8022846:	4401      	add	r1, r0
 8022848:	2b07      	cmp	r3, #7
 802284a:	9111      	str	r1, [sp, #68]	; 0x44
 802284c:	9310      	str	r3, [sp, #64]	; 0x40
 802284e:	f8c9 0004 	str.w	r0, [r9, #4]
 8022852:	f300 8090 	bgt.w	8022976 <_svfiprintf_r+0x7ae>
 8022856:	f109 0908 	add.w	r9, r9, #8
 802285a:	9b01      	ldr	r3, [sp, #4]
 802285c:	075b      	lsls	r3, r3, #29
 802285e:	d530      	bpl.n	80228c2 <_svfiprintf_r+0x6fa>
 8022860:	9b06      	ldr	r3, [sp, #24]
 8022862:	9a00      	ldr	r2, [sp, #0]
 8022864:	1a9c      	subs	r4, r3, r2
 8022866:	2c00      	cmp	r4, #0
 8022868:	dd2b      	ble.n	80228c2 <_svfiprintf_r+0x6fa>
 802286a:	2c10      	cmp	r4, #16
 802286c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802286e:	4d52      	ldr	r5, [pc, #328]	; (80229b8 <_svfiprintf_r+0x7f0>)
 8022870:	dd1c      	ble.n	80228ac <_svfiprintf_r+0x6e4>
 8022872:	2610      	movs	r6, #16
 8022874:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8022878:	e004      	b.n	8022884 <_svfiprintf_r+0x6bc>
 802287a:	3c10      	subs	r4, #16
 802287c:	2c10      	cmp	r4, #16
 802287e:	f109 0908 	add.w	r9, r9, #8
 8022882:	dd13      	ble.n	80228ac <_svfiprintf_r+0x6e4>
 8022884:	3301      	adds	r3, #1
 8022886:	3110      	adds	r1, #16
 8022888:	2b07      	cmp	r3, #7
 802288a:	9111      	str	r1, [sp, #68]	; 0x44
 802288c:	9310      	str	r3, [sp, #64]	; 0x40
 802288e:	e889 0060 	stmia.w	r9, {r5, r6}
 8022892:	ddf2      	ble.n	802287a <_svfiprintf_r+0x6b2>
 8022894:	aa0f      	add	r2, sp, #60	; 0x3c
 8022896:	4641      	mov	r1, r8
 8022898:	4638      	mov	r0, r7
 802289a:	f7ff fc17 	bl	80220cc <__ssprint_r>
 802289e:	bb28      	cbnz	r0, 80228ec <_svfiprintf_r+0x724>
 80228a0:	3c10      	subs	r4, #16
 80228a2:	2c10      	cmp	r4, #16
 80228a4:	9911      	ldr	r1, [sp, #68]	; 0x44
 80228a6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80228a8:	46d1      	mov	r9, sl
 80228aa:	dceb      	bgt.n	8022884 <_svfiprintf_r+0x6bc>
 80228ac:	3301      	adds	r3, #1
 80228ae:	4421      	add	r1, r4
 80228b0:	2b07      	cmp	r3, #7
 80228b2:	9111      	str	r1, [sp, #68]	; 0x44
 80228b4:	9310      	str	r3, [sp, #64]	; 0x40
 80228b6:	f8c9 5000 	str.w	r5, [r9]
 80228ba:	f8c9 4004 	str.w	r4, [r9, #4]
 80228be:	f300 80f9 	bgt.w	8022ab4 <_svfiprintf_r+0x8ec>
 80228c2:	9b02      	ldr	r3, [sp, #8]
 80228c4:	9a06      	ldr	r2, [sp, #24]
 80228c6:	9800      	ldr	r0, [sp, #0]
 80228c8:	4282      	cmp	r2, r0
 80228ca:	bfac      	ite	ge
 80228cc:	189b      	addge	r3, r3, r2
 80228ce:	181b      	addlt	r3, r3, r0
 80228d0:	9302      	str	r3, [sp, #8]
 80228d2:	2900      	cmp	r1, #0
 80228d4:	d159      	bne.n	802298a <_svfiprintf_r+0x7c2>
 80228d6:	2300      	movs	r3, #0
 80228d8:	9310      	str	r3, [sp, #64]	; 0x40
 80228da:	46d1      	mov	r9, sl
 80228dc:	e48e      	b.n	80221fc <_svfiprintf_r+0x34>
 80228de:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80228e0:	b123      	cbz	r3, 80228ec <_svfiprintf_r+0x724>
 80228e2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80228e4:	9905      	ldr	r1, [sp, #20]
 80228e6:	aa0f      	add	r2, sp, #60	; 0x3c
 80228e8:	f7ff fbf0 	bl	80220cc <__ssprint_r>
 80228ec:	9b05      	ldr	r3, [sp, #20]
 80228ee:	899b      	ldrh	r3, [r3, #12]
 80228f0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80228f4:	9b02      	ldr	r3, [sp, #8]
 80228f6:	bf18      	it	ne
 80228f8:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 80228fc:	9302      	str	r3, [sp, #8]
 80228fe:	9802      	ldr	r0, [sp, #8]
 8022900:	b02d      	add	sp, #180	; 0xb4
 8022902:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022906:	9a06      	ldr	r2, [sp, #24]
 8022908:	9800      	ldr	r0, [sp, #0]
 802290a:	1a15      	subs	r5, r2, r0
 802290c:	2d00      	cmp	r5, #0
 802290e:	f77f af5f 	ble.w	80227d0 <_svfiprintf_r+0x608>
 8022912:	2d10      	cmp	r5, #16
 8022914:	4c27      	ldr	r4, [pc, #156]	; (80229b4 <_svfiprintf_r+0x7ec>)
 8022916:	dd22      	ble.n	802295e <_svfiprintf_r+0x796>
 8022918:	464a      	mov	r2, r9
 802291a:	46b1      	mov	r9, r6
 802291c:	4626      	mov	r6, r4
 802291e:	9c05      	ldr	r4, [sp, #20]
 8022920:	e004      	b.n	802292c <_svfiprintf_r+0x764>
 8022922:	3d10      	subs	r5, #16
 8022924:	2d10      	cmp	r5, #16
 8022926:	f102 0208 	add.w	r2, r2, #8
 802292a:	dd15      	ble.n	8022958 <_svfiprintf_r+0x790>
 802292c:	3301      	adds	r3, #1
 802292e:	3110      	adds	r1, #16
 8022930:	2010      	movs	r0, #16
 8022932:	2b07      	cmp	r3, #7
 8022934:	9111      	str	r1, [sp, #68]	; 0x44
 8022936:	9310      	str	r3, [sp, #64]	; 0x40
 8022938:	6016      	str	r6, [r2, #0]
 802293a:	6050      	str	r0, [r2, #4]
 802293c:	ddf1      	ble.n	8022922 <_svfiprintf_r+0x75a>
 802293e:	aa0f      	add	r2, sp, #60	; 0x3c
 8022940:	4621      	mov	r1, r4
 8022942:	4638      	mov	r0, r7
 8022944:	f7ff fbc2 	bl	80220cc <__ssprint_r>
 8022948:	2800      	cmp	r0, #0
 802294a:	d1cf      	bne.n	80228ec <_svfiprintf_r+0x724>
 802294c:	3d10      	subs	r5, #16
 802294e:	2d10      	cmp	r5, #16
 8022950:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022952:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022954:	4652      	mov	r2, sl
 8022956:	dce9      	bgt.n	802292c <_svfiprintf_r+0x764>
 8022958:	4634      	mov	r4, r6
 802295a:	464e      	mov	r6, r9
 802295c:	4691      	mov	r9, r2
 802295e:	3301      	adds	r3, #1
 8022960:	4429      	add	r1, r5
 8022962:	2b07      	cmp	r3, #7
 8022964:	9111      	str	r1, [sp, #68]	; 0x44
 8022966:	9310      	str	r3, [sp, #64]	; 0x40
 8022968:	e889 0030 	stmia.w	r9, {r4, r5}
 802296c:	f300 80f0 	bgt.w	8022b50 <_svfiprintf_r+0x988>
 8022970:	f109 0908 	add.w	r9, r9, #8
 8022974:	e72c      	b.n	80227d0 <_svfiprintf_r+0x608>
 8022976:	aa0f      	add	r2, sp, #60	; 0x3c
 8022978:	9905      	ldr	r1, [sp, #20]
 802297a:	4638      	mov	r0, r7
 802297c:	f7ff fba6 	bl	80220cc <__ssprint_r>
 8022980:	2800      	cmp	r0, #0
 8022982:	d1b3      	bne.n	80228ec <_svfiprintf_r+0x724>
 8022984:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022986:	46d1      	mov	r9, sl
 8022988:	e767      	b.n	802285a <_svfiprintf_r+0x692>
 802298a:	aa0f      	add	r2, sp, #60	; 0x3c
 802298c:	9905      	ldr	r1, [sp, #20]
 802298e:	4638      	mov	r0, r7
 8022990:	f7ff fb9c 	bl	80220cc <__ssprint_r>
 8022994:	2800      	cmp	r0, #0
 8022996:	d09e      	beq.n	80228d6 <_svfiprintf_r+0x70e>
 8022998:	e7a8      	b.n	80228ec <_svfiprintf_r+0x724>
 802299a:	9b01      	ldr	r3, [sp, #4]
 802299c:	2a01      	cmp	r2, #1
 802299e:	f000 80b7 	beq.w	8022b10 <_svfiprintf_r+0x948>
 80229a2:	2a02      	cmp	r2, #2
 80229a4:	d11e      	bne.n	80229e4 <_svfiprintf_r+0x81c>
 80229a6:	9301      	str	r3, [sp, #4]
 80229a8:	2400      	movs	r4, #0
 80229aa:	2500      	movs	r5, #0
 80229ac:	e5f0      	b.n	8022590 <_svfiprintf_r+0x3c8>
 80229ae:	bf00      	nop
 80229b0:	080251ac 	.word	0x080251ac
 80229b4:	08025304 	.word	0x08025304
 80229b8:	080252f4 	.word	0x080252f4
 80229bc:	aa0f      	add	r2, sp, #60	; 0x3c
 80229be:	9905      	ldr	r1, [sp, #20]
 80229c0:	4638      	mov	r0, r7
 80229c2:	f7ff fb83 	bl	80220cc <__ssprint_r>
 80229c6:	2800      	cmp	r0, #0
 80229c8:	d190      	bne.n	80228ec <_svfiprintf_r+0x724>
 80229ca:	46d1      	mov	r9, sl
 80229cc:	e435      	b.n	802223a <_svfiprintf_r+0x72>
 80229ce:	aa0f      	add	r2, sp, #60	; 0x3c
 80229d0:	9905      	ldr	r1, [sp, #20]
 80229d2:	4638      	mov	r0, r7
 80229d4:	f7ff fb7a 	bl	80220cc <__ssprint_r>
 80229d8:	2800      	cmp	r0, #0
 80229da:	d187      	bne.n	80228ec <_svfiprintf_r+0x724>
 80229dc:	9911      	ldr	r1, [sp, #68]	; 0x44
 80229de:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80229e0:	46d1      	mov	r9, sl
 80229e2:	e72c      	b.n	802283e <_svfiprintf_r+0x676>
 80229e4:	9301      	str	r3, [sp, #4]
 80229e6:	2400      	movs	r4, #0
 80229e8:	2500      	movs	r5, #0
 80229ea:	4651      	mov	r1, sl
 80229ec:	e000      	b.n	80229f0 <_svfiprintf_r+0x828>
 80229ee:	4631      	mov	r1, r6
 80229f0:	08e2      	lsrs	r2, r4, #3
 80229f2:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 80229f6:	08e8      	lsrs	r0, r5, #3
 80229f8:	f004 0307 	and.w	r3, r4, #7
 80229fc:	4605      	mov	r5, r0
 80229fe:	4614      	mov	r4, r2
 8022a00:	3330      	adds	r3, #48	; 0x30
 8022a02:	ea54 0205 	orrs.w	r2, r4, r5
 8022a06:	f801 3c01 	strb.w	r3, [r1, #-1]
 8022a0a:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
 8022a0e:	d1ee      	bne.n	80229ee <_svfiprintf_r+0x826>
 8022a10:	9a01      	ldr	r2, [sp, #4]
 8022a12:	07d2      	lsls	r2, r2, #31
 8022a14:	f57f adcc 	bpl.w	80225b0 <_svfiprintf_r+0x3e8>
 8022a18:	2b30      	cmp	r3, #48	; 0x30
 8022a1a:	f43f adc9 	beq.w	80225b0 <_svfiprintf_r+0x3e8>
 8022a1e:	3902      	subs	r1, #2
 8022a20:	2330      	movs	r3, #48	; 0x30
 8022a22:	f806 3c01 	strb.w	r3, [r6, #-1]
 8022a26:	ebaa 0301 	sub.w	r3, sl, r1
 8022a2a:	9304      	str	r3, [sp, #16]
 8022a2c:	460e      	mov	r6, r1
 8022a2e:	e5c2      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022a30:	aa0f      	add	r2, sp, #60	; 0x3c
 8022a32:	9905      	ldr	r1, [sp, #20]
 8022a34:	4638      	mov	r0, r7
 8022a36:	f7ff fb49 	bl	80220cc <__ssprint_r>
 8022a3a:	2800      	cmp	r0, #0
 8022a3c:	f47f af56 	bne.w	80228ec <_svfiprintf_r+0x724>
 8022a40:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022a42:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022a44:	46d1      	mov	r9, sl
 8022a46:	e6b0      	b.n	80227aa <_svfiprintf_r+0x5e2>
 8022a48:	aa0f      	add	r2, sp, #60	; 0x3c
 8022a4a:	9905      	ldr	r1, [sp, #20]
 8022a4c:	4638      	mov	r0, r7
 8022a4e:	f7ff fb3d 	bl	80220cc <__ssprint_r>
 8022a52:	2800      	cmp	r0, #0
 8022a54:	f47f af4a 	bne.w	80228ec <_svfiprintf_r+0x724>
 8022a58:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022a5a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022a5c:	46d1      	mov	r9, sl
 8022a5e:	e6b3      	b.n	80227c8 <_svfiprintf_r+0x600>
 8022a60:	2d00      	cmp	r5, #0
 8022a62:	bf08      	it	eq
 8022a64:	2c0a      	cmpeq	r4, #10
 8022a66:	d352      	bcc.n	8022b0e <_svfiprintf_r+0x946>
 8022a68:	4656      	mov	r6, sl
 8022a6a:	4620      	mov	r0, r4
 8022a6c:	4629      	mov	r1, r5
 8022a6e:	220a      	movs	r2, #10
 8022a70:	2300      	movs	r3, #0
 8022a72:	f7e1 feed 	bl	8004850 <__aeabi_uldivmod>
 8022a76:	3230      	adds	r2, #48	; 0x30
 8022a78:	f806 2d01 	strb.w	r2, [r6, #-1]!
 8022a7c:	4620      	mov	r0, r4
 8022a7e:	4629      	mov	r1, r5
 8022a80:	2300      	movs	r3, #0
 8022a82:	220a      	movs	r2, #10
 8022a84:	f7e1 fee4 	bl	8004850 <__aeabi_uldivmod>
 8022a88:	4604      	mov	r4, r0
 8022a8a:	460d      	mov	r5, r1
 8022a8c:	ea54 0305 	orrs.w	r3, r4, r5
 8022a90:	d1eb      	bne.n	8022a6a <_svfiprintf_r+0x8a2>
 8022a92:	e58d      	b.n	80225b0 <_svfiprintf_r+0x3e8>
 8022a94:	f8cd 8010 	str.w	r8, [sp, #16]
 8022a98:	4656      	mov	r6, sl
 8022a9a:	e58c      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022a9c:	aa0f      	add	r2, sp, #60	; 0x3c
 8022a9e:	9905      	ldr	r1, [sp, #20]
 8022aa0:	4638      	mov	r0, r7
 8022aa2:	f7ff fb13 	bl	80220cc <__ssprint_r>
 8022aa6:	2800      	cmp	r0, #0
 8022aa8:	f47f af20 	bne.w	80228ec <_svfiprintf_r+0x724>
 8022aac:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022aae:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022ab0:	46d1      	mov	r9, sl
 8022ab2:	e669      	b.n	8022788 <_svfiprintf_r+0x5c0>
 8022ab4:	aa0f      	add	r2, sp, #60	; 0x3c
 8022ab6:	9905      	ldr	r1, [sp, #20]
 8022ab8:	4638      	mov	r0, r7
 8022aba:	f7ff fb07 	bl	80220cc <__ssprint_r>
 8022abe:	2800      	cmp	r0, #0
 8022ac0:	f47f af14 	bne.w	80228ec <_svfiprintf_r+0x724>
 8022ac4:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022ac6:	e6fc      	b.n	80228c2 <_svfiprintf_r+0x6fa>
 8022ac8:	9207      	str	r2, [sp, #28]
 8022aca:	f89b 2000 	ldrb.w	r2, [fp]
 8022ace:	f7ff bbc8 	b.w	8022262 <_svfiprintf_r+0x9a>
 8022ad2:	4656      	mov	r6, sl
 8022ad4:	e56f      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022ad6:	9e07      	ldr	r6, [sp, #28]
 8022ad8:	f9b6 4000 	ldrsh.w	r4, [r6]
 8022adc:	4632      	mov	r2, r6
 8022ade:	17e5      	asrs	r5, r4, #31
 8022ae0:	4620      	mov	r0, r4
 8022ae2:	3204      	adds	r2, #4
 8022ae4:	4629      	mov	r1, r5
 8022ae6:	2800      	cmp	r0, #0
 8022ae8:	9207      	str	r2, [sp, #28]
 8022aea:	f171 0200 	sbcs.w	r2, r1, #0
 8022aee:	f6bf ad3b 	bge.w	8022568 <_svfiprintf_r+0x3a0>
 8022af2:	222d      	movs	r2, #45	; 0x2d
 8022af4:	4264      	negs	r4, r4
 8022af6:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 8022afa:	9203      	str	r2, [sp, #12]
 8022afc:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8022b00:	2201      	movs	r2, #1
 8022b02:	e604      	b.n	802270e <_svfiprintf_r+0x546>
 8022b04:	880c      	ldrh	r4, [r1, #0]
 8022b06:	3104      	adds	r1, #4
 8022b08:	2500      	movs	r5, #0
 8022b0a:	9107      	str	r1, [sp, #28]
 8022b0c:	e455      	b.n	80223ba <_svfiprintf_r+0x1f2>
 8022b0e:	9b01      	ldr	r3, [sp, #4]
 8022b10:	9301      	str	r3, [sp, #4]
 8022b12:	ae2c      	add	r6, sp, #176	; 0xb0
 8022b14:	3430      	adds	r4, #48	; 0x30
 8022b16:	2301      	movs	r3, #1
 8022b18:	f806 4d41 	strb.w	r4, [r6, #-65]!
 8022b1c:	9304      	str	r3, [sp, #16]
 8022b1e:	e54a      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022b20:	9a07      	ldr	r2, [sp, #28]
 8022b22:	9902      	ldr	r1, [sp, #8]
 8022b24:	6813      	ldr	r3, [r2, #0]
 8022b26:	17cd      	asrs	r5, r1, #31
 8022b28:	4608      	mov	r0, r1
 8022b2a:	3204      	adds	r2, #4
 8022b2c:	4629      	mov	r1, r5
 8022b2e:	9207      	str	r2, [sp, #28]
 8022b30:	e9c3 0100 	strd	r0, r1, [r3]
 8022b34:	f7ff bb62 	b.w	80221fc <_svfiprintf_r+0x34>
 8022b38:	9c07      	ldr	r4, [sp, #28]
 8022b3a:	3407      	adds	r4, #7
 8022b3c:	f024 0407 	bic.w	r4, r4, #7
 8022b40:	e9d4 0100 	ldrd	r0, r1, [r4]
 8022b44:	f104 0208 	add.w	r2, r4, #8
 8022b48:	9207      	str	r2, [sp, #28]
 8022b4a:	4604      	mov	r4, r0
 8022b4c:	460d      	mov	r5, r1
 8022b4e:	e506      	b.n	802255e <_svfiprintf_r+0x396>
 8022b50:	aa0f      	add	r2, sp, #60	; 0x3c
 8022b52:	9905      	ldr	r1, [sp, #20]
 8022b54:	4638      	mov	r0, r7
 8022b56:	f7ff fab9 	bl	80220cc <__ssprint_r>
 8022b5a:	2800      	cmp	r0, #0
 8022b5c:	f47f aec6 	bne.w	80228ec <_svfiprintf_r+0x724>
 8022b60:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022b62:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022b64:	46d1      	mov	r9, sl
 8022b66:	e633      	b.n	80227d0 <_svfiprintf_r+0x608>
 8022b68:	9a07      	ldr	r2, [sp, #28]
 8022b6a:	6813      	ldr	r3, [r2, #0]
 8022b6c:	3204      	adds	r2, #4
 8022b6e:	9207      	str	r2, [sp, #28]
 8022b70:	9a02      	ldr	r2, [sp, #8]
 8022b72:	601a      	str	r2, [r3, #0]
 8022b74:	f7ff bb42 	b.w	80221fc <_svfiprintf_r+0x34>
 8022b78:	4630      	mov	r0, r6
 8022b7a:	9301      	str	r3, [sp, #4]
 8022b7c:	9407      	str	r4, [sp, #28]
 8022b7e:	f7e1 fd5f 	bl	8004640 <strlen>
 8022b82:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8022b86:	9004      	str	r0, [sp, #16]
 8022b88:	9303      	str	r3, [sp, #12]
 8022b8a:	f04f 0800 	mov.w	r8, #0
 8022b8e:	e512      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022b90:	2140      	movs	r1, #64	; 0x40
 8022b92:	9200      	str	r2, [sp, #0]
 8022b94:	f7f9 f8c4 	bl	801bd20 <_malloc_r>
 8022b98:	9a05      	ldr	r2, [sp, #20]
 8022b9a:	6010      	str	r0, [r2, #0]
 8022b9c:	6110      	str	r0, [r2, #16]
 8022b9e:	9a00      	ldr	r2, [sp, #0]
 8022ba0:	b328      	cbz	r0, 8022bee <_svfiprintf_r+0xa26>
 8022ba2:	9905      	ldr	r1, [sp, #20]
 8022ba4:	2340      	movs	r3, #64	; 0x40
 8022ba6:	614b      	str	r3, [r1, #20]
 8022ba8:	f7ff bb1c 	b.w	80221e4 <_svfiprintf_r+0x1c>
 8022bac:	4642      	mov	r2, r8
 8022bae:	2a06      	cmp	r2, #6
 8022bb0:	bf28      	it	cs
 8022bb2:	2206      	movcs	r2, #6
 8022bb4:	9204      	str	r2, [sp, #16]
 8022bb6:	9407      	str	r4, [sp, #28]
 8022bb8:	9200      	str	r2, [sp, #0]
 8022bba:	4e17      	ldr	r6, [pc, #92]	; (8022c18 <_svfiprintf_r+0xa50>)
 8022bbc:	e42f      	b.n	802241e <_svfiprintf_r+0x256>
 8022bbe:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8022bc2:	f8cd 8010 	str.w	r8, [sp, #16]
 8022bc6:	9203      	str	r2, [sp, #12]
 8022bc8:	9407      	str	r4, [sp, #28]
 8022bca:	9301      	str	r3, [sp, #4]
 8022bcc:	4680      	mov	r8, r0
 8022bce:	e4f2      	b.n	80225b6 <_svfiprintf_r+0x3ee>
 8022bd0:	9a07      	ldr	r2, [sp, #28]
 8022bd2:	6811      	ldr	r1, [r2, #0]
 8022bd4:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8022bd8:	ea41 78e1 	orr.w	r8, r1, r1, asr #31
 8022bdc:	9907      	ldr	r1, [sp, #28]
 8022bde:	3104      	adds	r1, #4
 8022be0:	46b3      	mov	fp, r6
 8022be2:	9107      	str	r1, [sp, #28]
 8022be4:	f7ff bb3d 	b.w	8022262 <_svfiprintf_r+0x9a>
 8022be8:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022bec:	e51f      	b.n	802262e <_svfiprintf_r+0x466>
 8022bee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8022bf0:	230c      	movs	r3, #12
 8022bf2:	6013      	str	r3, [r2, #0]
 8022bf4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022bf8:	9302      	str	r3, [sp, #8]
 8022bfa:	e680      	b.n	80228fe <_svfiprintf_r+0x736>
 8022bfc:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022c00:	f7ff bbcb 	b.w	802239a <_svfiprintf_r+0x1d2>
 8022c04:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022c08:	e497      	b.n	802253a <_svfiprintf_r+0x372>
 8022c0a:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022c0e:	e59e      	b.n	802274e <_svfiprintf_r+0x586>
 8022c10:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 8022c14:	e457      	b.n	80224c6 <_svfiprintf_r+0x2fe>
 8022c16:	bf00      	nop
 8022c18:	08024c88 	.word	0x08024c88

08022c1c <__sprint_r.part.0>:
 8022c1c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022c20:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8022c22:	049c      	lsls	r4, r3, #18
 8022c24:	4693      	mov	fp, r2
 8022c26:	d52f      	bpl.n	8022c88 <__sprint_r.part.0+0x6c>
 8022c28:	6893      	ldr	r3, [r2, #8]
 8022c2a:	6812      	ldr	r2, [r2, #0]
 8022c2c:	b353      	cbz	r3, 8022c84 <__sprint_r.part.0+0x68>
 8022c2e:	460e      	mov	r6, r1
 8022c30:	4607      	mov	r7, r0
 8022c32:	f102 0908 	add.w	r9, r2, #8
 8022c36:	e919 0420 	ldmdb	r9, {r5, sl}
 8022c3a:	ea5f 089a 	movs.w	r8, sl, lsr #2
 8022c3e:	d017      	beq.n	8022c70 <__sprint_r.part.0+0x54>
 8022c40:	3d04      	subs	r5, #4
 8022c42:	2400      	movs	r4, #0
 8022c44:	e001      	b.n	8022c4a <__sprint_r.part.0+0x2e>
 8022c46:	45a0      	cmp	r8, r4
 8022c48:	d010      	beq.n	8022c6c <__sprint_r.part.0+0x50>
 8022c4a:	4632      	mov	r2, r6
 8022c4c:	f855 1f04 	ldr.w	r1, [r5, #4]!
 8022c50:	4638      	mov	r0, r7
 8022c52:	f000 f8ad 	bl	8022db0 <_fputwc_r>
 8022c56:	1c43      	adds	r3, r0, #1
 8022c58:	f104 0401 	add.w	r4, r4, #1
 8022c5c:	d1f3      	bne.n	8022c46 <__sprint_r.part.0+0x2a>
 8022c5e:	2300      	movs	r3, #0
 8022c60:	f8cb 3008 	str.w	r3, [fp, #8]
 8022c64:	f8cb 3004 	str.w	r3, [fp, #4]
 8022c68:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022c6c:	f8db 3008 	ldr.w	r3, [fp, #8]
 8022c70:	f02a 0a03 	bic.w	sl, sl, #3
 8022c74:	eba3 030a 	sub.w	r3, r3, sl
 8022c78:	f8cb 3008 	str.w	r3, [fp, #8]
 8022c7c:	f109 0908 	add.w	r9, r9, #8
 8022c80:	2b00      	cmp	r3, #0
 8022c82:	d1d8      	bne.n	8022c36 <__sprint_r.part.0+0x1a>
 8022c84:	2000      	movs	r0, #0
 8022c86:	e7ea      	b.n	8022c5e <__sprint_r.part.0+0x42>
 8022c88:	f7fe fcd8 	bl	802163c <__sfvwrite_r>
 8022c8c:	2300      	movs	r3, #0
 8022c8e:	f8cb 3008 	str.w	r3, [fp, #8]
 8022c92:	f8cb 3004 	str.w	r3, [fp, #4]
 8022c96:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022c9a:	bf00      	nop

08022c9c <__sprint_r>:
 8022c9c:	6893      	ldr	r3, [r2, #8]
 8022c9e:	b10b      	cbz	r3, 8022ca4 <__sprint_r+0x8>
 8022ca0:	f7ff bfbc 	b.w	8022c1c <__sprint_r.part.0>
 8022ca4:	b410      	push	{r4}
 8022ca6:	4618      	mov	r0, r3
 8022ca8:	6053      	str	r3, [r2, #4]
 8022caa:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022cae:	4770      	bx	lr

08022cb0 <_calloc_r>:
 8022cb0:	b510      	push	{r4, lr}
 8022cb2:	fb02 f101 	mul.w	r1, r2, r1
 8022cb6:	f7f9 f833 	bl	801bd20 <_malloc_r>
 8022cba:	4604      	mov	r4, r0
 8022cbc:	b1d8      	cbz	r0, 8022cf6 <_calloc_r+0x46>
 8022cbe:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8022cc2:	f022 0203 	bic.w	r2, r2, #3
 8022cc6:	3a04      	subs	r2, #4
 8022cc8:	2a24      	cmp	r2, #36	; 0x24
 8022cca:	d818      	bhi.n	8022cfe <_calloc_r+0x4e>
 8022ccc:	2a13      	cmp	r2, #19
 8022cce:	d914      	bls.n	8022cfa <_calloc_r+0x4a>
 8022cd0:	2300      	movs	r3, #0
 8022cd2:	2a1b      	cmp	r2, #27
 8022cd4:	6003      	str	r3, [r0, #0]
 8022cd6:	6043      	str	r3, [r0, #4]
 8022cd8:	d916      	bls.n	8022d08 <_calloc_r+0x58>
 8022cda:	2a24      	cmp	r2, #36	; 0x24
 8022cdc:	6083      	str	r3, [r0, #8]
 8022cde:	60c3      	str	r3, [r0, #12]
 8022ce0:	bf11      	iteee	ne
 8022ce2:	f100 0210 	addne.w	r2, r0, #16
 8022ce6:	6103      	streq	r3, [r0, #16]
 8022ce8:	6143      	streq	r3, [r0, #20]
 8022cea:	f100 0218 	addeq.w	r2, r0, #24
 8022cee:	2300      	movs	r3, #0
 8022cf0:	6013      	str	r3, [r2, #0]
 8022cf2:	6053      	str	r3, [r2, #4]
 8022cf4:	6093      	str	r3, [r2, #8]
 8022cf6:	4620      	mov	r0, r4
 8022cf8:	bd10      	pop	{r4, pc}
 8022cfa:	4602      	mov	r2, r0
 8022cfc:	e7f7      	b.n	8022cee <_calloc_r+0x3e>
 8022cfe:	2100      	movs	r1, #0
 8022d00:	f7fa fd68 	bl	801d7d4 <memset>
 8022d04:	4620      	mov	r0, r4
 8022d06:	bd10      	pop	{r4, pc}
 8022d08:	f100 0208 	add.w	r2, r0, #8
 8022d0c:	e7ef      	b.n	8022cee <_calloc_r+0x3e>
 8022d0e:	bf00      	nop

08022d10 <__fputwc>:
 8022d10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8022d14:	b082      	sub	sp, #8
 8022d16:	4680      	mov	r8, r0
 8022d18:	4689      	mov	r9, r1
 8022d1a:	4614      	mov	r4, r2
 8022d1c:	f7f7 ff0a 	bl	801ab34 <__locale_mb_cur_max>
 8022d20:	2801      	cmp	r0, #1
 8022d22:	d036      	beq.n	8022d92 <__fputwc+0x82>
 8022d24:	464a      	mov	r2, r9
 8022d26:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 8022d2a:	a901      	add	r1, sp, #4
 8022d2c:	4640      	mov	r0, r8
 8022d2e:	f000 f8cb 	bl	8022ec8 <_wcrtomb_r>
 8022d32:	1c42      	adds	r2, r0, #1
 8022d34:	4606      	mov	r6, r0
 8022d36:	d025      	beq.n	8022d84 <__fputwc+0x74>
 8022d38:	b3a8      	cbz	r0, 8022da6 <__fputwc+0x96>
 8022d3a:	f89d e004 	ldrb.w	lr, [sp, #4]
 8022d3e:	2500      	movs	r5, #0
 8022d40:	f10d 0a04 	add.w	sl, sp, #4
 8022d44:	e009      	b.n	8022d5a <__fputwc+0x4a>
 8022d46:	6823      	ldr	r3, [r4, #0]
 8022d48:	1c5a      	adds	r2, r3, #1
 8022d4a:	6022      	str	r2, [r4, #0]
 8022d4c:	f883 e000 	strb.w	lr, [r3]
 8022d50:	3501      	adds	r5, #1
 8022d52:	42b5      	cmp	r5, r6
 8022d54:	d227      	bcs.n	8022da6 <__fputwc+0x96>
 8022d56:	f815 e00a 	ldrb.w	lr, [r5, sl]
 8022d5a:	68a3      	ldr	r3, [r4, #8]
 8022d5c:	3b01      	subs	r3, #1
 8022d5e:	2b00      	cmp	r3, #0
 8022d60:	60a3      	str	r3, [r4, #8]
 8022d62:	daf0      	bge.n	8022d46 <__fputwc+0x36>
 8022d64:	69a7      	ldr	r7, [r4, #24]
 8022d66:	42bb      	cmp	r3, r7
 8022d68:	4671      	mov	r1, lr
 8022d6a:	4622      	mov	r2, r4
 8022d6c:	4640      	mov	r0, r8
 8022d6e:	db02      	blt.n	8022d76 <__fputwc+0x66>
 8022d70:	f1be 0f0a 	cmp.w	lr, #10
 8022d74:	d1e7      	bne.n	8022d46 <__fputwc+0x36>
 8022d76:	f000 f84f 	bl	8022e18 <__swbuf_r>
 8022d7a:	1c43      	adds	r3, r0, #1
 8022d7c:	d1e8      	bne.n	8022d50 <__fputwc+0x40>
 8022d7e:	b002      	add	sp, #8
 8022d80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022d84:	89a3      	ldrh	r3, [r4, #12]
 8022d86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8022d8a:	81a3      	strh	r3, [r4, #12]
 8022d8c:	b002      	add	sp, #8
 8022d8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022d92:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
 8022d96:	2bfe      	cmp	r3, #254	; 0xfe
 8022d98:	d8c4      	bhi.n	8022d24 <__fputwc+0x14>
 8022d9a:	fa5f fe89 	uxtb.w	lr, r9
 8022d9e:	4606      	mov	r6, r0
 8022da0:	f88d e004 	strb.w	lr, [sp, #4]
 8022da4:	e7cb      	b.n	8022d3e <__fputwc+0x2e>
 8022da6:	4648      	mov	r0, r9
 8022da8:	b002      	add	sp, #8
 8022daa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022dae:	bf00      	nop

08022db0 <_fputwc_r>:
 8022db0:	b530      	push	{r4, r5, lr}
 8022db2:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8022db4:	f013 0f01 	tst.w	r3, #1
 8022db8:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
 8022dbc:	4614      	mov	r4, r2
 8022dbe:	b083      	sub	sp, #12
 8022dc0:	4605      	mov	r5, r0
 8022dc2:	b29a      	uxth	r2, r3
 8022dc4:	d101      	bne.n	8022dca <_fputwc_r+0x1a>
 8022dc6:	0590      	lsls	r0, r2, #22
 8022dc8:	d51c      	bpl.n	8022e04 <_fputwc_r+0x54>
 8022dca:	0490      	lsls	r0, r2, #18
 8022dcc:	d406      	bmi.n	8022ddc <_fputwc_r+0x2c>
 8022dce:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8022dd0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8022dd4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8022dd8:	81a3      	strh	r3, [r4, #12]
 8022dda:	6662      	str	r2, [r4, #100]	; 0x64
 8022ddc:	4628      	mov	r0, r5
 8022dde:	4622      	mov	r2, r4
 8022de0:	f7ff ff96 	bl	8022d10 <__fputwc>
 8022de4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8022de6:	07da      	lsls	r2, r3, #31
 8022de8:	4605      	mov	r5, r0
 8022dea:	d402      	bmi.n	8022df2 <_fputwc_r+0x42>
 8022dec:	89a3      	ldrh	r3, [r4, #12]
 8022dee:	059b      	lsls	r3, r3, #22
 8022df0:	d502      	bpl.n	8022df8 <_fputwc_r+0x48>
 8022df2:	4628      	mov	r0, r5
 8022df4:	b003      	add	sp, #12
 8022df6:	bd30      	pop	{r4, r5, pc}
 8022df8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8022dfa:	f7f8 ff87 	bl	801bd0c <__retarget_lock_release_recursive>
 8022dfe:	4628      	mov	r0, r5
 8022e00:	b003      	add	sp, #12
 8022e02:	bd30      	pop	{r4, r5, pc}
 8022e04:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8022e06:	9101      	str	r1, [sp, #4]
 8022e08:	f7f8 ff7c 	bl	801bd04 <__retarget_lock_acquire_recursive>
 8022e0c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8022e10:	9901      	ldr	r1, [sp, #4]
 8022e12:	b29a      	uxth	r2, r3
 8022e14:	e7d9      	b.n	8022dca <_fputwc_r+0x1a>
 8022e16:	bf00      	nop

08022e18 <__swbuf_r>:
 8022e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022e1a:	460d      	mov	r5, r1
 8022e1c:	4614      	mov	r4, r2
 8022e1e:	4606      	mov	r6, r0
 8022e20:	b110      	cbz	r0, 8022e28 <__swbuf_r+0x10>
 8022e22:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8022e24:	2b00      	cmp	r3, #0
 8022e26:	d04b      	beq.n	8022ec0 <__swbuf_r+0xa8>
 8022e28:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8022e2c:	69a3      	ldr	r3, [r4, #24]
 8022e2e:	60a3      	str	r3, [r4, #8]
 8022e30:	b291      	uxth	r1, r2
 8022e32:	0708      	lsls	r0, r1, #28
 8022e34:	d539      	bpl.n	8022eaa <__swbuf_r+0x92>
 8022e36:	6923      	ldr	r3, [r4, #16]
 8022e38:	2b00      	cmp	r3, #0
 8022e3a:	d036      	beq.n	8022eaa <__swbuf_r+0x92>
 8022e3c:	b2ed      	uxtb	r5, r5
 8022e3e:	0489      	lsls	r1, r1, #18
 8022e40:	462f      	mov	r7, r5
 8022e42:	d515      	bpl.n	8022e70 <__swbuf_r+0x58>
 8022e44:	6822      	ldr	r2, [r4, #0]
 8022e46:	6961      	ldr	r1, [r4, #20]
 8022e48:	1ad3      	subs	r3, r2, r3
 8022e4a:	428b      	cmp	r3, r1
 8022e4c:	da1c      	bge.n	8022e88 <__swbuf_r+0x70>
 8022e4e:	3301      	adds	r3, #1
 8022e50:	68a1      	ldr	r1, [r4, #8]
 8022e52:	1c50      	adds	r0, r2, #1
 8022e54:	3901      	subs	r1, #1
 8022e56:	60a1      	str	r1, [r4, #8]
 8022e58:	6020      	str	r0, [r4, #0]
 8022e5a:	7015      	strb	r5, [r2, #0]
 8022e5c:	6962      	ldr	r2, [r4, #20]
 8022e5e:	429a      	cmp	r2, r3
 8022e60:	d01a      	beq.n	8022e98 <__swbuf_r+0x80>
 8022e62:	89a3      	ldrh	r3, [r4, #12]
 8022e64:	07db      	lsls	r3, r3, #31
 8022e66:	d501      	bpl.n	8022e6c <__swbuf_r+0x54>
 8022e68:	2d0a      	cmp	r5, #10
 8022e6a:	d015      	beq.n	8022e98 <__swbuf_r+0x80>
 8022e6c:	4638      	mov	r0, r7
 8022e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022e70:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8022e72:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8022e76:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8022e7a:	81a2      	strh	r2, [r4, #12]
 8022e7c:	6822      	ldr	r2, [r4, #0]
 8022e7e:	6661      	str	r1, [r4, #100]	; 0x64
 8022e80:	6961      	ldr	r1, [r4, #20]
 8022e82:	1ad3      	subs	r3, r2, r3
 8022e84:	428b      	cmp	r3, r1
 8022e86:	dbe2      	blt.n	8022e4e <__swbuf_r+0x36>
 8022e88:	4621      	mov	r1, r4
 8022e8a:	4630      	mov	r0, r6
 8022e8c:	f7fa fa76 	bl	801d37c <_fflush_r>
 8022e90:	b940      	cbnz	r0, 8022ea4 <__swbuf_r+0x8c>
 8022e92:	6822      	ldr	r2, [r4, #0]
 8022e94:	2301      	movs	r3, #1
 8022e96:	e7db      	b.n	8022e50 <__swbuf_r+0x38>
 8022e98:	4621      	mov	r1, r4
 8022e9a:	4630      	mov	r0, r6
 8022e9c:	f7fa fa6e 	bl	801d37c <_fflush_r>
 8022ea0:	2800      	cmp	r0, #0
 8022ea2:	d0e3      	beq.n	8022e6c <__swbuf_r+0x54>
 8022ea4:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8022ea8:	e7e0      	b.n	8022e6c <__swbuf_r+0x54>
 8022eaa:	4621      	mov	r1, r4
 8022eac:	4630      	mov	r0, r6
 8022eae:	f7fd fbaf 	bl	8020610 <__swsetup_r>
 8022eb2:	2800      	cmp	r0, #0
 8022eb4:	d1f6      	bne.n	8022ea4 <__swbuf_r+0x8c>
 8022eb6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8022eba:	6923      	ldr	r3, [r4, #16]
 8022ebc:	b291      	uxth	r1, r2
 8022ebe:	e7bd      	b.n	8022e3c <__swbuf_r+0x24>
 8022ec0:	f7fa fab4 	bl	801d42c <__sinit>
 8022ec4:	e7b0      	b.n	8022e28 <__swbuf_r+0x10>
 8022ec6:	bf00      	nop

08022ec8 <_wcrtomb_r>:
 8022ec8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022eca:	4606      	mov	r6, r0
 8022ecc:	b085      	sub	sp, #20
 8022ece:	461f      	mov	r7, r3
 8022ed0:	b189      	cbz	r1, 8022ef6 <_wcrtomb_r+0x2e>
 8022ed2:	4c10      	ldr	r4, [pc, #64]	; (8022f14 <_wcrtomb_r+0x4c>)
 8022ed4:	4d10      	ldr	r5, [pc, #64]	; (8022f18 <_wcrtomb_r+0x50>)
 8022ed6:	6824      	ldr	r4, [r4, #0]
 8022ed8:	6b64      	ldr	r4, [r4, #52]	; 0x34
 8022eda:	2c00      	cmp	r4, #0
 8022edc:	bf08      	it	eq
 8022ede:	462c      	moveq	r4, r5
 8022ee0:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
 8022ee4:	47a0      	blx	r4
 8022ee6:	1c43      	adds	r3, r0, #1
 8022ee8:	d103      	bne.n	8022ef2 <_wcrtomb_r+0x2a>
 8022eea:	2200      	movs	r2, #0
 8022eec:	238a      	movs	r3, #138	; 0x8a
 8022eee:	603a      	str	r2, [r7, #0]
 8022ef0:	6033      	str	r3, [r6, #0]
 8022ef2:	b005      	add	sp, #20
 8022ef4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022ef6:	460c      	mov	r4, r1
 8022ef8:	4906      	ldr	r1, [pc, #24]	; (8022f14 <_wcrtomb_r+0x4c>)
 8022efa:	4a07      	ldr	r2, [pc, #28]	; (8022f18 <_wcrtomb_r+0x50>)
 8022efc:	6809      	ldr	r1, [r1, #0]
 8022efe:	6b49      	ldr	r1, [r1, #52]	; 0x34
 8022f00:	2900      	cmp	r1, #0
 8022f02:	bf08      	it	eq
 8022f04:	4611      	moveq	r1, r2
 8022f06:	4622      	mov	r2, r4
 8022f08:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
 8022f0c:	a901      	add	r1, sp, #4
 8022f0e:	47a0      	blx	r4
 8022f10:	e7e9      	b.n	8022ee6 <_wcrtomb_r+0x1e>
 8022f12:	bf00      	nop
 8022f14:	20004474 	.word	0x20004474
 8022f18:	200048a0 	.word	0x200048a0
